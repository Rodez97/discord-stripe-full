/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/undici";
exports.ids = ["vendor-chunks/undici"];
exports.modules = {

/***/ "(rsc)/../../node_modules/undici/index.js":
/*!******************************************!*\
  !*** ../../node_modules/undici/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Client = __webpack_require__(/*! ./lib/client */ \"(rsc)/../../node_modules/undici/lib/client.js\");\nconst Dispatcher = __webpack_require__(/*! ./lib/dispatcher */ \"(rsc)/../../node_modules/undici/lib/dispatcher.js\");\nconst errors = __webpack_require__(/*! ./lib/core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst Pool = __webpack_require__(/*! ./lib/pool */ \"(rsc)/../../node_modules/undici/lib/pool.js\");\nconst BalancedPool = __webpack_require__(/*! ./lib/balanced-pool */ \"(rsc)/../../node_modules/undici/lib/balanced-pool.js\");\nconst Agent = __webpack_require__(/*! ./lib/agent */ \"(rsc)/../../node_modules/undici/lib/agent.js\");\nconst util = __webpack_require__(/*! ./lib/core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { InvalidArgumentError } = errors;\nconst api = __webpack_require__(/*! ./lib/api */ \"(rsc)/../../node_modules/undici/lib/api/index.js\");\nconst buildConnector = __webpack_require__(/*! ./lib/core/connect */ \"(rsc)/../../node_modules/undici/lib/core/connect.js\");\nconst MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ \"(rsc)/../../node_modules/undici/lib/mock/mock-client.js\");\nconst MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ \"(rsc)/../../node_modules/undici/lib/mock/mock-agent.js\");\nconst MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ \"(rsc)/../../node_modules/undici/lib/mock/mock-pool.js\");\nconst mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ \"(rsc)/../../node_modules/undici/lib/mock/mock-errors.js\");\nconst ProxyAgent = __webpack_require__(/*! ./lib/proxy-agent */ \"(rsc)/../../node_modules/undici/lib/proxy-agent.js\");\nconst { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__(/*! ./lib/global */ \"(rsc)/../../node_modules/undici/lib/global.js\");\nconst DecoratorHandler = __webpack_require__(/*! ./lib/handler/DecoratorHandler */ \"(rsc)/../../node_modules/undici/lib/handler/DecoratorHandler.js\");\nconst RedirectHandler = __webpack_require__(/*! ./lib/handler/RedirectHandler */ \"(rsc)/../../node_modules/undici/lib/handler/RedirectHandler.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ./lib/interceptor/redirectInterceptor */ \"(rsc)/../../node_modules/undici/lib/interceptor/redirectInterceptor.js\");\nlet hasCrypto;\ntry {\n    __webpack_require__(/*! crypto */ \"crypto\");\n    hasCrypto = true;\n} catch  {\n    hasCrypto = false;\n}\nObject.assign(Dispatcher.prototype, api);\nmodule.exports.Dispatcher = Dispatcher;\nmodule.exports.Client = Client;\nmodule.exports.Pool = Pool;\nmodule.exports.BalancedPool = BalancedPool;\nmodule.exports.Agent = Agent;\nmodule.exports.ProxyAgent = ProxyAgent;\nmodule.exports.DecoratorHandler = DecoratorHandler;\nmodule.exports.RedirectHandler = RedirectHandler;\nmodule.exports.createRedirectInterceptor = createRedirectInterceptor;\nmodule.exports.buildConnector = buildConnector;\nmodule.exports.errors = errors;\nfunction makeDispatcher(fn) {\n    return (url, opts, handler)=>{\n        if (typeof opts === \"function\") {\n            handler = opts;\n            opts = null;\n        }\n        if (!url || typeof url !== \"string\" && typeof url !== \"object\" && !(url instanceof URL)) {\n            throw new InvalidArgumentError(\"invalid url\");\n        }\n        if (opts != null && typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (opts && opts.path != null) {\n            if (typeof opts.path !== \"string\") {\n                throw new InvalidArgumentError(\"invalid opts.path\");\n            }\n            let path = opts.path;\n            if (!opts.path.startsWith(\"/\")) {\n                path = `/${path}`;\n            }\n            url = new URL(util.parseOrigin(url).origin + path);\n        } else {\n            if (!opts) {\n                opts = typeof url === \"object\" ? url : {};\n            }\n            url = util.parseURL(url);\n        }\n        const { agent, dispatcher = getGlobalDispatcher() } = opts;\n        if (agent) {\n            throw new InvalidArgumentError(\"unsupported opts.agent. Did you mean opts.client?\");\n        }\n        return fn.call(dispatcher, {\n            ...opts,\n            origin: url.origin,\n            path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n            method: opts.method || (opts.body ? \"PUT\" : \"GET\")\n        }, handler);\n    };\n}\nmodule.exports.setGlobalDispatcher = setGlobalDispatcher;\nmodule.exports.getGlobalDispatcher = getGlobalDispatcher;\nif (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {\n    let fetchImpl = null;\n    module.exports.fetch = async function fetch(resource) {\n        if (!fetchImpl) {\n            fetchImpl = (__webpack_require__(/*! ./lib/fetch */ \"(rsc)/../../node_modules/undici/lib/fetch/index.js\").fetch);\n        }\n        try {\n            return await fetchImpl(...arguments);\n        } catch (err) {\n            if (typeof err === \"object\") {\n                Error.captureStackTrace(err, this);\n            }\n            throw err;\n        }\n    };\n    module.exports.Headers = __webpack_require__(/*! ./lib/fetch/headers */ \"(rsc)/../../node_modules/undici/lib/fetch/headers.js\").Headers;\n    module.exports.Response = __webpack_require__(/*! ./lib/fetch/response */ \"(rsc)/../../node_modules/undici/lib/fetch/response.js\").Response;\n    module.exports.Request = __webpack_require__(/*! ./lib/fetch/request */ \"(rsc)/../../node_modules/undici/lib/fetch/request.js\").Request;\n    module.exports.FormData = __webpack_require__(/*! ./lib/fetch/formdata */ \"(rsc)/../../node_modules/undici/lib/fetch/formdata.js\").FormData;\n    module.exports.File = __webpack_require__(/*! ./lib/fetch/file */ \"(rsc)/../../node_modules/undici/lib/fetch/file.js\").File;\n    module.exports.FileReader = __webpack_require__(/*! ./lib/fileapi/filereader */ \"(rsc)/../../node_modules/undici/lib/fileapi/filereader.js\").FileReader;\n    const { setGlobalOrigin, getGlobalOrigin } = __webpack_require__(/*! ./lib/fetch/global */ \"(rsc)/../../node_modules/undici/lib/fetch/global.js\");\n    module.exports.setGlobalOrigin = setGlobalOrigin;\n    module.exports.getGlobalOrigin = getGlobalOrigin;\n    const { CacheStorage } = __webpack_require__(/*! ./lib/cache/cachestorage */ \"(rsc)/../../node_modules/undici/lib/cache/cachestorage.js\");\n    const { kConstruct } = __webpack_require__(/*! ./lib/cache/symbols */ \"(rsc)/../../node_modules/undici/lib/cache/symbols.js\");\n    // Cache & CacheStorage are tightly coupled with fetch. Even if it may run\n    // in an older version of Node, it doesn't have any use without fetch.\n    module.exports.caches = new CacheStorage(kConstruct);\n}\nif (util.nodeMajor >= 16) {\n    const { deleteCookie, getCookies, getSetCookies, setCookie } = __webpack_require__(/*! ./lib/cookies */ \"(rsc)/../../node_modules/undici/lib/cookies/index.js\");\n    module.exports.deleteCookie = deleteCookie;\n    module.exports.getCookies = getCookies;\n    module.exports.getSetCookies = getSetCookies;\n    module.exports.setCookie = setCookie;\n    const { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./lib/fetch/dataURL */ \"(rsc)/../../node_modules/undici/lib/fetch/dataURL.js\");\n    module.exports.parseMIMEType = parseMIMEType;\n    module.exports.serializeAMimeType = serializeAMimeType;\n}\nif (util.nodeMajor >= 18 && hasCrypto) {\n    const { WebSocket } = __webpack_require__(/*! ./lib/websocket/websocket */ \"(rsc)/../../node_modules/undici/lib/websocket/websocket.js\");\n    module.exports.WebSocket = WebSocket;\n}\nmodule.exports.request = makeDispatcher(api.request);\nmodule.exports.stream = makeDispatcher(api.stream);\nmodule.exports.pipeline = makeDispatcher(api.pipeline);\nmodule.exports.connect = makeDispatcher(api.connect);\nmodule.exports.upgrade = makeDispatcher(api.upgrade);\nmodule.exports.MockClient = MockClient;\nmodule.exports.MockPool = MockPool;\nmodule.exports.MockAgent = MockAgent;\nmodule.exports.mockErrors = mockErrors;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1HLE9BQU9ILG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1JLGVBQWVKLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1LLFFBQVFMLG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1NLE9BQU9OLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRU8sb0JBQW9CLEVBQUUsR0FBR0w7QUFDakMsTUFBTU0sTUFBTVIsbUJBQU9BLENBQUM7QUFDcEIsTUFBTVMsaUJBQWlCVCxtQkFBT0EsQ0FBQztBQUMvQixNQUFNVSxhQUFhVixtQkFBT0EsQ0FBQztBQUMzQixNQUFNVyxZQUFZWCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNWSxXQUFXWixtQkFBT0EsQ0FBQztBQUN6QixNQUFNYSxhQUFhYixtQkFBT0EsQ0FBQztBQUMzQixNQUFNYyxhQUFhZCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVlLG1CQUFtQixFQUFFQyxtQkFBbUIsRUFBRSxHQUFHaEIsbUJBQU9BLENBQUM7QUFDN0QsTUFBTWlCLG1CQUFtQmpCLG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU1rQixrQkFBa0JsQixtQkFBT0EsQ0FBQztBQUNoQyxNQUFNbUIsNEJBQTRCbkIsbUJBQU9BLENBQUM7QUFFMUMsSUFBSW9CO0FBQ0osSUFBSTtJQUNGcEIsbUJBQU9BLENBQUM7SUFDUm9CLFlBQVk7QUFDZCxFQUFFLE9BQU07SUFDTkEsWUFBWTtBQUNkO0FBRUFDLE9BQU9DLE1BQU0sQ0FBQ3JCLFdBQVdzQixTQUFTLEVBQUVmO0FBRXBDZ0IseUJBQXlCLEdBQUd2QjtBQUM1QnVCLHFCQUFxQixHQUFHekI7QUFDeEJ5QixtQkFBbUIsR0FBR3JCO0FBQ3RCcUIs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Y2kvaW5kZXguanM/ZTZiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9saWIvY2xpZW50JylcbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyJylcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vbGliL2NvcmUvZXJyb3JzJylcbmNvbnN0IFBvb2wgPSByZXF1aXJlKCcuL2xpYi9wb29sJylcbmNvbnN0IEJhbGFuY2VkUG9vbCA9IHJlcXVpcmUoJy4vbGliL2JhbGFuY2VkLXBvb2wnKVxuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuL2xpYi9hZ2VudCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi9saWIvY29yZS91dGlsJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IGVycm9yc1xuY29uc3QgYXBpID0gcmVxdWlyZSgnLi9saWIvYXBpJylcbmNvbnN0IGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZSgnLi9saWIvY29yZS9jb25uZWN0JylcbmNvbnN0IE1vY2tDbGllbnQgPSByZXF1aXJlKCcuL2xpYi9tb2NrL21vY2stY2xpZW50JylcbmNvbnN0IE1vY2tBZ2VudCA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1hZ2VudCcpXG5jb25zdCBNb2NrUG9vbCA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1wb29sJylcbmNvbnN0IG1vY2tFcnJvcnMgPSByZXF1aXJlKCcuL2xpYi9tb2NrL21vY2stZXJyb3JzJylcbmNvbnN0IFByb3h5QWdlbnQgPSByZXF1aXJlKCcuL2xpYi9wcm94eS1hZ2VudCcpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIsIHNldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4vbGliL2dsb2JhbCcpXG5jb25zdCBEZWNvcmF0b3JIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvaGFuZGxlci9EZWNvcmF0b3JIYW5kbGVyJylcbmNvbnN0IFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL2hhbmRsZXIvUmVkaXJlY3RIYW5kbGVyJylcbmNvbnN0IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdEludGVyY2VwdG9yJylcblxubGV0IGhhc0NyeXB0b1xudHJ5IHtcbiAgcmVxdWlyZSgnY3J5cHRvJylcbiAgaGFzQ3J5cHRvID0gdHJ1ZVxufSBjYXRjaCB7XG4gIGhhc0NyeXB0byA9IGZhbHNlXG59XG5cbk9iamVjdC5hc3NpZ24oRGlzcGF0Y2hlci5wcm90b3R5cGUsIGFwaSlcblxubW9kdWxlLmV4cG9ydHMuRGlzcGF0Y2hlciA9IERpc3BhdGNoZXJcbm1vZHVsZS5leHBvcnRzLkNsaWVudCA9IENsaWVudFxubW9kdWxlLmV4cG9ydHMuUG9vbCA9IFBvb2xcbm1vZHVsZS5leHBvcnRzLkJhbGFuY2VkUG9vbCA9IEJhbGFuY2VkUG9vbFxubW9kdWxlLmV4cG9ydHMuQWdlbnQgPSBBZ2VudFxubW9kdWxlLmV4cG9ydHMuUHJveHlBZ2VudCA9IFByb3h5QWdlbnRcblxubW9kdWxlLmV4cG9ydHMuRGVjb3JhdG9ySGFuZGxlciA9IERlY29yYXRvckhhbmRsZXJcbm1vZHVsZS5leHBvcnRzLlJlZGlyZWN0SGFuZGxlciA9IFJlZGlyZWN0SGFuZGxlclxubW9kdWxlLmV4cG9ydHMuY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciA9IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3JcblxubW9kdWxlLmV4cG9ydHMuYnVpbGRDb25uZWN0b3IgPSBidWlsZENvbm5lY3RvclxubW9kdWxlLmV4cG9ydHMuZXJyb3JzID0gZXJyb3JzXG5cbmZ1bmN0aW9uIG1ha2VEaXNwYXRjaGVyIChmbikge1xuICByZXR1cm4gKHVybCwgb3B0cywgaGFuZGxlcikgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaGFuZGxlciA9IG9wdHNcbiAgICAgIG9wdHMgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKCF1cmwgfHwgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB1cmwgIT09ICdvYmplY3QnICYmICEodXJsIGluc3RhbmNlb2YgVVJMKSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCB1cmwnKVxuICAgIH1cblxuICAgIGlmIChvcHRzICE9IG51bGwgJiYgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgaWYgKG9wdHMgJiYgb3B0cy5wYXRoICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cy5wYXRoJylcbiAgICAgIH1cblxuICAgICAgbGV0IHBhdGggPSBvcHRzLnBhdGhcbiAgICAgIGlmICghb3B0cy5wYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICBwYXRoID0gYC8ke3BhdGh9YFxuICAgICAgfVxuXG4gICAgICB1cmwgPSBuZXcgVVJMKHV0aWwucGFyc2VPcmlnaW4odXJsKS5vcmlnaW4gKyBwYXRoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgb3B0cyA9IHR5cGVvZiB1cmwgPT09ICdvYmplY3QnID8gdXJsIDoge31cbiAgICAgIH1cblxuICAgICAgdXJsID0gdXRpbC5wYXJzZVVSTCh1cmwpXG4gICAgfVxuXG4gICAgY29uc3QgeyBhZ2VudCwgZGlzcGF0Y2hlciA9IGdldEdsb2JhbERpc3BhdGNoZXIoKSB9ID0gb3B0c1xuXG4gICAgaWYgKGFnZW50KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIG9wdHMuYWdlbnQuIERpZCB5b3UgbWVhbiBvcHRzLmNsaWVudD8nKVxuICAgIH1cblxuICAgIHJldHVybiBmbi5jYWxsKGRpc3BhdGNoZXIsIHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBvcmlnaW46IHVybC5vcmlnaW4sXG4gICAgICBwYXRoOiB1cmwuc2VhcmNoID8gYCR7dXJsLnBhdGhuYW1lfSR7dXJsLnNlYXJjaH1gIDogdXJsLnBhdGhuYW1lLFxuICAgICAgbWV0aG9kOiBvcHRzLm1ldGhvZCB8fCAob3B0cy5ib2R5ID8gJ1BVVCcgOiAnR0VUJylcbiAgICB9LCBoYW5kbGVyKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLnNldEdsb2JhbERpc3BhdGNoZXIgPSBzZXRHbG9iYWxEaXNwYXRjaGVyXG5tb2R1bGUuZXhwb3J0cy5nZXRHbG9iYWxEaXNwYXRjaGVyID0gZ2V0R2xvYmFsRGlzcGF0Y2hlclxuXG5pZiAodXRpbC5ub2RlTWFqb3IgPiAxNiB8fCAodXRpbC5ub2RlTWFqb3IgPT09IDE2ICYmIHV0aWwubm9kZU1pbm9yID49IDgpKSB7XG4gIGxldCBmZXRjaEltcGwgPSBudWxsXG4gIG1vZHVsZS5leHBvcnRzLmZldGNoID0gYXN5bmMgZnVuY3Rpb24gZmV0Y2ggKHJlc291cmNlKSB7XG4gICAgaWYgKCFmZXRjaEltcGwpIHtcbiAgICAgIGZldGNoSW1wbCA9IHJlcXVpcmUoJy4vbGliL2ZldGNoJykuZmV0Y2hcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGZldGNoSW1wbCguLi5hcmd1bWVudHMpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCB0aGlzKVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMuSGVhZGVycyA9IHJlcXVpcmUoJy4vbGliL2ZldGNoL2hlYWRlcnMnKS5IZWFkZXJzXG4gIG1vZHVsZS5leHBvcnRzLlJlc3BvbnNlID0gcmVxdWlyZSgnLi9saWIvZmV0Y2gvcmVzcG9uc2UnKS5SZXNwb25zZVxuICBtb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvZmV0Y2gvcmVxdWVzdCcpLlJlcXVlc3RcbiAgbW9kdWxlLmV4cG9ydHMuRm9ybURhdGEgPSByZXF1aXJlKCcuL2xpYi9mZXRjaC9mb3JtZGF0YScpLkZvcm1EYXRhXG4gIG1vZHVsZS5leHBvcnRzLkZpbGUgPSByZXF1aXJlKCcuL2xpYi9mZXRjaC9maWxlJykuRmlsZVxuICBtb2R1bGUuZXhwb3J0cy5GaWxlUmVhZGVyID0gcmVxdWlyZSgnLi9saWIvZmlsZWFwaS9maWxlcmVhZGVyJykuRmlsZVJlYWRlclxuXG4gIGNvbnN0IHsgc2V0R2xvYmFsT3JpZ2luLCBnZXRHbG9iYWxPcmlnaW4gfSA9IHJlcXVpcmUoJy4vbGliL2ZldGNoL2dsb2JhbCcpXG5cbiAgbW9kdWxlLmV4cG9ydHMuc2V0R2xvYmFsT3JpZ2luID0gc2V0R2xvYmFsT3JpZ2luXG4gIG1vZHVsZS5leHBvcnRzLmdldEdsb2JhbE9yaWdpbiA9IGdldEdsb2JhbE9yaWdpblxuXG4gIGNvbnN0IHsgQ2FjaGVTdG9yYWdlIH0gPSByZXF1aXJlKCcuL2xpYi9jYWNoZS9jYWNoZXN0b3JhZ2UnKVxuICBjb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4vbGliL2NhY2hlL3N5bWJvbHMnKVxuXG4gIC8vIENhY2hlICYgQ2FjaGVTdG9yYWdlIGFyZSB0aWdodGx5IGNvdXBsZWQgd2l0aCBmZXRjaC4gRXZlbiBpZiBpdCBtYXkgcnVuXG4gIC8vIGluIGFuIG9sZGVyIHZlcnNpb24gb2YgTm9kZSwgaXQgZG9lc24ndCBoYXZlIGFueSB1c2Ugd2l0aG91dCBmZXRjaC5cbiAgbW9kdWxlLmV4cG9ydHMuY2FjaGVzID0gbmV3IENhY2hlU3RvcmFnZShrQ29uc3RydWN0KVxufVxuXG5pZiAodXRpbC5ub2RlTWFqb3IgPj0gMTYpIHtcbiAgY29uc3QgeyBkZWxldGVDb29raWUsIGdldENvb2tpZXMsIGdldFNldENvb2tpZXMsIHNldENvb2tpZSB9ID0gcmVxdWlyZSgnLi9saWIvY29va2llcycpXG5cbiAgbW9kdWxlLmV4cG9ydHMuZGVsZXRlQ29va2llID0gZGVsZXRlQ29va2llXG4gIG1vZHVsZS5leHBvcnRzLmdldENvb2tpZXMgPSBnZXRDb29raWVzXG4gIG1vZHVsZS5leHBvcnRzLmdldFNldENvb2tpZXMgPSBnZXRTZXRDb29raWVzXG4gIG1vZHVsZS5leHBvcnRzLnNldENvb2tpZSA9IHNldENvb2tpZVxuXG4gIGNvbnN0IHsgcGFyc2VNSU1FVHlwZSwgc2VyaWFsaXplQU1pbWVUeXBlIH0gPSByZXF1aXJlKCcuL2xpYi9mZXRjaC9kYXRhVVJMJylcblxuICBtb2R1bGUuZXhwb3J0cy5wYXJzZU1JTUVUeXBlID0gcGFyc2VNSU1FVHlwZVxuICBtb2R1bGUuZXhwb3J0cy5zZXJpYWxpemVBTWltZVR5cGUgPSBzZXJpYWxpemVBTWltZVR5cGVcbn1cblxuaWYgKHV0aWwubm9kZU1ham9yID49IDE4ICYmIGhhc0NyeXB0bykge1xuICBjb25zdCB7IFdlYlNvY2tldCB9ID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0L3dlYnNvY2tldCcpXG5cbiAgbW9kdWxlLmV4cG9ydHMuV2ViU29ja2V0ID0gV2ViU29ja2V0XG59XG5cbm1vZHVsZS5leHBvcnRzLnJlcXVlc3QgPSBtYWtlRGlzcGF0Y2hlcihhcGkucmVxdWVzdClcbm1vZHVsZS5leHBvcnRzLnN0cmVhbSA9IG1ha2VEaXNwYXRjaGVyKGFwaS5zdHJlYW0pXG5tb2R1bGUuZXhwb3J0cy5waXBlbGluZSA9IG1ha2VEaXNwYXRjaGVyKGFwaS5waXBlbGluZSlcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSBtYWtlRGlzcGF0Y2hlcihhcGkuY29ubmVjdClcbm1vZHVsZS5leHBvcnRzLnVwZ3JhZGUgPSBtYWtlRGlzcGF0Y2hlcihhcGkudXBncmFkZSlcblxubW9kdWxlLmV4cG9ydHMuTW9ja0NsaWVudCA9IE1vY2tDbGllbnRcbm1vZHVsZS5leHBvcnRzLk1vY2tQb29sID0gTW9ja1Bvb2xcbm1vZHVsZS5leHBvcnRzLk1vY2tBZ2VudCA9IE1vY2tBZ2VudFxubW9kdWxlLmV4cG9ydHMubW9ja0Vycm9ycyA9IG1vY2tFcnJvcnNcbiJdLCJuYW1lcyI6WyJDbGllbnQiLCJyZXF1aXJlIiwiRGlzcGF0Y2hlciIsImVycm9ycyIsIlBvb2wiLCJCYWxhbmNlZFBvb2wiLCJBZ2VudCIsInV0aWwiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImFwaSIsImJ1aWxkQ29ubmVjdG9yIiwiTW9ja0NsaWVudCIsIk1vY2tBZ2VudCIsIk1vY2tQb29sIiwibW9ja0Vycm9ycyIsIlByb3h5QWdlbnQiLCJnZXRHbG9iYWxEaXNwYXRjaGVyIiwic2V0R2xvYmFsRGlzcGF0Y2hlciIsIkRlY29yYXRvckhhbmRsZXIiLCJSZWRpcmVjdEhhbmRsZXIiLCJjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yIiwiaGFzQ3J5cHRvIiwiT2JqZWN0IiwiYXNzaWduIiwicHJvdG90eXBlIiwibW9kdWxlIiwiZXhwb3J0cyIsIm1ha2VEaXNwYXRjaGVyIiwiZm4iLCJ1cmwiLCJvcHRzIiwiaGFuZGxlciIsIlVSTCIsInBhdGgiLCJzdGFydHNXaXRoIiwicGFyc2VPcmlnaW4iLCJvcmlnaW4iLCJwYXJzZVVSTCIsImFnZW50IiwiZGlzcGF0Y2hlciIsImNhbGwiLCJzZWFyY2giLCJwYXRobmFtZSIsIm1ldGhvZCIsImJvZHkiLCJub2RlTWFqb3IiLCJub2RlTWlub3IiLCJmZXRjaEltcGwiLCJmZXRjaCIsInJlc291cmNlIiwiYXJndW1lbnRzIiwiZXJyIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIkhlYWRlcnMiLCJSZXNwb25zZSIsIlJlcXVlc3QiLCJGb3JtRGF0YSIsIkZpbGUiLCJGaWxlUmVhZGVyIiwic2V0R2xvYmFsT3JpZ2luIiwiZ2V0R2xvYmFsT3JpZ2luIiwiQ2FjaGVTdG9yYWdlIiwia0NvbnN0cnVjdCIsImNhY2hlcyIsImRlbGV0ZUNvb2tpZSIsImdldENvb2tpZXMiLCJnZXRTZXRDb29raWVzIiwic2V0Q29va2llIiwicGFyc2VNSU1FVHlwZSIsInNlcmlhbGl6ZUFNaW1lVHlwZSIsIldlYlNvY2tldCIsInJlcXVlc3QiLCJzdHJlYW0iLCJwaXBlbGluZSIsImNvbm5lY3QiLCJ1cGdyYWRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/agent.js":
/*!**********************************************!*\
  !*** ../../node_modules/undici/lib/agent.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/../../node_modules/undici/lib/dispatcher-base.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/../../node_modules/undici/lib/pool.js\");\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/../../node_modules/undici/lib/client.js\");\nconst util = __webpack_require__(/*! ./core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ./interceptor/redirectInterceptor */ \"(rsc)/../../node_modules/undici/lib/interceptor/redirectInterceptor.js\");\nconst { WeakRef, FinalizationRegistry } = __webpack_require__(/*! ./compat/dispatcher-weakref */ \"(rsc)/../../node_modules/undici/lib/compat/dispatcher-weakref.js\")();\nconst kOnConnect = Symbol(\"onConnect\");\nconst kOnDisconnect = Symbol(\"onDisconnect\");\nconst kOnConnectionError = Symbol(\"onConnectionError\");\nconst kMaxRedirections = Symbol(\"maxRedirections\");\nconst kOnDrain = Symbol(\"onDrain\");\nconst kFactory = Symbol(\"factory\");\nconst kFinalizer = Symbol(\"finalizer\");\nconst kOptions = Symbol(\"options\");\nfunction defaultFactory(origin, opts) {\n    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n}\nclass Agent extends DispatcherBase {\n    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}){\n        super();\n        if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n            throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n            throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        if (connect && typeof connect !== \"function\") {\n            connect = {\n                ...connect\n            };\n        }\n        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [\n            createRedirectInterceptor({\n                maxRedirections\n            })\n        ];\n        this[kOptions] = {\n            ...util.deepClone(options),\n            connect\n        };\n        this[kOptions].interceptors = options.interceptors ? {\n            ...options.interceptors\n        } : undefined;\n        this[kMaxRedirections] = maxRedirections;\n        this[kFactory] = factory;\n        this[kClients] = new Map();\n        this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ (key)=>{\n            const ref = this[kClients].get(key);\n            if (ref !== undefined && ref.deref() === undefined) {\n                this[kClients].delete(key);\n            }\n        });\n        const agent = this;\n        this[kOnDrain] = (origin, targets)=>{\n            agent.emit(\"drain\", origin, [\n                agent,\n                ...targets\n            ]);\n        };\n        this[kOnConnect] = (origin, targets)=>{\n            agent.emit(\"connect\", origin, [\n                agent,\n                ...targets\n            ]);\n        };\n        this[kOnDisconnect] = (origin, targets, err)=>{\n            agent.emit(\"disconnect\", origin, [\n                agent,\n                ...targets\n            ], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err)=>{\n            agent.emit(\"connectionError\", origin, [\n                agent,\n                ...targets\n            ], err);\n        };\n    }\n    get [kRunning]() {\n        let ret = 0;\n        for (const ref of this[kClients].values()){\n            const client = ref.deref();\n            /* istanbul ignore next: gc is undeterministic */ if (client) {\n                ret += client[kRunning];\n            }\n        }\n        return ret;\n    }\n    [kDispatch](opts, handler) {\n        let key;\n        if (opts.origin && (typeof opts.origin === \"string\" || opts.origin instanceof URL)) {\n            key = String(opts.origin);\n        } else {\n            throw new InvalidArgumentError(\"opts.origin must be a non-empty string or URL.\");\n        }\n        const ref = this[kClients].get(key);\n        let dispatcher = ref ? ref.deref() : null;\n        if (!dispatcher) {\n            dispatcher = this[kFactory](opts.origin, this[kOptions]).on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]);\n            this[kClients].set(key, new WeakRef(dispatcher));\n            this[kFinalizer].register(dispatcher, key);\n        }\n        return dispatcher.dispatch(opts, handler);\n    }\n    async [kClose]() {\n        const closePromises = [];\n        for (const ref of this[kClients].values()){\n            const client = ref.deref();\n            /* istanbul ignore else: gc is undeterministic */ if (client) {\n                closePromises.push(client.close());\n            }\n        }\n        await Promise.all(closePromises);\n    }\n    async [kDestroy](err) {\n        const destroyPromises = [];\n        for (const ref of this[kClients].values()){\n            const client = ref.deref();\n            /* istanbul ignore else: gc is undeterministic */ if (client) {\n                destroyPromises.push(client.destroy(err));\n            }\n        }\n        await Promise.all(destroyPromises);\n    }\n}\nmodule.exports = Agent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLG9CQUFvQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3pDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLGFBQWEsRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUNuRixNQUFNTyxpQkFBaUJQLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU1RLE9BQU9SLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1TLFNBQVNULG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1VLE9BQU9WLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1XLDRCQUE0QlgsbUJBQU9BLENBQUM7QUFDMUMsTUFBTSxFQUFFWSxPQUFPLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdiLG1CQUFPQSxDQUFDO0FBRWxELE1BQU1jLGFBQWFDLE9BQU87QUFDMUIsTUFBTUMsZ0JBQWdCRCxPQUFPO0FBQzdCLE1BQU1FLHFCQUFxQkYsT0FBTztBQUNsQyxNQUFNRyxtQkFBbUJILE9BQU87QUFDaEMsTUFBTUksV0FBV0osT0FBTztBQUN4QixNQUFNSyxXQUFXTCxPQUFPO0FBQ3hCLE1BQU1NLGFBQWFOLE9BQU87QUFDMUIsTUFBTU8sV0FBV1AsT0FBTztBQUV4QixTQUFTUSxlQUFnQkMsTUFBTSxFQUFFQyxJQUFJO0lBQ25DLE9BQU9BLFFBQVFBLEtBQUtDLFdBQVcsS0FBSyxJQUNoQyxJQUFJakIsT0FBT2UsUUFBUUMsUUFDbkIsSUFBSWpCLEtBQUtnQixRQUFRQztBQUN2QjtBQUVBLE1BQU1FLGNBQWNwQjtJQUNsQnFCLFlBQWEsRUFBRUMsVUFBVU4sY0FBYyxFQUFFTyxrQkFBa0IsQ0FBQyxFQUFFQyxPQUFPLEVBQUUsR0FBR0MsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3hGLEtBQUs7UUFFTCxJQUFJLE9BQU9ILFlBQVksWUFBWTtZQUNqQyxNQUFNLElBQUk5QixxQkFBcUI7UUFDakM7UUFFQSxJQUFJZ0MsV0FBVyxRQUFRLE9BQU9BLFlBQVksY0FBYyxPQUFPQSxZQUFZLFVBQVU7WUFDbkYsTUFBTSxJQUFJaEMscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxDQUFDa0MsT0FBT0MsU0FBUyxDQUFDSixvQkFBb0JBLGtCQUFrQixHQUFHO1lBQzdELE1BQU0sSUFBSS9CLHFCQUFxQjtRQUNqQztRQUVBLElBQUlnQyxXQUFXLE9BQU9BLFlBQVksWUFBWTtZQUM1Q0EsVUFBVTtnQkFBRSxHQUFHQSxPQUFPO1lBQUM7UUFDekI7UUFFQSxJQUFJLENBQUN6QixjQUFjLEdBQUcwQixRQUFRRyxZQUFZLElBQUlILFFBQVFHLFlBQVksQ0FBQ1IsS0FBSyxJQUFJUyxNQUFNQyxPQUFPLENBQUNMLFFBQVFHLFlBQVksQ0FBQ1IsS0FBSyxJQUNoSEssUUFBUUcsWUFBWSxDQUFDUixLQUFLLEdBQzFCO1lBQUNoQiwwQkFBMEI7Z0JBQUVtQjtZQUFnQjtTQUFHO1FBRXBELElBQUksQ0FBQ1IsU0FBUyxHQUFHO1lBQUUsR0FBR1osS0FBSzRCLFNBQVMsQ0FBQ04sUUFBUTtZQUFFRDtRQUFRO1FBQ3ZELElBQUksQ0FBQ1QsU0FBUyxDQUFDYSxZQUFZLEdBQUdILFFBQVFHLFlBQVksR0FDOUM7WUFBRSxHQUFHSCxRQUFRRyxZQUFZO1FBQUMsSUFDMUJJO1FBQ0osSUFBSSxDQUFDckIsaUJBQWlCLEdBQUdZO1FBQ3pCLElBQUksQ0FBQ1YsU0FBUyxHQUFHUztRQUNqQixJQUFJLENBQUM1QixTQUFTLEdBQUcsSUFBSXVDO1FBQ3JCLElBQUksQ0FBQ25CLFdBQVcsR0FBRyxJQUFJUixxQkFBcUIsK0NBQStDLEdBQUc0QixDQUFBQTtZQUM1RixNQUFNQyxNQUFNLElBQUksQ0FBQ3pDLFNBQVMsQ0FBQzBDLEdBQUcsQ0FBQ0Y7WUFDL0IsSUFBSUMsUUFBUUgsYUFBYUcsSUFBSUUsS0FBSyxPQUFPTCxXQUFXO2dCQUNsRCxJQUFJLENBQUN0QyxTQUFTLENBQUM0QyxNQUFNLENBQUNKO1lBQ3hCO1FBQ0Y7UUFFQSxNQUFNSyxRQUFRLElBQUk7UUFFbEIsSUFBSSxDQUFDM0IsU0FBUyxHQUFHLENBQUNLLFFBQVF1QjtZQUN4QkQsTUFBTUUsSUFBSSxDQUFDLFNBQVN4QixRQUFRO2dCQUFDc0I7bUJBQVVDO2FBQVE7UUFDakQ7UUFFQSxJQUFJLENBQUNqQyxXQUFXLEdBQUcsQ0FBQ1UsUUFBUXVCO1lBQzFCRCxNQUFNRSxJQUFJLENBQUMsV0FBV3hCLFFBQVE7Z0JBQUNzQjttQkFBVUM7YUFBUTtRQUNuRDtRQUVBLElBQUksQ0FBQy9CLGNBQWMsR0FBRyxDQUFDUSxRQUFRdUIsU0FBU0U7WUFDdENILE1BQU1FLElBQUksQ0FBQyxjQUFjeEIsUUFBUTtnQkFBQ3NCO21CQUFVQzthQUFRLEVBQUVFO1FBQ3hEO1FBRUEsSUFBSSxDQUFDaEMsbUJBQW1CLEdBQUcsQ0FBQ08sUUFBUXVCLFNBQVNFO1lBQzNDSCxNQUFNRSxJQUFJLENBQUMsbUJBQW1CeEIsUUFBUTtnQkFBQ3NCO21CQUFVQzthQUFRLEVBQUVFO1FBQzdEO0lBQ0Y7SUFFQSxJQUFJLENBQUMvQyxTQUFTLEdBQUk7UUFDaEIsSUFBSWdELE1BQU07UUFDVixLQUFLLE1BQU1SLE9BQU8sSUFBSSxDQUFDekMsU0FBUyxDQUFDa0QsTUFBTSxHQUFJO1lBQ3pDLE1BQU1DLFNBQVNWLElBQUlFLEtBQUs7WUFDeEIsK0NBQStDLEdBQy9DLElBQUlRLFFBQVE7Z0JBQ1ZGLE9BQU9FLE1BQU0sQ0FBQ2xELFNBQVM7WUFDekI7UUFDRjtRQUNBLE9BQU9nRDtJQUNUO0lBRUEsQ0FBQzdDLFVBQVUsQ0FBRW9CLElBQUksRUFBRTRCLE9BQU8sRUFBRTtRQUMxQixJQUFJWjtRQUNKLElBQUloQixLQUFLRCxNQUFNLElBQUssUUFBT0MsS0FBS0QsTUFBTSxLQUFLLFlBQVlDLEtBQUtELE1BQU0sWUFBWThCLEdBQUUsR0FBSTtZQUNsRmIsTUFBTWMsT0FBTzlCLEtBQUtELE1BQU07UUFDMUIsT0FBTztZQUNMLE1BQU0sSUFBSXpCLHFCQUFxQjtRQUNqQztRQUVBLE1BQU0yQyxNQUFNLElBQUksQ0FBQ3pDLFNBQVMsQ0FBQzBDLEdBQUcsQ0FBQ0Y7UUFFL0IsSUFBSWUsYUFBYWQsTUFBTUEsSUFBSUUsS0FBSyxLQUFLO1FBQ3JDLElBQUksQ0FBQ1ksWUFBWTtZQUNmQSxhQUFhLElBQUksQ0FBQ3BDLFNBQVMsQ0FBQ0ssS0FBS0QsTUFBTSxFQUFFLElBQUksQ0FBQ0YsU0FBUyxFQUNwRG1DLEVBQUUsQ0FBQyxTQUFTLElBQUksQ0FBQ3RDLFNBQVMsRUFDMUJzQyxFQUFFLENBQUMsV0FBVyxJQUFJLENBQUMzQyxXQUFXLEVBQzlCMkMsRUFBRSxDQUFDLGNBQWMsSUFBSSxDQUFDekMsY0FBYyxFQUNwQ3lDLEVBQUUsQ0FBQyxtQkFBbUIsSUFBSSxDQUFDeEMsbUJBQW1CO1lBRWpELElBQUksQ0FBQ2hCLFNBQVMsQ0FBQ3lELEdBQUcsQ0FBQ2pCLEtBQUssSUFBSTdCLFFBQVE0QztZQUNwQyxJQUFJLENBQUNuQyxXQUFXLENBQUNzQyxRQUFRLENBQUNILFlBQVlmO1FBQ3hDO1FBRUEsT0FBT2UsV0FBV0ksUUFBUSxDQUFDbkMsTUFBTTRCO0lBQ25DO0lBRUEsTUFBTSxDQUFDbEQsT0FBTyxHQUFJO1FBQ2hCLE1BQU0wRCxnQkFBZ0IsRUFBRTtRQUN4QixLQUFLLE1BQU1uQixPQUFPLElBQUksQ0FBQ3pDLFNBQVMsQ0FBQ2tELE1BQU0sR0FBSTtZQUN6QyxNQUFNQyxTQUFTVixJQUFJRSxLQUFLO1lBQ3hCLCtDQUErQyxHQUMvQyxJQUFJUSxRQUFRO2dCQUNWUyxjQUFjQyxJQUFJLENBQUNWLE9BQU9XLEtBQUs7WUFDakM7UUFDRjtRQUVBLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ0o7SUFDcEI7SUFFQSxNQUFNLENBQUN6RCxTQUFTLENBQUU2QyxHQUFHLEVBQUU7UUFDckIsTUFBTWlCLGtCQUFrQixFQUFFO1FBQzFCLEtBQUssTUFBTXhCLE9BQU8sSUFBSSxDQUFDekMsU0FBUyxDQUFDa0QsTUFBTSxHQUFJO1lBQ3pDLE1BQU1DLFNBQVNWLElBQUlFLEtBQUs7WUFDeEIsK0NBQStDLEdBQy9DLElBQUlRLFFBQVE7Z0JBQ1ZjLGdCQUFnQkosSUFBSSxDQUFDVixPQUFPZSxPQUFPLENBQUNsQjtZQUN0QztRQUNGO1FBRUEsTUFBTWUsUUFBUUMsR0FBRyxDQUFDQztJQUNwQjtBQUNGO0FBRUFFLE9BQU9DLE9BQU8sR0FBRzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hZ2VudC5qcz83ODU4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsga0NsaWVudHMsIGtSdW5uaW5nLCBrQ2xvc2UsIGtEZXN0cm95LCBrRGlzcGF0Y2gsIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4vY29yZS9zeW1ib2xzJylcbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKVxuY29uc3QgY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4vaW50ZXJjZXB0b3IvcmVkaXJlY3RJbnRlcmNlcHRvcicpXG5jb25zdCB7IFdlYWtSZWYsIEZpbmFsaXphdGlvblJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuL2NvbXBhdC9kaXNwYXRjaGVyLXdlYWtyZWYnKSgpXG5cbmNvbnN0IGtPbkNvbm5lY3QgPSBTeW1ib2woJ29uQ29ubmVjdCcpXG5jb25zdCBrT25EaXNjb25uZWN0ID0gU3ltYm9sKCdvbkRpc2Nvbm5lY3QnKVxuY29uc3Qga09uQ29ubmVjdGlvbkVycm9yID0gU3ltYm9sKCdvbkNvbm5lY3Rpb25FcnJvcicpXG5jb25zdCBrTWF4UmVkaXJlY3Rpb25zID0gU3ltYm9sKCdtYXhSZWRpcmVjdGlvbnMnKVxuY29uc3Qga09uRHJhaW4gPSBTeW1ib2woJ29uRHJhaW4nKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuY29uc3Qga0ZpbmFsaXplciA9IFN5bWJvbCgnZmluYWxpemVyJylcbmNvbnN0IGtPcHRpb25zID0gU3ltYm9sKCdvcHRpb25zJylcblxuZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKG9yaWdpbiwgb3B0cykge1xuICByZXR1cm4gb3B0cyAmJiBvcHRzLmNvbm5lY3Rpb25zID09PSAxXG4gICAgPyBuZXcgQ2xpZW50KG9yaWdpbiwgb3B0cylcbiAgICA6IG5ldyBQb29sKG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgQWdlbnQgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yICh7IGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSwgbWF4UmVkaXJlY3Rpb25zID0gMCwgY29ubmVjdCwgLi4ub3B0aW9ucyB9ID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdCAhPSBudWxsICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdjb25uZWN0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZWRpcmVjdGlvbnMpIHx8IG1heFJlZGlyZWN0aW9ucyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0geyAuLi5jb25uZWN0IH1cbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gb3B0aW9ucy5pbnRlcmNlcHRvcnMgJiYgb3B0aW9ucy5pbnRlcmNlcHRvcnMuQWdlbnQgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyY2VwdG9ycy5BZ2VudClcbiAgICAgID8gb3B0aW9ucy5pbnRlcmNlcHRvcnMuQWdlbnRcbiAgICAgIDogW2NyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IoeyBtYXhSZWRpcmVjdGlvbnMgfSldXG5cbiAgICB0aGlzW2tPcHRpb25zXSA9IHsgLi4udXRpbC5kZWVwQ2xvbmUob3B0aW9ucyksIGNvbm5lY3QgfVxuICAgIHRoaXNba09wdGlvbnNdLmludGVyY2VwdG9ycyA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzXG4gICAgICA/IHsgLi4ub3B0aW9ucy5pbnRlcmNlcHRvcnMgfVxuICAgICAgOiB1bmRlZmluZWRcbiAgICB0aGlzW2tNYXhSZWRpcmVjdGlvbnNdID0gbWF4UmVkaXJlY3Rpb25zXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG4gICAgdGhpc1trQ2xpZW50c10gPSBuZXcgTWFwKClcbiAgICB0aGlzW2tGaW5hbGl6ZXJdID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBnYyBpcyB1bmRldGVybWluaXN0aWMgKi8ga2V5ID0+IHtcbiAgICAgIGNvbnN0IHJlZiA9IHRoaXNba0NsaWVudHNdLmdldChrZXkpXG4gICAgICBpZiAocmVmICE9PSB1bmRlZmluZWQgJiYgcmVmLmRlcmVmKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzW2tDbGllbnRzXS5kZWxldGUoa2V5KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBhZ2VudCA9IHRoaXNcblxuICAgIHRoaXNba09uRHJhaW5dID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgYWdlbnQuZW1pdCgnZHJhaW4nLCBvcmlnaW4sIFthZ2VudCwgLi4udGFyZ2V0c10pXG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMpID0+IHtcbiAgICAgIGFnZW50LmVtaXQoJ2Nvbm5lY3QnLCBvcmlnaW4sIFthZ2VudCwgLi4udGFyZ2V0c10pXG4gICAgfVxuXG4gICAgdGhpc1trT25EaXNjb25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgYWdlbnQuZW1pdCgnZGlzY29ubmVjdCcsIG9yaWdpbiwgW2FnZW50LCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgYWdlbnQuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgb3JpZ2luLCBbYWdlbnQsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuICB9XG5cbiAgZ2V0IFtrUnVubmluZ10gKCkge1xuICAgIGxldCByZXQgPSAwXG4gICAgZm9yIChjb25zdCByZWYgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IHJlZi5kZXJlZigpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZ2MgaXMgdW5kZXRlcm1pbmlzdGljICovXG4gICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgIHJldCArPSBjbGllbnRba1J1bm5pbmddXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgbGV0IGtleVxuICAgIGlmIChvcHRzLm9yaWdpbiAmJiAodHlwZW9mIG9wdHMub3JpZ2luID09PSAnc3RyaW5nJyB8fCBvcHRzLm9yaWdpbiBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgIGtleSA9IFN0cmluZyhvcHRzLm9yaWdpbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLm9yaWdpbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBVUkwuJylcbiAgICB9XG5cbiAgICBjb25zdCByZWYgPSB0aGlzW2tDbGllbnRzXS5nZXQoa2V5KVxuXG4gICAgbGV0IGRpc3BhdGNoZXIgPSByZWYgPyByZWYuZGVyZWYoKSA6IG51bGxcbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcHRzLm9yaWdpbiwgdGhpc1trT3B0aW9uc10pXG4gICAgICAgIC5vbignZHJhaW4nLCB0aGlzW2tPbkRyYWluXSlcbiAgICAgICAgLm9uKCdjb25uZWN0JywgdGhpc1trT25Db25uZWN0XSlcbiAgICAgICAgLm9uKCdkaXNjb25uZWN0JywgdGhpc1trT25EaXNjb25uZWN0XSlcbiAgICAgICAgLm9uKCdjb25uZWN0aW9uRXJyb3InLCB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0pXG5cbiAgICAgIHRoaXNba0NsaWVudHNdLnNldChrZXksIG5ldyBXZWFrUmVmKGRpc3BhdGNoZXIpKVxuICAgICAgdGhpc1trRmluYWxpemVyXS5yZWdpc3RlcihkaXNwYXRjaGVyLCBrZXkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3BhdGNoZXIuZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBjb25zdCBjbG9zZVByb21pc2VzID0gW11cbiAgICBmb3IgKGNvbnN0IHJlZiBvZiB0aGlzW2tDbGllbnRzXS52YWx1ZXMoKSkge1xuICAgICAgY29uc3QgY2xpZW50ID0gcmVmLmRlcmVmKClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBnYyBpcyB1bmRldGVybWluaXN0aWMgKi9cbiAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgY2xvc2VQcm9taXNlcy5wdXNoKGNsaWVudC5jbG9zZSgpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKGNsb3NlUHJvbWlzZXMpXG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldIChlcnIpIHtcbiAgICBjb25zdCBkZXN0cm95UHJvbWlzZXMgPSBbXVxuICAgIGZvciAoY29uc3QgcmVmIG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCBjbGllbnQgPSByZWYuZGVyZWYoKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGdjIGlzIHVuZGV0ZXJtaW5pc3RpYyAqL1xuICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICBkZXN0cm95UHJvbWlzZXMucHVzaChjbGllbnQuZGVzdHJveShlcnIpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKGRlc3Ryb3lQcm9taXNlcylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZW50XG4iXSwibmFtZXMiOlsiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJyZXF1aXJlIiwia0NsaWVudHMiLCJrUnVubmluZyIsImtDbG9zZSIsImtEZXN0cm95Iiwia0Rpc3BhdGNoIiwia0ludGVyY2VwdG9ycyIsIkRpc3BhdGNoZXJCYXNlIiwiUG9vbCIsIkNsaWVudCIsInV0aWwiLCJjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yIiwiV2Vha1JlZiIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5Iiwia09uQ29ubmVjdCIsIlN5bWJvbCIsImtPbkRpc2Nvbm5lY3QiLCJrT25Db25uZWN0aW9uRXJyb3IiLCJrTWF4UmVkaXJlY3Rpb25zIiwia09uRHJhaW4iLCJrRmFjdG9yeSIsImtGaW5hbGl6ZXIiLCJrT3B0aW9ucyIsImRlZmF1bHRGYWN0b3J5Iiwib3JpZ2luIiwib3B0cyIsImNvbm5lY3Rpb25zIiwiQWdlbnQiLCJjb25zdHJ1Y3RvciIsImZhY3RvcnkiLCJtYXhSZWRpcmVjdGlvbnMiLCJjb25uZWN0Iiwib3B0aW9ucyIsIk51bWJlciIsImlzSW50ZWdlciIsImludGVyY2VwdG9ycyIsIkFycmF5IiwiaXNBcnJheSIsImRlZXBDbG9uZSIsInVuZGVmaW5lZCIsIk1hcCIsImtleSIsInJlZiIsImdldCIsImRlcmVmIiwiZGVsZXRlIiwiYWdlbnQiLCJ0YXJnZXRzIiwiZW1pdCIsImVyciIsInJldCIsInZhbHVlcyIsImNsaWVudCIsImhhbmRsZXIiLCJVUkwiLCJTdHJpbmciLCJkaXNwYXRjaGVyIiwib24iLCJzZXQiLCJyZWdpc3RlciIsImRpc3BhdGNoIiwiY2xvc2VQcm9taXNlcyIsInB1c2giLCJjbG9zZSIsIlByb21pc2UiLCJhbGwiLCJkZXN0cm95UHJvbWlzZXMiLCJkZXN0cm95IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/agent.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/api/abort-signal.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/api/abort-signal.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { addAbortListener } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst kListener = Symbol(\"kListener\");\nconst kSignal = Symbol(\"kSignal\");\nfunction abort(self) {\n    if (self.abort) {\n        self.abort();\n    } else {\n        self.onError(new RequestAbortedError());\n    }\n}\nfunction addSignal(self, signal) {\n    self[kSignal] = null;\n    self[kListener] = null;\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        abort(self);\n        return;\n    }\n    self[kSignal] = signal;\n    self[kListener] = ()=>{\n        abort(self);\n    };\n    addAbortListener(self[kSignal], self[kListener]);\n}\nfunction removeSignal(self) {\n    if (!self[kSignal]) {\n        return;\n    }\n    if (\"removeEventListener\" in self[kSignal]) {\n        self[kSignal].removeEventListener(\"abort\", self[kListener]);\n    } else {\n        self[kSignal].removeListener(\"abort\", self[kListener]);\n    }\n    self[kSignal] = null;\n    self[kListener] = null;\n}\nmodule.exports = {\n    addSignal,\n    removeSignal\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2Fib3J0LXNpZ25hbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNLEVBQUVBLGdCQUFnQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3JDLE1BQU0sRUFBRUMsbUJBQW1CLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFeEMsTUFBTUUsWUFBWUMsT0FBTztBQUN6QixNQUFNQyxVQUFVRCxPQUFPO0FBRXZCLFNBQVNFLE1BQU9DLElBQUk7SUFDbEIsSUFBSUEsS0FBS0QsS0FBSyxFQUFFO1FBQ2RDLEtBQUtELEtBQUs7SUFDWixPQUFPO1FBQ0xDLEtBQUtDLE9BQU8sQ0FBQyxJQUFJTjtJQUNuQjtBQUNGO0FBRUEsU0FBU08sVUFBV0YsSUFBSSxFQUFFRyxNQUFNO0lBQzlCSCxJQUFJLENBQUNGLFFBQVEsR0FBRztJQUNoQkUsSUFBSSxDQUFDSixVQUFVLEdBQUc7SUFFbEIsSUFBSSxDQUFDTyxRQUFRO1FBQ1g7SUFDRjtJQUVBLElBQUlBLE9BQU9DLE9BQU8sRUFBRTtRQUNsQkwsTUFBTUM7UUFDTjtJQUNGO0lBRUFBLElBQUksQ0FBQ0YsUUFBUSxHQUFHSztJQUNoQkgsSUFBSSxDQUFDSixVQUFVLEdBQUc7UUFDaEJHLE1BQU1DO0lBQ1I7SUFFQVAsaUJBQWlCTyxJQUFJLENBQUNGLFFBQVEsRUFBRUUsSUFBSSxDQUFDSixVQUFVO0FBQ2pEO0FBRUEsU0FBU1MsYUFBY0wsSUFBSTtJQUN6QixJQUFJLENBQUNBLElBQUksQ0FBQ0YsUUFBUSxFQUFFO1FBQ2xCO0lBQ0Y7SUFFQSxJQUFJLHlCQUF5QkUsSUFBSSxDQUFDRixRQUFRLEVBQUU7UUFDMUNFLElBQUksQ0FBQ0YsUUFBUSxDQUFDUSxtQkFBbUIsQ0FBQyxTQUFTTixJQUFJLENBQUNKLFVBQVU7SUFDNUQsT0FBTztRQUNMSSxJQUFJLENBQUNGLFFBQVEsQ0FBQ1MsY0FBYyxDQUFDLFNBQVNQLElBQUksQ0FBQ0osVUFBVTtJQUN2RDtJQUVBSSxJQUFJLENBQUNGLFFBQVEsR0FBRztJQUNoQkUsSUFBSSxDQUFDSixVQUFVLEdBQUc7QUFDcEI7QUFFQVksT0FBT0MsT0FBTyxHQUFHO0lBQ2ZQO0lBQ0FHO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hYm9ydC1zaWduYWwuanM/NWFkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGFkZEFib3J0TGlzdGVuZXIgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuY29uc3Qga0xpc3RlbmVyID0gU3ltYm9sKCdrTGlzdGVuZXInKVxuY29uc3Qga1NpZ25hbCA9IFN5bWJvbCgna1NpZ25hbCcpXG5cbmZ1bmN0aW9uIGFib3J0IChzZWxmKSB7XG4gIGlmIChzZWxmLmFib3J0KSB7XG4gICAgc2VsZi5hYm9ydCgpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5vbkVycm9yKG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU2lnbmFsIChzZWxmLCBzaWduYWwpIHtcbiAgc2VsZltrU2lnbmFsXSA9IG51bGxcbiAgc2VsZltrTGlzdGVuZXJdID0gbnVsbFxuXG4gIGlmICghc2lnbmFsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICBhYm9ydChzZWxmKVxuICAgIHJldHVyblxuICB9XG5cbiAgc2VsZltrU2lnbmFsXSA9IHNpZ25hbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSAoKSA9PiB7XG4gICAgYWJvcnQoc2VsZilcbiAgfVxuXG4gIGFkZEFib3J0TGlzdGVuZXIoc2VsZltrU2lnbmFsXSwgc2VsZltrTGlzdGVuZXJdKVxufVxuXG5mdW5jdGlvbiByZW1vdmVTaWduYWwgKHNlbGYpIHtcbiAgaWYgKCFzZWxmW2tTaWduYWxdKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIHNlbGZba1NpZ25hbF0pIHtcbiAgICBzZWxmW2tTaWduYWxdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgc2VsZltrTGlzdGVuZXJdKVxuICB9IGVsc2Uge1xuICAgIHNlbGZba1NpZ25hbF0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgc2VsZltrTGlzdGVuZXJdKVxuICB9XG5cbiAgc2VsZltrU2lnbmFsXSA9IG51bGxcbiAgc2VsZltrTGlzdGVuZXJdID0gbnVsbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkU2lnbmFsLFxuICByZW1vdmVTaWduYWxcbn1cbiJdLCJuYW1lcyI6WyJhZGRBYm9ydExpc3RlbmVyIiwicmVxdWlyZSIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJrTGlzdGVuZXIiLCJTeW1ib2wiLCJrU2lnbmFsIiwiYWJvcnQiLCJzZWxmIiwib25FcnJvciIsImFkZFNpZ25hbCIsInNpZ25hbCIsImFib3J0ZWQiLCJyZW1vdmVTaWduYWwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/api/abort-signal.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/api/api-connect.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/api/api-connect.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/../../node_modules/undici/lib/api/abort-signal.js\");\nclass ConnectHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        super(\"UNDICI_CONNECT\");\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.callback = callback;\n        this.abort = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (!this.callback) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders() {\n        throw new SocketError(\"bad connect\", null);\n    }\n    onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context } = this;\n        removeSignal(this);\n        this.callback = null;\n        let headers = rawHeaders;\n        // Indicates is an HTTP2Session\n        if (headers != null) {\n            headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        }\n        this.runInAsyncScope(callback, null, null, {\n            statusCode,\n            headers,\n            socket,\n            opaque,\n            context\n        });\n    }\n    onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n    }\n}\nfunction connect(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            connect.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        const connectHandler = new ConnectHandler(opts, callback);\n        this.dispatch({\n            ...opts,\n            method: \"CONNECT\"\n        }, connectHandler);\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = connect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1jb25uZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxhQUFhLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFQyxvQkFBb0IsRUFBRUMsbUJBQW1CLEVBQUVDLFdBQVcsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUMzRSxNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVLLFNBQVMsRUFBRUMsWUFBWSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBRTVDLE1BQU1PLHVCQUF1QlI7SUFDM0JTLFlBQWFDLElBQUksRUFBRUMsUUFBUSxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsUUFBUSxPQUFPQSxTQUFTLFVBQVU7WUFDckMsTUFBTSxJQUFJUixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLE9BQU9TLGFBQWEsWUFBWTtZQUNsQyxNQUFNLElBQUlULHFCQUFxQjtRQUNqQztRQUVBLE1BQU0sRUFBRVUsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHSjtRQUU1QyxJQUFJRSxVQUFVLE9BQU9BLE9BQU9HLEVBQUUsS0FBSyxjQUFjLE9BQU9ILE9BQU9JLGdCQUFnQixLQUFLLFlBQVk7WUFDOUYsTUFBTSxJQUFJZCxxQkFBcUI7UUFDakM7UUFFQSxLQUFLLENBQUM7UUFFTixJQUFJLENBQUNXLE1BQU0sR0FBR0EsVUFBVTtRQUN4QixJQUFJLENBQUNDLGVBQWUsR0FBR0EsbUJBQW1CO1FBQzFDLElBQUksQ0FBQ0gsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNNLEtBQUssR0FBRztRQUViWCxVQUFVLElBQUksRUFBRU07SUFDbEI7SUFFQU0sVUFBV0QsS0FBSyxFQUFFRSxPQUFPLEVBQUU7UUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQ1IsUUFBUSxFQUFFO1lBQ2xCLE1BQU0sSUFBSVI7UUFDWjtRQUVBLElBQUksQ0FBQ2MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0UsT0FBTyxHQUFHQTtJQUNqQjtJQUVBQyxZQUFhO1FBQ1gsTUFBTSxJQUFJaEIsWUFBWSxlQUFlO0lBQ3ZDO0lBRUFpQixVQUFXQyxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFO1FBQ3pDLE1BQU0sRUFBRWIsUUFBUSxFQUFFRSxNQUFNLEVBQUVNLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFFMUNaLGFBQWEsSUFBSTtRQUVqQixJQUFJLENBQUNJLFFBQVEsR0FBRztRQUVoQixJQUFJYyxVQUFVRjtRQUNkLCtCQUErQjtRQUMvQixJQUFJRSxXQUFXLE1BQU07WUFDbkJBLFVBQVUsSUFBSSxDQUFDWCxlQUFlLEtBQUssUUFBUVQsS0FBS3FCLGVBQWUsQ0FBQ0gsY0FBY2xCLEtBQUtzQixZQUFZLENBQUNKO1FBQ2xHO1FBRUEsSUFBSSxDQUFDSyxlQUFlLENBQUNqQixVQUFVLE1BQU0sTUFBTTtZQUN6Q1c7WUFDQUc7WUFDQUQ7WUFDQVg7WUFDQU07UUFDRjtJQUNGO0lBRUFVLFFBQVNDLEdBQUcsRUFBRTtRQUNaLE1BQU0sRUFBRW5CLFFBQVEsRUFBRUUsTUFBTSxFQUFFLEdBQUcsSUFBSTtRQUVqQ04sYUFBYSxJQUFJO1FBRWpCLElBQUlJLFVBQVU7WUFDWixJQUFJLENBQUNBLFFBQVEsR0FBRztZQUNoQm9CLGVBQWU7Z0JBQ2IsSUFBSSxDQUFDSCxlQUFlLENBQUNqQixVQUFVLE1BQU1tQixLQUFLO29CQUFFakI7Z0JBQU87WUFDckQ7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTbUIsUUFBU3RCLElBQUksRUFBRUMsUUFBUTtJQUM5QixJQUFJQSxhQUFhc0IsV0FBVztRQUMxQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0JKLFFBQVFLLElBQUksQ0FBQyxJQUFJLEVBQUUzQixNQUFNLENBQUNvQixLQUFLUTtnQkFDN0IsT0FBT1IsTUFBTU0sT0FBT04sT0FBT0ssUUFBUUc7WUFDckM7UUFDRjtJQUNGO0lBRUEsSUFBSTtRQUNGLE1BQU1DLGlCQUFpQixJQUFJL0IsZUFBZUUsTUFBTUM7UUFDaEQsSUFBSSxDQUFDNkIsUUFBUSxDQUFDO1lBQUUsR0FBRzlCLElBQUk7WUFBRStCLFFBQVE7UUFBVSxHQUFHRjtJQUNoRCxFQUFFLE9BQU9ULEtBQUs7UUFDWixJQUFJLE9BQU9uQixhQUFhLFlBQVk7WUFDbEMsTUFBTW1CO1FBQ1I7UUFDQSxNQUFNakIsU0FBU0gsUUFBUUEsS0FBS0csTUFBTTtRQUNsQ2tCLGVBQWUsSUFBTXBCLFNBQVNtQixLQUFLO2dCQUFFakI7WUFBTztJQUM5QztBQUNGO0FBRUE2QixPQUFPQyxPQUFPLEdBQUdYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLWNvbm5lY3QuanM/ZmFhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdhc3luY19ob29rcycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBSZXF1ZXN0QWJvcnRlZEVycm9yLCBTb2NrZXRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5cbmNsYXNzIENvbm5lY3RIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBvcGFxdWUsIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0c1xuXG4gICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgIH1cblxuICAgIHN1cGVyKCdVTkRJQ0lfQ09OTkVDVCcpXG5cbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMuYWJvcnQgPSBudWxsXG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICghdGhpcy5jYWxsYmFjaykge1xuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoKSB7XG4gICAgdGhyb3cgbmV3IFNvY2tldEVycm9yKCdiYWQgY29ubmVjdCcsIG51bGwpXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHNvY2tldCkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSwgY29udGV4dCB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuXG4gICAgbGV0IGhlYWRlcnMgPSByYXdIZWFkZXJzXG4gICAgLy8gSW5kaWNhdGVzIGlzIGFuIEhUVFAyU2Vzc2lvblxuICAgIGlmIChoZWFkZXJzICE9IG51bGwpIHtcbiAgICAgIGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgfVxuXG4gICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIG51bGwsIHtcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc29ja2V0LFxuICAgICAgb3BhcXVlLFxuICAgICAgY29udGV4dFxuICAgIH0pXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29ubmVjdCAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29ubmVjdC5jYWxsKHRoaXMsIG9wdHMsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBjb25uZWN0SGFuZGxlciA9IG5ldyBDb25uZWN0SGFuZGxlcihvcHRzLCBjYWxsYmFjaylcbiAgICB0aGlzLmRpc3BhdGNoKHsgLi4ub3B0cywgbWV0aG9kOiAnQ09OTkVDVCcgfSwgY29ubmVjdEhhbmRsZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzICYmIG9wdHMub3BhcXVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3RcbiJdLCJuYW1lcyI6WyJBc3luY1Jlc291cmNlIiwicmVxdWlyZSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsIlNvY2tldEVycm9yIiwidXRpbCIsImFkZFNpZ25hbCIsInJlbW92ZVNpZ25hbCIsIkNvbm5lY3RIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiY2FsbGJhY2siLCJzaWduYWwiLCJvcGFxdWUiLCJyZXNwb25zZUhlYWRlcnMiLCJvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJhYm9ydCIsIm9uQ29ubmVjdCIsImNvbnRleHQiLCJvbkhlYWRlcnMiLCJvblVwZ3JhZGUiLCJzdGF0dXNDb2RlIiwicmF3SGVhZGVycyIsInNvY2tldCIsImhlYWRlcnMiLCJwYXJzZVJhd0hlYWRlcnMiLCJwYXJzZUhlYWRlcnMiLCJydW5JbkFzeW5jU2NvcGUiLCJvbkVycm9yIiwiZXJyIiwicXVldWVNaWNyb3Rhc2siLCJjb25uZWN0IiwidW5kZWZpbmVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYWxsIiwiZGF0YSIsImNvbm5lY3RIYW5kbGVyIiwiZGlzcGF0Y2giLCJtZXRob2QiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/api/api-connect.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/api/api-pipeline.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/api/api-pipeline.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Readable, Duplex, PassThrough } = __webpack_require__(/*! stream */ \"stream\");\nconst { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/../../node_modules/undici/lib/api/abort-signal.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst kResume = Symbol(\"resume\");\nclass PipelineRequest extends Readable {\n    constructor(){\n        super({\n            autoDestroy: true\n        });\n        this[kResume] = null;\n    }\n    _read() {\n        const { [kResume]: resume } = this;\n        if (resume) {\n            this[kResume] = null;\n            resume();\n        }\n    }\n    _destroy(err, callback) {\n        this._read();\n        callback(err);\n    }\n}\nclass PipelineResponse extends Readable {\n    constructor(resume){\n        super({\n            autoDestroy: true\n        });\n        this[kResume] = resume;\n    }\n    _read() {\n        this[kResume]();\n    }\n    _destroy(err, callback) {\n        if (!err && !this._readableState.endEmitted) {\n            err = new RequestAbortedError();\n        }\n        callback(err);\n    }\n}\nclass PipelineHandler extends AsyncResource {\n    constructor(opts, handler){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof handler !== \"function\") {\n            throw new InvalidArgumentError(\"invalid handler\");\n        }\n        const { signal, method, opaque, onInfo, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        if (method === \"CONNECT\") {\n            throw new InvalidArgumentError(\"invalid method\");\n        }\n        if (onInfo && typeof onInfo !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onInfo callback\");\n        }\n        super(\"UNDICI_PIPELINE\");\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.handler = handler;\n        this.abort = null;\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.req = new PipelineRequest().on(\"error\", util.nop);\n        this.ret = new Duplex({\n            readableObjectMode: opts.objectMode,\n            autoDestroy: true,\n            read: ()=>{\n                const { body } = this;\n                if (body && body.resume) {\n                    body.resume();\n                }\n            },\n            write: (chunk, encoding, callback)=>{\n                const { req } = this;\n                if (req.push(chunk, encoding) || req._readableState.destroyed) {\n                    callback();\n                } else {\n                    req[kResume] = callback;\n                }\n            },\n            destroy: (err, callback)=>{\n                const { body, req, res, ret, abort } = this;\n                if (!err && !ret._readableState.endEmitted) {\n                    err = new RequestAbortedError();\n                }\n                if (abort && err) {\n                    abort();\n                }\n                util.destroy(body, err);\n                util.destroy(req, err);\n                util.destroy(res, err);\n                removeSignal(this);\n                callback(err);\n            }\n        }).on(\"prefinish\", ()=>{\n            const { req } = this;\n            // Node < 15 does not call _final in same tick.\n            req.push(null);\n        });\n        this.res = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        const { ret, res } = this;\n        assert(!res, \"pipeline cannot be retried\");\n        if (ret.destroyed) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume) {\n        const { opaque, handler, context } = this;\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                const headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        this.res = new PipelineResponse(resume);\n        let body;\n        try {\n            this.handler = null;\n            const headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n            body = this.runInAsyncScope(handler, null, {\n                statusCode,\n                headers,\n                opaque,\n                body: this.res,\n                context\n            });\n        } catch (err) {\n            this.res.on(\"error\", util.nop);\n            throw err;\n        }\n        if (!body || typeof body.on !== \"function\") {\n            throw new InvalidReturnValueError(\"expected Readable\");\n        }\n        body.on(\"data\", (chunk)=>{\n            const { ret, body } = this;\n            if (!ret.push(chunk) && body.pause) {\n                body.pause();\n            }\n        }).on(\"error\", (err)=>{\n            const { ret } = this;\n            util.destroy(ret, err);\n        }).on(\"end\", ()=>{\n            const { ret } = this;\n            ret.push(null);\n        }).on(\"close\", ()=>{\n            const { ret } = this;\n            if (!ret._readableState.ended) {\n                util.destroy(ret, new RequestAbortedError());\n            }\n        });\n        this.body = body;\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res.push(chunk);\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        res.push(null);\n    }\n    onError(err) {\n        const { ret } = this;\n        this.handler = null;\n        util.destroy(ret, err);\n    }\n}\nfunction pipeline(opts, handler) {\n    try {\n        const pipelineHandler = new PipelineHandler(opts, handler);\n        this.dispatch({\n            ...opts,\n            body: pipelineHandler.req\n        }, pipelineHandler);\n        return pipelineHandler.ret;\n    } catch (err) {\n        return new PassThrough().destroy(err);\n    }\n}\nmodule.exports = pipeline;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1waXBlbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFDSkEsUUFBUSxFQUNSQyxNQUFNLEVBQ05DLFdBQVcsRUFDWixHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFDSkMsb0JBQW9CLEVBQ3BCQyx1QkFBdUIsRUFDdkJDLG1CQUFtQixFQUNwQixHQUFHSCxtQkFBT0EsQ0FBQztBQUNaLE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUssYUFBYSxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRU0sU0FBUyxFQUFFQyxZQUFZLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDNUMsTUFBTVEsU0FBU1IsbUJBQU9BLENBQUM7QUFFdkIsTUFBTVMsVUFBVUMsT0FBTztBQUV2QixNQUFNQyx3QkFBd0JkO0lBQzVCZSxhQUFlO1FBQ2IsS0FBSyxDQUFDO1lBQUVDLGFBQWE7UUFBSztRQUUxQixJQUFJLENBQUNKLFFBQVEsR0FBRztJQUNsQjtJQUVBSyxRQUFTO1FBQ1AsTUFBTSxFQUFFLENBQUNMLFFBQVEsRUFBRU0sTUFBTSxFQUFFLEdBQUcsSUFBSTtRQUVsQyxJQUFJQSxRQUFRO1lBQ1YsSUFBSSxDQUFDTixRQUFRLEdBQUc7WUFDaEJNO1FBQ0Y7SUFDRjtJQUVBQyxTQUFVQyxHQUFHLEVBQUVDLFFBQVEsRUFBRTtRQUN2QixJQUFJLENBQUNKLEtBQUs7UUFFVkksU0FBU0Q7SUFDWDtBQUNGO0FBRUEsTUFBTUUseUJBQXlCdEI7SUFDN0JlLFlBQWFHLE1BQU0sQ0FBRTtRQUNuQixLQUFLLENBQUM7WUFBRUYsYUFBYTtRQUFLO1FBQzFCLElBQUksQ0FBQ0osUUFBUSxHQUFHTTtJQUNsQjtJQUVBRCxRQUFTO1FBQ1AsSUFBSSxDQUFDTCxRQUFRO0lBQ2Y7SUFFQU8sU0FBVUMsR0FBRyxFQUFFQyxRQUFRLEVBQUU7UUFDdkIsSUFBSSxDQUFDRCxPQUFPLENBQUMsSUFBSSxDQUFDRyxjQUFjLENBQUNDLFVBQVUsRUFBRTtZQUMzQ0osTUFBTSxJQUFJZDtRQUNaO1FBRUFlLFNBQVNEO0lBQ1g7QUFDRjtBQUVBLE1BQU1LLHdCQUF3QmpCO0lBQzVCTyxZQUFhVyxJQUFJLEVBQUVDLE9BQU8sQ0FBRTtRQUMxQixJQUFJLENBQUNELFFBQVEsT0FBT0EsU0FBUyxVQUFVO1lBQ3JDLE1BQU0sSUFBSXRCLHFCQUFxQjtRQUNqQztRQUVBLElBQUksT0FBT3VCLFlBQVksWUFBWTtZQUNqQyxNQUFNLElBQUl2QixxQkFBcUI7UUFDakM7UUFFQSxNQUFNLEVBQUV3QixNQUFNLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHTjtRQUU1RCxJQUFJRSxVQUFVLE9BQU9BLE9BQU9LLEVBQUUsS0FBSyxjQUFjLE9BQU9MLE9BQU9NLGdCQUFnQixLQUFLLFlBQVk7WUFDOUYsTUFBTSxJQUFJOUIscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSXlCLFdBQVcsV0FBVztZQUN4QixNQUFNLElBQUl6QixxQkFBcUI7UUFDakM7UUFFQSxJQUFJMkIsVUFBVSxPQUFPQSxXQUFXLFlBQVk7WUFDMUMsTUFBTSxJQUFJM0IscUJBQXFCO1FBQ2pDO1FBRUEsS0FBSyxDQUFDO1FBRU4sSUFBSSxDQUFDMEIsTUFBTSxHQUFHQSxVQUFVO1FBQ3hCLElBQUksQ0FBQ0UsZUFBZSxHQUFHQSxtQkFBbUI7UUFDMUMsSUFBSSxDQUFDTCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDUSxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0wsTUFBTSxHQUFHQSxVQUFVO1FBRXhCLElBQUksQ0FBQ00sR0FBRyxHQUFHLElBQUl2QixrQkFBa0JtQixFQUFFLENBQUMsU0FBUzFCLEtBQUsrQixHQUFHO1FBRXJELElBQUksQ0FBQ0MsR0FBRyxHQUFHLElBQUl0QyxPQUFPO1lBQ3BCdUMsb0JBQW9CZCxLQUFLZSxVQUFVO1lBQ25DekIsYUFBYTtZQUNiMEIsTUFBTTtnQkFDSixNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHLElBQUk7Z0JBRXJCLElBQUlBLFFBQVFBLEtBQUt6QixNQUFNLEVBQUU7b0JBQ3ZCeUIsS0FBS3pCLE1BQU07Z0JBQ2I7WUFDRjtZQUNBMEIsT0FBTyxDQUFDQyxPQUFPQyxVQUFVekI7Z0JBQ3ZCLE1BQU0sRUFBRWdCLEdBQUcsRUFBRSxHQUFHLElBQUk7Z0JBRXBCLElBQUlBLElBQUlVLElBQUksQ0FBQ0YsT0FBT0MsYUFBYVQsSUFBSWQsY0FBYyxDQUFDeUIsU0FBUyxFQUFFO29CQUM3RDNCO2dCQUNGLE9BQU87b0JBQ0xnQixHQUFHLENBQUN6QixRQUFRLEdBQUdTO2dCQUNqQjtZQUNGO1lBQ0E0QixTQUFTLENBQUM3QixLQUFLQztnQkFDYixNQUFNLEVBQUVzQixJQUFJLEVBQUVOLEdBQUcsRUFBRWEsR0FBRyxFQUFFWCxHQUFHLEVBQUVKLEtBQUssRUFBRSxHQUFHLElBQUk7Z0JBRTNDLElBQUksQ0FBQ2YsT0FBTyxDQUFDbUIsSUFBSWhCLGNBQWMsQ0FBQ0MsVUFBVSxFQUFFO29CQUMxQ0osTUFBTSxJQUFJZDtnQkFDWjtnQkFFQSxJQUFJNkIsU0FBU2YsS0FBSztvQkFDaEJlO2dCQUNGO2dCQUVBNUIsS0FBSzBDLE9BQU8sQ0FBQ04sTUFBTXZCO2dCQUNuQmIsS0FBSzBDLE9BQU8sQ0FBQ1osS0FBS2pCO2dCQUNsQmIsS0FBSzBDLE9BQU8sQ0FBQ0MsS0FBSzlCO2dCQUVsQlYsYUFBYSxJQUFJO2dCQUVqQlcsU0FBU0Q7WUFDWDtRQUNGLEdBQUdhLEVBQUUsQ0FBQyxhQUFhO1lBQ2pCLE1BQU0sRUFBRUksR0FBRyxFQUFFLEdBQUcsSUFBSTtZQUVwQiwrQ0FBK0M7WUFDL0NBLElBQUlVLElBQUksQ0FBQztRQUNYO1FBRUEsSUFBSSxDQUFDRyxHQUFHLEdBQUc7UUFFWHpDLFVBQVUsSUFBSSxFQUFFbUI7SUFDbEI7SUFFQXVCLFVBQVdoQixLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUN6QixNQUFNLEVBQUVHLEdBQUcsRUFBRVcsR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUV6QnZDLE9BQU8sQ0FBQ3VDLEtBQUs7UUFFYixJQUFJWCxJQUFJUyxTQUFTLEVBQUU7WUFDakIsTUFBTSxJQUFJMUM7UUFDWjtRQUVBLElBQUksQ0FBQzZCLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBR0E7SUFDakI7SUFFQWdCLFVBQVdDLFVBQVUsRUFBRUMsVUFBVSxFQUFFcEMsTUFBTSxFQUFFO1FBQ3pDLE1BQU0sRUFBRVksTUFBTSxFQUFFSCxPQUFPLEVBQUVTLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFFekMsSUFBSWlCLGFBQWEsS0FBSztZQUNwQixJQUFJLElBQUksQ0FBQ3RCLE1BQU0sRUFBRTtnQkFDZixNQUFNd0IsVUFBVSxJQUFJLENBQUN2QixlQUFlLEtBQUssUUFBUXpCLEtBQUtpRCxlQUFlLENBQUNGLGNBQWMvQyxLQUFLa0QsWUFBWSxDQUFDSDtnQkFDdEcsSUFBSSxDQUFDdkIsTUFBTSxDQUFDO29CQUFFc0I7b0JBQVlFO2dCQUFRO1lBQ3BDO1lBQ0E7UUFDRjtRQUVBLElBQUksQ0FBQ0wsR0FBRyxHQUFHLElBQUk1QixpQkFBaUJKO1FBRWhDLElBQUl5QjtRQUNKLElBQUk7WUFDRixJQUFJLENBQUNoQixPQUFPLEdBQUc7WUFDZixNQUFNNEIsVUFBVSxJQUFJLENBQUN2QixlQUFlLEtBQUssUUFBUXpCLEtBQUtpRCxlQUFlLENBQUNGLGNBQWMvQyxLQUFLa0QsWUFBWSxDQUFDSDtZQUN0R1gsT0FBTyxJQUFJLENBQUNlLGVBQWUsQ0FBQy9CLFNBQVMsTUFBTTtnQkFDekMwQjtnQkFDQUU7Z0JBQ0F6QjtnQkFDQWEsTUFBTSxJQUFJLENBQUNPLEdBQUc7Z0JBQ2RkO1lBQ0Y7UUFDRixFQUFFLE9BQU9oQixLQUFLO1lBQ1osSUFBSSxDQUFDOEIsR0FBRyxDQUFDakIsRUFBRSxDQUFDLFNBQVMxQixLQUFLK0IsR0FBRztZQUM3QixNQUFNbEI7UUFDUjtRQUVBLElBQUksQ0FBQ3VCLFFBQVEsT0FBT0EsS0FBS1YsRUFBRSxLQUFLLFlBQVk7WUFDMUMsTUFBTSxJQUFJNUIsd0JBQXdCO1FBQ3BDO1FBRUFzQyxLQUNHVixFQUFFLENBQUMsUUFBUSxDQUFDWTtZQUNYLE1BQU0sRUFBRU4sR0FBRyxFQUFFSSxJQUFJLEVBQUUsR0FBRyxJQUFJO1lBRTFCLElBQUksQ0FBQ0osSUFBSVEsSUFBSSxDQUFDRixVQUFVRixLQUFLZ0IsS0FBSyxFQUFFO2dCQUNsQ2hCLEtBQUtnQixLQUFLO1lBQ1o7UUFDRixHQUNDMUIsRUFBRSxDQUFDLFNBQVMsQ0FBQ2I7WUFDWixNQUFNLEVBQUVtQixHQUFHLEVBQUUsR0FBRyxJQUFJO1lBRXBCaEMsS0FBSzBDLE9BQU8sQ0FBQ1YsS0FBS25CO1FBQ3BCLEdBQ0NhLEVBQUUsQ0FBQyxPQUFPO1lBQ1QsTUFBTSxFQUFFTSxHQUFHLEVBQUUsR0FBRyxJQUFJO1lBRXBCQSxJQUFJUSxJQUFJLENBQUM7UUFDWCxHQUNDZCxFQUFFLENBQUMsU0FBUztZQUNYLE1BQU0sRUFBRU0sR0FBRyxFQUFFLEdBQUcsSUFBSTtZQUVwQixJQUFJLENBQUNBLElBQUloQixjQUFjLENBQUNxQyxLQUFLLEVBQUU7Z0JBQzdCckQsS0FBSzBDLE9BQU8sQ0FBQ1YsS0FBSyxJQUFJakM7WUFDeEI7UUFDRjtRQUVGLElBQUksQ0FBQ3FDLElBQUksR0FBR0E7SUFDZDtJQUVBa0IsT0FBUWhCLEtBQUssRUFBRTtRQUNiLE1BQU0sRUFBRUssR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUNwQixPQUFPQSxJQUFJSCxJQUFJLENBQUNGO0lBQ2xCO0lBRUFpQixXQUFZQyxRQUFRLEVBQUU7UUFDcEIsTUFBTSxFQUFFYixHQUFHLEVBQUUsR0FBRyxJQUFJO1FBQ3BCQSxJQUFJSCxJQUFJLENBQUM7SUFDWDtJQUVBaUIsUUFBUzVDLEdBQUcsRUFBRTtRQUNaLE1BQU0sRUFBRW1CLEdBQUcsRUFBRSxHQUFHLElBQUk7UUFDcEIsSUFBSSxDQUFDWixPQUFPLEdBQUc7UUFDZnBCLEtBQUswQyxPQUFPLENBQUNWLEtBQUtuQjtJQUNwQjtBQUNGO0FBRUEsU0FBUzZDLFNBQVV2QyxJQUFJLEVBQUVDLE9BQU87SUFDOUIsSUFBSTtRQUNGLE1BQU11QyxrQkFBa0IsSUFBSXpDLGdCQUFnQkMsTUFBTUM7UUFDbEQsSUFBSSxDQUFDd0MsUUFBUSxDQUFDO1lBQUUsR0FBR3pDLElBQUk7WUFBRWlCLE1BQU11QixnQkFBZ0I3QixHQUFHO1FBQUMsR0FBRzZCO1FBQ3RELE9BQU9BLGdCQUFnQjNCLEdBQUc7SUFDNUIsRUFBRSxPQUFPbkIsS0FBSztRQUNaLE9BQU8sSUFBSWxCLGNBQWMrQyxPQUFPLENBQUM3QjtJQUNuQztBQUNGO0FBRUFnRCxPQUFPQyxPQUFPLEdBQUdKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXBpcGVsaW5lLmpzPzQ5ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgUmVhZGFibGUsXG4gIER1cGxleCxcbiAgUGFzc1Rocm91Z2hcbn0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZFJldHVyblZhbHVlRXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnYXN5bmNfaG9va3MnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxuY29uc3Qga1Jlc3VtZSA9IFN5bWJvbCgncmVzdW1lJylcblxuY2xhc3MgUGlwZWxpbmVSZXF1ZXN0IGV4dGVuZHMgUmVhZGFibGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoeyBhdXRvRGVzdHJveTogdHJ1ZSB9KVxuXG4gICAgdGhpc1trUmVzdW1lXSA9IG51bGxcbiAgfVxuXG4gIF9yZWFkICgpIHtcbiAgICBjb25zdCB7IFtrUmVzdW1lXTogcmVzdW1lIH0gPSB0aGlzXG5cbiAgICBpZiAocmVzdW1lKSB7XG4gICAgICB0aGlzW2tSZXN1bWVdID0gbnVsbFxuICAgICAgcmVzdW1lKClcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3JlYWQoKVxuXG4gICAgY2FsbGJhY2soZXJyKVxuICB9XG59XG5cbmNsYXNzIFBpcGVsaW5lUmVzcG9uc2UgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChyZXN1bWUpIHtcbiAgICBzdXBlcih7IGF1dG9EZXN0cm95OiB0cnVlIH0pXG4gICAgdGhpc1trUmVzdW1lXSA9IHJlc3VtZVxuICB9XG5cbiAgX3JlYWQgKCkge1xuICAgIHRoaXNba1Jlc3VtZV0oKVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWVyciAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXJyKVxuICB9XG59XG5cbmNsYXNzIFBpcGVsaW5lSGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgaGFuZGxlcikge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBoYW5kbGVyJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgbWV0aG9kLCBvcGFxdWUsIG9uSW5mbywgcmVzcG9uc2VIZWFkZXJzIH0gPSBvcHRzXG5cbiAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAob25JbmZvICYmIHR5cGVvZiBvbkluZm8gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkluZm8gY2FsbGJhY2snKVxuICAgIH1cblxuICAgIHN1cGVyKCdVTkRJQ0lfUElQRUxJTkUnKVxuXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG4gICAgdGhpcy5vbkluZm8gPSBvbkluZm8gfHwgbnVsbFxuXG4gICAgdGhpcy5yZXEgPSBuZXcgUGlwZWxpbmVSZXF1ZXN0KCkub24oJ2Vycm9yJywgdXRpbC5ub3ApXG5cbiAgICB0aGlzLnJldCA9IG5ldyBEdXBsZXgoe1xuICAgICAgcmVhZGFibGVPYmplY3RNb2RlOiBvcHRzLm9iamVjdE1vZGUsXG4gICAgICBhdXRvRGVzdHJveTogdHJ1ZSxcbiAgICAgIHJlYWQ6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBib2R5IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKGJvZHkgJiYgYm9keS5yZXN1bWUpIHtcbiAgICAgICAgICBib2R5LnJlc3VtZSgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3cml0ZTogKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgeyByZXEgfSA9IHRoaXNcblxuICAgICAgICBpZiAocmVxLnB1c2goY2h1bmssIGVuY29kaW5nKSB8fCByZXEuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcVtrUmVzdW1lXSA9IGNhbGxiYWNrXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiAoZXJyLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCB7IGJvZHksIHJlcSwgcmVzLCByZXQsIGFib3J0IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKCFlcnIgJiYgIXJldC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFib3J0ICYmIGVycikge1xuICAgICAgICAgIGFib3J0KClcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgICAgIHV0aWwuZGVzdHJveShyZXEsIGVycilcbiAgICAgICAgdXRpbC5kZXN0cm95KHJlcywgZXJyKVxuXG4gICAgICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICB9KS5vbigncHJlZmluaXNoJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXEgfSA9IHRoaXNcblxuICAgICAgLy8gTm9kZSA8IDE1IGRvZXMgbm90IGNhbGwgX2ZpbmFsIGluIHNhbWUgdGljay5cbiAgICAgIHJlcS5wdXNoKG51bGwpXG4gICAgfSlcblxuICAgIHRoaXMucmVzID0gbnVsbFxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHJldCwgcmVzIH0gPSB0aGlzXG5cbiAgICBhc3NlcnQoIXJlcywgJ3BpcGVsaW5lIGNhbm5vdCBiZSByZXRyaWVkJylcblxuICAgIGlmIChyZXQuZGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUpIHtcbiAgICBjb25zdCB7IG9wYXF1ZSwgaGFuZGxlciwgY29udGV4dCB9ID0gdGhpc1xuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnMgfSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMucmVzID0gbmV3IFBpcGVsaW5lUmVzcG9uc2UocmVzdW1lKVxuXG4gICAgbGV0IGJvZHlcbiAgICB0cnkge1xuICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbFxuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICAgIGJvZHkgPSB0aGlzLnJ1bkluQXN5bmNTY29wZShoYW5kbGVyLCBudWxsLCB7XG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG9wYXF1ZSxcbiAgICAgICAgYm9keTogdGhpcy5yZXMsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLnJlcy5vbignZXJyb3InLCB1dGlsLm5vcClcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIGlmICghYm9keSB8fCB0eXBlb2YgYm9keS5vbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRSZXR1cm5WYWx1ZUVycm9yKCdleHBlY3RlZCBSZWFkYWJsZScpXG4gICAgfVxuXG4gICAgYm9keVxuICAgICAgLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmV0LCBib2R5IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKCFyZXQucHVzaChjaHVuaykgJiYgYm9keS5wYXVzZSkge1xuICAgICAgICAgIGJvZHkucGF1c2UoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXNcblxuICAgICAgICB1dGlsLmRlc3Ryb3kocmV0LCBlcnIpXG4gICAgICB9KVxuICAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG5cbiAgICAgICAgcmV0LnB1c2gobnVsbClcbiAgICAgIH0pXG4gICAgICAub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuXG4gICAgICAgIGlmICghcmV0Ll9yZWFkYWJsZVN0YXRlLmVuZGVkKSB7XG4gICAgICAgICAgdXRpbC5kZXN0cm95KHJldCwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuICAgIHJldHVybiByZXMucHVzaChjaHVuaylcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcbiAgICByZXMucHVzaChudWxsKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyByZXQgfSA9IHRoaXNcbiAgICB0aGlzLmhhbmRsZXIgPSBudWxsXG4gICAgdXRpbC5kZXN0cm95KHJldCwgZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lIChvcHRzLCBoYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGlwZWxpbmVIYW5kbGVyID0gbmV3IFBpcGVsaW5lSGFuZGxlcihvcHRzLCBoYW5kbGVyKVxuICAgIHRoaXMuZGlzcGF0Y2goeyAuLi5vcHRzLCBib2R5OiBwaXBlbGluZUhhbmRsZXIucmVxIH0sIHBpcGVsaW5lSGFuZGxlcilcbiAgICByZXR1cm4gcGlwZWxpbmVIYW5kbGVyLnJldFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKCkuZGVzdHJveShlcnIpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaXBlbGluZVxuIl0sIm5hbWVzIjpbIlJlYWRhYmxlIiwiRHVwbGV4IiwiUGFzc1Rocm91Z2giLCJyZXF1aXJlIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJ1dGlsIiwiQXN5bmNSZXNvdXJjZSIsImFkZFNpZ25hbCIsInJlbW92ZVNpZ25hbCIsImFzc2VydCIsImtSZXN1bWUiLCJTeW1ib2wiLCJQaXBlbGluZVJlcXVlc3QiLCJjb25zdHJ1Y3RvciIsImF1dG9EZXN0cm95IiwiX3JlYWQiLCJyZXN1bWUiLCJfZGVzdHJveSIsImVyciIsImNhbGxiYWNrIiwiUGlwZWxpbmVSZXNwb25zZSIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kRW1pdHRlZCIsIlBpcGVsaW5lSGFuZGxlciIsIm9wdHMiLCJoYW5kbGVyIiwic2lnbmFsIiwibWV0aG9kIiwib3BhcXVlIiwib25JbmZvIiwicmVzcG9uc2VIZWFkZXJzIiwib24iLCJhZGRFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJjb250ZXh0IiwicmVxIiwibm9wIiwicmV0IiwicmVhZGFibGVPYmplY3RNb2RlIiwib2JqZWN0TW9kZSIsInJlYWQiLCJib2R5Iiwid3JpdGUiLCJjaHVuayIsImVuY29kaW5nIiwicHVzaCIsImRlc3Ryb3llZCIsImRlc3Ryb3kiLCJyZXMiLCJvbkNvbm5lY3QiLCJvbkhlYWRlcnMiLCJzdGF0dXNDb2RlIiwicmF3SGVhZGVycyIsImhlYWRlcnMiLCJwYXJzZVJhd0hlYWRlcnMiLCJwYXJzZUhlYWRlcnMiLCJydW5JbkFzeW5jU2NvcGUiLCJwYXVzZSIsImVuZGVkIiwib25EYXRhIiwib25Db21wbGV0ZSIsInRyYWlsZXJzIiwib25FcnJvciIsInBpcGVsaW5lIiwicGlwZWxpbmVIYW5kbGVyIiwiZGlzcGF0Y2giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/api/api-pipeline.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/api/api-request.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/api/api-request.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Readable = __webpack_require__(/*! ./readable */ \"(rsc)/../../node_modules/undici/lib/api/readable.js\");\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/api/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/../../node_modules/undici/lib/api/abort-signal.js\");\nclass RequestHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;\n        try {\n            if (typeof callback !== \"function\") {\n                throw new InvalidArgumentError(\"invalid callback\");\n            }\n            if (highWaterMark && (typeof highWaterMark !== \"number\" || highWaterMark < 0)) {\n                throw new InvalidArgumentError(\"invalid highWaterMark\");\n            }\n            if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n                throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n            }\n            if (method === \"CONNECT\") {\n                throw new InvalidArgumentError(\"invalid method\");\n            }\n            if (onInfo && typeof onInfo !== \"function\") {\n                throw new InvalidArgumentError(\"invalid onInfo callback\");\n            }\n            super(\"UNDICI_REQUEST\");\n        } catch (err) {\n            if (util.isStream(body)) {\n                util.destroy(body.on(\"error\", util.nop), err);\n            }\n            throw err;\n        }\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.body = body;\n        this.trailers = {};\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.throwOnError = throwOnError;\n        this.highWaterMark = highWaterMark;\n        if (util.isStream(body)) {\n            body.on(\"error\", (err)=>{\n                this.onError(err);\n            });\n        }\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (!this.callback) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;\n        const headers = responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        const parsedHeaders = responseHeaders === \"raw\" ? util.parseHeaders(rawHeaders) : headers;\n        const contentType = parsedHeaders[\"content-type\"];\n        const body = new Readable({\n            resume,\n            abort,\n            contentType,\n            highWaterMark\n        });\n        this.callback = null;\n        this.res = body;\n        if (callback !== null) {\n            if (this.throwOnError && statusCode >= 400) {\n                this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n                    callback,\n                    body,\n                    contentType,\n                    statusCode,\n                    statusMessage,\n                    headers\n                });\n            } else {\n                this.runInAsyncScope(callback, null, null, {\n                    statusCode,\n                    headers,\n                    trailers: this.trailers,\n                    opaque,\n                    body,\n                    context\n                });\n            }\n        }\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res.push(chunk);\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        removeSignal(this);\n        util.parseHeaders(trailers, this.trailers);\n        res.push(null);\n    }\n    onError(err) {\n        const { res, callback, body, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            // TODO: Does this need queueMicrotask?\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n        if (res) {\n            this.res = null;\n            // Ensure all queued handlers are invoked before destroying res.\n            queueMicrotask(()=>{\n                util.destroy(res, err);\n            });\n        }\n        if (body) {\n            this.body = null;\n            util.destroy(body, err);\n        }\n    }\n}\nfunction request(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            request.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        this.dispatch(opts, new RequestHandler(opts, callback));\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = request;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsV0FBV0MsbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUNKQyxvQkFBb0IsRUFDcEJDLG1CQUFtQixFQUNwQixHQUFHRixtQkFBT0EsQ0FBQztBQUNaLE1BQU1HLE9BQU9ILG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUksMkJBQTJCLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFDaEQsTUFBTSxFQUFFSyxhQUFhLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFTSxTQUFTLEVBQUVDLFlBQVksRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUU1QyxNQUFNUSx1QkFBdUJIO0lBQzNCSSxZQUFhQyxJQUFJLEVBQUVDLFFBQVEsQ0FBRTtRQUMzQixJQUFJLENBQUNELFFBQVEsT0FBT0EsU0FBUyxVQUFVO1lBQ3JDLE1BQU0sSUFBSVQscUJBQXFCO1FBQ2pDO1FBRUEsTUFBTSxFQUFFVyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsZUFBZSxFQUFFQyxZQUFZLEVBQUVDLGFBQWEsRUFBRSxHQUFHVDtRQUUvRixJQUFJO1lBQ0YsSUFBSSxPQUFPQyxhQUFhLFlBQVk7Z0JBQ2xDLE1BQU0sSUFBSVYscUJBQXFCO1lBQ2pDO1lBRUEsSUFBSWtCLGlCQUFrQixRQUFPQSxrQkFBa0IsWUFBWUEsZ0JBQWdCLElBQUk7Z0JBQzdFLE1BQU0sSUFBSWxCLHFCQUFxQjtZQUNqQztZQUVBLElBQUlXLFVBQVUsT0FBT0EsT0FBT1EsRUFBRSxLQUFLLGNBQWMsT0FBT1IsT0FBT1MsZ0JBQWdCLEtBQUssWUFBWTtnQkFDOUYsTUFBTSxJQUFJcEIscUJBQXFCO1lBQ2pDO1lBRUEsSUFBSVksV0FBVyxXQUFXO2dCQUN4QixNQUFNLElBQUlaLHFCQUFxQjtZQUNqQztZ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UUFDUjtRQUNBLE1BQU1SLFNBQVNKLFFBQVFBLEtBQUtJLE1BQU07UUFDbENpQyxlQUFlLElBQU1wQyxTQUFTVyxLQUFLO2dCQUFFUjtZQUFPO0lBQzlDO0FBQ0Y7QUFFQTBDLE9BQU9DLE9BQU8sR0FBR1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktcmVxdWVzdC5qcz85MTZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKVxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2sgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ2FzeW5jX2hvb2tzJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcblxuY2xhc3MgUmVxdWVzdEhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgYm9keSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMsIHRocm93T25FcnJvciwgaGlnaFdhdGVyTWFyayB9ID0gb3B0c1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgaWYgKGhpZ2hXYXRlck1hcmsgJiYgKHR5cGVvZiBoaWdoV2F0ZXJNYXJrICE9PSAnbnVtYmVyJyB8fCBoaWdoV2F0ZXJNYXJrIDwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhpZ2hXYXRlck1hcmsnKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICAgIH1cblxuICAgICAgaWYgKG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtZXRob2QnKVxuICAgICAgfVxuXG4gICAgICBpZiAob25JbmZvICYmIHR5cGVvZiBvbkluZm8gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uSW5mbyBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIHN1cGVyKCdVTkRJQ0lfUkVRVUVTVCcpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICB1dGlsLmRlc3Ryb3koYm9keS5vbignZXJyb3InLCB1dGlsLm5vcCksIGVycilcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5yZXMgPSBudWxsXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmJvZHkgPSBib2R5XG4gICAgdGhpcy50cmFpbGVycyA9IHt9XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGxcbiAgICB0aGlzLnRocm93T25FcnJvciA9IHRocm93T25FcnJvclxuICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IGhpZ2hXYXRlck1hcmtcblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICBib2R5Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSwgYWJvcnQsIGNvbnRleHQsIHJlc3BvbnNlSGVhZGVycywgaGlnaFdhdGVyTWFyayB9ID0gdGhpc1xuXG4gICAgY29uc3QgaGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgaWYgKHRoaXMub25JbmZvKSB7XG4gICAgICAgIHRoaXMub25JbmZvKHsgc3RhdHVzQ29kZSwgaGVhZGVycyB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSA6IGhlYWRlcnNcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHBhcnNlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gICAgY29uc3QgYm9keSA9IG5ldyBSZWFkYWJsZSh7IHJlc3VtZSwgYWJvcnQsIGNvbnRlbnRUeXBlLCBoaWdoV2F0ZXJNYXJrIH0pXG5cbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgIHRoaXMucmVzID0gYm9keVxuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMudGhyb3dPbkVycm9yICYmIHN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjaywgbnVsbCxcbiAgICAgICAgICB7IGNhbGxiYWNrLCBib2R5LCBjb250ZW50VHlwZSwgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycyB9XG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIHRyYWlsZXJzOiB0aGlzLnRyYWlsZXJzLFxuICAgICAgICAgIG9wYXF1ZSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcbiAgICByZXR1cm4gcmVzLnB1c2goY2h1bmspXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHV0aWwucGFyc2VIZWFkZXJzKHRyYWlsZXJzLCB0aGlzLnRyYWlsZXJzKVxuXG4gICAgcmVzLnB1c2gobnVsbClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgcmVzLCBjYWxsYmFjaywgYm9keSwgb3BhcXVlIH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgLy8gVE9ETzogRG9lcyB0aGlzIG5lZWQgcXVldWVNaWNyb3Rhc2s/XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAocmVzKSB7XG4gICAgICB0aGlzLnJlcyA9IG51bGxcbiAgICAgIC8vIEVuc3VyZSBhbGwgcXVldWVkIGhhbmRsZXJzIGFyZSBpbnZva2VkIGJlZm9yZSBkZXN0cm95aW5nIHJlcy5cbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHJlcywgZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgdGhpcy5ib2R5ID0gbnVsbFxuICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdCAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVxdWVzdC5jYWxsKHRoaXMsIG9wdHMsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmRpc3BhdGNoKG9wdHMsIG5ldyBSZXF1ZXN0SGFuZGxlcihvcHRzLCBjYWxsYmFjaykpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzICYmIG9wdHMub3BhcXVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVlc3RcbiJdLCJuYW1lcyI6WyJSZWFkYWJsZSIsInJlcXVpcmUiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJ1dGlsIiwiZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrIiwiQXN5bmNSZXNvdXJjZSIsImFkZFNpZ25hbCIsInJlbW92ZVNpZ25hbCIsIlJlcXVlc3RIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiY2FsbGJhY2siLCJzaWduYWwiLCJtZXRob2QiLCJvcGFxdWUiLCJib2R5Iiwib25JbmZvIiwicmVzcG9uc2VIZWFkZXJzIiwidGhyb3dPbkVycm9yIiwiaGlnaFdhdGVyTWFyayIsIm9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsImVyciIsImlzU3RyZWFtIiwiZGVzdHJveSIsIm5vcCIsInJlcyIsImFib3J0IiwidHJhaWxlcnMiLCJjb250ZXh0Iiwib25FcnJvciIsIm9uQ29ubmVjdCIsIm9uSGVhZGVycyIsInN0YXR1c0NvZGUiLCJyYXdIZWFkZXJzIiwicmVzdW1lIiwic3RhdHVzTWVzc2FnZSIsImhlYWRlcnMiLCJwYXJzZVJhd0hlYWRlcnMiLCJwYXJzZUhlYWRlcnMiLCJwYXJzZWRIZWFkZXJzIiwiY29udGVudFR5cGUiLCJydW5JbkFzeW5jU2NvcGUiLCJvbkRhdGEiLCJjaHVuayIsInB1c2giLCJvbkNvbXBsZXRlIiwicXVldWVNaWNyb3Rhc2siLCJyZXF1ZXN0IiwidW5kZWZpbmVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYWxsIiwiZGF0YSIsImRpc3BhdGNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/api/api-request.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/api/api-stream.js":
/*!*******************************************************!*\
  !*** ../../node_modules/undici/lib/api/api-stream.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { finished, PassThrough } = __webpack_require__(/*! stream */ \"stream\");\nconst { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/api/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/../../node_modules/undici/lib/api/abort-signal.js\");\nclass StreamHandler extends AsyncResource {\n    constructor(opts, factory, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;\n        try {\n            if (typeof callback !== \"function\") {\n                throw new InvalidArgumentError(\"invalid callback\");\n            }\n            if (typeof factory !== \"function\") {\n                throw new InvalidArgumentError(\"invalid factory\");\n            }\n            if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n                throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n            }\n            if (method === \"CONNECT\") {\n                throw new InvalidArgumentError(\"invalid method\");\n            }\n            if (onInfo && typeof onInfo !== \"function\") {\n                throw new InvalidArgumentError(\"invalid onInfo callback\");\n            }\n            super(\"UNDICI_STREAM\");\n        } catch (err) {\n            if (util.isStream(body)) {\n                util.destroy(body.on(\"error\", util.nop), err);\n            }\n            throw err;\n        }\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.factory = factory;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.context = null;\n        this.trailers = null;\n        this.body = body;\n        this.onInfo = onInfo || null;\n        this.throwOnError = throwOnError || false;\n        if (util.isStream(body)) {\n            body.on(\"error\", (err)=>{\n                this.onError(err);\n            });\n        }\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (!this.callback) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const { factory, opaque, context, callback, responseHeaders } = this;\n        const headers = responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        this.factory = null;\n        let res;\n        if (this.throwOnError && statusCode >= 400) {\n            const parsedHeaders = responseHeaders === \"raw\" ? util.parseHeaders(rawHeaders) : headers;\n            const contentType = parsedHeaders[\"content-type\"];\n            res = new PassThrough();\n            this.callback = null;\n            this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n                callback,\n                body: res,\n                contentType,\n                statusCode,\n                statusMessage,\n                headers\n            });\n        } else {\n            if (factory === null) {\n                return;\n            }\n            res = this.runInAsyncScope(factory, null, {\n                statusCode,\n                headers,\n                opaque,\n                context\n            });\n            if (!res || typeof res.write !== \"function\" || typeof res.end !== \"function\" || typeof res.on !== \"function\") {\n                throw new InvalidReturnValueError(\"expected Writable\");\n            }\n            // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n            finished(res, {\n                readable: false\n            }, (err)=>{\n                const { callback, res, opaque, trailers, abort } = this;\n                this.res = null;\n                if (err || !res.readable) {\n                    util.destroy(res, err);\n                }\n                this.callback = null;\n                this.runInAsyncScope(callback, null, err || null, {\n                    opaque,\n                    trailers\n                });\n                if (err) {\n                    abort();\n                }\n            });\n        }\n        res.on(\"drain\", resume);\n        this.res = res;\n        const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;\n        return needDrain !== true;\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res ? res.write(chunk) : true;\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        removeSignal(this);\n        if (!res) {\n            return;\n        }\n        this.trailers = util.parseHeaders(trailers);\n        res.end();\n    }\n    onError(err) {\n        const { res, callback, opaque, body } = this;\n        removeSignal(this);\n        this.factory = null;\n        if (res) {\n            this.res = null;\n            util.destroy(res, err);\n        } else if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n        if (body) {\n            this.body = null;\n            util.destroy(body, err);\n        }\n    }\n}\nfunction stream(opts, factory, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            stream.call(this, opts, factory, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        this.dispatch(opts, new StreamHandler(opts, factory, callback));\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = stream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFFBQVEsRUFBRUMsV0FBVyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzFDLE1BQU0sRUFDSkMsb0JBQW9CLEVBQ3BCQyx1QkFBdUIsRUFDdkJDLG1CQUFtQixFQUNwQixHQUFHSCxtQkFBT0EsQ0FBQztBQUNaLE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUssMkJBQTJCLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDaEQsTUFBTSxFQUFFTSxhQUFhLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFTyxTQUFTLEVBQUVDLFlBQVksRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUU1QyxNQUFNUyxzQkFBc0JIO0lBQzFCSSxZQUFhQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxDQUFFO1FBQ3BDLElBQUksQ0FBQ0YsUUFBUSxPQUFPQSxTQUFTLFVBQVU7WUFDckMsTUFBTSxJQUFJVixxQkFBcUI7UUFDakM7UUFFQSxNQUFNLEVBQUVhLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxlQUFlLEVBQUVDLFlBQVksRUFBRSxHQUFHVDtRQUVoRixJQUFJO1lBQ0YsSUFBSSxPQUFPRSxhQUFhLFlBQVk7Z0JBQ2xDLE1BQU0sSUFBSVoscUJBQXFCO1lBQ2pDO1lBRUEsSUFBSSxPQUFPVyxZQUFZLFlBQVk7Z0JBQ2pDLE1BQU0sSUFBSVgscUJBQXFCO1lBQ2pDO1lBRUEsSUFBSWEsVUFBVSxPQUFPQSxPQUFPTyxFQUFFLEtBQUssY0FBYyxPQUFPUCxPQUFPUSxnQkFBZ0IsS0FBSyxZQUFZO2dCQUM5RixNQUFNLElBQUlyQixxQkFBcUI7WUFDakM7WUFFQSxJQUFJYyxXQUFXLFdBQVc7Z0JBQ3hCLE1BQU0sSUFBSWQscUJBQXFCO1lBQ2pDO1lBRUEsSUFBSWlCLFVBQVUsT0FBT0EsV0FBVyxZQUFZO2dCQUMxQyxNQUFNLElBQUlqQixxQkFBcUI7WUFDakM7WUFFQSxLQUFLLENBQUM7UUFDUixFQUFFLE9BQU9zQixLQUFLO1lBQ1osSUFBSW5CLEtBQUtvQixRQUFRLENBQUNQLE9BQU87Z0JBQ3ZCYixLQUFLcUIsT0FBTyxDQUFDUixLQUFLSSxFQUFFLENBQUMsU0FBU2pCLEtBQUtzQixHQUFHLEdBQUdIO1lBQzNDO1lBQ0EsTUFBTUE7UUFDUjtRQUVBLElBQUksQ0FBQ0osZUFBZSxHQUFHQSxtQkFBbUI7UUFDMUMsSUFBSSxDQUFDSCxNQUFNLEdBQUdBLFVBQVU7UUFDeEIsSUFBSSxDQUFDSixPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ2MsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ2IsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsTUFBTSxHQUFHQSxVQUFVO1FBQ3hCLElBQUksQ0FBQ0UsWUFBWSxHQUFHQSxnQkFBZ0I7UUFFcEMsSUFBSWhCLEtBQUtvQixRQUFRLENBQUNQLE9BQU87WUFDdkJBLEtBQUtJLEVBQUUsQ0FBQyxTQUFTLENBQUNFO2dCQUNoQixJQUFJLENBQUNRLE9BQU8sQ0FBQ1I7WUFDZjtRQUNGO1FBRUFoQixVQUFVLElBQUksRUFBRU87SUFDbEI7SUFFQWtCLFVBQVdKLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUNoQixRQUFRLEVBQUU7WUFDbEIsTUFBTSxJQUFJVjtRQUNaO1FBRUEsSUFBSSxDQUFDeUIsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtJQUNqQjtJQUVBSSxVQUFXQyxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFQyxhQUFhLEVBQUU7UUFDeEQsTUFBTSxFQUFFekIsT0FBTyxFQUFFSSxNQUFNLEVBQUVhLE9BQU8sRUFBRWhCLFFBQVEsRUFBRU0sZUFBZSxFQUFFLEdBQUcsSUFBSTtRQUVwRSxNQUFNbUIsVUFBVW5CLG9CQUFvQixRQUFRZixLQUFLbUMsZUFBZSxDQUFDSixjQUFjL0IsS0FBS29DLFlBQVksQ0FBQ0w7UUFFakcsSUFBSUQsYUFBYSxLQUFLO1lBQ3BCLElBQUksSUFBSSxDQUFDaEIsTUFBTSxFQUFFO2dCQUNmLElBQUksQ0FBQ0EsTUFBTSxDQUFDO29CQUFFZ0I7b0JBQVlJO2dCQUFRO1lBQ3BDO1lBQ0E7UUFDRjtRQUVBLElBQUksQ0FBQzFCLE9BQU8sR0FBRztRQUVmLElBQUllO1FBRUosSUFBSSxJQUFJLENBQUNQLFlBQVksSUFBSWMsY0FBYyxLQUFLO1lBQzFDLE1BQU1PLGdCQUFnQnRCLG9CQUFvQixRQUFRZixLQUFLb0MsWUFBWSxDQUFDTCxjQUFjRztZQUNsRixNQUFNSSxjQUFjRCxhQUFhLENBQUMsZUFBZTtZQUNqRGQsTUFBTSxJQUFJNUI7WUFFVixJQUFJLENBQUNjLFFBQVEsR0FBRztZQUNoQixJQUFJLENBQUM4QixlQUFlLENBQUN0Qyw2QkFBNkIsTUFDaEQ7Z0JBQUVRO2dCQUFVSSxNQUFNVTtnQkFBS2U7Z0JBQWFSO2dCQUFZRztnQkFBZUM7WUFBUTtRQUUzRSxPQUFPO1lBQ0wsSUFBSTFCLFlBQVksTUFBTTtnQkFDcEI7WUFDRjtZQUVBZSxNQUFNLElBQUksQ0FBQ2dCLGVBQWUsQ0FBQy9CLFNBQVMsTUFBTTtnQkFDeENzQjtnQkFDQUk7Z0JBQ0F0QjtnQkFDQWE7WUFDRjtZQUVBLElBQ0UsQ0FBQ0YsT0FDRCxPQUFPQSxJQUFJaUIsS0FBSyxLQUFLLGNBQ3JCLE9BQU9qQixJQUFJa0IsR0FBRyxLQUFLLGNBQ25CLE9BQU9sQixJQUFJTixFQUFFLEtBQUssWUFDbEI7Z0JBQ0EsTUFBTSxJQUFJbkIsd0JBQXdCO1lBQ3BDO1lBRUEseUVBQXlFO1lBQ3pFSixTQUFTNkIsS0FBSztnQkFBRW1CLFVBQVU7WUFBTSxHQUFHLENBQUN2QjtnQkFDbEMsTUFBTSxFQUFFVixRQUFRLEVBQUVjLEdBQUcsRUFBRVgsTUFBTSxFQUFFYyxRQUFRLEVBQUVGLEtBQUssRUFBRSxHQUFHLElBQUk7Z0JBRXZELElBQUksQ0FBQ0QsR0FBRyxHQUFHO2dCQUNYLElBQUlKLE9BQU8sQ0FBQ0ksSUFBSW1CLFFBQVEsRUFBRTtvQkFDeEIxQyxLQUFLcUIsT0FBTyxDQUFDRSxLQUFLSjtnQkFDcEI7Z0JBRUEsSUFBSSxDQUFDVixRQUFRLEdBQUc7Z0JBQ2hCLElBQUksQ0FBQzhCLGVBQWUsQ0FBQzlCLFVBQVUsTUFBTVUsT0FBTyxNQUFNO29CQUFFUDtvQkFBUWM7Z0JBQVM7Z0JBRXJFLElBQUlQLEtBQUs7b0JBQ1BLO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBRCxJQUFJTixFQUFFLENBQUMsU0FBU2U7UUFFaEIsSUFBSSxDQUFDVCxHQUFHLEdBQUdBO1FBRVgsTUFBTW9CLFlBQVlwQixJQUFJcUIsaUJBQWlCLEtBQUtDLFlBQ3hDdEIsSUFBSXFCLGlCQUFpQixHQUNyQnJCLElBQUl1QixjQUFjLElBQUl2QixJQUFJdUIsY0FBYyxDQUFDSCxTQUFTO1FBRXRELE9BQU9BLGNBQWM7SUFDdkI7SUFFQUksT0FBUUMsS0FBSyxFQUFFO1FBQ2IsTUFBTSxFQUFFekIsR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUVwQixPQUFPQSxNQUFNQSxJQUFJaUIsS0FBSyxDQUFDUSxTQUFTO0lBQ2xDO0lBRUFDLFdBQVl2QixRQUFRLEVBQUU7UUFDcEIsTUFBTSxFQUFFSCxHQUFHLEVBQUUsR0FBRyxJQUFJO1FBRXBCbkIsYUFBYSxJQUFJO1FBRWpCLElBQUksQ0FBQ21CLEtBQUs7WUFDUjtRQUNGO1FBRUEsSUFBSSxDQUFDRyxRQUFRLEdBQUcxQixLQUFLb0MsWUFBWSxDQUFDVjtRQUVsQ0gsSUFBSWtCLEdBQUc7SUFDVDtJQUVBZCxRQUFTUixHQUFHLEVBQUU7UUFDWixNQUFNLEVBQUVJLEdBQUcsRUFBRWQsUUFBUSxFQUFFRyxNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHLElBQUk7UUFFNUNULGFBQWEsSUFBSTtRQUVqQixJQUFJLENBQUNJLE9BQU8sR0FBRztRQUVmLElBQUllLEtBQUs7WUFDUCxJQUFJLENBQUNBLEdBQUcsR0FBRztZQUNYdkIsS0FBS3FCLE9BQU8sQ0FBQ0UsS0FBS0o7UUFDcEIsT0FBTyxJQUFJVixVQUFVO1lBQ25CLElBQUksQ0FBQ0EsUUFBUSxHQUFHO1lBQ2hCeUMsZUFBZTtnQkFDYixJQUFJLENBQUNYLGVBQWUsQ0FBQzlCLFVBQVUsTUFBTVUsS0FBSztvQkFBRVA7Z0JBQU87WUFDckQ7UUFDRjtRQUVBLElBQUlDLE1BQU07WUFDUixJQUFJLENBQUNBLElBQUksR0FBRztZQUNaYixLQUFLcUIsT0FBTyxDQUFDUixNQUFNTTtRQUNyQjtJQUNGO0FBQ0Y7QUFFQSxTQUFTZ0MsT0FBUTVDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxRQUFRO0lBQ3RDLElBQUlBLGFBQWFvQyxXQUFXO1FBQzFCLE9BQU8sSUFBSU8sUUFBUSxDQUFDQyxTQUFTQztZQUMzQkgsT0FBT0ksSUFBSSxDQUFDLElBQUksRUFBRWhELE1BQU1DLFNBQVMsQ0FBQ1csS0FBS3FDO2dCQUNyQyxPQUFPckMsTUFBTW1DLE9BQU9uQyxPQUFPa0MsUUFBUUc7WUFDckM7UUFDRjtJQUNGO0lBRUEsSUFBSTtRQUNGLElBQUksQ0FBQ0MsUUFBUSxDQUFDbEQsTUFBTSxJQUFJRixjQUFjRSxNQUFNQyxTQUFTQztJQUN2RCxFQUFFLE9BQU9VLEtBQUs7UUFDWixJQUFJLE9BQU9WLGFBQWEsWUFBWTtZQUNsQyxNQUFNVTtRQUNSO1FBQ0EsTUFBTVAsU0FBU0wsUUFBUUEsS0FBS0ssTUFBTTtRQUNsQ3NDLGVBQWUsSUFBTXpDLFNBQVNVLEtBQUs7Z0JBQUVQO1lBQU87SUFDOUM7QUFDRjtBQUVBOEMsT0FBT0MsT0FBTyxHQUFHUiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1zdHJlYW0uanM/ZmI5OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBmaW5pc2hlZCwgUGFzc1Rocm91Z2ggfSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2sgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ2FzeW5jX2hvb2tzJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcblxuY2xhc3MgU3RyZWFtSGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgZmFjdG9yeSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG1ldGhvZCwgb3BhcXVlLCBib2R5LCBvbkluZm8sIHJlc3BvbnNlSGVhZGVycywgdGhyb3dPbkVycm9yIH0gPSBvcHRzXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGZhY3RvcnknKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICAgIH1cblxuICAgICAgaWYgKG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtZXRob2QnKVxuICAgICAgfVxuXG4gICAgICBpZiAob25JbmZvICYmIHR5cGVvZiBvbkluZm8gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uSW5mbyBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIHN1cGVyKCdVTkRJQ0lfU1RSRUFNJylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICAgIHV0aWwuZGVzdHJveShib2R5Lm9uKCdlcnJvcicsIHV0aWwubm9wKSwgZXJyKVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5yZXMgPSBudWxsXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG4gICAgdGhpcy50cmFpbGVycyA9IG51bGxcbiAgICB0aGlzLmJvZHkgPSBib2R5XG4gICAgdGhpcy5vbkluZm8gPSBvbkluZm8gfHwgbnVsbFxuICAgIHRoaXMudGhyb3dPbkVycm9yID0gdGhyb3dPbkVycm9yIHx8IGZhbHNlXG5cbiAgICBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgYm9keS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICBjb25zdCB7IGZhY3RvcnksIG9wYXF1ZSwgY29udGV4dCwgY2FsbGJhY2ssIHJlc3BvbnNlSGVhZGVycyB9ID0gdGhpc1xuXG4gICAgY29uc3QgaGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgaWYgKHRoaXMub25JbmZvKSB7XG4gICAgICAgIHRoaXMub25JbmZvKHsgc3RhdHVzQ29kZSwgaGVhZGVycyB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5mYWN0b3J5ID0gbnVsbFxuXG4gICAgbGV0IHJlc1xuXG4gICAgaWYgKHRoaXMudGhyb3dPbkVycm9yICYmIHN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICBjb25zdCBwYXJzZWRIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIDogaGVhZGVyc1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSBwYXJzZWRIZWFkZXJzWydjb250ZW50LXR5cGUnXVxuICAgICAgcmVzID0gbmV3IFBhc3NUaHJvdWdoKClcblxuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjaywgbnVsbCxcbiAgICAgICAgeyBjYWxsYmFjaywgYm9keTogcmVzLCBjb250ZW50VHlwZSwgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycyB9XG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmYWN0b3J5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByZXMgPSB0aGlzLnJ1bkluQXN5bmNTY29wZShmYWN0b3J5LCBudWxsLCB7XG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG9wYXF1ZSxcbiAgICAgICAgY29udGV4dFxuICAgICAgfSlcblxuICAgICAgaWYgKFxuICAgICAgICAhcmVzIHx8XG4gICAgICAgIHR5cGVvZiByZXMud3JpdGUgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZW9mIHJlcy5lbmQgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZW9mIHJlcy5vbiAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcignZXhwZWN0ZWQgV3JpdGFibGUnKVxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBBdm9pZCBmaW5pc2hlZC4gSXQgcmVnaXN0ZXJzIGFuIHVubmVjZXNzYXJ5IGFtb3VudCBvZiBsaXN0ZW5lcnMuXG4gICAgICBmaW5pc2hlZChyZXMsIHsgcmVhZGFibGU6IGZhbHNlIH0sIChlcnIpID0+IHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFjaywgcmVzLCBvcGFxdWUsIHRyYWlsZXJzLCBhYm9ydCB9ID0gdGhpc1xuXG4gICAgICAgIHRoaXMucmVzID0gbnVsbFxuICAgICAgICBpZiAoZXJyIHx8ICFyZXMucmVhZGFibGUpIHtcbiAgICAgICAgICB1dGlsLmRlc3Ryb3kocmVzLCBlcnIpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyIHx8IG51bGwsIHsgb3BhcXVlLCB0cmFpbGVycyB9KVxuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBhYm9ydCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmVzLm9uKCdkcmFpbicsIHJlc3VtZSlcblxuICAgIHRoaXMucmVzID0gcmVzXG5cbiAgICBjb25zdCBuZWVkRHJhaW4gPSByZXMud3JpdGFibGVOZWVkRHJhaW4gIT09IHVuZGVmaW5lZFxuICAgICAgPyByZXMud3JpdGFibGVOZWVkRHJhaW5cbiAgICAgIDogcmVzLl93cml0YWJsZVN0YXRlICYmIHJlcy5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW5cblxuICAgIHJldHVybiBuZWVkRHJhaW4gIT09IHRydWVcbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuXG4gICAgcmV0dXJuIHJlcyA/IHJlcy53cml0ZShjaHVuaykgOiB0cnVlXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIGlmICghcmVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnRyYWlsZXJzID0gdXRpbC5wYXJzZUhlYWRlcnModHJhaWxlcnMpXG5cbiAgICByZXMuZW5kKClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgcmVzLCBjYWxsYmFjaywgb3BhcXVlLCBib2R5IH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHRoaXMuZmFjdG9yeSA9IG51bGxcblxuICAgIGlmIChyZXMpIHtcbiAgICAgIHRoaXMucmVzID0gbnVsbFxuICAgICAgdXRpbC5kZXN0cm95KHJlcywgZXJyKVxuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChib2R5KSB7XG4gICAgICB0aGlzLmJvZHkgPSBudWxsXG4gICAgICB1dGlsLmRlc3Ryb3koYm9keSwgZXJyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJlYW0gKG9wdHMsIGZhY3RvcnksIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHN0cmVhbS5jYWxsKHRoaXMsIG9wdHMsIGZhY3RvcnksIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmRpc3BhdGNoKG9wdHMsIG5ldyBTdHJlYW1IYW5kbGVyKG9wdHMsIGZhY3RvcnksIGNhbGxiYWNrKSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHMgJiYgb3B0cy5vcGFxdWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyZWFtXG4iXSwibmFtZXMiOlsiZmluaXNoZWQiLCJQYXNzVGhyb3VnaCIsInJlcXVpcmUiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkludmFsaWRSZXR1cm5WYWx1ZUVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsInV0aWwiLCJnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2siLCJBc3luY1Jlc291cmNlIiwiYWRkU2lnbmFsIiwicmVtb3ZlU2lnbmFsIiwiU3RyZWFtSGFuZGxlciIsImNvbnN0cnVjdG9yIiwib3B0cyIsImZhY3RvcnkiLCJjYWxsYmFjayIsInNpZ25hbCIsIm1ldGhvZCIsIm9wYXF1ZSIsImJvZHkiLCJvbkluZm8iLCJyZXNwb25zZUhlYWRlcnMiLCJ0aHJvd09uRXJyb3IiLCJvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJlcnIiLCJpc1N0cmVhbSIsImRlc3Ryb3kiLCJub3AiLCJyZXMiLCJhYm9ydCIsImNvbnRleHQiLCJ0cmFpbGVycyIsIm9uRXJyb3IiLCJvbkNvbm5lY3QiLCJvbkhlYWRlcnMiLCJzdGF0dXNDb2RlIiwicmF3SGVhZGVycyIsInJlc3VtZSIsInN0YXR1c01lc3NhZ2UiLCJoZWFkZXJzIiwicGFyc2VSYXdIZWFkZXJzIiwicGFyc2VIZWFkZXJzIiwicGFyc2VkSGVhZGVycyIsImNvbnRlbnRUeXBlIiwicnVuSW5Bc3luY1Njb3BlIiwid3JpdGUiLCJlbmQiLCJyZWFkYWJsZSIsIm5lZWREcmFpbiIsIndyaXRhYmxlTmVlZERyYWluIiwidW5kZWZpbmVkIiwiX3dyaXRhYmxlU3RhdGUiLCJvbkRhdGEiLCJjaHVuayIsIm9uQ29tcGxldGUiLCJxdWV1ZU1pY3JvdGFzayIsInN0cmVhbSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2FsbCIsImRhdGEiLCJkaXNwYXRjaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/api/api-stream.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/api/api-upgrade.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/api/api-upgrade.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/../../node_modules/undici/lib/api/abort-signal.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nclass UpgradeHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        super(\"UNDICI_UPGRADE\");\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.abort = null;\n        this.context = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (!this.callback) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = null;\n    }\n    onHeaders() {\n        throw new SocketError(\"bad upgrade\", null);\n    }\n    onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context } = this;\n        assert.strictEqual(statusCode, 101);\n        removeSignal(this);\n        this.callback = null;\n        const headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        this.runInAsyncScope(callback, null, null, {\n            headers,\n            socket,\n            opaque,\n            context\n        });\n    }\n    onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n    }\n}\nfunction upgrade(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            upgrade.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        const upgradeHandler = new UpgradeHandler(opts, callback);\n        this.dispatch({\n            ...opts,\n            method: opts.method || \"GET\",\n            upgrade: opts.protocol || \"Websocket\"\n        }, upgradeHandler);\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = upgrade;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS11cGdyYWRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxvQkFBb0IsRUFBRUMsbUJBQW1CLEVBQUVDLFdBQVcsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMzRSxNQUFNLEVBQUVDLGFBQWEsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVHLFNBQVMsRUFBRUMsWUFBWSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQzVDLE1BQU1LLFNBQVNMLG1CQUFPQSxDQUFDO0FBRXZCLE1BQU1NLHVCQUF1Qkw7SUFDM0JNLFlBQWFDLElBQUksRUFBRUMsUUFBUSxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsUUFBUSxPQUFPQSxTQUFTLFVBQVU7WUFDckMsTUFBTSxJQUFJWCxxQkFBcUI7UUFDakM7UUFFQSxJQUFJLE9BQU9ZLGFBQWEsWUFBWTtZQUNsQyxNQUFNLElBQUlaLHFCQUFxQjtRQUNqQztRQUVBLE1BQU0sRUFBRWEsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHSjtRQUU1QyxJQUFJRSxVQUFVLE9BQU9BLE9BQU9HLEVBQUUsS0FBSyxjQUFjLE9BQU9ILE9BQU9JLGdCQUFnQixLQUFLLFlBQVk7WUFDOUYsTUFBTSxJQUFJakIscUJBQXFCO1FBQ2pDO1FBRUEsS0FBSyxDQUFDO1FBRU4sSUFBSSxDQUFDZSxlQUFlLEdBQUdBLG1CQUFtQjtRQUMxQyxJQUFJLENBQUNELE1BQU0sR0FBR0EsVUFBVTtRQUN4QixJQUFJLENBQUNGLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDTSxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUVmYixVQUFVLElBQUksRUFBRU87SUFDbEI7SUFFQU8sVUFBV0YsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQ1AsUUFBUSxFQUFFO1lBQ2xCLE1BQU0sSUFBSVg7UUFDWjtRQUVBLElBQUksQ0FBQ2lCLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNqQjtJQUVBRSxZQUFhO1FBQ1gsTUFBTSxJQUFJbkIsWUFBWSxlQUFlO0lBQ3ZDO0lBRUFvQixVQUFXQyxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFO1FBQ3pDLE1BQU0sRUFBRWIsUUFBUSxFQUFFRSxNQUFNLEVBQUVLLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFFMUNYLE9BQU9rQixXQUFXLENBQUNILFlBQVk7UUFFL0JoQixhQUFhLElBQUk7UUFFakIsSUFBSSxDQUFDSyxRQUFRLEdBQUc7UUFDaEIsTUFBTWUsVUFBVSxJQUFJLENBQUNaLGVBQWUsS0FBSyxRQUFRVixLQUFLdUIsZUFBZSxDQUFDSixjQUFjbkIsS0FBS3dCLFlBQVksQ0FBQ0w7UUFDdEcsSUFBSSxDQUFDTSxlQUFlLENBQUNsQixVQUFVLE1BQU0sTUFBTTtZQUN6Q2U7WUFDQUY7WUFDQVg7WUFDQUs7UUFDRjtJQUNGO0lBRUFZLFFBQVNDLEdBQUcsRUFBRTtRQUNaLE1BQU0sRUFBRXBCLFFBQVEsRUFBRUUsTUFBTSxFQUFFLEdBQUcsSUFBSTtRQUVqQ1AsYUFBYSxJQUFJO1FBRWpCLElBQUlLLFVBQVU7WUFDWixJQUFJLENBQUNBLFFBQVEsR0FBRztZQUNoQnFCLGVBQWU7Z0JBQ2IsSUFBSSxDQUFDSCxlQUFlLENBQUNsQixVQUFVLE1BQU1vQixLQUFLO29CQUFFbEI7Z0JBQU87WUFDckQ7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTb0IsUUFBU3ZCLElBQUksRUFBRUMsUUFBUTtJQUM5QixJQUFJQSxhQUFhdUIsV0FBVztRQUMxQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0JKLFFBQVFLLElBQUksQ0FBQyxJQUFJLEVBQUU1QixNQUFNLENBQUNxQixLQUFLUTtnQkFDN0IsT0FBT1IsTUFBTU0sT0FBT04sT0FBT0ssUUFBUUc7WUFDckM7UUFDRjtJQUNGO0lBRUEsSUFBSTtRQUNGLE1BQU1DLGlCQUFpQixJQUFJaEMsZUFBZUUsTUFBTUM7UUFDaEQsSUFBSSxDQUFDOEIsUUFBUSxDQUFDO1lBQ1osR0FBRy9CLElBQUk7WUFDUGdDLFFBQVFoQyxLQUFLZ0MsTUFBTSxJQUFJO1lBQ3ZCVCxTQUFTdkIsS0FBS2lDLFFBQVEsSUFBSTtRQUM1QixHQUFHSDtJQUNMLEVBQUUsT0FBT1QsS0FBSztRQUNaLElBQUksT0FBT3BCLGFBQWEsWUFBWTtZQUNsQyxNQUFNb0I7UUFDUjtRQUNBLE1BQU1sQixTQUFTSCxRQUFRQSxLQUFLRyxNQUFNO1FBQ2xDbUIsZUFBZSxJQUFNckIsU0FBU29CLEtBQUs7Z0JBQUVsQjtZQUFPO0lBQzlDO0FBQ0Y7QUFFQStCLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktdXBncmFkZS5qcz80YmIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBSZXF1ZXN0QWJvcnRlZEVycm9yLCBTb2NrZXRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdhc3luY19ob29rcycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbmNsYXNzIFVwZ3JhZGVIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBvcGFxdWUsIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0c1xuXG4gICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgIH1cblxuICAgIHN1cGVyKCdVTkRJQ0lfVVBHUkFERScpXG5cbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG4gIH1cblxuICBvbkhlYWRlcnMgKCkge1xuICAgIHRocm93IG5ldyBTb2NrZXRFcnJvcignYmFkIHVwZ3JhZGUnLCBudWxsKVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIGFzc2VydC5zdHJpY3RFcXVhbChzdGF0dXNDb2RlLCAxMDEpXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgaGVhZGVycyxcbiAgICAgIHNvY2tldCxcbiAgICAgIG9wYXF1ZSxcbiAgICAgIGNvbnRleHRcbiAgICB9KVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlIH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGUgKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHVwZ3JhZGUuY2FsbCh0aGlzLCBvcHRzLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdXBncmFkZUhhbmRsZXIgPSBuZXcgVXBncmFkZUhhbmRsZXIob3B0cywgY2FsbGJhY2spXG4gICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgbWV0aG9kOiBvcHRzLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgIHVwZ3JhZGU6IG9wdHMucHJvdG9jb2wgfHwgJ1dlYnNvY2tldCdcbiAgICB9LCB1cGdyYWRlSGFuZGxlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHMgJiYgb3B0cy5vcGFxdWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdXBncmFkZVxuIl0sIm5hbWVzIjpbIkludmFsaWRBcmd1bWVudEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsIlNvY2tldEVycm9yIiwicmVxdWlyZSIsIkFzeW5jUmVzb3VyY2UiLCJ1dGlsIiwiYWRkU2lnbmFsIiwicmVtb3ZlU2lnbmFsIiwiYXNzZXJ0IiwiVXBncmFkZUhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJjYWxsYmFjayIsInNpZ25hbCIsIm9wYXF1ZSIsInJlc3BvbnNlSGVhZGVycyIsIm9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFib3J0IiwiY29udGV4dCIsIm9uQ29ubmVjdCIsIm9uSGVhZGVycyIsIm9uVXBncmFkZSIsInN0YXR1c0NvZGUiLCJyYXdIZWFkZXJzIiwic29ja2V0Iiwic3RyaWN0RXF1YWwiLCJoZWFkZXJzIiwicGFyc2VSYXdIZWFkZXJzIiwicGFyc2VIZWFkZXJzIiwicnVuSW5Bc3luY1Njb3BlIiwib25FcnJvciIsImVyciIsInF1ZXVlTWljcm90YXNrIiwidXBncmFkZSIsInVuZGVmaW5lZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2FsbCIsImRhdGEiLCJ1cGdyYWRlSGFuZGxlciIsImRpc3BhdGNoIiwibWV0aG9kIiwicHJvdG9jb2wiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/api/api-upgrade.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/api/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/undici/lib/api/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports.request = __webpack_require__(/*! ./api-request */ \"(rsc)/../../node_modules/undici/lib/api/api-request.js\");\nmodule.exports.stream = __webpack_require__(/*! ./api-stream */ \"(rsc)/../../node_modules/undici/lib/api/api-stream.js\");\nmodule.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ \"(rsc)/../../node_modules/undici/lib/api/api-pipeline.js\");\nmodule.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ \"(rsc)/../../node_modules/undici/lib/api/api-upgrade.js\");\nmodule.exports.connect = __webpack_require__(/*! ./api-connect */ \"(rsc)/../../node_modules/undici/lib/api/api-connect.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDJIQUFpQztBQUNqQ0Esd0hBQWdDO0FBQ2hDQSw4SEFBa0M7QUFDbENBLDJIQUFpQztBQUNqQ0EsMkhBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvaW5kZXguanM/YTFhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMucmVxdWVzdCA9IHJlcXVpcmUoJy4vYXBpLXJlcXVlc3QnKVxubW9kdWxlLmV4cG9ydHMuc3RyZWFtID0gcmVxdWlyZSgnLi9hcGktc3RyZWFtJylcbm1vZHVsZS5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9hcGktcGlwZWxpbmUnKVxubW9kdWxlLmV4cG9ydHMudXBncmFkZSA9IHJlcXVpcmUoJy4vYXBpLXVwZ3JhZGUnKVxubW9kdWxlLmV4cG9ydHMuY29ubmVjdCA9IHJlcXVpcmUoJy4vYXBpLWNvbm5lY3QnKVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1ZXN0IiwicmVxdWlyZSIsInN0cmVhbSIsInBpcGVsaW5lIiwidXBncmFkZSIsImNvbm5lY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/api/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/api/readable.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/api/readable.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/nodejs/undici/pull/907\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { ReadableStreamFrom, toUSVString } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nlet Blob;\nconst kConsume = Symbol(\"kConsume\");\nconst kReading = Symbol(\"kReading\");\nconst kBody = Symbol(\"kBody\");\nconst kAbort = Symbol(\"abort\");\nconst kContentType = Symbol(\"kContentType\");\nmodule.exports = class BodyReadable extends Readable {\n    constructor({ resume, abort, contentType = \"\", highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n     }){\n        super({\n            autoDestroy: true,\n            read: resume,\n            highWaterMark\n        });\n        this._readableState.dataEmitted = false;\n        this[kAbort] = abort;\n        this[kConsume] = null;\n        this[kBody] = null;\n        this[kContentType] = contentType;\n        // Is stream being consumed through Readable API?\n        // This is an optimization so that we avoid checking\n        // for 'data' and 'readable' listeners in the hot path\n        // inside push().\n        this[kReading] = false;\n    }\n    destroy(err) {\n        if (this.destroyed) {\n            // Node < 16\n            return this;\n        }\n        if (!err && !this._readableState.endEmitted) {\n            err = new RequestAbortedError();\n        }\n        if (err) {\n            this[kAbort]();\n        }\n        return super.destroy(err);\n    }\n    emit(ev, ...args) {\n        if (ev === \"data\") {\n            // Node < 16.7\n            this._readableState.dataEmitted = true;\n        } else if (ev === \"error\") {\n            // Node < 16\n            this._readableState.errorEmitted = true;\n        }\n        return super.emit(ev, ...args);\n    }\n    on(ev, ...args) {\n        if (ev === \"data\" || ev === \"readable\") {\n            this[kReading] = true;\n        }\n        return super.on(ev, ...args);\n    }\n    addListener(ev, ...args) {\n        return this.on(ev, ...args);\n    }\n    off(ev, ...args) {\n        const ret = super.off(ev, ...args);\n        if (ev === \"data\" || ev === \"readable\") {\n            this[kReading] = this.listenerCount(\"data\") > 0 || this.listenerCount(\"readable\") > 0;\n        }\n        return ret;\n    }\n    removeListener(ev, ...args) {\n        return this.off(ev, ...args);\n    }\n    push(chunk) {\n        if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n            consumePush(this[kConsume], chunk);\n            return this[kReading] ? super.push(chunk) : true;\n        }\n        return super.push(chunk);\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-text\n    async text() {\n        return consume(this, \"text\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-json\n    async json() {\n        return consume(this, \"json\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-blob\n    async blob() {\n        return consume(this, \"blob\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n    async arrayBuffer() {\n        return consume(this, \"arrayBuffer\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-formdata\n    async formData() {\n        // TODO: Implement.\n        throw new NotSupportedError();\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-bodyused\n    get bodyUsed() {\n        return util.isDisturbed(this);\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-body\n    get body() {\n        if (!this[kBody]) {\n            this[kBody] = ReadableStreamFrom(this);\n            if (this[kConsume]) {\n                // TODO: Is this the best way to force a lock?\n                this[kBody].getReader() // Ensure stream is locked.\n                ;\n                assert(this[kBody].locked);\n            }\n        }\n        return this[kBody];\n    }\n    async dump(opts) {\n        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;\n        const signal = opts && opts.signal;\n        const abortFn = ()=>{\n            this.destroy();\n        };\n        let signalListenerCleanup;\n        if (signal) {\n            if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n                throw new InvalidArgumentError(\"signal must be an AbortSignal\");\n            }\n            util.throwIfAborted(signal);\n            signalListenerCleanup = util.addAbortListener(signal, abortFn);\n        }\n        try {\n            for await (const chunk of this){\n                util.throwIfAborted(signal);\n                limit -= Buffer.byteLength(chunk);\n                if (limit < 0) {\n                    return;\n                }\n            }\n        } catch  {\n            util.throwIfAborted(signal);\n        } finally{\n            if (typeof signalListenerCleanup === \"function\") {\n                signalListenerCleanup();\n            } else if (signalListenerCleanup) {\n                signalListenerCleanup[Symbol.dispose]();\n            }\n        }\n    }\n};\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked(self) {\n    // Consume is an implicit lock.\n    return self[kBody] && self[kBody].locked === true || self[kConsume];\n}\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable(self) {\n    return util.isDisturbed(self) || isLocked(self);\n}\nasync function consume(stream, type) {\n    if (isUnusable(stream)) {\n        throw new TypeError(\"unusable\");\n    }\n    assert(!stream[kConsume]);\n    return new Promise((resolve, reject)=>{\n        stream[kConsume] = {\n            type,\n            stream,\n            resolve,\n            reject,\n            length: 0,\n            body: []\n        };\n        stream.on(\"error\", function(err) {\n            consumeFinish(this[kConsume], err);\n        }).on(\"close\", function() {\n            if (this[kConsume].body !== null) {\n                consumeFinish(this[kConsume], new RequestAbortedError());\n            }\n        });\n        process.nextTick(consumeStart, stream[kConsume]);\n    });\n}\nfunction consumeStart(consume) {\n    if (consume.body === null) {\n        return;\n    }\n    const { _readableState: state } = consume.stream;\n    for (const chunk of state.buffer){\n        consumePush(consume, chunk);\n    }\n    if (state.endEmitted) {\n        consumeEnd(this[kConsume]);\n    } else {\n        consume.stream.on(\"end\", function() {\n            consumeEnd(this[kConsume]);\n        });\n    }\n    consume.stream.resume();\n    while(consume.stream.read() != null){\n    // Loop\n    }\n}\nfunction consumeEnd(consume) {\n    const { type, body, resolve, stream, length } = consume;\n    try {\n        if (type === \"text\") {\n            resolve(toUSVString(Buffer.concat(body)));\n        } else if (type === \"json\") {\n            resolve(JSON.parse(Buffer.concat(body)));\n        } else if (type === \"arrayBuffer\") {\n            const dst = new Uint8Array(length);\n            let pos = 0;\n            for (const buf of body){\n                dst.set(buf, pos);\n                pos += buf.byteLength;\n            }\n            resolve(dst.buffer);\n        } else if (type === \"blob\") {\n            if (!Blob) {\n                Blob = (__webpack_require__(/*! buffer */ \"buffer\").Blob);\n            }\n            resolve(new Blob(body, {\n                type: stream[kContentType]\n            }));\n        }\n        consumeFinish(consume);\n    } catch (err) {\n        stream.destroy(err);\n    }\n}\nfunction consumePush(consume, chunk) {\n    consume.length += chunk.length;\n    consume.body.push(chunk);\n}\nfunction consumeFinish(consume, err) {\n    if (consume.body === null) {\n        return;\n    }\n    if (err) {\n        consume.reject(err);\n    } else {\n        consume.resolve();\n    }\n    consume.type = null;\n    consume.stream = null;\n    consume.resolve = null;\n    consume.reject = null;\n    consume.length = 0;\n    consume.body = null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL3JlYWRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHdEQUF3RDtBQUV4RDtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQzdCLE1BQU0sRUFBRUUsbUJBQW1CLEVBQUVDLGlCQUFpQixFQUFFQyxvQkFBb0IsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUNqRixNQUFNSyxPQUFPTCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVNLGtCQUFrQixFQUFFQyxXQUFXLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFFcEQsSUFBSVE7QUFFSixNQUFNQyxXQUFXQyxPQUFPO0FBQ3hCLE1BQU1DLFdBQVdELE9BQU87QUFDeEIsTUFBTUUsUUFBUUYsT0FBTztBQUNyQixNQUFNRyxTQUFTSCxPQUFPO0FBQ3RCLE1BQU1JLGVBQWVKLE9BQU87QUFFNUJLLE9BQU9DLE9BQU8sR0FBRyxNQUFNQyxxQkFBcUJoQjtJQUMxQ2lCLFlBQWEsRUFDWEMsTUFBTSxFQUNOQyxLQUFLLEVBQ0xDLGNBQWMsRUFBRSxFQUNoQkMsZ0JBQWdCLEtBQUssS0FBSyw2QkFBNkI7SUFBOUIsRUFDMUIsQ0FBRTtRQUNELEtBQUssQ0FBQztZQUNKQyxhQUFhO1lBQ2JDLE1BQU1MO1lBQ05HO1FBQ0Y7UUFFQSxJQUFJLENBQUNHLGNBQWMsQ0FBQ0MsV0FBVyxHQUFHO1FBRWxDLElBQUksQ0FBQ2IsT0FBTyxHQUFHTztRQUNmLElBQUksQ0FBQ1gsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0csTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDRSxhQUFhLEdBQUdPO1FBRXJCLGlEQUFpRDtRQUNqRCxvREFBb0Q7UUFDcEQsc0RBQXNEO1FBQ3RELGlCQUFpQjtRQUNqQixJQUFJLENBQUNWLFNBQVMsR0FBRztJQUNuQjtJQUVBZ0IsUUFBU0MsR0FBRyxF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O0FBQ3BCO0FBRUEsU0FBU3FDLGNBQWVqQyxPQUFPLEVBQUVsQixHQUFHO0lBQ2xDLElBQUlrQixRQUFRTyxJQUFJLEtBQUssTUFBTTtRQUN6QjtJQUNGO0lBRUEsSUFBSXpCLEtBQUs7UUFDUGtCLFFBQVErQixNQUFNLENBQUNqRDtJQUNqQixPQUFPO1FBQ0xrQixRQUFROEIsT0FBTztJQUNqQjtJQUVBOUIsUUFBUTJCLElBQUksR0FBRztJQUNmM0IsUUFBUTBCLE1BQU0sR0FBRztJQUNqQjFCLFFBQVE4QixPQUFPLEdBQUc7SUFDbEI5QixRQUFRK0IsTUFBTSxHQUFHO0lBQ2pCL0IsUUFBUWdDLE1BQU0sR0FBRztJQUNqQmhDLFFBQVFPLElBQUksR0FBRztBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL3JlYWRhYmxlLmpzP2UxYjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvcHVsbC85MDdcblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3QgeyBSZXF1ZXN0QWJvcnRlZEVycm9yLCBOb3RTdXBwb3J0ZWRFcnJvciwgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBSZWFkYWJsZVN0cmVhbUZyb20sIHRvVVNWU3RyaW5nIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG5sZXQgQmxvYlxuXG5jb25zdCBrQ29uc3VtZSA9IFN5bWJvbCgna0NvbnN1bWUnKVxuY29uc3Qga1JlYWRpbmcgPSBTeW1ib2woJ2tSZWFkaW5nJylcbmNvbnN0IGtCb2R5ID0gU3ltYm9sKCdrQm9keScpXG5jb25zdCBrQWJvcnQgPSBTeW1ib2woJ2Fib3J0JylcbmNvbnN0IGtDb250ZW50VHlwZSA9IFN5bWJvbCgna0NvbnRlbnRUeXBlJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBCb2R5UmVhZGFibGUgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yICh7XG4gICAgcmVzdW1lLFxuICAgIGFib3J0LFxuICAgIGNvbnRlbnRUeXBlID0gJycsXG4gICAgaGlnaFdhdGVyTWFyayA9IDY0ICogMTAyNCAvLyBTYW1lIGFzIG5vZGVqcyBmcyBzdHJlYW1zLlxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgYXV0b0Rlc3Ryb3k6IHRydWUsXG4gICAgICByZWFkOiByZXN1bWUsXG4gICAgICBoaWdoV2F0ZXJNYXJrXG4gICAgfSlcblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGF0YUVtaXR0ZWQgPSBmYWxzZVxuXG4gICAgdGhpc1trQWJvcnRdID0gYWJvcnRcbiAgICB0aGlzW2tDb25zdW1lXSA9IG51bGxcbiAgICB0aGlzW2tCb2R5XSA9IG51bGxcbiAgICB0aGlzW2tDb250ZW50VHlwZV0gPSBjb250ZW50VHlwZVxuXG4gICAgLy8gSXMgc3RyZWFtIGJlaW5nIGNvbnN1bWVkIHRocm91Z2ggUmVhZGFibGUgQVBJP1xuICAgIC8vIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHNvIHRoYXQgd2UgYXZvaWQgY2hlY2tpbmdcbiAgICAvLyBmb3IgJ2RhdGEnIGFuZCAncmVhZGFibGUnIGxpc3RlbmVycyBpbiB0aGUgaG90IHBhdGhcbiAgICAvLyBpbnNpZGUgcHVzaCgpLlxuICAgIHRoaXNba1JlYWRpbmddID0gZmFsc2VcbiAgfVxuXG4gIGRlc3Ryb3kgKGVycikge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgLy8gTm9kZSA8IDE2XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGlmICghZXJyICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgIGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aGlzW2tBYm9ydF0oKVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5kZXN0cm95KGVycilcbiAgfVxuXG4gIGVtaXQgKGV2LCAuLi5hcmdzKSB7XG4gICAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgIC8vIE5vZGUgPCAxNi43XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdlcnJvcicpIHtcbiAgICAgIC8vIE5vZGUgPCAxNlxuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCAuLi5hcmdzKVxuICB9XG5cbiAgb24gKGV2LCAuLi5hcmdzKSB7XG4gICAgaWYgKGV2ID09PSAnZGF0YScgfHwgZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgIHRoaXNba1JlYWRpbmddID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIub24oZXYsIC4uLmFyZ3MpXG4gIH1cblxuICBhZGRMaXN0ZW5lciAoZXYsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5vbihldiwgLi4uYXJncylcbiAgfVxuXG4gIG9mZiAoZXYsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZXQgPSBzdXBlci5vZmYoZXYsIC4uLmFyZ3MpXG4gICAgaWYgKGV2ID09PSAnZGF0YScgfHwgZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgIHRoaXNba1JlYWRpbmddID0gKFxuICAgICAgICB0aGlzLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDAgfHxcbiAgICAgICAgdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMFxuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICByZW1vdmVMaXN0ZW5lciAoZXYsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5vZmYoZXYsIC4uLmFyZ3MpXG4gIH1cblxuICBwdXNoIChjaHVuaykge1xuICAgIGlmICh0aGlzW2tDb25zdW1lXSAmJiBjaHVuayAhPT0gbnVsbCAmJiB0aGlzLnJlYWRhYmxlTGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdW1lUHVzaCh0aGlzW2tDb25zdW1lXSwgY2h1bmspXG4gICAgICByZXR1cm4gdGhpc1trUmVhZGluZ10gPyBzdXBlci5wdXNoKGNodW5rKSA6IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnB1c2goY2h1bmspXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktdGV4dFxuICBhc3luYyB0ZXh0ICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAndGV4dCcpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktanNvblxuICBhc3luYyBqc29uICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAnanNvbicpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYmxvYlxuICBhc3luYyBibG9iICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAnYmxvYicpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYXJyYXlidWZmZXJcbiAgYXN5bmMgYXJyYXlCdWZmZXIgKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICdhcnJheUJ1ZmZlcicpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktZm9ybWRhdGFcbiAgYXN5bmMgZm9ybURhdGEgKCkge1xuICAgIC8vIFRPRE86IEltcGxlbWVudC5cbiAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWJvZHl1c2VkXG4gIGdldCBib2R5VXNlZCAoKSB7XG4gICAgcmV0dXJuIHV0aWwuaXNEaXN0dXJiZWQodGhpcylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1ib2R5XG4gIGdldCBib2R5ICgpIHtcbiAgICBpZiAoIXRoaXNba0JvZHldKSB7XG4gICAgICB0aGlzW2tCb2R5XSA9IFJlYWRhYmxlU3RyZWFtRnJvbSh0aGlzKVxuICAgICAgaWYgKHRoaXNba0NvbnN1bWVdKSB7XG4gICAgICAgIC8vIFRPRE86IElzIHRoaXMgdGhlIGJlc3Qgd2F5IHRvIGZvcmNlIGEgbG9jaz9cbiAgICAgICAgdGhpc1trQm9keV0uZ2V0UmVhZGVyKCkgLy8gRW5zdXJlIHN0cmVhbSBpcyBsb2NrZWQuXG4gICAgICAgIGFzc2VydCh0aGlzW2tCb2R5XS5sb2NrZWQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzW2tCb2R5XVxuICB9XG5cbiAgYXN5bmMgZHVtcCAob3B0cykge1xuICAgIGxldCBsaW1pdCA9IG9wdHMgJiYgTnVtYmVyLmlzRmluaXRlKG9wdHMubGltaXQpID8gb3B0cy5saW1pdCA6IDI2MjE0NFxuICAgIGNvbnN0IHNpZ25hbCA9IG9wdHMgJiYgb3B0cy5zaWduYWxcbiAgICBjb25zdCBhYm9ydEZuID0gKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95KClcbiAgICB9XG4gICAgbGV0IHNpZ25hbExpc3RlbmVyQ2xlYW51cFxuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2lnbmFsICE9PSAnb2JqZWN0JyB8fCAhKCdhYm9ydGVkJyBpbiBzaWduYWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gQWJvcnRTaWduYWwnKVxuICAgICAgfVxuICAgICAgdXRpbC50aHJvd0lmQWJvcnRlZChzaWduYWwpXG4gICAgICBzaWduYWxMaXN0ZW5lckNsZWFudXAgPSB1dGlsLmFkZEFib3J0TGlzdGVuZXIoc2lnbmFsLCBhYm9ydEZuKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB0aGlzKSB7XG4gICAgICAgIHV0aWwudGhyb3dJZkFib3J0ZWQoc2lnbmFsKVxuICAgICAgICBsaW1pdCAtPSBCdWZmZXIuYnl0ZUxlbmd0aChjaHVuaylcbiAgICAgICAgaWYgKGxpbWl0IDwgMCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICB1dGlsLnRocm93SWZBYm9ydGVkKHNpZ25hbClcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHR5cGVvZiBzaWduYWxMaXN0ZW5lckNsZWFudXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2lnbmFsTGlzdGVuZXJDbGVhbnVwKClcbiAgICAgIH0gZWxzZSBpZiAoc2lnbmFsTGlzdGVuZXJDbGVhbnVwKSB7XG4gICAgICAgIHNpZ25hbExpc3RlbmVyQ2xlYW51cFtTeW1ib2wuZGlzcG9zZV0oKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyNyZWFkYWJsZXN0cmVhbS1sb2NrZWRcbmZ1bmN0aW9uIGlzTG9ja2VkIChzZWxmKSB7XG4gIC8vIENvbnN1bWUgaXMgYW4gaW1wbGljaXQgbG9jay5cbiAgcmV0dXJuIChzZWxmW2tCb2R5XSAmJiBzZWxmW2tCb2R5XS5sb2NrZWQgPT09IHRydWUpIHx8IHNlbGZba0NvbnN1bWVdXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5LXVudXNhYmxlXG5mdW5jdGlvbiBpc1VudXNhYmxlIChzZWxmKSB7XG4gIHJldHVybiB1dGlsLmlzRGlzdHVyYmVkKHNlbGYpIHx8IGlzTG9ja2VkKHNlbGYpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWUgKHN0cmVhbSwgdHlwZSkge1xuICBpZiAoaXNVbnVzYWJsZShzdHJlYW0pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW51c2FibGUnKVxuICB9XG5cbiAgYXNzZXJ0KCFzdHJlYW1ba0NvbnN1bWVdKVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc3RyZWFtW2tDb25zdW1lXSA9IHtcbiAgICAgIHR5cGUsXG4gICAgICBzdHJlYW0sXG4gICAgICByZXNvbHZlLFxuICAgICAgcmVqZWN0LFxuICAgICAgbGVuZ3RoOiAwLFxuICAgICAgYm9keTogW11cbiAgICB9XG5cbiAgICBzdHJlYW1cbiAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNvbnN1bWVGaW5pc2godGhpc1trQ29uc3VtZV0sIGVycilcbiAgICAgIH0pXG4gICAgICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpc1trQ29uc3VtZV0uYm9keSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN1bWVGaW5pc2godGhpc1trQ29uc3VtZV0sIG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGNvbnN1bWVTdGFydCwgc3RyZWFtW2tDb25zdW1lXSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY29uc3VtZVN0YXJ0IChjb25zdW1lKSB7XG4gIGlmIChjb25zdW1lLmJvZHkgPT09IG51bGwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHsgX3JlYWRhYmxlU3RhdGU6IHN0YXRlIH0gPSBjb25zdW1lLnN0cmVhbVxuXG4gIGZvciAoY29uc3QgY2h1bmsgb2Ygc3RhdGUuYnVmZmVyKSB7XG4gICAgY29uc3VtZVB1c2goY29uc3VtZSwgY2h1bmspXG4gIH1cblxuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIGNvbnN1bWVFbmQodGhpc1trQ29uc3VtZV0pXG4gIH0gZWxzZSB7XG4gICAgY29uc3VtZS5zdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN1bWVFbmQodGhpc1trQ29uc3VtZV0pXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN1bWUuc3RyZWFtLnJlc3VtZSgpXG5cbiAgd2hpbGUgKGNvbnN1bWUuc3RyZWFtLnJlYWQoKSAhPSBudWxsKSB7XG4gICAgLy8gTG9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVFbmQgKGNvbnN1bWUpIHtcbiAgY29uc3QgeyB0eXBlLCBib2R5LCByZXNvbHZlLCBzdHJlYW0sIGxlbmd0aCB9ID0gY29uc3VtZVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgcmVzb2x2ZSh0b1VTVlN0cmluZyhCdWZmZXIuY29uY2F0KGJvZHkpKSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdqc29uJykge1xuICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKEJ1ZmZlci5jb25jYXQoYm9keSkpKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2FycmF5QnVmZmVyJykge1xuICAgICAgY29uc3QgZHN0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuXG4gICAgICBsZXQgcG9zID0gMFxuICAgICAgZm9yIChjb25zdCBidWYgb2YgYm9keSkge1xuICAgICAgICBkc3Quc2V0KGJ1ZiwgcG9zKVxuICAgICAgICBwb3MgKz0gYnVmLmJ5dGVMZW5ndGhcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShkc3QuYnVmZmVyKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICBpZiAoIUJsb2IpIHtcbiAgICAgICAgQmxvYiA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJsb2JcbiAgICAgIH1cbiAgICAgIHJlc29sdmUobmV3IEJsb2IoYm9keSwgeyB0eXBlOiBzdHJlYW1ba0NvbnRlbnRUeXBlXSB9KSlcbiAgICB9XG5cbiAgICBjb25zdW1lRmluaXNoKGNvbnN1bWUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdW1lUHVzaCAoY29uc3VtZSwgY2h1bmspIHtcbiAgY29uc3VtZS5sZW5ndGggKz0gY2h1bmsubGVuZ3RoXG4gIGNvbnN1bWUuYm9keS5wdXNoKGNodW5rKVxufVxuXG5mdW5jdGlvbiBjb25zdW1lRmluaXNoIChjb25zdW1lLCBlcnIpIHtcbiAgaWYgKGNvbnN1bWUuYm9keSA9PT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKGVycikge1xuICAgIGNvbnN1bWUucmVqZWN0KGVycilcbiAgfSBlbHNlIHtcbiAgICBjb25zdW1lLnJlc29sdmUoKVxuICB9XG5cbiAgY29uc3VtZS50eXBlID0gbnVsbFxuICBjb25zdW1lLnN0cmVhbSA9IG51bGxcbiAgY29uc3VtZS5yZXNvbHZlID0gbnVsbFxuICBjb25zdW1lLnJlamVjdCA9IG51bGxcbiAgY29uc3VtZS5sZW5ndGggPSAwXG4gIGNvbnN1bWUuYm9keSA9IG51bGxcbn1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiUmVhZGFibGUiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwiTm90U3VwcG9ydGVkRXJyb3IiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsInV0aWwiLCJSZWFkYWJsZVN0cmVhbUZyb20iLCJ0b1VTVlN0cmluZyIsIkJsb2IiLCJrQ29uc3VtZSIsIlN5bWJvbCIsImtSZWFkaW5nIiwia0JvZHkiLCJrQWJvcnQiLCJrQ29udGVudFR5cGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiQm9keVJlYWRhYmxlIiwiY29uc3RydWN0b3IiLCJyZXN1bWUiLCJhYm9ydCIsImNvbnRlbnRUeXBlIiwiaGlnaFdhdGVyTWFyayIsImF1dG9EZXN0cm95IiwicmVhZCIsIl9yZWFkYWJsZVN0YXRlIiwiZGF0YUVtaXR0ZWQiLCJkZXN0cm95IiwiZXJyIiwiZGVzdHJveWVkIiwiZW5kRW1pdHRlZCIsImVtaXQiLCJldiIsImFyZ3MiLCJlcnJvckVtaXR0ZWQiLCJvbiIsImFkZExpc3RlbmVyIiwib2ZmIiwicmV0IiwibGlzdGVuZXJDb3VudCIsInJlbW92ZUxpc3RlbmVyIiwicHVzaCIsImNodW5rIiwicmVhZGFibGVMZW5ndGgiLCJjb25zdW1lUHVzaCIsInRleHQiLCJjb25zdW1lIiwianNvbiIsImJsb2IiLCJhcnJheUJ1ZmZlciIsImZvcm1EYXRhIiwiYm9keVVzZWQiLCJpc0Rpc3R1cmJlZCIsImJvZHkiLCJnZXRSZWFkZXIiLCJsb2NrZWQiLCJkdW1wIiwib3B0cyIsImxpbWl0IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJzaWduYWwiLCJhYm9ydEZuIiwic2lnbmFsTGlzdGVuZXJDbGVhbnVwIiwidGhyb3dJZkFib3J0ZWQiLCJhZGRBYm9ydExpc3RlbmVyIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsImRpc3Bvc2UiLCJpc0xvY2tlZCIsInNlbGYiLCJpc1VudXNhYmxlIiwic3RyZWFtIiwidHlwZSIsIlR5cGVFcnJvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibGVuZ3RoIiwiY29uc3VtZUZpbmlzaCIsInByb2Nlc3MiLCJuZXh0VGljayIsImNvbnN1bWVTdGFydCIsInN0YXRlIiwiYnVmZmVyIiwiY29uc3VtZUVuZCIsImNvbmNhdCIsIkpTT04iLCJwYXJzZSIsImRzdCIsIlVpbnQ4QXJyYXkiLCJwb3MiLCJidWYiLCJzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/api/readable.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/api/util.js":
/*!*************************************************!*\
  !*** ../../node_modules/undici/lib/api/util.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! assert */ \"assert\");\nconst { ResponseStatusCodeError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst { toUSVString } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nasync function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {\n    assert(body);\n    let chunks = [];\n    let limit = 0;\n    for await (const chunk of body){\n        chunks.push(chunk);\n        limit += chunk.length;\n        if (limit > 128 * 1024) {\n            chunks = null;\n            break;\n        }\n    }\n    if (statusCode === 204 || !contentType || !chunks) {\n        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers));\n        return;\n    }\n    try {\n        if (contentType.startsWith(\"application/json\")) {\n            const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));\n            process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers, payload));\n            return;\n        }\n        if (contentType.startsWith(\"text/\")) {\n            const payload = toUSVString(Buffer.concat(chunks));\n            process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers, payload));\n            return;\n        }\n    } catch (err) {\n    // Process in a fallback if error\n    }\n    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers));\n}\nmodule.exports = {\n    getResolveErrorBodyCallback\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUNKQyx1QkFBdUIsRUFDeEIsR0FBR0QsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVFLFdBQVcsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUVoQyxlQUFlRyw0QkFBNkIsRUFBRUMsUUFBUSxFQUFFQyxJQUFJLEVBQUVDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxhQUFhLEVBQUVDLE9BQU8sRUFBRTtJQUM3R1YsT0FBT007SUFFUCxJQUFJSyxTQUFTLEVBQUU7SUFDZixJQUFJQyxRQUFRO0lBRVosV0FBVyxNQUFNQyxTQUFTUCxLQUFNO1FBQzlCSyxPQUFPRyxJQUFJLENBQUNEO1FBQ1pELFNBQVNDLE1BQU1FLE1BQU07UUFDckIsSUFBSUgsUUFBUSxNQUFNLE1BQU07WUFDdEJELFNBQVM7WUFDVDtRQUNGO0lBQ0Y7SUFFQSxJQUFJSCxlQUFlLE9BQU8sQ0FBQ0QsZUFBZSxDQUFDSSxRQUFRO1FBQ2pESyxRQUFRQyxRQUFRLENBQUNaLFVBQVUsSUFBSUgsd0JBQXdCLENBQUMscUJBQXFCLEVBQUVNLFdBQVcsRUFBRUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFQSxjQUFjLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRUQsWUFBWUU7UUFDcko7SUFDRjtJQUVBLElBQUk7UUFDRixJQUFJSCxZQUFZVyxVQUFVLENBQUMscUJBQXFCO1lBQzlDLE1BQU1DLFVBQVVDLEtBQUtDLEtBQUssQ0FBQ2xCLFlBQVltQixPQUFPQyxNQUFNLENBQUNaO1lBQ3JESyxRQUFRQyxRQUFRLENBQUNaLFVBQVUsSUFBSUgsd0JBQXdCLENBQUMscUJBQXFCLEVBQUVNLFdBQVcsRUFBRUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFQSxjQUFjLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRUQsWUFBWUUsU0FBU1M7WUFDOUo7UUFDRjtRQUVBLElBQUlaLFlBQVlXLFVBQVUsQ0FBQyxVQUFVO1lBQ25DLE1BQU1DLFVBQVVoQixZQUFZbUIsT0FBT0MsTUFBTSxDQUFDWjtZQUMxQ0ssUUFBUUMsUUFBUSxDQUFDWixVQUFVLElBQUlILHdCQUF3QixDQUFDLHFCQUFxQixFQUFFTSxXQUFXLEVBQUVDLGdCQUFnQixDQUFDLEVBQUUsRUFBRUEsY0FBYyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUVELFlBQVlFLFNBQVNTO1lBQzlKO1FBQ0Y7SUFDRixFQUFFLE9BQU9LLEtBQUs7SUFDWixpQ0FBaUM7SUFDbkM7SUFFQVIsUUFBUUMsUUFBUSxDQUFDWixVQUFVLElBQUlILHdCQUF3QixDQUFDLHFCQUFxQixFQUFFTSxXQUFXLEVBQUVDLGdCQUFnQixDQUFDLEVBQUUsRUFBRUEsY0FBYyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUVELFlBQVlFO0FBQ3ZKO0FBRUFlLE9BQU9DLE9BQU8sR0FBRztJQUFFdEI7QUFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS91dGlsLmpzP2ZjZGEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHtcbiAgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7IHRvVVNWU3RyaW5nIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG5hc3luYyBmdW5jdGlvbiBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2sgKHsgY2FsbGJhY2ssIGJvZHksIGNvbnRlbnRUeXBlLCBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzIH0pIHtcbiAgYXNzZXJ0KGJvZHkpXG5cbiAgbGV0IGNodW5rcyA9IFtdXG4gIGxldCBsaW1pdCA9IDBcblxuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcbiAgICBjaHVua3MucHVzaChjaHVuaylcbiAgICBsaW1pdCArPSBjaHVuay5sZW5ndGhcbiAgICBpZiAobGltaXQgPiAxMjggKiAxMDI0KSB7XG4gICAgICBjaHVua3MgPSBudWxsXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0dXNDb2RlID09PSAyMDQgfHwgIWNvbnRlbnRUeXBlIHx8ICFjaHVua3MpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IoYFJlc3BvbnNlIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2UgPyBgOiAke3N0YXR1c01lc3NhZ2V9YCA6ICcnfWAsIHN0YXR1c0NvZGUsIGhlYWRlcnMpKVxuICAgIHJldHVyblxuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoY29udGVudFR5cGUuc3RhcnRzV2l0aCgnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZSh0b1VTVlN0cmluZyhCdWZmZXIuY29uY2F0KGNodW5rcykpKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbmV3IFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yKGBSZXNwb25zZSBzdGF0dXMgY29kZSAke3N0YXR1c0NvZGV9JHtzdGF0dXNNZXNzYWdlID8gYDogJHtzdGF0dXNNZXNzYWdlfWAgOiAnJ31gLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBwYXlsb2FkKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjb250ZW50VHlwZS5zdGFydHNXaXRoKCd0ZXh0LycpKSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gdG9VU1ZTdHJpbmcoQnVmZmVyLmNvbmNhdChjaHVua3MpKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbmV3IFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yKGBSZXNwb25zZSBzdGF0dXMgY29kZSAke3N0YXR1c0NvZGV9JHtzdGF0dXNNZXNzYWdlID8gYDogJHtzdGF0dXNNZXNzYWdlfWAgOiAnJ31gLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBwYXlsb2FkKSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gUHJvY2VzcyBpbiBhIGZhbGxiYWNrIGlmIGVycm9yXG4gIH1cblxuICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IoYFJlc3BvbnNlIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2UgPyBgOiAke3N0YXR1c01lc3NhZ2V9YCA6ICcnfWAsIHN0YXR1c0NvZGUsIGhlYWRlcnMpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrIH1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IiLCJ0b1VTVlN0cmluZyIsImdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayIsImNhbGxiYWNrIiwiYm9keSIsImNvbnRlbnRUeXBlIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJoZWFkZXJzIiwiY2h1bmtzIiwibGltaXQiLCJjaHVuayIsInB1c2giLCJsZW5ndGgiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJzdGFydHNXaXRoIiwicGF5bG9hZCIsIkpTT04iLCJwYXJzZSIsIkJ1ZmZlciIsImNvbmNhdCIsImVyciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/api/util.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/balanced-pool.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/balanced-pool.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { BalancedPoolMissingUpstreamError, InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst { PoolBase, kClients, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = __webpack_require__(/*! ./pool-base */ \"(rsc)/../../node_modules/undici/lib/pool-base.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/../../node_modules/undici/lib/pool.js\");\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst { parseOrigin } = __webpack_require__(/*! ./core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst kFactory = Symbol(\"factory\");\nconst kOptions = Symbol(\"options\");\nconst kGreatestCommonDivisor = Symbol(\"kGreatestCommonDivisor\");\nconst kCurrentWeight = Symbol(\"kCurrentWeight\");\nconst kIndex = Symbol(\"kIndex\");\nconst kWeight = Symbol(\"kWeight\");\nconst kMaxWeightPerServer = Symbol(\"kMaxWeightPerServer\");\nconst kErrorPenalty = Symbol(\"kErrorPenalty\");\nfunction getGreatestCommonDivisor(a, b) {\n    if (b === 0) return a;\n    return getGreatestCommonDivisor(b, a % b);\n}\nfunction defaultFactory(origin, opts) {\n    return new Pool(origin, opts);\n}\nclass BalancedPool extends PoolBase {\n    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}){\n        super();\n        this[kOptions] = opts;\n        this[kIndex] = -1;\n        this[kCurrentWeight] = 0;\n        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;\n        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;\n        if (!Array.isArray(upstreams)) {\n            upstreams = [\n                upstreams\n            ];\n        }\n        if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];\n        this[kFactory] = factory;\n        for (const upstream of upstreams){\n            this.addUpstream(upstream);\n        }\n        this._updateBalancedPoolStats();\n    }\n    addUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        if (this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true)) {\n            return this;\n        }\n        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));\n        this[kAddClient](pool);\n        pool.on(\"connect\", ()=>{\n            pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);\n        });\n        pool.on(\"connectionError\", ()=>{\n            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n            this._updateBalancedPoolStats();\n        });\n        pool.on(\"disconnect\", (...args)=>{\n            const err = args[2];\n            if (err && err.code === \"UND_ERR_SOCKET\") {\n                // decrease the weight of the pool.\n                pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n                this._updateBalancedPoolStats();\n            }\n        });\n        for (const client of this[kClients]){\n            client[kWeight] = this[kMaxWeightPerServer];\n        }\n        this._updateBalancedPoolStats();\n        return this;\n    }\n    _updateBalancedPoolStats() {\n        this[kGreatestCommonDivisor] = this[kClients].map((p)=>p[kWeight]).reduce(getGreatestCommonDivisor, 0);\n    }\n    removeUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        const pool = this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true);\n        if (pool) {\n            this[kRemoveClient](pool);\n        }\n        return this;\n    }\n    get upstreams() {\n        return this[kClients].filter((dispatcher)=>dispatcher.closed !== true && dispatcher.destroyed !== true).map((p)=>p[kUrl].origin);\n    }\n    [kGetDispatcher]() {\n        // We validate that pools is greater than 0,\n        // otherwise we would have to wait until an upstream\n        // is added, which might never happen.\n        if (this[kClients].length === 0) {\n            throw new BalancedPoolMissingUpstreamError();\n        }\n        const dispatcher = this[kClients].find((dispatcher)=>!dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n        if (!dispatcher) {\n            return;\n        }\n        const allClientsBusy = this[kClients].map((pool)=>pool[kNeedDrain]).reduce((a, b)=>a && b, true);\n        if (allClientsBusy) {\n            return;\n        }\n        let counter = 0;\n        let maxWeightIndex = this[kClients].findIndex((pool)=>!pool[kNeedDrain]);\n        while(counter++ < this[kClients].length){\n            this[kIndex] = (this[kIndex] + 1) % this[kClients].length;\n            const pool = this[kClients][this[kIndex]];\n            // find pool index with the largest weight\n            if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n                maxWeightIndex = this[kIndex];\n            }\n            // decrease the current weight every `this[kClients].length`.\n            if (this[kIndex] === 0) {\n                // Set the current weight to the next lower weight.\n                this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];\n                if (this[kCurrentWeight] <= 0) {\n                    this[kCurrentWeight] = this[kMaxWeightPerServer];\n                }\n            }\n            if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {\n                return pool;\n            }\n        }\n        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];\n        this[kIndex] = maxWeightIndex;\n        return this[kClients][maxWeightIndex];\n    }\n}\nmodule.exports = BalancedPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYmFsYW5jZWQtcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFDSkEsZ0NBQWdDLEVBQ2hDQyxvQkFBb0IsRUFDckIsR0FBR0MsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQ0pDLFFBQVEsRUFDUkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsYUFBYSxFQUNiQyxjQUFjLEVBQ2YsR0FBR04sbUJBQU9BLENBQUM7QUFDWixNQUFNTyxPQUFPUCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVRLElBQUksRUFBRUMsYUFBYSxFQUFFLEdBQUdULG1CQUFPQSxDQUFDO0FBQ3hDLE1BQU0sRUFBRVUsV0FBVyxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU1XLFdBQVdDLE9BQU87QUFFeEIsTUFBTUMsV0FBV0QsT0FBTztBQUN4QixNQUFNRSx5QkFBeUJGLE9BQU87QUFDdEMsTUFBTUcsaUJBQWlCSCxPQUFPO0FBQzlCLE1BQU1JLFNBQVNKLE9BQU87QUFDdEIsTUFBTUssVUFBVUwsT0FBTztBQUN2QixNQUFNTSxzQkFBc0JOLE9BQU87QUFDbkMsTUFBTU8sZ0JBQWdCUCxPQUFPO0FBRTdCLFNBQVNRLHlCQUEwQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3JDLElBQUlBLE1BQU0sR0FBRyxPQUFPRDtJQUNwQixPQUFPRCx5QkFBeUJFLEdBQUdELElBQUlDO0FBQ3pDO0FBRUEsU0FBU0MsZUFBZ0JDLE1BQU0sRUFBRUMsSUFBSTtJQUNuQyxPQUFPLElBQUlsQixLQUFLaUIsUUFBUUM7QUFDMUI7QUFFQSxNQUFNQyxxQkFBcUJ6QjtJQUN6QjBCLFlBQWFDLFlBQVksRUFBRSxFQUFFLEVBQUVDLFVBQVVOLGNBQWMsRUFBRSxHQUFHRSxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDdkUsS0FBSztRQUVMLElBQUksQ0FBQ1osU0FBUyxHQUFHWTtRQUNqQixJQUFJLENB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LGVBQWU7SUFDdkM7QUFDRjtBQUVBRSxPQUFPQyxPQUFPLEdBQUd2QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYmFsYW5jZWQtcG9vbC5qcz81ZTIyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvclxufSA9IHJlcXVpcmUoJy4vY29yZS9lcnJvcnMnKVxuY29uc3Qge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtSZW1vdmVDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyXG59ID0gcmVxdWlyZSgnLi9wb29sLWJhc2UnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCB7IGtVcmwsIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgcGFyc2VPcmlnaW4gfSA9IHJlcXVpcmUoJy4vY29yZS91dGlsJylcbmNvbnN0IGtGYWN0b3J5ID0gU3ltYm9sKCdmYWN0b3J5JylcblxuY29uc3Qga09wdGlvbnMgPSBTeW1ib2woJ29wdGlvbnMnKVxuY29uc3Qga0dyZWF0ZXN0Q29tbW9uRGl2aXNvciA9IFN5bWJvbCgna0dyZWF0ZXN0Q29tbW9uRGl2aXNvcicpXG5jb25zdCBrQ3VycmVudFdlaWdodCA9IFN5bWJvbCgna0N1cnJlbnRXZWlnaHQnKVxuY29uc3Qga0luZGV4ID0gU3ltYm9sKCdrSW5kZXgnKVxuY29uc3Qga1dlaWdodCA9IFN5bWJvbCgna1dlaWdodCcpXG5jb25zdCBrTWF4V2VpZ2h0UGVyU2VydmVyID0gU3ltYm9sKCdrTWF4V2VpZ2h0UGVyU2VydmVyJylcbmNvbnN0IGtFcnJvclBlbmFsdHkgPSBTeW1ib2woJ2tFcnJvclBlbmFsdHknKVxuXG5mdW5jdGlvbiBnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IgKGEsIGIpIHtcbiAgaWYgKGIgPT09IDApIHJldHVybiBhXG4gIHJldHVybiBnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IoYiwgYSAlIGIpXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBQb29sKG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgQmFsYW5jZWRQb29sIGV4dGVuZHMgUG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvciAodXBzdHJlYW1zID0gW10sIHsgZmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5LCAuLi5vcHRzIH0gPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXNba09wdGlvbnNdID0gb3B0c1xuICAgIHRoaXNba0luZGV4XSA9IC0xXG4gICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSAwXG5cbiAgICB0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdID0gdGhpc1trT3B0aW9uc10ubWF4V2VpZ2h0UGVyU2VydmVyIHx8IDEwMFxuICAgIHRoaXNba0Vycm9yUGVuYWx0eV0gPSB0aGlzW2tPcHRpb25zXS5lcnJvclBlbmFsdHkgfHwgMTVcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh1cHN0cmVhbXMpKSB7XG4gICAgICB1cHN0cmVhbXMgPSBbdXBzdHJlYW1zXVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBvcHRzLmludGVyY2VwdG9ycyAmJiBvcHRzLmludGVyY2VwdG9ycy5CYWxhbmNlZFBvb2wgJiYgQXJyYXkuaXNBcnJheShvcHRzLmludGVyY2VwdG9ycy5CYWxhbmNlZFBvb2wpXG4gICAgICA/IG9wdHMuaW50ZXJjZXB0b3JzLkJhbGFuY2VkUG9vbFxuICAgICAgOiBbXVxuICAgIHRoaXNba0ZhY3RvcnldID0gZmFjdG9yeVxuXG4gICAgZm9yIChjb25zdCB1cHN0cmVhbSBvZiB1cHN0cmVhbXMpIHtcbiAgICAgIHRoaXMuYWRkVXBzdHJlYW0odXBzdHJlYW0pXG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcbiAgfVxuXG4gIGFkZFVwc3RyZWFtICh1cHN0cmVhbSkge1xuICAgIGNvbnN0IHVwc3RyZWFtT3JpZ2luID0gcGFyc2VPcmlnaW4odXBzdHJlYW0pLm9yaWdpblxuXG4gICAgaWYgKHRoaXNba0NsaWVudHNdLmZpbmQoKHBvb2wpID0+IChcbiAgICAgIHBvb2xba1VybF0ub3JpZ2luID09PSB1cHN0cmVhbU9yaWdpbiAmJlxuICAgICAgcG9vbC5jbG9zZWQgIT09IHRydWUgJiZcbiAgICAgIHBvb2wuZGVzdHJveWVkICE9PSB0cnVlXG4gICAgKSkpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tGYWN0b3J5XSh1cHN0cmVhbU9yaWdpbiwgT2JqZWN0LmFzc2lnbih7fSwgdGhpc1trT3B0aW9uc10pKVxuXG4gICAgdGhpc1trQWRkQ2xpZW50XShwb29sKVxuICAgIHBvb2wub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBwb29sW2tXZWlnaHRdID0gTWF0aC5taW4odGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXSwgcG9vbFtrV2VpZ2h0XSArIHRoaXNba0Vycm9yUGVuYWx0eV0pXG4gICAgfSlcblxuICAgIHBvb2wub24oJ2Nvbm5lY3Rpb25FcnJvcicsICgpID0+IHtcbiAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1heCgxLCBwb29sW2tXZWlnaHRdIC0gdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcbiAgICB9KVxuXG4gICAgcG9vbC5vbignZGlzY29ubmVjdCcsICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBhcmdzWzJdXG4gICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnVU5EX0VSUl9TT0NLRVQnKSB7XG4gICAgICAgIC8vIGRlY3JlYXNlIHRoZSB3ZWlnaHQgb2YgdGhlIHBvb2wuXG4gICAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1heCgxLCBwb29sW2tXZWlnaHRdIC0gdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgY2xpZW50W2tXZWlnaHRdID0gdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBfdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMgKCkge1xuICAgIHRoaXNba0dyZWF0ZXN0Q29tbW9uRGl2aXNvcl0gPSB0aGlzW2tDbGllbnRzXS5tYXAocCA9PiBwW2tXZWlnaHRdKS5yZWR1Y2UoZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yLCAwKVxuICB9XG5cbiAgcmVtb3ZlVXBzdHJlYW0gKHVwc3RyZWFtKSB7XG4gICAgY29uc3QgdXBzdHJlYW1PcmlnaW4gPSBwYXJzZU9yaWdpbih1cHN0cmVhbSkub3JpZ2luXG5cbiAgICBjb25zdCBwb29sID0gdGhpc1trQ2xpZW50c10uZmluZCgocG9vbCkgPT4gKFxuICAgICAgcG9vbFtrVXJsXS5vcmlnaW4gPT09IHVwc3RyZWFtT3JpZ2luICYmXG4gICAgICBwb29sLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgcG9vbC5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKVxuXG4gICAgaWYgKHBvb2wpIHtcbiAgICAgIHRoaXNba1JlbW92ZUNsaWVudF0ocG9vbClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IHVwc3RyZWFtcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NsaWVudHNdXG4gICAgICAuZmlsdGVyKGRpc3BhdGNoZXIgPT4gZGlzcGF0Y2hlci5jbG9zZWQgIT09IHRydWUgJiYgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWUpXG4gICAgICAubWFwKChwKSA9PiBwW2tVcmxdLm9yaWdpbilcbiAgfVxuXG4gIFtrR2V0RGlzcGF0Y2hlcl0gKCkge1xuICAgIC8vIFdlIHZhbGlkYXRlIHRoYXQgcG9vbHMgaXMgZ3JlYXRlciB0aGFuIDAsXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdvdWxkIGhhdmUgdG8gd2FpdCB1bnRpbCBhbiB1cHN0cmVhbVxuICAgIC8vIGlzIGFkZGVkLCB3aGljaCBtaWdodCBuZXZlciBoYXBwZW4uXG4gICAgaWYgKHRoaXNba0NsaWVudHNdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yKClcbiAgICB9XG5cbiAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trQ2xpZW50c10uZmluZChkaXNwYXRjaGVyID0+IChcbiAgICAgICFkaXNwYXRjaGVyW2tOZWVkRHJhaW5dICYmXG4gICAgICBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKVxuXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBhbGxDbGllbnRzQnVzeSA9IHRoaXNba0NsaWVudHNdLm1hcChwb29sID0+IHBvb2xba05lZWREcmFpbl0pLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKVxuXG4gICAgaWYgKGFsbENsaWVudHNCdXN5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgY291bnRlciA9IDBcblxuICAgIGxldCBtYXhXZWlnaHRJbmRleCA9IHRoaXNba0NsaWVudHNdLmZpbmRJbmRleChwb29sID0+ICFwb29sW2tOZWVkRHJhaW5dKVxuXG4gICAgd2hpbGUgKGNvdW50ZXIrKyA8IHRoaXNba0NsaWVudHNdLmxlbmd0aCkge1xuICAgICAgdGhpc1trSW5kZXhdID0gKHRoaXNba0luZGV4XSArIDEpICUgdGhpc1trQ2xpZW50c10ubGVuZ3RoXG4gICAgICBjb25zdCBwb29sID0gdGhpc1trQ2xpZW50c11bdGhpc1trSW5kZXhdXVxuXG4gICAgICAvLyBmaW5kIHBvb2wgaW5kZXggd2l0aCB0aGUgbGFyZ2VzdCB3ZWlnaHRcbiAgICAgIGlmIChwb29sW2tXZWlnaHRdID4gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdW2tXZWlnaHRdICYmICFwb29sW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgIG1heFdlaWdodEluZGV4ID0gdGhpc1trSW5kZXhdXG4gICAgICB9XG5cbiAgICAgIC8vIGRlY3JlYXNlIHRoZSBjdXJyZW50IHdlaWdodCBldmVyeSBgdGhpc1trQ2xpZW50c10ubGVuZ3RoYC5cbiAgICAgIGlmICh0aGlzW2tJbmRleF0gPT09IDApIHtcbiAgICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IHdlaWdodCB0byB0aGUgbmV4dCBsb3dlciB3ZWlnaHQuXG4gICAgICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trQ3VycmVudFdlaWdodF0gLSB0aGlzW2tHcmVhdGVzdENvbW1vbkRpdmlzb3JdXG5cbiAgICAgICAgaWYgKHRoaXNba0N1cnJlbnRXZWlnaHRdIDw9IDApIHtcbiAgICAgICAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IHRoaXNba01heFdlaWdodFBlclNlcnZlcl1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvb2xba1dlaWdodF0gPj0gdGhpc1trQ3VycmVudFdlaWdodF0gJiYgKCFwb29sW2tOZWVkRHJhaW5dKSkge1xuICAgICAgICByZXR1cm4gcG9vbFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdW2tXZWlnaHRdXG4gICAgdGhpc1trSW5kZXhdID0gbWF4V2VpZ2h0SW5kZXhcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYWxhbmNlZFBvb2xcbiJdLCJuYW1lcyI6WyJCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvciIsIkludmFsaWRBcmd1bWVudEVycm9yIiwicmVxdWlyZSIsIlBvb2xCYXNlIiwia0NsaWVudHMiLCJrTmVlZERyYWluIiwia0FkZENsaWVudCIsImtSZW1vdmVDbGllbnQiLCJrR2V0RGlzcGF0Y2hlciIsIlBvb2wiLCJrVXJsIiwia0ludGVyY2VwdG9ycyIsInBhcnNlT3JpZ2luIiwia0ZhY3RvcnkiLCJTeW1ib2wiLCJrT3B0aW9ucyIsImtHcmVhdGVzdENvbW1vbkRpdmlzb3IiLCJrQ3VycmVudFdlaWdodCIsImtJbmRleCIsImtXZWlnaHQiLCJrTWF4V2VpZ2h0UGVyU2VydmVyIiwia0Vycm9yUGVuYWx0eSIsImdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvciIsImEiLCJiIiwiZGVmYXVsdEZhY3RvcnkiLCJvcmlnaW4iLCJvcHRzIiwiQmFsYW5jZWRQb29sIiwiY29uc3RydWN0b3IiLCJ1cHN0cmVhbXMiLCJmYWN0b3J5IiwibWF4V2VpZ2h0UGVyU2VydmVyIiwiZXJyb3JQZW5hbHR5IiwiQXJyYXkiLCJpc0FycmF5IiwiaW50ZXJjZXB0b3JzIiwidXBzdHJlYW0iLCJhZGRVcHN0cmVhbSIsIl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cyIsInVwc3RyZWFtT3JpZ2luIiwiZmluZCIsInBvb2wiLCJjbG9zZWQiLCJkZXN0cm95ZWQiLCJPYmplY3QiLCJhc3NpZ24iLCJvbiIsIk1hdGgiLCJtaW4iLCJtYXgiLCJhcmdzIiwiZXJyIiwiY29kZSIsImNsaWVudCIsIm1hcCIsInAiLCJyZWR1Y2UiLCJyZW1vdmVVcHN0cmVhbSIsImZpbHRlciIsImRpc3BhdGNoZXIiLCJsZW5ndGgiLCJhbGxDbGllbnRzQnVzeSIsImNvdW50ZXIiLCJtYXhXZWlnaHRJbmRleCIsImZpbmRJbmRleCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/balanced-pool.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/cache/cache.js":
/*!****************************************************!*\
  !*** ../../node_modules/undici/lib/cache/cache.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/cache/symbols.js\");\nconst { urlEquals, fieldValues: getFieldValues } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/cache/util.js\");\nconst { kEnumerableProperty, isDisturbed } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst { Response, cloneResponse } = __webpack_require__(/*! ../fetch/response */ \"(rsc)/../../node_modules/undici/lib/fetch/response.js\");\nconst { Request } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/../../node_modules/undici/lib/fetch/request.js\");\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ../fetch/symbols */ \"(rsc)/../../node_modules/undici/lib/fetch/symbols.js\");\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(rsc)/../../node_modules/undici/lib/fetch/index.js\");\nconst { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/../../node_modules/undici/lib/fetch/util.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(rsc)/../../node_modules/undici/lib/global.js\");\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */ /**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */ class Cache {\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */ #relevantRequestResponseList;\n    constructor(){\n        if (arguments[0] !== kConstruct) {\n            webidl.illegalConstructor();\n        }\n        this.#relevantRequestResponseList = arguments[1];\n    }\n    async match(request, options = {}) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Cache.match\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.CacheQueryOptions(options);\n        const p = await this.matchAll(request, options);\n        if (p.length === 0) {\n            return;\n        }\n        return p[0];\n    }\n    async matchAll(request = undefined, options = {}) {\n        webidl.brandCheck(this, Cache);\n        if (request !== undefined) request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.CacheQueryOptions(options);\n        // 1.\n        let r = null;\n        // 2.\n        if (request !== undefined) {\n            if (request instanceof Request) {\n                // 2.1.1\n                r = request[kState];\n                // 2.1.2\n                if (r.method !== \"GET\" && !options.ignoreMethod) {\n                    return [];\n                }\n            } else if (typeof request === \"string\") {\n                // 2.2.1\n                r = new Request(request)[kState];\n            }\n        }\n        // 5.\n        // 5.1\n        const responses = [];\n        // 5.2\n        if (request === undefined) {\n            // 5.2.1\n            for (const requestResponse of this.#relevantRequestResponseList){\n                responses.push(requestResponse[1]);\n            }\n        } else {\n            // 5.3.1\n            const requestResponses = this.#queryCache(r, options);\n            // 5.3.2\n            for (const requestResponse of requestResponses){\n                responses.push(requestResponse[1]);\n            }\n        }\n        // 5.4\n        // We don't implement CORs so we don't need to loop over the responses, yay!\n        // 5.5.1\n        const responseList = [];\n        // 5.5.2\n        for (const response of responses){\n            // 5.5.2.1\n            const responseObject = new Response(response.body?.source ?? null);\n            const body = responseObject[kState].body;\n            responseObject[kState] = response;\n            responseObject[kState].body = body;\n            responseObject[kHeaders][kHeadersList] = response.headersList;\n            responseObject[kHeaders][kGuard] = \"immutable\";\n            responseList.push(responseObject);\n        }\n        // 6.\n        return Object.freeze(responseList);\n    }\n    async add(request) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Cache.add\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        // 1.\n        const requests = [\n            request\n        ];\n        // 2.\n        const responseArrayPromise = this.addAll(requests);\n        // 3.\n        return await responseArrayPromise;\n    }\n    async addAll(requests) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Cache.addAll\"\n        });\n        requests = webidl.converters[\"sequence<RequestInfo>\"](requests);\n        // 1.\n        const responsePromises = [];\n        // 2.\n        const requestList = [];\n        // 3.\n        for (const request of requests){\n            if (typeof request === \"string\") {\n                continue;\n            }\n            // 3.1\n            const r = request[kState];\n            // 3.2\n            if (!urlIsHttpHttpsScheme(r.url) || r.method !== \"GET\") {\n                throw webidl.errors.exception({\n                    header: \"Cache.addAll\",\n                    message: \"Expected http/s scheme when method is not GET.\"\n                });\n            }\n        }\n        // 4.\n        /** @type {ReturnType<typeof fetching>[]} */ const fetchControllers = [];\n        // 5.\n        for (const request of requests){\n            // 5.1\n            const r = new Request(request)[kState];\n            // 5.2\n            if (!urlIsHttpHttpsScheme(r.url)) {\n                throw webidl.errors.exception({\n                    header: \"Cache.addAll\",\n                    message: \"Expected http/s scheme.\"\n                });\n            }\n            // 5.4\n            r.initiator = \"fetch\";\n            r.destination = \"subresource\";\n            // 5.5\n            requestList.push(r);\n            // 5.6\n            const responsePromise = createDeferredPromise();\n            // 5.7\n            fetchControllers.push(fetching({\n                request: r,\n                dispatcher: getGlobalDispatcher(),\n                processResponse (response) {\n                    // 1.\n                    if (response.type === \"error\" || response.status === 206 || response.status < 200 || response.status > 299) {\n                        responsePromise.reject(webidl.errors.exception({\n                            header: \"Cache.addAll\",\n                            message: \"Received an invalid status code or the request failed.\"\n                        }));\n                    } else if (response.headersList.contains(\"vary\")) {\n                        // 2.1\n                        const fieldValues = getFieldValues(response.headersList.get(\"vary\"));\n                        // 2.2\n                        for (const fieldValue of fieldValues){\n                            // 2.2.1\n                            if (fieldValue === \"*\") {\n                                responsePromise.reject(webidl.errors.exception({\n                                    header: \"Cache.addAll\",\n                                    message: \"invalid vary field value\"\n                                }));\n                                for (const controller of fetchControllers){\n                                    controller.abort();\n                                }\n                                return;\n                            }\n                        }\n                    }\n                },\n                processResponseEndOfBody (response) {\n                    // 1.\n                    if (response.aborted) {\n                        responsePromise.reject(new DOMException(\"aborted\", \"AbortError\"));\n                        return;\n                    }\n                    // 2.\n                    responsePromise.resolve(response);\n                }\n            }));\n            // 5.8\n            responsePromises.push(responsePromise.promise);\n        }\n        // 6.\n        const p = Promise.all(responsePromises);\n        // 7.\n        const responses = await p;\n        // 7.1\n        const operations = [];\n        // 7.2\n        let index = 0;\n        // 7.3\n        for (const response of responses){\n            // 7.3.1\n            /** @type {CacheBatchOperation} */ const operation = {\n                type: \"put\",\n                request: requestList[index],\n                response\n            };\n            operations.push(operation) // 7.3.5\n            ;\n            index++ // 7.3.6\n            ;\n        }\n        // 7.5\n        const cacheJobPromise = createDeferredPromise();\n        // 7.6.1\n        let errorData = null;\n        // 7.6.2\n        try {\n            this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        // 7.6.3\n        queueMicrotask(()=>{\n            // 7.6.3.1\n            if (errorData === null) {\n                cacheJobPromise.resolve(undefined);\n            } else {\n                // 7.6.3.2\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        // 7.7\n        return cacheJobPromise.promise;\n    }\n    async put(request, response) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"Cache.put\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        response = webidl.converters.Response(response);\n        // 1.\n        let innerRequest = null;\n        // 2.\n        if (request instanceof Request) {\n            innerRequest = request[kState];\n        } else {\n            innerRequest = new Request(request)[kState];\n        }\n        // 4.\n        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== \"GET\") {\n            throw webidl.errors.exception({\n                header: \"Cache.put\",\n                message: \"Expected an http/s scheme when method is not GET\"\n            });\n        }\n        // 5.\n        const innerResponse = response[kState];\n        // 6.\n        if (innerResponse.status === 206) {\n            throw webidl.errors.exception({\n                header: \"Cache.put\",\n                message: \"Got 206 status\"\n            });\n        }\n        // 7.\n        if (innerResponse.headersList.contains(\"vary\")) {\n            // 7.1.\n            const fieldValues = getFieldValues(innerResponse.headersList.get(\"vary\"));\n            // 7.2.\n            for (const fieldValue of fieldValues){\n                // 7.2.1\n                if (fieldValue === \"*\") {\n                    throw webidl.errors.exception({\n                        header: \"Cache.put\",\n                        message: \"Got * vary field value\"\n                    });\n                }\n            }\n        }\n        // 8.\n        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n            throw webidl.errors.exception({\n                header: \"Cache.put\",\n                message: \"Response body is locked or disturbed\"\n            });\n        }\n        // 9.\n        const clonedResponse = cloneResponse(innerResponse);\n        // 10.\n        const bodyReadPromise = createDeferredPromise();\n        // 11.\n        if (innerResponse.body != null) {\n            // 11.1\n            const stream = innerResponse.body.stream;\n            // 11.2\n            const reader = stream.getReader();\n            // 11.3\n            readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);\n        } else {\n            bodyReadPromise.resolve(undefined);\n        }\n        // 12.\n        /** @type {CacheBatchOperation[]} */ const operations = [];\n        // 13.\n        /** @type {CacheBatchOperation} */ const operation = {\n            type: \"put\",\n            request: innerRequest,\n            response: clonedResponse // 16.\n        };\n        // 17.\n        operations.push(operation);\n        // 19.\n        const bytes = await bodyReadPromise.promise;\n        if (clonedResponse.body != null) {\n            clonedResponse.body.source = bytes;\n        }\n        // 19.1\n        const cacheJobPromise = createDeferredPromise();\n        // 19.2.1\n        let errorData = null;\n        // 19.2.2\n        try {\n            this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        // 19.2.3\n        queueMicrotask(()=>{\n            // 19.2.3.1\n            if (errorData === null) {\n                cacheJobPromise.resolve();\n            } else {\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        return cacheJobPromise.promise;\n    }\n    async delete(request, options = {}) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Cache.delete\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.CacheQueryOptions(options);\n        /**\n     * @type {Request}\n     */ let r = null;\n        if (request instanceof Request) {\n            r = request[kState];\n            if (r.method !== \"GET\" && !options.ignoreMethod) {\n                return false;\n            }\n        } else {\n            assert(typeof request === \"string\");\n            r = new Request(request)[kState];\n        }\n        /** @type {CacheBatchOperation[]} */ const operations = [];\n        /** @type {CacheBatchOperation} */ const operation = {\n            type: \"delete\",\n            request: r,\n            options\n        };\n        operations.push(operation);\n        const cacheJobPromise = createDeferredPromise();\n        let errorData = null;\n        let requestResponses;\n        try {\n            requestResponses = this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        queueMicrotask(()=>{\n            if (errorData === null) {\n                cacheJobPromise.resolve(!!requestResponses?.length);\n            } else {\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        return cacheJobPromise.promise;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {readonly Request[]}\n   */ async keys(request = undefined, options = {}) {\n        webidl.brandCheck(this, Cache);\n        if (request !== undefined) request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.CacheQueryOptions(options);\n        // 1.\n        let r = null;\n        // 2.\n        if (request !== undefined) {\n            // 2.1\n            if (request instanceof Request) {\n                // 2.1.1\n                r = request[kState];\n                // 2.1.2\n                if (r.method !== \"GET\" && !options.ignoreMethod) {\n                    return [];\n                }\n            } else if (typeof request === \"string\") {\n                r = new Request(request)[kState];\n            }\n        }\n        // 4.\n        const promise = createDeferredPromise();\n        // 5.\n        // 5.1\n        const requests = [];\n        // 5.2\n        if (request === undefined) {\n            // 5.2.1\n            for (const requestResponse of this.#relevantRequestResponseList){\n                // 5.2.1.1\n                requests.push(requestResponse[0]);\n            }\n        } else {\n            // 5.3.1\n            const requestResponses = this.#queryCache(r, options);\n            // 5.3.2\n            for (const requestResponse of requestResponses){\n                // 5.3.2.1\n                requests.push(requestResponse[0]);\n            }\n        }\n        // 5.4\n        queueMicrotask(()=>{\n            // 5.4.1\n            const requestList = [];\n            // 5.4.2\n            for (const request of requests){\n                const requestObject = new Request(\"https://a\");\n                requestObject[kState] = request;\n                requestObject[kHeaders][kHeadersList] = request.headersList;\n                requestObject[kHeaders][kGuard] = \"immutable\";\n                requestObject[kRealm] = request.client;\n                // 5.4.2.1\n                requestList.push(requestObject);\n            }\n            // 5.4.3\n            promise.resolve(Object.freeze(requestList));\n        });\n        return promise.promise;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */ #batchCacheOperations(operations) {\n        // 1.\n        const cache = this.#relevantRequestResponseList;\n        // 2.\n        const backupCache = [\n            ...cache\n        ];\n        // 3.\n        const addedItems = [];\n        // 4.1\n        const resultList = [];\n        try {\n            // 4.2\n            for (const operation of operations){\n                // 4.2.1\n                if (operation.type !== \"delete\" && operation.type !== \"put\") {\n                    throw webidl.errors.exception({\n                        header: \"Cache.#batchCacheOperations\",\n                        message: 'operation type does not match \"delete\" or \"put\"'\n                    });\n                }\n                // 4.2.2\n                if (operation.type === \"delete\" && operation.response != null) {\n                    throw webidl.errors.exception({\n                        header: \"Cache.#batchCacheOperations\",\n                        message: \"delete operation should not have an associated response\"\n                    });\n                }\n                // 4.2.3\n                if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n                    throw new DOMException(\"???\", \"InvalidStateError\");\n                }\n                // 4.2.4\n                let requestResponses;\n                // 4.2.5\n                if (operation.type === \"delete\") {\n                    // 4.2.5.1\n                    requestResponses = this.#queryCache(operation.request, operation.options);\n                    // TODO: the spec is wrong, this is needed to pass WPTs\n                    if (requestResponses.length === 0) {\n                        return [];\n                    }\n                    // 4.2.5.2\n                    for (const requestResponse of requestResponses){\n                        const idx = cache.indexOf(requestResponse);\n                        assert(idx !== -1);\n                        // 4.2.5.2.1\n                        cache.splice(idx, 1);\n                    }\n                } else if (operation.type === \"put\") {\n                    // 4.2.6.1\n                    if (operation.response == null) {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"put operation should have an associated response\"\n                        });\n                    }\n                    // 4.2.6.2\n                    const r = operation.request;\n                    // 4.2.6.3\n                    if (!urlIsHttpHttpsScheme(r.url)) {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"expected http or https scheme\"\n                        });\n                    }\n                    // 4.2.6.4\n                    if (r.method !== \"GET\") {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"not get method\"\n                        });\n                    }\n                    // 4.2.6.5\n                    if (operation.options != null) {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"options must not be defined\"\n                        });\n                    }\n                    // 4.2.6.6\n                    requestResponses = this.#queryCache(operation.request);\n                    // 4.2.6.7\n                    for (const requestResponse of requestResponses){\n                        const idx = cache.indexOf(requestResponse);\n                        assert(idx !== -1);\n                        // 4.2.6.7.1\n                        cache.splice(idx, 1);\n                    }\n                    // 4.2.6.8\n                    cache.push([\n                        operation.request,\n                        operation.response\n                    ]);\n                    // 4.2.6.10\n                    addedItems.push([\n                        operation.request,\n                        operation.response\n                    ]);\n                }\n                // 4.2.7\n                resultList.push([\n                    operation.request,\n                    operation.response\n                ]);\n            }\n            // 4.3\n            return resultList;\n        } catch (e) {\n            // 5.1\n            this.#relevantRequestResponseList.length = 0;\n            // 5.2\n            this.#relevantRequestResponseList = backupCache;\n            // 5.3\n            throw e;\n        }\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */ #queryCache(requestQuery, options, targetStorage) {\n        /** @type {requestResponseList} */ const resultList = [];\n        const storage = targetStorage ?? this.#relevantRequestResponseList;\n        for (const requestResponse of storage){\n            const [cachedRequest, cachedResponse] = requestResponse;\n            if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n                resultList.push(requestResponse);\n            }\n        }\n        return resultList;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */ #requestMatchesCachedItem(requestQuery, request, response = null, options) {\n        // if (options?.ignoreMethod === false && request.method === 'GET') {\n        //   return false\n        // }\n        const queryURL = new URL(requestQuery.url);\n        const cachedURL = new URL(request.url);\n        if (options?.ignoreSearch) {\n            cachedURL.search = \"\";\n            queryURL.search = \"\";\n        }\n        if (!urlEquals(queryURL, cachedURL, true)) {\n            return false;\n        }\n        if (response == null || options?.ignoreVary || !response.headersList.contains(\"vary\")) {\n            return true;\n        }\n        const fieldValues = getFieldValues(response.headersList.get(\"vary\"));\n        for (const fieldValue of fieldValues){\n            if (fieldValue === \"*\") {\n                return false;\n            }\n            const requestValue = request.headersList.get(fieldValue);\n            const queryValue = requestQuery.headersList.get(fieldValue);\n            // If one has the header and the other doesn't, or one has\n            // a different value than the other, return false\n            if (requestValue !== queryValue) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nObject.defineProperties(Cache.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"Cache\",\n        configurable: true\n    },\n    match: kEnumerableProperty,\n    matchAll: kEnumerableProperty,\n    add: kEnumerableProperty,\n    addAll: kEnumerableProperty,\n    put: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    keys: kEnumerableProperty\n});\nconst cacheQueryOptionConverters = [\n    {\n        key: \"ignoreSearch\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"ignoreMethod\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"ignoreVary\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    }\n];\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n    ...cacheQueryOptionConverters,\n    {\n        key: \"cacheName\",\n        converter: webidl.converters.DOMString\n    }\n]);\nwebidl.converters.Response = webidl.interfaceConverter(Response);\nwebidl.converters[\"sequence<RequestInfo>\"] = webidl.sequenceConverter(webidl.converters.RequestInfo);\nmodule.exports = {\n    Cache\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMvQixNQUFNLEVBQUVDLFNBQVMsRUFBRUMsYUFBYUMsY0FBYyxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQzNELE1BQU0sRUFBRUksbUJBQW1CLEVBQUVDLFdBQVcsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUNyRCxNQUFNLEVBQUVNLFlBQVksRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUNqQyxNQUFNLEVBQUVPLE1BQU0sRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVRLFFBQVEsRUFBRUMsYUFBYSxFQUFFLEdBQUdULG1CQUFPQSxDQUFDO0FBQzVDLE1BQU0sRUFBRVUsT0FBTyxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU0sRUFBRVcsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdkLG1CQUFPQSxDQUFDO0FBQ3JELE1BQU0sRUFBRWUsUUFBUSxFQUFFLEdBQUdmLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU0sRUFBRWdCLG9CQUFvQixFQUFFQyxxQkFBcUIsRUFBRUMsWUFBWSxFQUFFLEdBQUdsQixtQkFBT0EsQ0FBQztBQUM5RSxNQUFNbUIsU0FBU25CLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRW9CLG1CQUFtQixFQUFFLEdBQUdwQixtQkFBT0EsQ0FBQztBQUV4Qzs7Ozs7OztDQU9DLEdBRUQ7OztDQUdDLEdBRUQsTUFBTXFCO0lBQ0o7OztHQUdDLEdBQ0QsQ0FBQ0MsMkJBQTJCO0lBRTVCQyxhQUFlO1FBQ2IsSUFBSUMsU0FBUyxDQUFDLEVBQUUsS0FBS3pCLFlBQVk7WUFDL0JRLE9BQU9rQixrQkFBa0I7UUFDM0I7UUFFQSxJQUFJLENBQUMsQ0FBQ0gsMkJBQTJCLEdBQUdFLFNBQVMsQ0FBQyxFQUFFO0lBQ2xEO0lBRUEsTUFBTUUsTUFBT0MsT0FBTyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ2xDckIsT0FBT3NCLFVBQVUsQ0FBQyxJQUFJLEVBQUVSO1FBQ3hCZCxPQUFPdUIsbUJBQW1CLENBQUNOLFdBQVcsR0FBRztZQUFFTyxRQUFRO1FBQWM7UUFFakVKLFVBQVVwQixPQUFPeUIsVUFBVSxDQUFDQyxXQUFXLENBQUNOO1FBQ3hDQyxVQUFVckIsT0FBT3lCLFVBQVUsQ0FBQ0UsaUJBQWlCLENBQUNOO1FBRTlDLE1BQU1PLElBQUksTUFBTSxJQUFJLENBQUNDLFFBQVEsQ0FBQ1QsU0FBU0M7UUFFdkMsSUFBSU8sRUFBRUUsTUFBTSxLQUFLLEdBQUc7WUFDbEI7UUFDRjtRQUVBLE9BQU9GLENBQUMsQ0FBQyxFQUFFO0lBQ2I7SUFFQSxNQUFNQyxTQUFVVCxVQUFVVyxTQUFTLEVBQUVWLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDakRyQixPQUFPc0IsVUFBVSxDQUFDLElBQUksRUFBRVI7UUFFeEIsSUFBSU0sWUFBWVcsV0FBV1gsVUFBVXBCLE9BQU95QixVQUFVLENBQUNDLFdBQVcsQ0FBQ047UUFDbkVDLFVBQVVyQixPQUFPeUIsVUFBVSxDQUFDRSxpQkFBaUIsQ0FBQ047UUFFOUMsS0FBSztRQUNMLElBQUlXLElBQUk7UUFFUixLQUFLO1FBQ0wsSUFBSVosWUFBWVcsV0FBVztZQUN6QixJQUFJWCxtQkFBbUJqQixTQUFTO2dCQUM5QixRQUFRO2dCQUNSNkIsSUFBSVosT0FBTyxDQUFDaEIsT0FBTztnQkFFbkIsUUFBUTtnQkFDUixJQUFJNEIsRUFBRUMsTUFBTSxLQUFLLFNBQVMsQ0FBQ1osUUFBUWEsWUFBWSxFQUFFO29CQUMvQyxPQUFPLEVBQUU7Z0JBQ1g7WUFDRixPQUFPLElBQUksT0FBT2QsWUFBWSxVQUFVO2dCQUN0QyxRQUFRO2dCQUNSWSxJQUFJLElBQUk3QixRQUFRaUIsUUFBUSxDQUFDaEIsT0FBTztZQUNsQztRQUNGO1FBRUEsS0FBSztRQUNMLE1BQU07UUFDTixNQUFNK0IsWUFBWSxFQUFFO1FBRXBCLE1BQU07UUFDTixJQUFJZixZQUFZVyxXQUFXO1lBQ3pCLFFBQVE7WUFDUixLQUFLLE1BQU1LLG1CQUFtQixJQUFJLENBQUMsQ0FBQ3JCLDJCQUEyQixDQUFFO2dCQUMvRG9CLFVBQVVFLElBQUksQ0FBQ0QsZUFBZSxDQUFDLEVBQUU7WUFDbkM7UUFDRixPQUFPO1lBQ0wsUUFBUTtZQUNSLE1BQU1FLG1CQUFtQixJQUFJLENBQUMsQ0FBQ0MsVUFBVSxDQUFDUCxHQUFHWDtZQUU3QyxRQUFRO1lBQ1IsS0FBSyxNQUFNZSxtQkFBbUJFLGlCQUFrQjtnQkFDOUNILFVBQVVFLElBQUksQ0FBQ0QsZUFBZSxDQUFDLEVBQUU7WUFDbkM7UUFDRjtRQUVBLE1BQU07UUFDTiw0RUFBNEU7UUFFNUUsUUFBUTtRQUNSLE1BQU1JLGVBQWUsRUFBRTtRQUV2QixRQUFRO1FBQ1IsS0FBSyxNQUFNQyxZQUFZTixVQUFXO1lBQ2hDLFVBQVU7WUFDVixNQUFNTyxpQkFBaUIsSUFBSXpDLFNBQVN3QyxTQUFTRSxJQUFJLEVBQUVDLFVBQVU7WUFDN0QsTUFBTUQsT0FBT0QsY0FBYyxDQUFDdEMsT0FBTyxDQUFDdUMsSUFBSTtZQUN4Q0QsY0FBYyxDQUFDdEMsT0FBTyxHQUFHcUM7WUFDekJDLGNBQWMsQ0FBQ3RDLE9BQU8sQ0FBQ3VDLElBQUksR0FBR0E7WUFDOUJELGNBQWMsQ0FBQ3JDLFNBQVMsQ0FBQ04sYUFBYSxHQUFHMEMsU0FBU0ksV0FBVztZQUM3REgsY0FBYyxDQUFDckMsU0FBUyxDQUFDQyxPQUFPLEdBQUc7WUFFbkNrQyxhQUFhSCxJQUFJLENBQUNLO1FBQ3BCO1FBRUEsS0FBSztRQUNMLE9BQU9JLE9BQU9DLE1BQU0sQ0FBQ1A7SUFDdkI7SUFFQSxNQUFNUSxJQUFLNUIsT0FBTyxFQUFFO1FBQ2xCcEIsT0FBT3NCLFVBQVUsQ0FBQyxJQUFJLEVBQUVSO1FBQ3hCZCxPQUFPdUIsbUJBQW1CLENBQUNOLFdBQVcsR0FBRztZQUFFTyxRQUFRO1FBQVk7UUFFL0RKLFVBQVVwQixPQUFPeUIsVUFBVSxDQUFDQyxXQUFXLENBQUNOO1FBRXhDLEtBQUs7UUFDTCxNQUFNNkIsV0FBVztZQUFDN0I7U0FBUTtRQUUxQixLQUFLO1FBQ0wsTUFBTThCLHVCQUF1QixJQUFJLENBQUNDLE1BQU0sQ0FBQ0Y7UUFFekMsS0FBSztRQUNMLE9BQU8sTUFBTUM7SUFDZjtJQUVBLE1BQU1DLE9BQVFGLFFBQVEsRUFBRTtRQUN0QmpELE9BQU9zQixVQUFVLENBQUMsSUFBSSxFQUFFUjtRQUN4QmQsT0FBT3VCLG1CQUFtQixDQUFDTixXQUFXLEdBQUc7WUFBRU8sUUFBUTtRQUFlO1FBRWxFeUIsV0FBV2pELE9BQU95QixVQUFVLENBQUMsd0JBQXdCLENBQUN3QjtRQUV0RCxLQUFLO1FBQ0wsTUFBTUcsbUJBQW1CLEVBQUU7UUFFM0IsS0FBSztRQUNMLE1BQU1DLGNBQWMsRUFBRTtRQUV0QixLQUFLO1FBQ0wsS0FBSyxNQUFNakMsV0FBVzZCLFNBQVU7WUFDOUIsSUFBSSxPQUFPN0IsWUFBWSxVQUFVO2dCQUMvQjtZQUNGO1lBRUEsTUFBTTtZQUNOLE1BQU1ZLElBQUlaLE9BQU8sQ0FBQ2hCLE9BQU87WUFFekIsTUFBTTtZQUNOLElBQUksQ0FBQ0sscUJBQXFCdUIsRUFBRXNCLEdBQUcsS0FBS3RCLEVBQUVDLE1BQU0sS0FBSyxPQUFPO2dCQUN0RCxNQUFNakMsT0FBT3VELE1BQU0sQ0FBQ0MsU0FBUyxDQUFDO29CQUM1QmhDLFFBQVE7b0JBQ1JpQyxTQUFTO2dCQUNYO1lBQ0Y7UUFDRjtRQUVBLEtBQUs7UUFDTCwwQ0FBMEMsR0FDMUMsTUFBTUMsbUJBQW1CLEVBQUU7UUFFM0IsS0FBSztRQUNMLEtBQUssTUFBTXRDLFdBQVc2QixTQUFVO1lBQzlCLE1BQU07WUFDTixNQUFNakIsSUFBSSxJQUFJN0IsUUFBUWlCLFFBQVEsQ0FBQ2hCLE9BQU87WUFFdEMsTUFBTTtZQUNOLElBQUksQ0FBQ0sscUJBQXFCdUIsRUFBRXNCLEdBQUcsR0FBRztnQkFDaEMsTUFBTXRELE9BQU91RCxNQUFNLENBQUNDLFNBQVMsQ0FBQztvQkFDNUJoQyxRQUFRO29CQUNSaUMsU0FBUztnQkFDWDtZQUNGO1lBRUEsTUFBTTtZQUNOekIsRUFBRTJCLFNBQVMsR0FBRztZQUNkM0IsRUFBRTRCLFdBQVcsR0FBRztZQUVoQixNQUFNO1lBQ05QLFlBQVloQixJQUFJLENBQUNMO1lBRWpCLE1BQU07WUFDTixNQUFNNkIsa0JBQWtCbkQ7WUFFeEIsTUFBTTtZQUNOZ0QsaUJBQWlCckIsSUFBSSxDQUFDN0IsU0FBUztnQkFDN0JZLFNBQVNZO2dCQUNUOEIsWUFBWWpEO2dCQUNaa0QsaUJBQWlCdEIsUUFBUTtvQkFDdkIsS0FBSztvQkFDTCxJQUFJQSxTQUFTdUIsSUFBSSxLQUFLLFdBQVd2QixTQUFTd0IsTUFBTSxLQUFLLE9BQU94QixTQUFTd0IsTUFBTSxHQUFHLE9BQU94QixTQUFTd0IsTUFBTSxHQUFHLEtBQUs7d0JBQzFHSixnQkFBZ0JLLE1BQU0sQ0FBQ2xFLE9BQU91RCxNQUFNLENBQUNDLFNBQVMsQ0FBQzs0QkFDN0NoQyxRQUFROzRCQUNSaUMsU0FBUzt3QkFDWDtvQkFDRixPQUFPLElBQUloQixTQUFTSSxXQUFXLENBQUNzQixRQUFRLENBQUMsU0FBUzt3QkFDaEQsTUFBTTt3QkFDTixNQUFNeEUsY0FBY0MsZUFBZTZDLFNBQVNJLFdBQVcsQ0FBQ3VCLEdBQUcsQ0FBQzt3QkFFNUQsTUFBTTt3QkFDTixLQUFLLE1BQU1DLGNBQWMxRSxZQUFhOzRCQUNwQyxRQUFROzRCQUNSLElBQUkwRSxlQUFlLEtBQUs7Z0NBQ3RCUixnQkFBZ0JLLE1BQU0sQ0FBQ2xFLE9BQU91RCxNQUFNLENBQUNDLFNBQVMsQ0FBQztvQ0FDN0NoQyxRQUFRO29DQUNSaUMsU0FBUztnQ0FDWDtnQ0FFQSxLQUFLLE1BQU1hLGNBQWNaLGlCQUFrQjtvQ0FDekNZLFdBQVdDLEtBQUs7Z0NBQ2xCO2dDQUVBOzRCQUNGO3dCQUNGO29CQUNGO2dCQUNGO2dCQUNBQywwQkFBMEIvQixRQUFRO29CQUNoQyxLQUFLO29CQUNMLElBQUlBLFNBQVNnQyxPQUFPLEVBQUU7d0JBQ3BCWixnQkFBZ0JLLE1BQU0sQ0FBQyxJQUFJUSxhQUFhLFdBQVc7d0JBQ25EO29CQUNGO29CQUVBLEtBQUs7b0JBQ0xiLGdCQUFnQmMsT0FBTyxDQUFDbEM7Z0JBQzFCO1lBQ0Y7WUFFQSxNQUFNO1lBQ05XLGlCQUFpQmYsSUFBSSxDQUFDd0IsZ0JBQWdCZSxPQUFPO1FBQy9DO1FBRUEsS0FBSztRQUNMLE1BQU1oRCxJQUFJaUQsUUFBUUMsR0FBRyxDQUFDMUI7UUFFdEIsS0FBSztRQUNMLE1BQU1qQixZQUFZLE1BQU1QO1FBRXhCLE1BQU07UUFDTixNQUFNbUQsYUFBYSxFQUFFO1FBRXJCLE1BQU07UUFDTixJQUFJQyxRQUFRO1FBRVosTUFBTTtRQUNOLEtBQUssTUFBTXZDLFlBQVlOLFVBQVc7WUFDaEMsUUFBUTtZQUNSLGdDQUFnQyxHQUNoQyxNQUFNOEMsWUFBWTtnQkFDaEJqQixNQUFNO2dCQUNONUMsU0FBU2lDLFdBQVcsQ0FBQzJCLE1BQU07Z0JBQzNCdkM7WUFDRjtZQUVBc0MsV0FBVzFDLElBQUksQ0FBQzRDLFdBQVcsUUFBUTs7WUFFbkNELFFBQVEsUUFBUTs7UUFDbEI7UUFFQSxNQUFNO1FBQ04sTUFBTUUsa0JBQWtCeEU7UUFFeEIsUUFBUTtRQUNSLElBQUl5RSxZQUFZO1FBRWhCLFFBQVE7UUFDUixJQUFJO1lBQ0YsSUFBSSxDQUFDLENBQUNDLG9CQUFvQixDQUFDTDtRQUM3QixFQUFFLE9BQU9NLEdBQUc7WUFDVkYsWUFBWUU7UUFDZDtRQUVBLFFBQVE7UUFDUkMsZUFBZTtZQUNiLFVBQVU7WUFDVixJQUFJSCxjQUFjLE1BQU07Z0JBQ3RCRCxnQkFBZ0JQLE9BQU8sQ0FBQzVDO1lBQzFCLE9BQU87Z0JBQ0wsVUFBVTtnQkFDVm1ELGdCQUFnQmhCLE1BQU0sQ0FBQ2lCO1lBQ3pCO1FBQ0Y7UUFFQSxNQUFNO1FBQ04sT0FBT0QsZ0JBQWdCTixPQUFPO0lBQ2hDO0lBRUEsTUFBTVcsSUFBS25FLE9BQU8sRUFBRXFCLFFBQVEsRUFBRTtRQUM1QnpDLE9BQU9zQixVQUFVLENBQUMsSUFBSSxFQUFFUjtRQUN4QmQsT0FBT3VCLG1CQUFtQixDQUFDTixXQUFXLEdBQUc7WUFBRU8sUUFBUTtRQUFZO1FBRS9ESixVQUFVcEIsT0FBT3lCLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDTjtRQUN4Q3FCLFdBQVd6QyxPQUFPeUIsVUFBVSxDQUFDeEIsUUFBUSxDQUFDd0M7UUFFdEMsS0FBSztRQUNMLElBQUkrQyxlQUFlO1FBRW5CLEtBQUs7UUFDTCxJQUFJcEUsbUJBQW1CakIsU0FBUztZQUM5QnFGLGVBQWVwRSxPQUFPLENBQUNoQixPQUFPO1FBQ2hDLE9BQU87WUFDTG9GLGVBQWUsSUFBSXJGLFFBQVFpQixRQUFRLENBQUNoQixPQUFPO1FBQzdDO1FBRUEsS0FBSztRQUNMLElBQUksQ0FBQ0sscUJBQXFCK0UsYUFBYWxDLEdBQUcsS0FBS2tDLGFBQWF2RCxNQUFNLEtBQUssT0FBTztZQUM1RSxNQUFNakMsT0FBT3VELE1BQU0sQ0FBQ0MsU0FBUyxDQUFDO2dCQUM1QmhDLFFBQVE7Z0JBQ1JpQyxTQUFTO1lBQ1g7UUFDRjtRQUVBLEtBQUs7UUFDTCxNQUFNZ0MsZ0JBQWdCaEQsUUFBUSxDQUFDckMsT0FBTztRQUV0QyxLQUFLO1FBQ0wsSUFBSXFGLGNBQWN4QixNQUFNLEtBQUssS0FBSztZQUNoQyxNQUFNakUsT0FBT3VELE1BQU0sQ0FBQ0MsU0FBUyxDQUFDO2dCQUM1QmhDLFFBQVE7Z0JBQ1JpQyxTQUFTO1lBQ1g7UUFDRjtRQUVBLEtBQUs7UUFDTCxJQUFJZ0MsY0FBYzVDLFdBQVcsQ0FBQ3NCLFFBQVEsQ0FBQyxTQUFTO1lBQzlDLE9BQU87WUFDUCxNQUFNeEUsY0FBY0MsZUFBZTZGLGNBQWM1QyxXQUFXLENBQUN1QixHQUFHLENBQUM7WUFFakUsT0FBTztZQUNQLEtBQUssTUFBTUMsY0FBYzFFLFlBQWE7Z0JBQ3BDLFFBQVE7Z0JBQ1IsSUFBSTBFLGVBQWUsS0FBSztvQkFDdEIsTUFBTXJFLE9BQU91RCxNQUFNLENBQUNDLFNBQVMsQ0FBQzt3QkFDNUJoQyxRQUFRO3dCQUNSaUMsU0FBUztvQkFDWDtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxLQUFLO1FBQ0wsSUFBSWdDLGNBQWM5QyxJQUFJLElBQUs3QyxDQUFBQSxZQUFZMkYsY0FBYzlDLElBQUksQ0FBQytDLE1BQU0sS0FBS0QsY0FBYzlDLElBQUksQ0FBQytDLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHO1lBQ3RHLE1BQU0zRixPQUFPdUQsTUFBTSxDQUFDQyxTQUFTLENBQUM7Z0JBQzVCaEMsUUFBUTtnQkFDUmlDLFNBQVM7WUFDWDtRQUNGO1FBRUEsS0FBSztRQUNMLE1BQU1tQyxpQkFBaUIxRixjQUFjdUY7UUFFckMsTUFBTTtRQUNOLE1BQU1JLGtCQUFrQm5GO1FBRXhCLE1BQU07UUFDTixJQUFJK0UsY0FBYzlDLElBQUksSUFBSSxNQUFNO1lBQzlCLE9BQU87WUFDUCxNQUFNK0MsU0FBU0QsY0FBYzlDLElBQUksQ0FBQytDLE1BQU07WUFFeEMsT0FBTztZQUNQLE1BQU1JLFNBQVNKLE9BQU9LLFNBQVM7WUFFL0IsT0FBTztZQUNQcEYsYUFBYW1GLFFBQVFFLElBQUksQ0FBQ0gsZ0JBQWdCbEIsT0FBTyxFQUFFa0IsZ0JBQWdCM0IsTUFBTTtRQUMzRSxPQUFPO1lBQ0wyQixnQkFBZ0JsQixPQUFPLENBQUM1QztRQUMxQjtRQUVBLE1BQU07UUFDTixrQ0FBa0MsR0FDbEMsTUFBTWdELGFBQWEsRUFBRTtRQUVyQixNQUFNO1FBQ04sZ0NBQWdDLEdBQ2hDLE1BQU1FLFlBQVk7WUFDaEJqQixNQUFNO1lBQ041QyxTQUFTb0U7WUFDVC9DLFVBQVVtRCxlQUFlLE1BQU07UUFDakM7UUFFQSxNQUFNO1FBQ05iLFdBQVcxQyxJQUFJLENBQUM0QztRQUVoQixNQUFNO1FBQ04sTUFBTWdCLFFBQVEsTUFBTUosZ0JBQWdCakIsT0FBTztRQUUzQyxJQUFJZ0IsZUFBZWpELElBQUksSUFBSSxNQUFNO1lBQy9CaUQsZUFBZWpELElBQUksQ0FBQ0MsTUFBTSxHQUFHcUQ7UUFDL0I7UUFFQSxPQUFPO1FBQ1AsTUFBTWYsa0JBQWtCeEU7UUFFeEIsU0FBUztRQUNULElBQUl5RSxZQUFZO1FBRWhCLFNBQVM7UUFDVCxJQUFJO1lBQ0YsSUFBSSxDQUFDLENBQUNDLG9CQUFvQixDQUFDTDtRQUM3QixFQUFFLE9BQU9NLEdBQUc7WUFDVkYsWUFBWUU7UUFDZDtRQUVBLFNBQVM7UUFDVEMsZUFBZTtZQUNiLFdBQVc7WUFDWCxJQUFJSCxjQUFjLE1BQU07Z0JBQ3RCRCxnQkFBZ0JQLE9BQU87WUFDekIsT0FBTztnQkFDTE8sZ0JBQWdCaEIsTUFBTSxDQUFDaUI7WUFDekI7UUFDRjtRQUVBLE9BQU9ELGdCQUFnQk4sT0FBTztJQUNoQztJQUVBLE1BQU1zQixPQUFROUUsT0FBTyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ25DckIsT0FBT3NCLFVBQVUsQ0FBQyxJQUFJLEVBQUVSO1FBQ3hCZCxPQUFPdUIsbUJBQW1CLENBQUNOLFdBQVcsR0FBRztZQUFFTyxRQUFRO1FBQWU7UUFFbEVKLFVBQVVwQixPQUFPeUIsVUFBVSxDQUFDQyxXQUFXLENBQUNOO1FBQ3hDQyxVQUFVckIsT0FBT3lCLFVBQVUsQ0FBQ0UsaUJBQWlCLENBQUNOO1FBRTlDOztLQUVDLEdBQ0QsSUFBSVcsSUFBSTtRQUVSLElBQUlaLG1CQUFtQmpCLFNBQVM7WUFDOUI2QixJQUFJWixPQUFPLENBQUNoQixPQUFPO1lBRW5CLElBQUk0QixFQUFFQyxNQUFNLEtBQUssU0FBUyxDQUFDWixRQUFRYSxZQUFZLEVBQUU7Z0JBQy9DLE9BQU87WUFDVDtRQUNGLE9BQU87WUFDTHRCLE9BQU8sT0FBT1EsWUFBWTtZQUUxQlksSUFBSSxJQUFJN0IsUUFBUWlCLFFBQVEsQ0FBQ2hCLE9BQU87UUFDbEM7UUFFQSxrQ0FBa0MsR0FDbEMsTUFBTTJFLGFBQWEsRUFBRTtRQUVyQixnQ0FBZ0MsR0FDaEMsTUFBTUUsWUFBWTtZQUNoQmpCLE1BQU07WUFDTjVDLFNBQVNZO1lBQ1RYO1FBQ0Y7UUFFQTBELFdBQVcxQyxJQUFJLENBQUM0QztRQUVoQixNQUFNQyxrQkFBa0J4RTtRQUV4QixJQUFJeUUsWUFBWTtRQUNoQixJQUFJN0M7UUFFSixJQUFJO1lBQ0ZBLG1CQUFtQixJQUFJLENBQUMsQ0FBQzhDLG9CQUFvQixDQUFDTDtRQUNoRCxFQUFFLE9BQU9NLEdBQUc7WUFDVkYsWUFBWUU7UUFDZDtRQUVBQyxlQUFlO1lBQ2IsSUFBSUgsY0FBYyxNQUFNO2dCQUN0QkQsZ0JBQWdCUCxPQUFPLENBQUMsQ0FBQyxDQUFDckMsa0JBQWtCUjtZQUM5QyxPQUFPO2dCQUNMb0QsZ0JBQWdCaEIsTUFBTSxDQUFDaUI7WUFDekI7UUFDRjtRQUVBLE9BQU9ELGdCQUFnQk4sT0FBTztJQUNoQztJQUVBOzs7OztHQUtDLEdBQ0QsTUFBTXVCLEtBQU0vRSxVQUFVVyxTQUFTLEVBQUVWLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDN0NyQixPQUFPc0IsVUFBVSxDQUFDLElBQUksRUFBRVI7UUFFeEIsSUFBSU0sWUFBWVcsV0FBV1gsVUFBVXBCLE9BQU95QixVQUFVLENBQUNDLFdBQVcsQ0FBQ047UUFDbkVDLFVBQVVyQixPQUFPeUIsVUFBVSxDQUFDRSxpQkFBaUIsQ0FBQ047UUFFOUMsS0FBSztRQUNMLElBQUlXLElBQUk7UUFFUixLQUFLO1FBQ0wsSUFBSVosWUFBWVcsV0FBVztZQUN6QixNQUFNO1lBQ04sSUFBSVgsbUJBQW1CakIsU0FBUztnQkFDOUIsUUFBUTtnQkFDUjZCLElBQUlaLE9BQU8sQ0FBQ2hCLE9BQU87Z0JBRW5CLFFBQVE7Z0JBQ1IsSUFBSTRCLEVBQUVDLE1BQU0sS0FBSyxTQUFTLENBQUNaLFFBQVFhLFlBQVksRUFBRTtvQkFDL0MsT0FBTyxFQUFFO2dCQUNYO1lBQ0YsT0FBTyxJQUFJLE9BQU9kLFlBQVksVUFBVTtnQkFDdENZLElBQUksSUFBSTdCLFFBQVFpQixRQUFRLENBQUNoQixPQUFPO1lBQ2xDO1FBQ0Y7UUFFQSxLQUFLO1FBQ0wsTUFBTXdFLFVBQVVsRTtRQUVoQixLQUFLO1FBQ0wsTUFBTTtRQUNOLE1BQU11QyxXQUFXLEVBQUU7UUFFbkIsTUFBTTtRQUNOLElBQUk3QixZQUFZVyxXQUFXO1lBQ3pCLFFBQVE7WUFDUixLQUFLLE1BQU1LLG1CQUFtQixJQUFJLENBQUMsQ0FBQ3JCLDJCQUEyQixDQUFFO2dCQUMvRCxVQUFVO2dCQUNWa0MsU0FBU1osSUFBSSxDQUFDRCxlQUFlLENBQUMsRUFBRTtZQUNsQztRQUNGLE9BQU87WUFDTCxRQUFRO1lBQ1IsTUFBTUUsbUJBQW1CLElBQUksQ0FBQyxDQUFDQyxVQUFVLENBQUNQLEdBQUdYO1lBRTdDLFFBQVE7WUFDUixLQUFLLE1BQU1lLG1CQUFtQkUsaUJBQWtCO2dCQUM5QyxVQUFVO2dCQUNWVyxTQUFTWixJQUFJLENBQUNELGVBQWUsQ0FBQyxFQUFFO1lBQ2xDO1FBQ0Y7UUFFQSxNQUFNO1FBQ05rRCxlQUFlO1lBQ2IsUUFBUTtZQUNSLE1BQU1qQyxjQUFjLEVBQUU7WUFFdEIsUUFBUTtZQUNSLEtBQUssTUFBTWpDLFdBQVc2QixTQUFVO2dCQUM5QixNQUFNbUQsZ0JBQWdCLElBQUlqRyxRQUFRO2dCQUNsQ2lHLGFBQWEsQ0FBQ2hHLE9BQU8sR0FBR2dCO2dCQUN4QmdGLGFBQWEsQ0FBQy9GLFNBQVMsQ0FBQ04sYUFBYSxHQUFHcUIsUUFBUXlCLFdBQVc7Z0JBQzNEdUQsYUFBYSxDQUFDL0YsU0FBUyxDQUFDQyxPQUFPLEdBQUc7Z0JBQ2xDOEYsYUFBYSxDQUFDN0YsT0FBTyxHQUFHYSxRQUFRaUYsTUFBTTtnQkFFdEMsVUFBVTtnQkFDVmhELFlBQVloQixJQUFJLENBQUMrRDtZQUNuQjtZQUVBLFFBQVE7WUFDUnhCLFFBQVFELE9BQU8sQ0FBQzdCLE9BQU9DLE1BQU0sQ0FBQ007UUFDaEM7UUFFQSxPQUFPdUIsUUFBUUEsT0FBTztJQUN4QjtJQUVBOzs7O0dBSUMsR0FDRCxDQUFDUSxvQkFBb0IsQ0FBRUwsVUFBVTtRQUMvQixLQUFLO1FBQ0wsTUFBTXVCLFFBQVEsSUFBSSxDQUFDLENBQUN2RiwyQkFBMkI7UUFFL0MsS0FBSztRQUNMLE1BQU13RixjQUFjO2VBQUlEO1NBQU07UUFFOUIsS0FBSztRQUNMLE1BQU1FLGFBQWEsRUFBRTtRQUVyQixNQUFNO1FBQ04sTUFBTUMsYUFBYSxFQUFFO1FBRXJCLElBQUk7WUFDRixNQUFNO1lBQ04sS0FBSyxNQUFNeEIsYUFBYUYsV0FBWTtnQkFDbEMsUUFBUTtnQkFDUixJQUFJRSxVQUFVakIsSUFBSSxLQUFLLFlBQVlpQixVQUFVakIsSUFBSSxLQUFLLE9BQU87b0JBQzNELE1BQU1oRSxPQUFPdUQsTUFBTSxDQUFDQyxTQUFTLENBQUM7d0JBQzVCaEMsUUFBUTt3QkFDUmlDLFNBQVM7b0JBQ1g7Z0JBQ0Y7Z0JBRUEsUUFBUTtnQkFDUixJQUFJd0IsVUFBVWpCLElBQUksS0FBSyxZQUFZaUIsVUFBVXhDLFFBQVEsSUFBSSxNQUFNO29CQUM3RCxNQUFNekMsT0FBT3VELE1BQU0sQ0FBQ0MsU0FBUyxDQUFDO3dCQUM1QmhDLFFBQVE7d0JBQ1JpQyxTQUFTO29CQUNYO2dCQUNGO2dCQUVBLFFBQVE7Z0JBQ1IsSUFBSSxJQUFJLENBQUMsQ0FBQ2xCLFVBQVUsQ0FBQzBDLFVBQVU3RCxPQUFPLEVBQUU2RCxVQUFVNUQsT0FBTyxFQUFFbUYsWUFBWTFFLE1BQU0sRUFBRTtvQkFDN0UsTUFBTSxJQUFJNEMsYUFBYSxPQUFPO2dCQUNoQztnQkFFQSxRQUFRO2dCQUNSLElBQUlwQztnQkFFSixRQUFRO2dCQUNSLElBQUkyQyxVQUFVakIsSUFBSSxLQUFLLFVBQVU7b0JBQy9CLFVBQVU7b0JBQ1YxQixtQkFBbUIsSUFBSSxDQUFDLENBQUNDLFVBQVUsQ0FBQzBDLFVBQVU3RCxPQUFPLEVBQUU2RCxVQUFVNUQsT0FBTztvQkFFeEUsdURBQXVEO29CQUN2RCxJQUFJaUIsaUJBQWlCUixNQUFNLEtBQUssR0FBRzt3QkFDakMsT0FBTyxFQUFFO29CQUNYO29CQUVBLFVBQVU7b0JBQ1YsS0FBSyxNQUFNTSxtQkFBbUJFLGlCQUFrQjt3QkFDOUMsTUFBTW9FLE1BQU1KLE1BQU1LLE9BQU8sQ0FBQ3ZFO3dCQUMxQnhCLE9BQU84RixRQUFRLENBQUM7d0JBRWhCLFlBQVk7d0JBQ1pKLE1BQU1NLE1BQU0sQ0FBQ0YsS0FBSztvQkFDcEI7Z0JBQ0YsT0FBTyxJQUFJekIsVUFBVWpCLElBQUksS0FBSyxPQUFPO29CQUNuQyxVQUFVO29CQUNWLElBQUlpQixVQUFVeEMsUUFBUSxJQUFJLE1BQU07d0JBQzlCLE1BQU16QyxPQUFPdUQsTUFBTSxDQUFDQyxTQUFTLENBQUM7NEJBQzVCaEMsUUFBUTs0QkFDUmlDLFNBQVM7d0JBQ1g7b0JBQ0Y7b0JBRUEsVUFBVTtvQkFDVixNQUFNekIsSUFBSWlELFVBQVU3RCxPQUFPO29CQUUzQixVQUFVO29CQUNWLElBQUksQ0FBQ1gscUJBQXFCdUIsRUFBRXNCLEdBQUcsR0FBRzt3QkFDaEMsTUFBTXRELE9BQU91RCxNQUFNLENBQUNDLFNBQVMsQ0FBQzs0QkFDNUJoQyxRQUFROzRCQUNSaUMsU0FBUzt3QkFDWDtvQkFDRjtvQkFFQSxVQUFVO29CQUNWLElBQUl6QixFQUFFQyxNQUFNLEtBQUssT0FBTzt3QkFDdEIsTUFBTWpDLE9BQU91RCxNQUFNLENBQUNDLFNBQVMsQ0FBQzs0QkFDNUJoQyxRQUFROzRCQUNSaUMsU0FBUzt3QkFDWDtvQkFDRjtvQkFFQSxVQUFVO29CQUNWLElBQUl3QixVQUFVNUQsT0FBTyxJQUFJLE1BQU07d0JBQzdCLE1BQU1yQixPQUFPdUQsTUFBTSxDQUFDQyxTQUFTLENBQUM7NEJBQzVCaEMsUUFBUTs0QkFDUmlDLFNBQVM7d0JBQ1g7b0JBQ0Y7b0JBRUEsVUFBVTtvQkFDVm5CLG1CQUFtQixJQUFJLENBQUMsQ0FBQ0MsVUFBVSxDQUFDMEMsVUFBVTdELE9BQU87b0JBRXJELFVBQVU7b0JBQ1YsS0FBSyxNQUFNZ0IsbUJBQW1CRSxpQkFBa0I7d0JBQzlDLE1BQU1vRSxNQUFNSixNQUFNSyxPQUFPLENBQUN2RTt3QkFDMUJ4QixPQUFPOEYsUUFBUSxDQUFDO3dCQUVoQixZQUFZO3dCQUNaSixNQUFNTSxNQUFNLENBQUNGLEtBQUs7b0JBQ3BCO29CQUVBLFVBQVU7b0JBQ1ZKLE1BQU1qRSxJQUFJLENBQUM7d0JBQUM0QyxVQUFVN0QsT0FBTzt3QkFBRTZELFVBQVV4QyxRQUFRO3FCQUFDO29CQUVsRCxXQUFXO29CQUNYK0QsV0FBV25FLElBQUksQ0FBQzt3QkFBQzRDLFVBQVU3RCxPQUFPO3dCQUFFNkQsVUFBVXhDLFFBQVE7cUJBQUM7Z0JBQ3pEO2dCQUVBLFFBQVE7Z0JBQ1JnRSxXQUFXcEUsSUFBSSxDQUFDO29CQUFDNEMsVUFBVTdELE9BQU87b0JBQUU2RCxVQUFVeEMsUUFBUTtpQkFBQztZQUN6RDtZQUVBLE1BQU07WUFDTixPQUFPZ0U7UUFDVCxFQUFFLE9BQU9wQixHQUFHO1lBQ1YsTUFBTTtZQUNOLElBQUksQ0FBQyxDQUFDdEUsMkJBQTJCLENBQUNlLE1BQU0sR0FBRztZQUUzQyxNQUFNO1lBQ04sSUFBSSxDQUFDLENBQUNmLDJCQUEyQixHQUFHd0Y7WUFFcEMsTUFBTTtZQUNOLE1BQU1sQjtRQUNSO0lBQ0Y7SUFFQTs7Ozs7O0dBTUMsR0FDRCxDQUFDOUMsVUFBVSxDQUFFc0UsWUFBWSxFQUFFeEYsT0FBTyxFQUFFeUYsYUFBYTtRQUMvQyxnQ0FBZ0MsR0FDaEMsTUFBTUwsYUFBYSxFQUFFO1FBRXJCLE1BQU1NLFVBQVVELGlCQUFpQixJQUFJLENBQUMsQ0FBQy9GLDJCQUEyQjtRQUVsRSxLQUFLLE1BQU1xQixtQkFBbUIyRSxRQUFTO1lBQ3JDLE1BQU0sQ0FBQ0MsZUFBZUMsZUFBZSxHQUFHN0U7WUFDeEMsSUFBSSxJQUFJLENBQUMsQ0FBQzhFLHdCQUF3QixDQUFDTCxjQUFjRyxlQUFlQyxnQkFBZ0I1RixVQUFVO2dCQUN4Rm9GLFdBQVdwRSxJQUFJLENBQUNEO1lBQ2xCO1FBQ0Y7UUFFQSxPQUFPcUU7SUFDVDtJQUVBOzs7Ozs7O0dBT0MsR0FDRCxDQUFDUyx3QkFBd0IsQ0FBRUwsWUFBWSxFQUFFekYsT0FBTyxFQUFFcUIsV0FBVyxJQUFJLEVBQUVwQixPQUFPO1FBQ3hFLHFFQUFxRTtRQUNyRSxpQkFBaUI7UUFDakIsSUFBSTtRQUVKLE1BQU04RixXQUFXLElBQUlDLElBQUlQLGFBQWF2RCxHQUFHO1FBRXpDLE1BQU0rRCxZQUFZLElBQUlELElBQUloRyxRQUFRa0MsR0FBRztRQUVyQyxJQUFJakMsU0FBU2lHLGNBQWM7WUFDekJELFVBQVVFLE1BQU0sR0FBRztZQUVuQkosU0FBU0ksTUFBTSxHQUFHO1FBQ3BCO1FBRUEsSUFBSSxDQUFDN0gsVUFBVXlILFVBQVVFLFdBQVcsT0FBTztZQUN6QyxPQUFPO1FBQ1Q7UUFFQSxJQUNFNUUsWUFBWSxRQUNacEIsU0FBU21HLGNBQ1QsQ0FBQy9FLFNBQVNJLFdBQVcsQ0FBQ3NCLFFBQVEsQ0FBQyxTQUMvQjtZQUNBLE9BQU87UUFDVDtRQUVBLE1BQU14RSxjQUFjQyxlQUFlNkMsU0FBU0ksV0FBVyxDQUFDdUIsR0FBRyxDQUFDO1FBRTVELEtBQUssTUFBTUMsY0FBYzFFLFlBQWE7WUFDcEMsSUFBSTBFLGVBQWUsS0FBSztnQkFDdEIsT0FBTztZQUNUO1lBRUEsTUFBTW9ELGVBQWVyRyxRQUFReUIsV0FBVyxDQUFDdUIsR0FBRyxDQUFDQztZQUM3QyxNQUFNcUQsYUFBYWIsYUFBYWhFLFdBQVcsQ0FBQ3VCLEdBQUcsQ0FBQ0M7WUFFaEQsMERBQTBEO1lBQzFELGlEQUFpRDtZQUNqRCxJQUFJb0QsaUJBQWlCQyxZQUFZO2dCQUMvQixPQUFPO1lBQ1Q7UUFDRjtRQUVBLE9BQU87SUFDVDtBQUNGO0FBRUE1RSxPQUFPNkUsZ0JBQWdCLENBQUM3RyxNQUFNOEcsU0FBUyxFQUFFO0lBQ3ZDLENBQUNDLE9BQU9DLFdBQVcsQ0FBQyxFQUFFO1FBQ3BCQyxPQUFPO1FBQ1BDLGNBQWM7SUFDaEI7SUFDQTdHLE9BQU90QjtJQUNQZ0MsVUFBVWhDO0lBQ1ZtRCxLQUFLbkQ7SUFDTHNELFFBQVF0RDtJQUNSMEYsS0FBSzFGO0lBQ0xxRyxRQUFRckc7SUFDUnNHLE1BQU10RztBQUNSO0FBRUEsTUFBTW9JLDZCQUE2QjtJQUNqQztRQUNFQyxLQUFLO1FBQ0xDLFdBQVduSSxPQUFPeUIsVUFBVSxDQUFDMkcsT0FBTztRQUNwQ0MsY0FBYztJQUNoQjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV25JLE9BQU95QixVQUFVLENBQUMyRyxPQUFPO1FBQ3BDQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXbkksT0FBT3lCLFVBQVUsQ0FBQzJHLE9BQU87UUFDcENDLGNBQWM7SUFDaEI7Q0FDRDtBQUVEckksT0FBT3lCLFVBQVUsQ0FBQ0UsaUJBQWlCLEdBQUczQixPQUFPc0ksbUJBQW1CLENBQUNMO0FBRWpFakksT0FBT3lCLFVBQVUsQ0FBQzhHLHNCQUFzQixHQUFHdkksT0FBT3NJLG1CQUFtQixDQUFDO09BQ2pFTDtJQUNIO1FBQ0VDLEtBQUs7UUFDTEMsV0FBV25JLE9BQU95QixVQUFVLENBQUMrRyxTQUFTO0lBQ3hDO0NBQ0Q7QUFFRHhJLE9BQU95QixVQUFVLENBQUN4QixRQUFRLEdBQUdELE9BQU95SSxrQkFBa0IsQ0FBQ3hJO0FBRXZERCxPQUFPeUIsVUFBVSxDQUFDLHdCQUF3QixHQUFHekIsT0FBTzBJLGlCQUFpQixDQUNuRTFJLE9BQU95QixVQUFVLENBQUNDLFdBQVc7QUFHL0JpSCxPQUFPQyxPQUFPLEdBQUc7SUFDZjlIO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NhY2hlL2NhY2hlLmpzPzNlNTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgdXJsRXF1YWxzLCBmaWVsZFZhbHVlczogZ2V0RmllbGRWYWx1ZXMgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHksIGlzRGlzdHVyYmVkIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBrSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsgUmVzcG9uc2UsIGNsb25lUmVzcG9uc2UgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3Jlc3BvbnNlJylcbmNvbnN0IHsgUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVxdWVzdCcpXG5jb25zdCB7IGtTdGF0ZSwga0hlYWRlcnMsIGtHdWFyZCwga1JlYWxtIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9zeW1ib2xzJylcbmNvbnN0IHsgZmV0Y2hpbmcgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2luZGV4JylcbmNvbnN0IHsgdXJsSXNIdHRwSHR0cHNTY2hlbWUsIGNyZWF0ZURlZmVycmVkUHJvbWlzZSwgcmVhZEFsbEJ5dGVzIH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4uL2dsb2JhbCcpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLWNhY2hlLWJhdGNoLW9wZXJhdGlvblxuICogQHR5cGVkZWYge09iamVjdH0gQ2FjaGVCYXRjaE9wZXJhdGlvblxuICogQHByb3BlcnR5IHsnZGVsZXRlJyB8ICdwdXQnfSB0eXBlXG4gKiBAcHJvcGVydHkge2FueX0gcmVxdWVzdFxuICogQHByb3BlcnR5IHthbnl9IHJlc3BvbnNlXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUnKS5DYWNoZVF1ZXJ5T3B0aW9uc30gb3B0aW9uc1xuICovXG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLXJlcXVlc3QtcmVzcG9uc2UtbGlzdFxuICogQHR5cGVkZWYge1thbnksIGFueV1bXX0gcmVxdWVzdFJlc3BvbnNlTGlzdFxuICovXG5cbmNsYXNzIENhY2hlIHtcbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1yZWxldmFudC1yZXF1ZXN0LXJlc3BvbnNlLWxpc3RcbiAgICogQHR5cGUge3JlcXVlc3RSZXNwb25zZUxpc3R9XG4gICAqL1xuICAjcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gIT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHdlYmlkbC5pbGxlZ2FsQ29uc3RydWN0b3IoKVxuICAgIH1cblxuICAgIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCA9IGFyZ3VtZW50c1sxXVxuICB9XG5cbiAgYXN5bmMgbWF0Y2ggKHJlcXVlc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdDYWNoZS5tYXRjaCcgfSlcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zKVxuXG4gICAgY29uc3QgcCA9IGF3YWl0IHRoaXMubWF0Y2hBbGwocmVxdWVzdCwgb3B0aW9ucylcblxuICAgIGlmIChwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmV0dXJuIHBbMF1cbiAgfVxuXG4gIGFzeW5jIG1hdGNoQWxsIChyZXF1ZXN0ID0gdW5kZWZpbmVkLCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gMS5cbiAgICBsZXQgciA9IG51bGxcblxuICAgIC8vIDIuXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICAgIC8vIDIuMS4xXG4gICAgICAgIHIgPSByZXF1ZXN0W2tTdGF0ZV1cblxuICAgICAgICAvLyAyLjEuMlxuICAgICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnICYmICFvcHRpb25zLmlnbm9yZU1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyAyLjIuMVxuICAgICAgICByID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuXG4gICAgLy8gNS4xXG4gICAgY29uc3QgcmVzcG9uc2VzID0gW11cblxuICAgIC8vIDUuMlxuICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDUuMi4xXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QpIHtcbiAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVxdWVzdFJlc3BvbnNlWzFdKVxuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIDUuM1xuICAgICAgLy8gNS4zLjFcbiAgICAgIGNvbnN0IHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKHIsIG9wdGlvbnMpXG5cbiAgICAgIC8vIDUuMy4yXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiByZXF1ZXN0UmVzcG9uc2VzKSB7XG4gICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlcXVlc3RSZXNwb25zZVsxXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LjRcbiAgICAvLyBXZSBkb24ndCBpbXBsZW1lbnQgQ09ScyBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvb3Agb3ZlciB0aGUgcmVzcG9uc2VzLCB5YXkhXG5cbiAgICAvLyA1LjUuMVxuICAgIGNvbnN0IHJlc3BvbnNlTGlzdCA9IFtdXG5cbiAgICAvLyA1LjUuMlxuICAgIGZvciAoY29uc3QgcmVzcG9uc2Ugb2YgcmVzcG9uc2VzKSB7XG4gICAgICAvLyA1LjUuMi4xXG4gICAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZShyZXNwb25zZS5ib2R5Py5zb3VyY2UgPz8gbnVsbClcbiAgICAgIGNvbnN0IGJvZHkgPSByZXNwb25zZU9iamVjdFtrU3RhdGVdLmJvZHlcbiAgICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0gPSByZXNwb25zZVxuICAgICAgcmVzcG9uc2VPYmplY3Rba1N0YXRlXS5ib2R5ID0gYm9keVxuICAgICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSByZXNwb25zZS5oZWFkZXJzTGlzdFxuICAgICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSAnaW1tdXRhYmxlJ1xuXG4gICAgICByZXNwb25zZUxpc3QucHVzaChyZXNwb25zZU9iamVjdClcbiAgICB9XG5cbiAgICAvLyA2LlxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3BvbnNlTGlzdClcbiAgfVxuXG4gIGFzeW5jIGFkZCAocmVxdWVzdCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdDYWNoZS5hZGQnIH0pXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcblxuICAgIC8vIDEuXG4gICAgY29uc3QgcmVxdWVzdHMgPSBbcmVxdWVzdF1cblxuICAgIC8vIDIuXG4gICAgY29uc3QgcmVzcG9uc2VBcnJheVByb21pc2UgPSB0aGlzLmFkZEFsbChyZXF1ZXN0cylcblxuICAgIC8vIDMuXG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlQXJyYXlQcm9taXNlXG4gIH1cblxuICBhc3luYyBhZGRBbGwgKHJlcXVlc3RzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0NhY2hlLmFkZEFsbCcgfSlcblxuICAgIHJlcXVlc3RzID0gd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPFJlcXVlc3RJbmZvPiddKHJlcXVlc3RzKVxuXG4gICAgLy8gMS5cbiAgICBjb25zdCByZXNwb25zZVByb21pc2VzID0gW11cblxuICAgIC8vIDIuXG4gICAgY29uc3QgcmVxdWVzdExpc3QgPSBbXVxuXG4gICAgLy8gMy5cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMy4xXG4gICAgICBjb25zdCByID0gcmVxdWVzdFtrU3RhdGVdXG5cbiAgICAgIC8vIDMuMlxuICAgICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShyLnVybCkgfHwgci5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnLFxuICAgICAgICAgIG1lc3NhZ2U6ICdFeHBlY3RlZCBodHRwL3Mgc2NoZW1lIHdoZW4gbWV0aG9kIGlzIG5vdCBHRVQuJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuXG4gICAgLyoqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiBmZXRjaGluZz5bXX0gKi9cbiAgICBjb25zdCBmZXRjaENvbnRyb2xsZXJzID0gW11cblxuICAgIC8vIDUuXG4gICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICAvLyA1LjFcbiAgICAgIGNvbnN0IHIgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG5cbiAgICAgIC8vIDUuMlxuICAgICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShyLnVybCkpIHtcbiAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLmFkZEFsbCcsXG4gICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGh0dHAvcyBzY2hlbWUuJ1xuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyA1LjRcbiAgICAgIHIuaW5pdGlhdG9yID0gJ2ZldGNoJ1xuICAgICAgci5kZXN0aW5hdGlvbiA9ICdzdWJyZXNvdXJjZSdcblxuICAgICAgLy8gNS41XG4gICAgICByZXF1ZXN0TGlzdC5wdXNoKHIpXG5cbiAgICAgIC8vIDUuNlxuICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgICAgLy8gNS43XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLnB1c2goZmV0Y2hpbmcoe1xuICAgICAgICByZXF1ZXN0OiByLFxuICAgICAgICBkaXNwYXRjaGVyOiBnZXRHbG9iYWxEaXNwYXRjaGVyKCksXG4gICAgICAgIHByb2Nlc3NSZXNwb25zZSAocmVzcG9uc2UpIHtcbiAgICAgICAgICAvLyAxLlxuICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2IHx8IHJlc3BvbnNlLnN0YXR1cyA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXMgPiAyOTkpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3Qod2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnUmVjZWl2ZWQgYW4gaW52YWxpZCBzdGF0dXMgY29kZSBvciB0aGUgcmVxdWVzdCBmYWlsZWQuJ1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5oZWFkZXJzTGlzdC5jb250YWlucygndmFyeScpKSB7IC8vIDIuXG4gICAgICAgICAgICAvLyAyLjFcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRWYWx1ZXMocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCd2YXJ5JykpXG5cbiAgICAgICAgICAgIC8vIDIuMlxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZFZhbHVlIG9mIGZpZWxkVmFsdWVzKSB7XG4gICAgICAgICAgICAgIC8vIDIuMi4xXG4gICAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLmFkZEFsbCcsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW52YWxpZCB2YXJ5IGZpZWxkIHZhbHVlJ1xuICAgICAgICAgICAgICAgIH0pKVxuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIGZldGNoQ29udHJvbGxlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgLy8gMS5cbiAgICAgICAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdhYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDIuXG4gICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpXG4gICAgICAgIH1cbiAgICAgIH0pKVxuXG4gICAgICAvLyA1LjhcbiAgICAgIHJlc3BvbnNlUHJvbWlzZXMucHVzaChyZXNwb25zZVByb21pc2UucHJvbWlzZSlcbiAgICB9XG5cbiAgICAvLyA2LlxuICAgIGNvbnN0IHAgPSBQcm9taXNlLmFsbChyZXNwb25zZVByb21pc2VzKVxuXG4gICAgLy8gNy5cbiAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBwXG5cbiAgICAvLyA3LjFcbiAgICBjb25zdCBvcGVyYXRpb25zID0gW11cblxuICAgIC8vIDcuMlxuICAgIGxldCBpbmRleCA9IDBcblxuICAgIC8vIDcuM1xuICAgIGZvciAoY29uc3QgcmVzcG9uc2Ugb2YgcmVzcG9uc2VzKSB7XG4gICAgICAvLyA3LjMuMVxuICAgICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9ufSAqL1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgICB0eXBlOiAncHV0JywgLy8gNy4zLjJcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdExpc3RbaW5kZXhdLCAvLyA3LjMuM1xuICAgICAgICByZXNwb25zZSAvLyA3LjMuNFxuICAgICAgfVxuXG4gICAgICBvcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKSAvLyA3LjMuNVxuXG4gICAgICBpbmRleCsrIC8vIDcuMy42XG4gICAgfVxuXG4gICAgLy8gNy41XG4gICAgY29uc3QgY2FjaGVKb2JQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDcuNi4xXG4gICAgbGV0IGVycm9yRGF0YSA9IG51bGxcblxuICAgIC8vIDcuNi4yXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuI2JhdGNoQ2FjaGVPcGVyYXRpb25zKG9wZXJhdGlvbnMpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JEYXRhID0gZVxuICAgIH1cblxuICAgIC8vIDcuNi4zXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgLy8gNy42LjMuMVxuICAgICAgaWYgKGVycm9yRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyA3LjYuMy4yXG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZWplY3QoZXJyb3JEYXRhKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyA3LjdcbiAgICByZXR1cm4gY2FjaGVKb2JQcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIGFzeW5jIHB1dCAocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnQ2FjaGUucHV0JyB9KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG4gICAgcmVzcG9uc2UgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZShyZXNwb25zZSlcblxuICAgIC8vIDEuXG4gICAgbGV0IGlubmVyUmVxdWVzdCA9IG51bGxcblxuICAgIC8vIDIuXG4gICAgaWYgKHJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpbm5lclJlcXVlc3QgPSByZXF1ZXN0W2tTdGF0ZV1cbiAgICB9IGVsc2UgeyAvLyAzLlxuICAgICAgaW5uZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuICAgIH1cblxuICAgIC8vIDQuXG4gICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShpbm5lclJlcXVlc3QudXJsKSB8fCBpbm5lclJlcXVlc3QubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdDYWNoZS5wdXQnLFxuICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgYW4gaHR0cC9zIHNjaGVtZSB3aGVuIG1ldGhvZCBpcyBub3QgR0VUJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA1LlxuICAgIGNvbnN0IGlubmVyUmVzcG9uc2UgPSByZXNwb25zZVtrU3RhdGVdXG5cbiAgICAvLyA2LlxuICAgIGlmIChpbm5lclJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0NhY2hlLnB1dCcsXG4gICAgICAgIG1lc3NhZ2U6ICdHb3QgMjA2IHN0YXR1cydcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gNy5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5oZWFkZXJzTGlzdC5jb250YWlucygndmFyeScpKSB7XG4gICAgICAvLyA3LjEuXG4gICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVzKGlubmVyUmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCd2YXJ5JykpXG5cbiAgICAgIC8vIDcuMi5cbiAgICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZSBvZiBmaWVsZFZhbHVlcykge1xuICAgICAgICAvLyA3LjIuMVxuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJyonKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUucHV0JyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdHb3QgKiB2YXJ5IGZpZWxkIHZhbHVlJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA4LlxuICAgIGlmIChpbm5lclJlc3BvbnNlLmJvZHkgJiYgKGlzRGlzdHVyYmVkKGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW0pIHx8IGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW0ubG9ja2VkKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdDYWNoZS5wdXQnLFxuICAgICAgICBtZXNzYWdlOiAnUmVzcG9uc2UgYm9keSBpcyBsb2NrZWQgb3IgZGlzdHVyYmVkJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA5LlxuICAgIGNvbnN0IGNsb25lZFJlc3BvbnNlID0gY2xvbmVSZXNwb25zZShpbm5lclJlc3BvbnNlKVxuXG4gICAgLy8gMTAuXG4gICAgY29uc3QgYm9keVJlYWRQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDExLlxuICAgIGlmIChpbm5lclJlc3BvbnNlLmJvZHkgIT0gbnVsbCkge1xuICAgICAgLy8gMTEuMVxuICAgICAgY29uc3Qgc3RyZWFtID0gaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbVxuXG4gICAgICAvLyAxMS4yXG4gICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKClcblxuICAgICAgLy8gMTEuM1xuICAgICAgcmVhZEFsbEJ5dGVzKHJlYWRlcikudGhlbihib2R5UmVhZFByb21pc2UucmVzb2x2ZSwgYm9keVJlYWRQcm9taXNlLnJlamVjdClcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keVJlYWRQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgIH1cblxuICAgIC8vIDEyLlxuICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbltdfSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXVxuXG4gICAgLy8gMTMuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9ufSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIHR5cGU6ICdwdXQnLCAvLyAxNC5cbiAgICAgIHJlcXVlc3Q6IGlubmVyUmVxdWVzdCwgLy8gMTUuXG4gICAgICByZXNwb25zZTogY2xvbmVkUmVzcG9uc2UgLy8gMTYuXG4gICAgfVxuXG4gICAgLy8gMTcuXG4gICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbilcblxuICAgIC8vIDE5LlxuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgYm9keVJlYWRQcm9taXNlLnByb21pc2VcblxuICAgIGlmIChjbG9uZWRSZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICAgIGNsb25lZFJlc3BvbnNlLmJvZHkuc291cmNlID0gYnl0ZXNcbiAgICB9XG5cbiAgICAvLyAxOS4xXG4gICAgY29uc3QgY2FjaGVKb2JQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDE5LjIuMVxuICAgIGxldCBlcnJvckRhdGEgPSBudWxsXG5cbiAgICAvLyAxOS4yLjJcbiAgICB0cnkge1xuICAgICAgdGhpcy4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMob3BlcmF0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvckRhdGEgPSBlXG4gICAgfVxuXG4gICAgLy8gMTkuMi4zXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgLy8gMTkuMi4zLjFcbiAgICAgIGlmIChlcnJvckRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfSBlbHNlIHsgLy8gMTkuMi4zLjJcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlamVjdChlcnJvckRhdGEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBjYWNoZUpvYlByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgYXN5bmMgZGVsZXRlIChyZXF1ZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2FjaGUuZGVsZXRlJyB9KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMpXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UmVxdWVzdH1cbiAgICAgKi9cbiAgICBsZXQgciA9IG51bGxcblxuICAgIGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgciA9IHJlcXVlc3Rba1N0YXRlXVxuXG4gICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnICYmICFvcHRpb25zLmlnbm9yZU1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJylcblxuICAgICAgciA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb25bXX0gKi9cbiAgICBjb25zdCBvcGVyYXRpb25zID0gW11cblxuICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbn0gKi9cbiAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICB0eXBlOiAnZGVsZXRlJyxcbiAgICAgIHJlcXVlc3Q6IHIsXG4gICAgICBvcHRpb25zXG4gICAgfVxuXG4gICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbilcblxuICAgIGNvbnN0IGNhY2hlSm9iUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICBsZXQgZXJyb3JEYXRhID0gbnVsbFxuICAgIGxldCByZXF1ZXN0UmVzcG9uc2VzXG5cbiAgICB0cnkge1xuICAgICAgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI2JhdGNoQ2FjaGVPcGVyYXRpb25zKG9wZXJhdGlvbnMpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JEYXRhID0gZVxuICAgIH1cblxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGlmIChlcnJvckRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlc29sdmUoISFyZXF1ZXN0UmVzcG9uc2VzPy5sZW5ndGgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVqZWN0KGVycm9yRGF0YSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIGNhY2hlSm9iUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZG9tLWNhY2hlLWtleXNcbiAgICogQHBhcmFtIHthbnl9IHJlcXVlc3RcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHJldHVybnMge3JlYWRvbmx5IFJlcXVlc3RbXX1cbiAgICovXG4gIGFzeW5jIGtleXMgKHJlcXVlc3QgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMpXG5cbiAgICAvLyAxLlxuICAgIGxldCByID0gbnVsbFxuXG4gICAgLy8gMi5cbiAgICBpZiAocmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAyLjFcbiAgICAgIGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAvLyAyLjEuMVxuICAgICAgICByID0gcmVxdWVzdFtrU3RhdGVdXG5cbiAgICAgICAgLy8gMi4xLjJcbiAgICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5pZ25vcmVNZXRob2QpIHtcbiAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpIHsgLy8gMi4yXG4gICAgICAgIHIgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC5cbiAgICBjb25zdCBwcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDUuXG4gICAgLy8gNS4xXG4gICAgY29uc3QgcmVxdWVzdHMgPSBbXVxuXG4gICAgLy8gNS4yXG4gICAgaWYgKHJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gNS4yLjFcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCkge1xuICAgICAgICAvLyA1LjIuMS4xXG4gICAgICAgIHJlcXVlc3RzLnB1c2gocmVxdWVzdFJlc3BvbnNlWzBdKVxuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIDUuM1xuICAgICAgLy8gNS4zLjFcbiAgICAgIGNvbnN0IHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKHIsIG9wdGlvbnMpXG5cbiAgICAgIC8vIDUuMy4yXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiByZXF1ZXN0UmVzcG9uc2VzKSB7XG4gICAgICAgIC8vIDUuMy4yLjFcbiAgICAgICAgcmVxdWVzdHMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMF0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS40XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgLy8gNS40LjFcbiAgICAgIGNvbnN0IHJlcXVlc3RMaXN0ID0gW11cblxuICAgICAgLy8gNS40LjJcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgICBjb25zdCByZXF1ZXN0T2JqZWN0ID0gbmV3IFJlcXVlc3QoJ2h0dHBzOi8vYScpXG4gICAgICAgIHJlcXVlc3RPYmplY3Rba1N0YXRlXSA9IHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdE9iamVjdFtrSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IHJlcXVlc3QuaGVhZGVyc0xpc3RcbiAgICAgICAgcmVxdWVzdE9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9ICdpbW11dGFibGUnXG4gICAgICAgIHJlcXVlc3RPYmplY3Rba1JlYWxtXSA9IHJlcXVlc3QuY2xpZW50XG5cbiAgICAgICAgLy8gNS40LjIuMVxuICAgICAgICByZXF1ZXN0TGlzdC5wdXNoKHJlcXVlc3RPYmplY3QpXG4gICAgICB9XG5cbiAgICAgIC8vIDUuNC4zXG4gICAgICBwcm9taXNlLnJlc29sdmUoT2JqZWN0LmZyZWV6ZShyZXF1ZXN0TGlzdCkpXG4gICAgfSlcblxuICAgIHJldHVybiBwcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNiYXRjaC1jYWNoZS1vcGVyYXRpb25zLWFsZ29yaXRobVxuICAgKiBAcGFyYW0ge0NhY2hlQmF0Y2hPcGVyYXRpb25bXX0gb3BlcmF0aW9uc1xuICAgKiBAcmV0dXJucyB7cmVxdWVzdFJlc3BvbnNlTGlzdH1cbiAgICovXG4gICNiYXRjaENhY2hlT3BlcmF0aW9ucyAob3BlcmF0aW9ucykge1xuICAgIC8vIDEuXG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3RcblxuICAgIC8vIDIuXG4gICAgY29uc3QgYmFja3VwQ2FjaGUgPSBbLi4uY2FjaGVdXG5cbiAgICAvLyAzLlxuICAgIGNvbnN0IGFkZGVkSXRlbXMgPSBbXVxuXG4gICAgLy8gNC4xXG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdXG5cbiAgICB0cnkge1xuICAgICAgLy8gNC4yXG4gICAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBvcGVyYXRpb25zKSB7XG4gICAgICAgIC8vIDQuMi4xXG4gICAgICAgIGlmIChvcGVyYXRpb24udHlwZSAhPT0gJ2RlbGV0ZScgJiYgb3BlcmF0aW9uLnR5cGUgIT09ICdwdXQnKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdvcGVyYXRpb24gdHlwZSBkb2VzIG5vdCBtYXRjaCBcImRlbGV0ZVwiIG9yIFwicHV0XCInXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuMi4yXG4gICAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gJ2RlbGV0ZScgJiYgb3BlcmF0aW9uLnJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ2RlbGV0ZSBvcGVyYXRpb24gc2hvdWxkIG5vdCBoYXZlIGFuIGFzc29jaWF0ZWQgcmVzcG9uc2UnXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuMi4zXG4gICAgICAgIGlmICh0aGlzLiNxdWVyeUNhY2hlKG9wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ub3B0aW9ucywgYWRkZWRJdGVtcykubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignPz8/JywgJ0ludmFsaWRTdGF0ZUVycm9yJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuMi40XG4gICAgICAgIGxldCByZXF1ZXN0UmVzcG9uc2VzXG5cbiAgICAgICAgLy8gNC4yLjVcbiAgICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSAnZGVsZXRlJykge1xuICAgICAgICAgIC8vIDQuMi41LjFcbiAgICAgICAgICByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jcXVlcnlDYWNoZShvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLm9wdGlvbnMpXG5cbiAgICAgICAgICAvLyBUT0RPOiB0aGUgc3BlYyBpcyB3cm9uZywgdGhpcyBpcyBuZWVkZWQgdG8gcGFzcyBXUFRzXG4gICAgICAgICAgaWYgKHJlcXVlc3RSZXNwb25zZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNS4yXG4gICAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgcmVxdWVzdFJlc3BvbnNlcykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gY2FjaGUuaW5kZXhPZihyZXF1ZXN0UmVzcG9uc2UpXG4gICAgICAgICAgICBhc3NlcnQoaWR4ICE9PSAtMSlcblxuICAgICAgICAgICAgLy8gNC4yLjUuMi4xXG4gICAgICAgICAgICBjYWNoZS5zcGxpY2UoaWR4LCAxKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24udHlwZSA9PT0gJ3B1dCcpIHsgLy8gNC4yLjZcbiAgICAgICAgICAvLyA0LjIuNi4xXG4gICAgICAgICAgaWYgKG9wZXJhdGlvbi5yZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdwdXQgb3BlcmF0aW9uIHNob3VsZCBoYXZlIGFuIGFzc29jaWF0ZWQgcmVzcG9uc2UnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjJcbiAgICAgICAgICBjb25zdCByID0gb3BlcmF0aW9uLnJlcXVlc3RcblxuICAgICAgICAgIC8vIDQuMi42LjNcbiAgICAgICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHIudXJsKSkge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgaHR0cCBvciBodHRwcyBzY2hlbWUnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjRcbiAgICAgICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdub3QgZ2V0IG1ldGhvZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuNVxuICAgICAgICAgIGlmIChvcGVyYXRpb24ub3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdvcHRpb25zIG11c3Qgbm90IGJlIGRlZmluZWQnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjZcbiAgICAgICAgICByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jcXVlcnlDYWNoZShvcGVyYXRpb24ucmVxdWVzdClcblxuICAgICAgICAgIC8vIDQuMi42LjdcbiAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiByZXF1ZXN0UmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBjYWNoZS5pbmRleE9mKHJlcXVlc3RSZXNwb25zZSlcbiAgICAgICAgICAgIGFzc2VydChpZHggIT09IC0xKVxuXG4gICAgICAgICAgICAvLyA0LjIuNi43LjFcbiAgICAgICAgICAgIGNhY2hlLnNwbGljZShpZHgsIDEpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuOFxuICAgICAgICAgIGNhY2hlLnB1c2goW29wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ucmVzcG9uc2VdKVxuXG4gICAgICAgICAgLy8gNC4yLjYuMTBcbiAgICAgICAgICBhZGRlZEl0ZW1zLnB1c2goW29wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ucmVzcG9uc2VdKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjdcbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKFtvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLnJlc3BvbnNlXSlcbiAgICAgIH1cblxuICAgICAgLy8gNC4zXG4gICAgICByZXR1cm4gcmVzdWx0TGlzdFxuICAgIH0gY2F0Y2ggKGUpIHsgLy8gNS5cbiAgICAgIC8vIDUuMVxuICAgICAgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0Lmxlbmd0aCA9IDBcblxuICAgICAgLy8gNS4yXG4gICAgICB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QgPSBiYWNrdXBDYWNoZVxuXG4gICAgICAvLyA1LjNcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jcXVlcnktY2FjaGVcbiAgICogQHBhcmFtIHthbnl9IHJlcXVlc3RRdWVyeVxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUnKS5DYWNoZVF1ZXJ5T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3JlcXVlc3RSZXNwb25zZUxpc3R9IHRhcmdldFN0b3JhZ2VcbiAgICogQHJldHVybnMge3JlcXVlc3RSZXNwb25zZUxpc3R9XG4gICAqL1xuICAjcXVlcnlDYWNoZSAocmVxdWVzdFF1ZXJ5LCBvcHRpb25zLCB0YXJnZXRTdG9yYWdlKSB7XG4gICAgLyoqIEB0eXBlIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fSAqL1xuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXVxuXG4gICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldFN0b3JhZ2UgPz8gdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0XG5cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiBzdG9yYWdlKSB7XG4gICAgICBjb25zdCBbY2FjaGVkUmVxdWVzdCwgY2FjaGVkUmVzcG9uc2VdID0gcmVxdWVzdFJlc3BvbnNlXG4gICAgICBpZiAodGhpcy4jcmVxdWVzdE1hdGNoZXNDYWNoZWRJdGVtKHJlcXVlc3RRdWVyeSwgY2FjaGVkUmVxdWVzdCwgY2FjaGVkUmVzcG9uc2UsIG9wdGlvbnMpKSB7XG4gICAgICAgIHJlc3VsdExpc3QucHVzaChyZXF1ZXN0UmVzcG9uc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdExpc3RcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNyZXF1ZXN0LW1hdGNoZXMtY2FjaGVkLWl0ZW0tYWxnb3JpdGhtXG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0UXVlcnlcbiAgICogQHBhcmFtIHthbnl9IHJlcXVlc3RcbiAgICogQHBhcmFtIHthbnkgfCBudWxsfSByZXNwb25zZVxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUnKS5DYWNoZVF1ZXJ5T3B0aW9ucyB8IHVuZGVmaW5lZH0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gICNyZXF1ZXN0TWF0Y2hlc0NhY2hlZEl0ZW0gKHJlcXVlc3RRdWVyeSwgcmVxdWVzdCwgcmVzcG9uc2UgPSBudWxsLCBvcHRpb25zKSB7XG4gICAgLy8gaWYgKG9wdGlvbnM/Lmlnbm9yZU1ldGhvZCA9PT0gZmFsc2UgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgLy8gICByZXR1cm4gZmFsc2VcbiAgICAvLyB9XG5cbiAgICBjb25zdCBxdWVyeVVSTCA9IG5ldyBVUkwocmVxdWVzdFF1ZXJ5LnVybClcblxuICAgIGNvbnN0IGNhY2hlZFVSTCA9IG5ldyBVUkwocmVxdWVzdC51cmwpXG5cbiAgICBpZiAob3B0aW9ucz8uaWdub3JlU2VhcmNoKSB7XG4gICAgICBjYWNoZWRVUkwuc2VhcmNoID0gJydcblxuICAgICAgcXVlcnlVUkwuc2VhcmNoID0gJydcbiAgICB9XG5cbiAgICBpZiAoIXVybEVxdWFscyhxdWVyeVVSTCwgY2FjaGVkVVJMLCB0cnVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcmVzcG9uc2UgPT0gbnVsbCB8fFxuICAgICAgb3B0aW9ucz8uaWdub3JlVmFyeSB8fFxuICAgICAgIXJlc3BvbnNlLmhlYWRlcnNMaXN0LmNvbnRhaW5zKCd2YXJ5JylcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZFZhbHVlcyhyZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3ZhcnknKSlcblxuICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZSBvZiBmaWVsZFZhbHVlcykge1xuICAgICAgaWYgKGZpZWxkVmFsdWUgPT09ICcqJykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVxdWVzdFZhbHVlID0gcmVxdWVzdC5oZWFkZXJzTGlzdC5nZXQoZmllbGRWYWx1ZSlcbiAgICAgIGNvbnN0IHF1ZXJ5VmFsdWUgPSByZXF1ZXN0UXVlcnkuaGVhZGVyc0xpc3QuZ2V0KGZpZWxkVmFsdWUpXG5cbiAgICAgIC8vIElmIG9uZSBoYXMgdGhlIGhlYWRlciBhbmQgdGhlIG90aGVyIGRvZXNuJ3QsIG9yIG9uZSBoYXNcbiAgICAgIC8vIGEgZGlmZmVyZW50IHZhbHVlIHRoYW4gdGhlIG90aGVyLCByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChyZXF1ZXN0VmFsdWUgIT09IHF1ZXJ5VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDYWNoZS5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0NhY2hlJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgbWF0Y2g6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG1hdGNoQWxsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhZGQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGFkZEFsbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcHV0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGtleXM6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbmNvbnN0IGNhY2hlUXVlcnlPcHRpb25Db252ZXJ0ZXJzID0gW1xuICB7XG4gICAga2V5OiAnaWdub3JlU2VhcmNoJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnaWdub3JlTWV0aG9kJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnaWdub3JlVmFyeScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfVxuXVxuXG53ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKGNhY2hlUXVlcnlPcHRpb25Db252ZXJ0ZXJzKVxuXG53ZWJpZGwuY29udmVydGVycy5NdWx0aUNhY2hlUXVlcnlPcHRpb25zID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICAuLi5jYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycyxcbiAge1xuICAgIGtleTogJ2NhY2hlTmFtZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2UgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFJlc3BvbnNlKVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8UmVxdWVzdEluZm8+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvXG4pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDYWNoZVxufVxuIl0sIm5hbWVzIjpbImtDb25zdHJ1Y3QiLCJyZXF1aXJlIiwidXJsRXF1YWxzIiwiZmllbGRWYWx1ZXMiLCJnZXRGaWVsZFZhbHVlcyIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJpc0Rpc3R1cmJlZCIsImtIZWFkZXJzTGlzdCIsIndlYmlkbCIsIlJlc3BvbnNlIiwiY2xvbmVSZXNwb25zZSIsIlJlcXVlc3QiLCJrU3RhdGUiLCJrSGVhZGVycyIsImtHdWFyZCIsImtSZWFsbSIsImZldGNoaW5nIiwidXJsSXNIdHRwSHR0cHNTY2hlbWUiLCJjcmVhdGVEZWZlcnJlZFByb21pc2UiLCJyZWFkQWxsQnl0ZXMiLCJhc3NlcnQiLCJnZXRHbG9iYWxEaXNwYXRjaGVyIiwiQ2FjaGUiLCJyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsImlsbGVnYWxDb25zdHJ1Y3RvciIsIm1hdGNoIiwicmVxdWVzdCIsIm9wdGlvbnMiLCJicmFuZENoZWNrIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImhlYWRlciIsImNvbnZlcnRlcnMiLCJSZXF1ZXN0SW5mbyIsIkNhY2hlUXVlcnlPcHRpb25zIiwicCIsIm1hdGNoQWxsIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiciIsIm1ldGhvZCIsImlnbm9yZU1ldGhvZCIsInJlc3BvbnNlcyIsInJlcXVlc3RSZXNwb25zZSIsInB1c2giLCJyZXF1ZXN0UmVzcG9uc2VzIiwicXVlcnlDYWNoZSIsInJlc3BvbnNlTGlzdCIsInJlc3BvbnNlIiwicmVzcG9uc2VPYmplY3QiLCJib2R5Iiwic291cmNlIiwiaGVhZGVyc0xpc3QiLCJPYmplY3QiLCJmcmVlemUiLCJhZGQiLCJyZXF1ZXN0cyIsInJlc3BvbnNlQXJyYXlQcm9taXNlIiwiYWRkQWxsIiwicmVzcG9uc2VQcm9taXNlcyIsInJlcXVlc3RMaXN0IiwidXJsIiwiZXJyb3JzIiwiZXhjZXB0aW9uIiwibWVzc2FnZSIsImZldGNoQ29udHJvbGxlcnMiLCJpbml0aWF0b3IiLCJkZXN0aW5hdGlvbiIsInJlc3BvbnNlUHJvbWlzZSIsImRpc3BhdGNoZXIiLCJwcm9jZXNzUmVzcG9uc2UiLCJ0eXBlIiwic3RhdHVzIiwicmVqZWN0IiwiY29udGFpbnMiLCJnZXQiLCJmaWVsZFZhbHVlIiwiY29udHJvbGxlciIsImFib3J0IiwicHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IiwiYWJvcnRlZCIsIkRPTUV4Y2VwdGlvbiIsInJlc29sdmUiLCJwcm9taXNlIiwiUHJvbWlzZSIsImFsbCIsIm9wZXJhdGlvbnMiLCJpbmRleCIsIm9wZXJhdGlvbiIsImNhY2hlSm9iUHJvbWlzZSIsImVycm9yRGF0YSIsImJhdGNoQ2FjaGVPcGVyYXRpb25zIiwiZSIsInF1ZXVlTWljcm90YXNrIiwicHV0IiwiaW5uZXJSZXF1ZXN0IiwiaW5uZXJSZXNwb25zZSIsInN0cmVhbSIsImxvY2tlZCIsImNsb25lZFJlc3BvbnNlIiwiYm9keVJlYWRQcm9taXNlIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwidGhlbiIsImJ5dGVzIiwiZGVsZXRlIiwia2V5cyIsInJlcXVlc3RPYmplY3QiLCJjbGllbnQiLCJjYWNoZSIsImJhY2t1cENhY2hlIiwiYWRkZWRJdGVtcyIsInJlc3VsdExpc3QiLCJpZHgiLCJpbmRleE9mIiwic3BsaWNlIiwicmVxdWVzdFF1ZXJ5IiwidGFyZ2V0U3RvcmFnZSIsInN0b3JhZ2UiLCJjYWNoZWRSZXF1ZXN0IiwiY2FjaGVkUmVzcG9uc2UiLCJyZXF1ZXN0TWF0Y2hlc0NhY2hlZEl0ZW0iLCJxdWVyeVVSTCIsIlVSTCIsImNhY2hlZFVSTCIsImlnbm9yZVNlYXJjaCIsInNlYXJjaCIsImlnbm9yZVZhcnkiLCJyZXF1ZXN0VmFsdWUiLCJxdWVyeVZhbHVlIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJjYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycyIsImtleSIsImNvbnZlcnRlciIsImJvb2xlYW4iLCJkZWZhdWx0VmFsdWUiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwiTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyIsIkRPTVN0cmluZyIsImludGVyZmFjZUNvbnZlcnRlciIsInNlcXVlbmNlQ29udmVydGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/cache/cache.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/cache/cachestorage.js":
/*!***********************************************************!*\
  !*** ../../node_modules/undici/lib/cache/cachestorage.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/cache/symbols.js\");\nconst { Cache } = __webpack_require__(/*! ./cache */ \"(rsc)/../../node_modules/undici/lib/cache/cache.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nclass CacheStorage {\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map\n   * @type {Map<string, import('./cache').requestResponseList}\n   */ #caches;\n    constructor(){\n        this.#caches = new Map();\n        if (arguments[0] !== kConstruct) {\n            webidl.illegalConstructor();\n        }\n    }\n    async match(request, options = {}) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CacheStorage.match\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.MultiCacheQueryOptions(options);\n        // 1.\n        if (options.cacheName != null) {\n            // 1.1.1.1\n            if (this.#caches.has(options.cacheName)) {\n                // 1.1.1.1.1\n                const cacheList = this.#caches.get(options.cacheName);\n                const cache = new Cache(kConstruct, cacheList);\n                return await cache.match(request, options);\n            }\n        } else {\n            // 2.2\n            for (const cacheList of this.#caches.values()){\n                const cache = new Cache(kConstruct, cacheList);\n                // 2.2.1.2\n                const response = await cache.match(request, options);\n                if (response !== undefined) {\n                    return response;\n                }\n            }\n        }\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */ async has(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CacheStorage.has\"\n        });\n        cacheName = webidl.converters.DOMString(cacheName);\n        // 2.1.1\n        // 2.2\n        return this.#caches.has(cacheName);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open\n   * @param {string} cacheName\n   * @returns {Promise<Cache>}\n   */ async open(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CacheStorage.open\"\n        });\n        cacheName = webidl.converters.DOMString(cacheName);\n        // 2.1\n        if (this.#caches.has(cacheName)) {\n            // await caches.open('v1') !== await caches.open('v1')\n            // 2.1.1\n            const cache = this.#caches.get(cacheName);\n            // 2.1.1.1\n            return new Cache(kConstruct, cache);\n        }\n        // 2.2\n        const cache = [];\n        // 2.3\n        this.#caches.set(cacheName, cache);\n        // 2.4\n        return new Cache(kConstruct, cache);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */ async delete(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CacheStorage.delete\"\n        });\n        cacheName = webidl.converters.DOMString(cacheName);\n        return this.#caches.delete(cacheName);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys\n   * @returns {string[]}\n   */ async keys() {\n        webidl.brandCheck(this, CacheStorage);\n        // 2.1\n        const keys = this.#caches.keys();\n        // 2.2\n        return [\n            ...keys\n        ];\n    }\n}\nObject.defineProperties(CacheStorage.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"CacheStorage\",\n        configurable: true\n    },\n    match: kEnumerableProperty,\n    has: kEnumerableProperty,\n    open: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    keys: kEnumerableProperty\n});\nmodule.exports = {\n    CacheStorage\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvY2FjaGVzdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxVQUFVLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDMUIsTUFBTSxFQUFFRSxNQUFNLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFRyxtQkFBbUIsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUV4QyxNQUFNSTtJQUNKOzs7R0FHQyxHQUNELENBQUNDLE1BQU0sQ0FBWTtJQUVuQkMsYUFBZTthQUZmLENBQUNELE1BQU0sR0FBRyxJQUFJRTtRQUdaLElBQUlDLFNBQVMsQ0FBQyxFQUFFLEtBQUtULFlBQVk7WUFDL0JHLE9BQU9PLGtCQUFrQjtRQUMzQjtJQUNGO0lBRUEsTUFBTUMsTUFBT0MsT0FBTyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ2xDVixPQUFPVyxVQUFVLENBQUMsSUFBSSxFQUFFVDtRQUN4QkYsT0FBT1ksbUJBQW1CLENBQUNOLFdBQVcsR0FBRztZQUFFTyxRQUFRO1FBQXFCO1FBRXhFSixVQUFVVCxPQUFPYyxVQUFVLENBQUNDLFdBQVcsQ0FBQ047UUFDeENDLFVBQVVWLE9BQU9jLFVBQVUsQ0FBQ0Usc0JBQXNCLENBQUNOO1FBRW5ELEtBQUs7UUFDTCxJQUFJQSxRQUFRTyxTQUFTLElBQUksTUFBTTtZQUM3QixVQUFVO1lBQ1YsSUFBSSxJQUFJLENBQUMsQ0FBQ2QsTUFBTSxDQUFDZSxHQUFHLENBQUNSLFFBQVFPLFNBQVMsR0FBRztnQkFDdkMsWUFBWTtnQkFDWixNQUFNRSxZQUFZLElBQUksQ0FBQyxDQUFDaEIsTUFBTSxDQUFDaUIsR0FBRyxDQUFDVixRQUFRTyxTQUFTO2dCQUNwRCxNQUFNSSxRQUFRLElBQUl0QixNQUFNRixZQUFZc0I7Z0JBRXBDLE9BQU8sTUFBTUUsTUFBTWIsS0FBSyxDQUFDQyxTQUFTQztZQUNwQztRQUNGLE9BQU87WUFDTCxNQUFNO1lBQ04sS0FBSyxNQUFNUyxhQUFhLElBQUksQ0FBQyxDQUFDaEIsTUFBTSxDQUFDbUIsTUFBTSxHQUFJO2dCQUM3QyxNQUFNRCxRQUFRLElBQUl0QixNQUFNRixZQUFZc0I7Z0JBRXBDLFVBQVU7Z0JBQ1YsTUFBTUksV0FBVyxNQUFNRixNQUFNYixLQUFLLENBQUNDLFNBQVNDO2dCQUU1QyxJQUFJYSxhQUFhQyxXQUFXO29CQUMxQixPQUFPRDtnQkFDVDtZQUNGO1FBQ0Y7SUFDRjtJQUVBOzs7O0dBSUMsR0FDRCxNQUFNTCxJQUFLRCxTQUFTLEVBQUU7UUFDcEJqQixPQUFPVyxVQUFVLENBQUMsSUFBSSxFQUFFVDtRQUN4QkYsT0FBT1ksbUJBQW1CLENBQUNOLFdBQVcsR0FBRztZQUFFTyxRQUFRO1FBQW1CO1FBRXRFSSxZQUFZakIsT0FBT2MsVUFBVSxDQUFDVyxTQUFTLENBQUNSO1FBRXhDLFFBQVE7UUFDUixNQUFNO1FBQ04sT0FBTyxJQUFJLENBQUMsQ0FBQ2QsTUFBTSxDQUFDZSxHQUFHLENBQUNEO0lBQzFCO0lBRUE7Ozs7R0FJQyxHQUNELE1BQU1TLEtBQU1ULFNBQVMsRUFBRTtRQUNyQmpCLE9BQU9XLFVBQVUsQ0FBQyxJQUFJLEVBQUVUO1FBQ3hCRixPQUFPWSxtQkFBbUIsQ0FBQ04sV0FBVyxHQUFHO1lBQUVPLFFBQVE7UUFBb0I7UUFFdkVJLFlBQVlqQixPQUFPYyxVQUFVLENBQUNXLFNBQVMsQ0FBQ1I7UUFFeEMsTUFBTTtRQUNOLElBQUksSUFBSSxDQUFDLENBQUNkLE1BQU0sQ0FBQ2UsR0FBRyxDQUFDRCxZQUFZO1lBQy9CLHNEQUFzRDtZQUV0RCxRQUFRO1lBQ1IsTUFBTUksUUFBUSxJQUFJLENBQUMsQ0FBQ2xCLE1BQU0sQ0FBQ2lCLEdBQUcsQ0FBQ0g7WUFFL0IsVUFBVTtZQUNWLE9BQU8sSUFBSWxCLE1BQU1GLFlBQVl3QjtRQUMvQjtRQUVBLE1BQU07UUFDTixNQUFNQSxRQUFRLEVBQUU7UUFFaEIsTUFBTTtRQUNOLElBQUksQ0FBQyxDQUFDbEIsTUFBTSxDQUFDd0IsR0FBRyxDQUFDVixXQUFXSTtRQUU1QixNQUFNO1FBQ04sT0FBTyxJQUFJdEIsTUFBTUYsWUFBWXdCO0lBQy9CO0lBRUE7Ozs7R0FJQyxHQUNELE1BQU1PLE9BQVFYLFNBQVMsRUFBRTtRQUN2QmpCLE9BQU9XLFVBQVUsQ0FBQyxJQUFJLEVBQUVUO1FBQ3hCRixPQUFPWSxtQkFBbUIsQ0FBQ04sV0FBVyxHQUFHO1lBQUVPLFFBQVE7UUFBc0I7UUFFekVJLFlBQVlqQixPQUFPYyxVQUFVLENBQUNXLFNBQVMsQ0FBQ1I7UUFFeEMsT0FBTyxJQUFJLENBQUMsQ0FBQ2QsTUFBTSxDQUFDeUIsTUFBTSxDQUFDWDtJQUM3QjtJQUVBOzs7R0FHQyxHQUNELE1BQU1ZLE9BQVE7UUFDWjdCLE9BQU9XLFVBQVUsQ0FBQyxJQUFJLEVBQUVUO1FBRXhCLE1BQU07UUFDTixNQUFNMkIsT0FBTyxJQUFJLENBQUMsQ0FBQzFCLE1BQU0sQ0FBQzBCLElBQUk7UUFFOUIsTUFBTTtRQUNOLE9BQU87ZUFBSUE7U0FBSztJQUNsQjtBQUNGO0FBRUFDLE9BQU9DLGdCQUFnQixDQUFDN0IsYUFBYThCLFNBQVMsRUFBRTtJQUM5QyxDQUFDQyxPQUFPQyxXQUFXLENBQUMsRUFBRTtRQUNwQkMsT0FBTztRQUNQQyxjQUFjO0lBQ2hCO0lBQ0E1QixPQUFPUDtJQUNQaUIsS0FBS2pCO0lBQ0x5QixNQUFNekI7SUFDTjJCLFFBQVEzQjtJQUNSNEIsTUFBTTVCO0FBQ1I7QUFFQW9DLE9BQU9DLE9BQU8sR0FBRztJQUNmcEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvY2FjaGVzdG9yYWdlLmpzP2M4NzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgQ2FjaGUgfSA9IHJlcXVpcmUoJy4vY2FjaGUnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmNsYXNzIENhY2hlU3RvcmFnZSB7XG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkZm4tcmVsZXZhbnQtbmFtZS10by1jYWNoZS1tYXBcbiAgICogQHR5cGUge01hcDxzdHJpbmcsIGltcG9ydCgnLi9jYWNoZScpLnJlcXVlc3RSZXNwb25zZUxpc3R9XG4gICAqL1xuICAjY2FjaGVzID0gbmV3IE1hcCgpXG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gIT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHdlYmlkbC5pbGxlZ2FsQ29uc3RydWN0b3IoKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIG1hdGNoIChyZXF1ZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0NhY2hlU3RvcmFnZS5tYXRjaCcgfSlcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5NdWx0aUNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMpXG5cbiAgICAvLyAxLlxuICAgIGlmIChvcHRpb25zLmNhY2hlTmFtZSAhPSBudWxsKSB7XG4gICAgICAvLyAxLjEuMS4xXG4gICAgICBpZiAodGhpcy4jY2FjaGVzLmhhcyhvcHRpb25zLmNhY2hlTmFtZSkpIHtcbiAgICAgICAgLy8gMS4xLjEuMS4xXG4gICAgICAgIGNvbnN0IGNhY2hlTGlzdCA9IHRoaXMuI2NhY2hlcy5nZXQob3B0aW9ucy5jYWNoZU5hbWUpXG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlTGlzdClcblxuICAgICAgICByZXR1cm4gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyAyLlxuICAgICAgLy8gMi4yXG4gICAgICBmb3IgKGNvbnN0IGNhY2hlTGlzdCBvZiB0aGlzLiNjYWNoZXMudmFsdWVzKCkpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBuZXcgQ2FjaGUoa0NvbnN0cnVjdCwgY2FjaGVMaXN0KVxuXG4gICAgICAgIC8vIDIuMi4xLjJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5tYXRjaChyZXF1ZXN0LCBvcHRpb25zKVxuXG4gICAgICAgIGlmIChyZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jY2FjaGUtc3RvcmFnZS1oYXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICovXG4gIGFzeW5jIGhhcyAoY2FjaGVOYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdDYWNoZVN0b3JhZ2UuaGFzJyB9KVxuXG4gICAgY2FjaGVOYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGNhY2hlTmFtZSlcblxuICAgIC8vIDIuMS4xXG4gICAgLy8gMi4yXG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlcy5oYXMoY2FjaGVOYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RvbS1jYWNoZXN0b3JhZ2Utb3BlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlPn1cbiAgICovXG4gIGFzeW5jIG9wZW4gKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2FjaGVTdG9yYWdlLm9wZW4nIH0pXG5cbiAgICBjYWNoZU5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoY2FjaGVOYW1lKVxuXG4gICAgLy8gMi4xXG4gICAgaWYgKHRoaXMuI2NhY2hlcy5oYXMoY2FjaGVOYW1lKSkge1xuICAgICAgLy8gYXdhaXQgY2FjaGVzLm9wZW4oJ3YxJykgIT09IGF3YWl0IGNhY2hlcy5vcGVuKCd2MScpXG5cbiAgICAgIC8vIDIuMS4xXG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMuI2NhY2hlcy5nZXQoY2FjaGVOYW1lKVxuXG4gICAgICAvLyAyLjEuMS4xXG4gICAgICByZXR1cm4gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlKVxuICAgIH1cblxuICAgIC8vIDIuMlxuICAgIGNvbnN0IGNhY2hlID0gW11cblxuICAgIC8vIDIuM1xuICAgIHRoaXMuI2NhY2hlcy5zZXQoY2FjaGVOYW1lLCBjYWNoZSlcblxuICAgIC8vIDIuNFxuICAgIHJldHVybiBuZXcgQ2FjaGUoa0NvbnN0cnVjdCwgY2FjaGUpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jY2FjaGUtc3RvcmFnZS1kZWxldGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICovXG4gIGFzeW5jIGRlbGV0ZSAoY2FjaGVOYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdDYWNoZVN0b3JhZ2UuZGVsZXRlJyB9KVxuXG4gICAgY2FjaGVOYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGNhY2hlTmFtZSlcblxuICAgIHJldHVybiB0aGlzLiNjYWNoZXMuZGVsZXRlKGNhY2hlTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNjYWNoZS1zdG9yYWdlLWtleXNcbiAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgKi9cbiAgYXN5bmMga2V5cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuXG4gICAgLy8gMi4xXG4gICAgY29uc3Qga2V5cyA9IHRoaXMuI2NhY2hlcy5rZXlzKClcblxuICAgIC8vIDIuMlxuICAgIHJldHVybiBbLi4ua2V5c11cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDYWNoZVN0b3JhZ2UucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdDYWNoZVN0b3JhZ2UnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBtYXRjaDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGFzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvcGVuOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGtleXM6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDYWNoZVN0b3JhZ2Vcbn1cbiJdLCJuYW1lcyI6WyJrQ29uc3RydWN0IiwicmVxdWlyZSIsIkNhY2hlIiwid2ViaWRsIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsIkNhY2hlU3RvcmFnZSIsImNhY2hlcyIsImNvbnN0cnVjdG9yIiwiTWFwIiwiYXJndW1lbnRzIiwiaWxsZWdhbENvbnN0cnVjdG9yIiwibWF0Y2giLCJyZXF1ZXN0Iiwib3B0aW9ucyIsImJyYW5kQ2hlY2siLCJhcmd1bWVudExlbmd0aENoZWNrIiwiaGVhZGVyIiwiY29udmVydGVycyIsIlJlcXVlc3RJbmZvIiwiTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyIsImNhY2hlTmFtZSIsImhhcyIsImNhY2hlTGlzdCIsImdldCIsImNhY2hlIiwidmFsdWVzIiwicmVzcG9uc2UiLCJ1bmRlZmluZWQiLCJET01TdHJpbmciLCJvcGVuIiwic2V0IiwiZGVsZXRlIiwia2V5cyIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/cache/cachestorage.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/cache/symbols.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/cache/symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    kConstruct: Symbol(\"constructable\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsWUFBWUMsT0FBTztBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvc3ltYm9scy5qcz8xMzkyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga0NvbnN0cnVjdDogU3ltYm9sKCdjb25zdHJ1Y3RhYmxlJylcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwia0NvbnN0cnVjdCIsIlN5bWJvbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/cache/symbols.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/cache/util.js":
/*!***************************************************!*\
  !*** ../../node_modules/undici/lib/cache/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/dataURL */ \"(rsc)/../../node_modules/undici/lib/fetch/dataURL.js\");\nconst { isValidHeaderName } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/../../node_modules/undici/lib/fetch/util.js\");\n/**\n * @see https://url.spec.whatwg.org/#concept-url-equals\n * @param {URL} A\n * @param {URL} B\n * @param {boolean | undefined} excludeFragment\n * @returns {boolean}\n */ function urlEquals(A, B, excludeFragment = false) {\n    const serializedA = URLSerializer(A, excludeFragment);\n    const serializedB = URLSerializer(B, excludeFragment);\n    return serializedA === serializedB;\n}\n/**\n * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262\n * @param {string} header\n */ function fieldValues(header) {\n    assert(header !== null);\n    const values = [];\n    for (let value of header.split(\",\")){\n        value = value.trim();\n        if (!value.length) {\n            continue;\n        } else if (!isValidHeaderName(value)) {\n            continue;\n        }\n        values.push(value);\n    }\n    return values;\n}\nmodule.exports = {\n    urlEquals,\n    fieldValues\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRUUsaUJBQWlCLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFFdEM7Ozs7OztDQU1DLEdBQ0QsU0FBU0csVUFBV0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLGtCQUFrQixLQUFLO0lBQy9DLE1BQU1DLGNBQWNOLGNBQWNHLEdBQUdFO0lBRXJDLE1BQU1FLGNBQWNQLGNBQWNJLEdBQUdDO0lBRXJDLE9BQU9DLGdCQUFnQkM7QUFDekI7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQyxZQUFhQyxNQUFNO0lBQzFCWCxPQUFPVyxXQUFXO0lBRWxCLE1BQU1DLFNBQVMsRUFBRTtJQUVqQixLQUFLLElBQUlDLFNBQVNGLE9BQU9HLEtBQUssQ0FBQyxLQUFNO1FBQ25DRCxRQUFRQSxNQUFNRSxJQUFJO1FBRWxCLElBQUksQ0FBQ0YsTUFBTUcsTUFBTSxFQUFFO1lBQ2pCO1FBQ0YsT0FBTyxJQUFJLENBQUNiLGtCQUFrQlUsUUFBUTtZQUNwQztRQUNGO1FBRUFELE9BQU9LLElBQUksQ0FBQ0o7SUFDZDtJQUVBLE9BQU9EO0FBQ1Q7QUFFQU0sT0FBT0MsT0FBTyxHQUFHO0lBQ2ZmO0lBQ0FNO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NhY2hlL3V0aWwuanM/OGI3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsgVVJMU2VyaWFsaXplciB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YVVSTCcpXG5jb25zdCB7IGlzVmFsaWRIZWFkZXJOYW1lIH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC11cmwtZXF1YWxzXG4gKiBAcGFyYW0ge1VSTH0gQVxuICogQHBhcmFtIHtVUkx9IEJcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gZXhjbHVkZUZyYWdtZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdXJsRXF1YWxzIChBLCBCLCBleGNsdWRlRnJhZ21lbnQgPSBmYWxzZSkge1xuICBjb25zdCBzZXJpYWxpemVkQSA9IFVSTFNlcmlhbGl6ZXIoQSwgZXhjbHVkZUZyYWdtZW50KVxuXG4gIGNvbnN0IHNlcmlhbGl6ZWRCID0gVVJMU2VyaWFsaXplcihCLCBleGNsdWRlRnJhZ21lbnQpXG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWRBID09PSBzZXJpYWxpemVkQlxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Nocm9taXVtL2Nocm9taXVtL2Jsb2IvNjk0ZDIwZDEzNGNiNTUzZDhkODllNTUwMGI5MTQ4MDEyYjFiYTI5OS9jb250ZW50L2Jyb3dzZXIvY2FjaGVfc3RvcmFnZS9jYWNoZV9zdG9yYWdlX2NhY2hlLmNjI0wyNjAtTDI2MlxuICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclxuICovXG5mdW5jdGlvbiBmaWVsZFZhbHVlcyAoaGVhZGVyKSB7XG4gIGFzc2VydChoZWFkZXIgIT09IG51bGwpXG5cbiAgY29uc3QgdmFsdWVzID0gW11cblxuICBmb3IgKGxldCB2YWx1ZSBvZiBoZWFkZXIuc3BsaXQoJywnKSkge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpXG5cbiAgICBpZiAoIXZhbHVlLmxlbmd0aCkge1xuICAgICAgY29udGludWVcbiAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZSh2YWx1ZSkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFsdWVzLnB1c2godmFsdWUpXG4gIH1cblxuICByZXR1cm4gdmFsdWVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB1cmxFcXVhbHMsXG4gIGZpZWxkVmFsdWVzXG59XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsIlVSTFNlcmlhbGl6ZXIiLCJpc1ZhbGlkSGVhZGVyTmFtZSIsInVybEVxdWFscyIsIkEiLCJCIiwiZXhjbHVkZUZyYWdtZW50Iiwic2VyaWFsaXplZEEiLCJzZXJpYWxpemVkQiIsImZpZWxkVmFsdWVzIiwiaGVhZGVyIiwidmFsdWVzIiwidmFsdWUiLCJzcGxpdCIsInRyaW0iLCJsZW5ndGgiLCJwdXNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/cache/util.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/client.js":
/*!***********************************************!*\
  !*** ../../node_modules/undici/lib/client.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// @ts-check\n\n/* global WebAssembly */ const assert = __webpack_require__(/*! assert */ \"assert\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst { pipeline } = __webpack_require__(/*! stream */ \"stream\");\nconst util = __webpack_require__(/*! ./core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst timers = __webpack_require__(/*! ./timers */ \"(rsc)/../../node_modules/undici/lib/timers.js\");\nconst Request = __webpack_require__(/*! ./core/request */ \"(rsc)/../../node_modules/undici/lib/core/request.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/../../node_modules/undici/lib/dispatcher-base.js\");\nconst { RequestContentLengthMismatchError, ResponseContentLengthMismatchError, InvalidArgumentError, RequestAbortedError, HeadersTimeoutError, HeadersOverflowError, SocketError, InformationalError, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError, ClientDestroyedError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"(rsc)/../../node_modules/undici/lib/core/connect.js\");\nconst { kUrl, kReset, kServerName, kClient, kBusy, kParser, kConnect, kBlocking, kResuming, kRunning, kPending, kSize, kWriting, kQueue, kConnected, kConnecting, kNeedDrain, kNoRef, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kSocket, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections, kMaxRequests, kCounter, kClose, kDestroy, kDispatch, kInterceptors, kLocalAddress, kMaxResponseSize, kHTTPConnVersion, // HTTP2\nkHost, kHTTP2Session, kHTTP2SessionState, kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\n/** @type {import('http2')} */ let http2;\ntry {\n    http2 = __webpack_require__(/*! http2 */ \"http2\");\n} catch  {\n    // @ts-ignore\n    http2 = {\n        constants: {}\n    };\n}\nconst { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;\n// Experimental\nlet h2ExperimentalWarned = false;\nconst FastBuffer = Buffer[Symbol.species];\nconst kClosedResolve = Symbol(\"kClosedResolve\");\nconst channels = {};\ntry {\n    const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\n    channels.sendHeaders = diagnosticsChannel.channel(\"undici:client:sendHeaders\");\n    channels.beforeConnect = diagnosticsChannel.channel(\"undici:client:beforeConnect\");\n    channels.connectError = diagnosticsChannel.channel(\"undici:client:connectError\");\n    channels.connected = diagnosticsChannel.channel(\"undici:client:connected\");\n} catch  {\n    channels.sendHeaders = {\n        hasSubscribers: false\n    };\n    channels.beforeConnect = {\n        hasSubscribers: false\n    };\n    channels.connectError = {\n        hasSubscribers: false\n    };\n    channels.connected = {\n        hasSubscribers: false\n    };\n}\n/**\n * @type {import('../types/client').default}\n */ class Client extends DispatcherBase {\n    /**\n   *\n   * @param {string|URL} url\n   * @param {import('../types/client').Client.Options} options\n   */ constructor(url, { interceptors, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls, strictContentLength, maxCachedSessions, maxRedirections, connect, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, // h2\n    allowH2, maxConcurrentStreams } = {}){\n        super();\n        if (keepAlive !== undefined) {\n            throw new InvalidArgumentError(\"unsupported keepAlive, use pipelining=0 instead\");\n        }\n        if (socketTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported socketTimeout, use headersTimeout & bodyTimeout instead\");\n        }\n        if (requestTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported requestTimeout, use headersTimeout & bodyTimeout instead\");\n        }\n        if (idleTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported idleTimeout, use keepAliveTimeout instead\");\n        }\n        if (maxKeepAliveTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead\");\n        }\n        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n            throw new InvalidArgumentError(\"invalid maxHeaderSize\");\n        }\n        if (socketPath != null && typeof socketPath !== \"string\") {\n            throw new InvalidArgumentError(\"invalid socketPath\");\n        }\n        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n            throw new InvalidArgumentError(\"invalid connectTimeout\");\n        }\n        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n            throw new InvalidArgumentError(\"invalid keepAliveTimeout\");\n        }\n        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n            throw new InvalidArgumentError(\"invalid keepAliveMaxTimeout\");\n        }\n        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n            throw new InvalidArgumentError(\"invalid keepAliveTimeoutThreshold\");\n        }\n        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n            throw new InvalidArgumentError(\"headersTimeout must be a positive integer or zero\");\n        }\n        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n            throw new InvalidArgumentError(\"bodyTimeout must be a positive integer or zero\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n            throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n            throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n            throw new InvalidArgumentError(\"maxRequestsPerClient must be a positive number\");\n        }\n        if (localAddress != null && (typeof localAddress !== \"string\" || net.isIP(localAddress) === 0)) {\n            throw new InvalidArgumentError(\"localAddress must be valid string IP address\");\n        }\n        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n            throw new InvalidArgumentError(\"maxResponseSize must be a positive number\");\n        }\n        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {\n            throw new InvalidArgumentError(\"autoSelectFamilyAttemptTimeout must be a positive number\");\n        }\n        // h2\n        if (allowH2 != null && typeof allowH2 !== \"boolean\") {\n            throw new InvalidArgumentError(\"allowH2 must be a valid boolean value\");\n        }\n        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== \"number\" || maxConcurrentStreams < 1)) {\n            throw new InvalidArgumentError(\"maxConcurrentStreams must be a possitive integer, greater than 0\");\n        }\n        if (typeof connect !== \"function\") {\n            connect = buildConnector({\n                ...tls,\n                maxCachedSessions,\n                allowH2,\n                socketPath,\n                timeout: connectTimeout,\n                ...util.nodeHasAutoSelectFamily && autoSelectFamily ? {\n                    autoSelectFamily,\n                    autoSelectFamilyAttemptTimeout\n                } : undefined,\n                ...connect\n            });\n        }\n        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [\n            createRedirectInterceptor({\n                maxRedirections\n            })\n        ];\n        this[kUrl] = util.parseOrigin(url);\n        this[kConnector] = connect;\n        this[kSocket] = null;\n        this[kPipelining] = pipelining != null ? pipelining : 1;\n        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;\n        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n        this[kServerName] = null;\n        this[kLocalAddress] = localAddress != null ? localAddress : null;\n        this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n        ;\n        this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n        ;\n        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : \"\"}\\r\\n`;\n        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;\n        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;\n        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n        this[kMaxRedirections] = maxRedirections;\n        this[kMaxRequests] = maxRequestsPerClient;\n        this[kClosedResolve] = null;\n        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;\n        this[kHTTPConnVersion] = \"h1\";\n        // HTTP/2\n        this[kHTTP2Session] = null;\n        this[kHTTP2SessionState] = !allowH2 ? null : {\n            // streams: null, // Fixed queue of streams - For future support of `push`\n            openStreams: 0,\n            maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n        };\n        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : \"\"}`;\n        // kQueue is built up of 3 sections separated by\n        // the kRunningIdx and kPendingIdx indices.\n        // |   complete   |   running   |   pending   |\n        //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n        // kRunningIdx points to the first running element.\n        // kPendingIdx points to the first pending element.\n        // This implements a fast queue with an amortized\n        // time of O(1).\n        this[kQueue] = [];\n        this[kRunningIdx] = 0;\n        this[kPendingIdx] = 0;\n    }\n    get pipelining() {\n        return this[kPipelining];\n    }\n    set pipelining(value) {\n        this[kPipelining] = value;\n        resume(this, true);\n    }\n    get [kPending]() {\n        return this[kQueue].length - this[kPendingIdx];\n    }\n    get [kRunning]() {\n        return this[kPendingIdx] - this[kRunningIdx];\n    }\n    get [kSize]() {\n        return this[kQueue].length - this[kRunningIdx];\n    }\n    get [kConnected]() {\n        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;\n    }\n    get [kBusy]() {\n        const socket = this[kSocket];\n        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;\n    }\n    /* istanbul ignore: only used for test */ [kConnect](cb) {\n        connect(this);\n        this.once(\"connect\", cb);\n    }\n    [kDispatch](opts, handler) {\n        const origin = opts.origin || this[kUrl].origin;\n        const request = this[kHTTPConnVersion] === \"h2\" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);\n        this[kQueue].push(request);\n        if (this[kResuming]) {\n        // Do nothing.\n        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n            // Wait a tick in case stream/iterator is ended in the same tick.\n            this[kResuming] = 1;\n            process.nextTick(resume, this);\n        } else {\n            resume(this, true);\n        }\n        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n            this[kNeedDrain] = 2;\n        }\n        return this[kNeedDrain] < 2;\n    }\n    async [kClose]() {\n        // TODO: for H2 we need to gracefully flush the remaining enqueued\n        // request and close each stream.\n        return new Promise((resolve)=>{\n            if (!this[kSize]) {\n                resolve(null);\n            } else {\n                this[kClosedResolve] = resolve;\n            }\n        });\n    }\n    async [kDestroy](err) {\n        return new Promise((resolve)=>{\n            const requests = this[kQueue].splice(this[kPendingIdx]);\n            for(let i = 0; i < requests.length; i++){\n                const request = requests[i];\n                errorRequest(this, request, err);\n            }\n            const callback = ()=>{\n                if (this[kClosedResolve]) {\n                    // TODO (fix): Should we error here with ClientDestroyedError?\n                    this[kClosedResolve]();\n                    this[kClosedResolve] = null;\n                }\n                resolve();\n            };\n            if (this[kHTTP2Session] != null) {\n                util.destroy(this[kHTTP2Session], err);\n                this[kHTTP2Session] = null;\n                this[kHTTP2SessionState] = null;\n            }\n            if (!this[kSocket]) {\n                queueMicrotask(callback);\n            } else {\n                util.destroy(this[kSocket].on(\"close\", callback), err);\n            }\n            resume(this);\n        });\n    }\n}\nfunction onHttp2SessionError(err) {\n    assert(err.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\");\n    this[kSocket][kError] = err;\n    onError(this[kClient], err);\n}\nfunction onHttp2FrameError(type, code, id) {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n    if (id === 0) {\n        this[kSocket][kError] = err;\n        onError(this[kClient], err);\n    }\n}\nfunction onHttp2SessionEnd() {\n    util.destroy(this, new SocketError(\"other side closed\"));\n    util.destroy(this[kSocket], new SocketError(\"other side closed\"));\n}\nfunction onHTTP2GoAway(code) {\n    const client = this[kClient];\n    const err = new InformationalError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`);\n    client[kSocket] = null;\n    client[kHTTP2Session] = null;\n    if (client.destroyed) {\n        assert(this[kPending] === 0);\n        // Fail entire queue.\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            errorRequest(this, request, err);\n        }\n    } else if (client[kRunning] > 0) {\n        // Fail head of pipeline.\n        const request = client[kQueue][client[kRunningIdx]];\n        client[kQueue][client[kRunningIdx]++] = null;\n        errorRequest(client, request, err);\n    }\n    client[kPendingIdx] = client[kRunningIdx];\n    assert(client[kRunning] === 0);\n    client.emit(\"disconnect\", client[kUrl], [\n        client\n    ], err);\n    resume(client);\n}\nconst constants = __webpack_require__(/*! ./llhttp/constants */ \"(rsc)/../../node_modules/undici/lib/llhttp/constants.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ./interceptor/redirectInterceptor */ \"(rsc)/../../node_modules/undici/lib/interceptor/redirectInterceptor.js\");\nconst EMPTY_BUF = Buffer.alloc(0);\nasync function lazyllhttp() {\n    const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__(/*! ./llhttp/llhttp-wasm.js */ \"(rsc)/../../node_modules/undici/lib/llhttp/llhttp-wasm.js\") : undefined;\n    let mod;\n    try {\n        mod = await WebAssembly.compile(Buffer.from(__webpack_require__(/*! ./llhttp/llhttp_simd-wasm.js */ \"(rsc)/../../node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\"), \"base64\"));\n    } catch (e) {\n        /* istanbul ignore next */ // We could check if the error was caused by the simd option not\n        // being enabled, but the occurring of this other error\n        // * https://github.com/emscripten-core/emscripten/issues/11495\n        // got me to remove that check to avoid breaking Node 12.\n        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || __webpack_require__(/*! ./llhttp/llhttp-wasm.js */ \"(rsc)/../../node_modules/undici/lib/llhttp/llhttp-wasm.js\"), \"base64\"));\n    }\n    return await WebAssembly.instantiate(mod, {\n        env: {\n            /* eslint-disable camelcase */ wasm_on_url: (p, at, len)=>{\n                /* istanbul ignore next */ return 0;\n            },\n            wasm_on_status: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_message_begin: (p)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onMessageBegin() || 0;\n            },\n            wasm_on_header_field: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_header_value: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n            },\n            wasm_on_body: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_message_complete: (p)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onMessageComplete() || 0;\n            }\n        }\n    });\n}\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp();\nllhttpPromise.catch();\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\nclass Parser {\n    constructor(client, socket, { exports }){\n        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n        this.llhttp = exports;\n        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n        this.client = client;\n        this.socket = socket;\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.upgrade = false;\n        this.headers = [];\n        this.headersSize = 0;\n        this.headersMaxSize = client[kMaxHeadersSize];\n        this.shouldKeepAlive = false;\n        this.paused = false;\n        this.resume = this.resume.bind(this);\n        this.bytesRead = 0;\n        this.keepAlive = \"\";\n        this.contentLength = \"\";\n        this.connection = \"\";\n        this.maxResponseSize = client[kMaxResponseSize];\n    }\n    setTimeout(value, type) {\n        this.timeoutType = type;\n        if (value !== this.timeoutValue) {\n            timers.clearTimeout(this.timeout);\n            if (value) {\n                this.timeout = timers.setTimeout(onParserTimeout, value, this);\n                // istanbul ignore else: only for jest\n                if (this.timeout.unref) {\n                    this.timeout.unref();\n                }\n            } else {\n                this.timeout = null;\n            }\n            this.timeoutValue = value;\n        } else if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n    }\n    resume() {\n        if (this.socket.destroyed || !this.paused) {\n            return;\n        }\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_resume(this.ptr);\n        assert(this.timeoutType === TIMEOUT_BODY);\n        if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        this.paused = false;\n        this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n        ;\n        this.readMore();\n    }\n    readMore() {\n        while(!this.paused && this.ptr){\n            const chunk = this.socket.read();\n            if (chunk === null) {\n                break;\n            }\n            this.execute(chunk);\n        }\n    }\n    execute(data) {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        assert(!this.paused);\n        const { socket, llhttp } = this;\n        if (data.length > currentBufferSize) {\n            if (currentBufferPtr) {\n                llhttp.free(currentBufferPtr);\n            }\n            currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n            currentBufferPtr = llhttp.malloc(currentBufferSize);\n        }\n        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n        // Call `execute` on the wasm parser.\n        // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n        // and finally the length of bytes to parse.\n        // The return value is an error code or `constants.ERROR.OK`.\n        try {\n            let ret;\n            try {\n                currentBufferRef = data;\n                currentParser = this;\n                ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n            /* eslint-disable-next-line no-useless-catch */ } catch (err) {\n                /* istanbul ignore next: difficult to make a test case for */ throw err;\n            } finally{\n                currentParser = null;\n                currentBufferRef = null;\n            }\n            const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n            if (ret === constants.ERROR.PAUSED_UPGRADE) {\n                this.onUpgrade(data.slice(offset));\n            } else if (ret === constants.ERROR.PAUSED) {\n                this.paused = true;\n                socket.unshift(data.slice(offset));\n            } else if (ret !== constants.ERROR.OK) {\n                const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n                let message = \"\";\n                /* istanbul ignore else: difficult to make a test case for */ if (ptr) {\n                    const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n                    message = \"Response does not match the HTTP/1.1 protocol (\" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + \")\";\n                }\n                throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n            }\n        } catch (err) {\n            util.destroy(socket, err);\n        }\n    }\n    destroy() {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_free(this.ptr);\n        this.ptr = null;\n        timers.clearTimeout(this.timeout);\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.paused = false;\n    }\n    onStatus(buf) {\n        this.statusText = buf.toString();\n    }\n    onMessageBegin() {\n        const { socket, client } = this;\n        /* istanbul ignore next: difficult to make a test case for */ if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        if (!request) {\n            return -1;\n        }\n    }\n    onHeaderField(buf) {\n        const len = this.headers.length;\n        if ((len & 1) === 0) {\n            this.headers.push(buf);\n        } else {\n            this.headers[len - 1] = Buffer.concat([\n                this.headers[len - 1],\n                buf\n            ]);\n        }\n        this.trackHeader(buf.length);\n    }\n    onHeaderValue(buf) {\n        let len = this.headers.length;\n        if ((len & 1) === 1) {\n            this.headers.push(buf);\n            len += 1;\n        } else {\n            this.headers[len - 1] = Buffer.concat([\n                this.headers[len - 1],\n                buf\n            ]);\n        }\n        const key = this.headers[len - 2];\n        if (key.length === 10 && key.toString().toLowerCase() === \"keep-alive\") {\n            this.keepAlive += buf.toString();\n        } else if (key.length === 10 && key.toString().toLowerCase() === \"connection\") {\n            this.connection += buf.toString();\n        } else if (key.length === 14 && key.toString().toLowerCase() === \"content-length\") {\n            this.contentLength += buf.toString();\n        }\n        this.trackHeader(buf.length);\n    }\n    trackHeader(len) {\n        this.headersSize += len;\n        if (this.headersSize >= this.headersMaxSize) {\n            util.destroy(this.socket, new HeadersOverflowError());\n        }\n    }\n    onUpgrade(head) {\n        const { upgrade, client, socket, headers, statusCode } = this;\n        assert(upgrade);\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert(!socket.destroyed);\n        assert(socket === client[kSocket]);\n        assert(!this.paused);\n        assert(request.upgrade || request.method === \"CONNECT\");\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.shouldKeepAlive = null;\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        socket.unshift(head);\n        socket[kParser].destroy();\n        socket[kParser] = null;\n        socket[kClient] = null;\n        socket[kError] = null;\n        socket.removeListener(\"error\", onSocketError).removeListener(\"readable\", onSocketReadable).removeListener(\"end\", onSocketEnd).removeListener(\"close\", onSocketClose);\n        client[kSocket] = null;\n        client[kQueue][client[kRunningIdx]++] = null;\n        client.emit(\"disconnect\", client[kUrl], [\n            client\n        ], new InformationalError(\"upgrade\"));\n        try {\n            request.onUpgrade(statusCode, headers, socket);\n        } catch (err) {\n            util.destroy(socket, err);\n        }\n        resume(client);\n    }\n    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n        const { client, socket, headers, statusText } = this;\n        /* istanbul ignore next: difficult to make a test case for */ if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        /* istanbul ignore next: difficult to make a test case for */ if (!request) {\n            return -1;\n        }\n        assert(!this.upgrade);\n        assert(this.statusCode < 200);\n        if (statusCode === 100) {\n            util.destroy(socket, new SocketError(\"bad response\", util.getSocketInfo(socket)));\n            return -1;\n        }\n        /* this can only happen if server is misbehaving */ if (upgrade && !request.upgrade) {\n            util.destroy(socket, new SocketError(\"bad upgrade\", util.getSocketInfo(socket)));\n            return -1;\n        }\n        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n        this.statusCode = statusCode;\n        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.\n        request.method === \"HEAD\" && !socket[kReset] && this.connection.toLowerCase() === \"keep-alive\";\n        if (this.statusCode >= 200) {\n            const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n            this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n        } else if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        if (request.method === \"CONNECT\") {\n            assert(client[kRunning] === 1);\n            this.upgrade = true;\n            return 2;\n        }\n        if (upgrade) {\n            assert(client[kRunning] === 1);\n            this.upgrade = true;\n            return 2;\n        }\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (this.shouldKeepAlive && client[kPipelining]) {\n            const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n            if (keepAliveTimeout != null) {\n                const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n                if (timeout <= 0) {\n                    socket[kReset] = true;\n                } else {\n                    client[kKeepAliveTimeoutValue] = timeout;\n                }\n            } else {\n                client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n            }\n        } else {\n            // Stop more requests from being dispatched.\n            socket[kReset] = true;\n        }\n        let pause;\n        try {\n            pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n        } catch (err) {\n            util.destroy(socket, err);\n            return -1;\n        }\n        if (request.method === \"HEAD\") {\n            return 1;\n        }\n        if (statusCode < 200) {\n            return 1;\n        }\n        if (socket[kBlocking]) {\n            socket[kBlocking] = false;\n            resume(client);\n        }\n        return pause ? constants.ERROR.PAUSED : 0;\n    }\n    onBody(buf) {\n        const { client, socket, statusCode, maxResponseSize } = this;\n        if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n        if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        assert(statusCode >= 200);\n        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n            util.destroy(socket, new ResponseExceededMaxSizeError());\n            return -1;\n        }\n        this.bytesRead += buf.length;\n        try {\n            if (request.onData(buf) === false) {\n                return constants.ERROR.PAUSED;\n            }\n        } catch (err) {\n            util.destroy(socket, err);\n            return -1;\n        }\n    }\n    onMessageComplete() {\n        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;\n        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n            return -1;\n        }\n        if (upgrade) {\n            return;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert(statusCode >= 100);\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.bytesRead = 0;\n        this.contentLength = \"\";\n        this.keepAlive = \"\";\n        this.connection = \"\";\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (statusCode < 200) {\n            return;\n        }\n        /* istanbul ignore next: should be handled by llhttp? */ if (request.method !== \"HEAD\" && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n            util.destroy(socket, new ResponseContentLengthMismatchError());\n            return -1;\n        }\n        try {\n            request.onComplete(headers);\n        } catch (err) {\n            errorRequest(client, request, err);\n        }\n        client[kQueue][client[kRunningIdx]++] = null;\n        if (socket[kWriting]) {\n            assert.strictEqual(client[kRunning], 0);\n            // Response completed before request.\n            util.destroy(socket, new InformationalError(\"reset\"));\n            return constants.ERROR.PAUSED;\n        } else if (!shouldKeepAlive) {\n            util.destroy(socket, new InformationalError(\"reset\"));\n            return constants.ERROR.PAUSED;\n        } else if (socket[kReset] && client[kRunning] === 0) {\n            // Destroy socket once all requests have completed.\n            // The request at the tail of the pipeline is the one\n            // that requested reset and no further requests should\n            // have been queued since then.\n            util.destroy(socket, new InformationalError(\"reset\"));\n            return constants.ERROR.PAUSED;\n        } else if (client[kPipelining] === 1) {\n            // We must wait a full event loop cycle to reuse this socket to make sure\n            // that non-spec compliant servers are not closing the connection even if they\n            // said they won't.\n            setImmediate(resume, client);\n        } else {\n            resume(client);\n        }\n    }\n}\nfunction onParserTimeout(parser) {\n    const { socket, timeoutType, client } = parser;\n    /* istanbul ignore else */ if (timeoutType === TIMEOUT_HEADERS) {\n        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n            assert(!parser.paused, \"cannot be paused while waiting for headers\");\n            util.destroy(socket, new HeadersTimeoutError());\n        }\n    } else if (timeoutType === TIMEOUT_BODY) {\n        if (!parser.paused) {\n            util.destroy(socket, new BodyTimeoutError());\n        }\n    } else if (timeoutType === TIMEOUT_IDLE) {\n        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n        util.destroy(socket, new InformationalError(\"socket idle timeout\"));\n    }\n}\nfunction onSocketReadable() {\n    const { [kParser]: parser } = this;\n    if (parser) {\n        parser.readMore();\n    }\n}\nfunction onSocketError(err) {\n    const { [kClient]: client, [kParser]: parser } = this;\n    assert(err.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\");\n    if (client[kHTTPConnVersion] !== \"h2\") {\n        // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n        // to the user.\n        if (err.code === \"ECONNRESET\" && parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so for as a valid response.\n            parser.onMessageComplete();\n            return;\n        }\n    }\n    this[kError] = err;\n    onError(this[kClient], err);\n}\nfunction onError(client, err) {\n    if (client[kRunning] === 0 && err.code !== \"UND_ERR_INFO\" && err.code !== \"UND_ERR_SOCKET\") {\n        // Error is not caused by running request and not a recoverable\n        // socket error.\n        assert(client[kPendingIdx] === client[kRunningIdx]);\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            errorRequest(client, request, err);\n        }\n        assert(client[kSize] === 0);\n    }\n}\nfunction onSocketEnd() {\n    const { [kParser]: parser, [kClient]: client } = this;\n    if (client[kHTTPConnVersion] !== \"h2\") {\n        if (parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so far as a valid response.\n            parser.onMessageComplete();\n            return;\n        }\n    }\n    util.destroy(this, new SocketError(\"other side closed\", util.getSocketInfo(this)));\n}\nfunction onSocketClose() {\n    const { [kClient]: client, [kParser]: parser } = this;\n    if (client[kHTTPConnVersion] === \"h1\" && parser) {\n        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so far as a valid response.\n            parser.onMessageComplete();\n        }\n        this[kParser].destroy();\n        this[kParser] = null;\n    }\n    const err = this[kError] || new SocketError(\"closed\", util.getSocketInfo(this));\n    client[kSocket] = null;\n    if (client.destroyed) {\n        assert(client[kPending] === 0);\n        // Fail entire queue.\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            errorRequest(client, request, err);\n        }\n    } else if (client[kRunning] > 0 && err.code !== \"UND_ERR_INFO\") {\n        // Fail head of pipeline.\n        const request = client[kQueue][client[kRunningIdx]];\n        client[kQueue][client[kRunningIdx]++] = null;\n        errorRequest(client, request, err);\n    }\n    client[kPendingIdx] = client[kRunningIdx];\n    assert(client[kRunning] === 0);\n    client.emit(\"disconnect\", client[kUrl], [\n        client\n    ], err);\n    resume(client);\n}\nasync function connect(client) {\n    assert(!client[kConnecting]);\n    assert(!client[kSocket]);\n    let { host, hostname, protocol, port } = client[kUrl];\n    // Resolve ipv6\n    if (hostname[0] === \"[\") {\n        const idx = hostname.indexOf(\"]\");\n        assert(idx !== -1);\n        const ip = hostname.substr(1, idx - 1);\n        assert(net.isIP(ip));\n        hostname = ip;\n    }\n    client[kConnecting] = true;\n    if (channels.beforeConnect.hasSubscribers) {\n        channels.beforeConnect.publish({\n            connectParams: {\n                host,\n                hostname,\n                protocol,\n                port,\n                servername: client[kServerName],\n                localAddress: client[kLocalAddress]\n            },\n            connector: client[kConnector]\n        });\n    }\n    try {\n        const socket = await new Promise((resolve, reject)=>{\n            client[kConnector]({\n                host,\n                hostname,\n                protocol,\n                port,\n                servername: client[kServerName],\n                localAddress: client[kLocalAddress]\n            }, (err, socket)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(socket);\n                }\n            });\n        });\n        if (client.destroyed) {\n            util.destroy(socket.on(\"error\", ()=>{}), new ClientDestroyedError());\n            return;\n        }\n        client[kConnecting] = false;\n        assert(socket);\n        const isH2 = socket.alpnProtocol === \"h2\";\n        if (isH2) {\n            if (!h2ExperimentalWarned) {\n                h2ExperimentalWarned = true;\n                process.emitWarning(\"H2 support is experimental, expect them to change at any time.\", {\n                    code: \"UNDICI-H2\"\n                });\n            }\n            const session = http2.connect(client[kUrl], {\n                createConnection: ()=>socket,\n                peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams\n            });\n            client[kHTTPConnVersion] = \"h2\";\n            session[kClient] = client;\n            session[kSocket] = socket;\n            session.on(\"error\", onHttp2SessionError);\n            session.on(\"frameError\", onHttp2FrameError);\n            session.on(\"end\", onHttp2SessionEnd);\n            session.on(\"goaway\", onHTTP2GoAway);\n            session.on(\"close\", onSocketClose);\n            session.unref();\n            client[kHTTP2Session] = session;\n            socket[kHTTP2Session] = session;\n        } else {\n            if (!llhttpInstance) {\n                llhttpInstance = await llhttpPromise;\n                llhttpPromise = null;\n            }\n            socket[kNoRef] = false;\n            socket[kWriting] = false;\n            socket[kReset] = false;\n            socket[kBlocking] = false;\n            socket[kParser] = new Parser(client, socket, llhttpInstance);\n        }\n        socket[kCounter] = 0;\n        socket[kMaxRequests] = client[kMaxRequests];\n        socket[kClient] = client;\n        socket[kError] = null;\n        socket.on(\"error\", onSocketError).on(\"readable\", onSocketReadable).on(\"end\", onSocketEnd).on(\"close\", onSocketClose);\n        client[kSocket] = socket;\n        if (channels.connected.hasSubscribers) {\n            channels.connected.publish({\n                connectParams: {\n                    host,\n                    hostname,\n                    protocol,\n                    port,\n                    servername: client[kServerName],\n                    localAddress: client[kLocalAddress]\n                },\n                connector: client[kConnector],\n                socket\n            });\n        }\n        client.emit(\"connect\", client[kUrl], [\n            client\n        ]);\n    } catch (err) {\n        if (client.destroyed) {\n            return;\n        }\n        client[kConnecting] = false;\n        if (channels.connectError.hasSubscribers) {\n            channels.connectError.publish({\n                connectParams: {\n                    host,\n                    hostname,\n                    protocol,\n                    port,\n                    servername: client[kServerName],\n                    localAddress: client[kLocalAddress]\n                },\n                connector: client[kConnector],\n                error: err\n            });\n        }\n        if (err.code === \"ERR_TLS_CERT_ALTNAME_INVALID\") {\n            assert(client[kRunning] === 0);\n            while(client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]){\n                const request = client[kQueue][client[kPendingIdx]++];\n                errorRequest(client, request, err);\n            }\n        } else {\n            onError(client, err);\n        }\n        client.emit(\"connectionError\", client[kUrl], [\n            client\n        ], err);\n    }\n    resume(client);\n}\nfunction emitDrain(client) {\n    client[kNeedDrain] = 0;\n    client.emit(\"drain\", client[kUrl], [\n        client\n    ]);\n}\nfunction resume(client, sync) {\n    if (client[kResuming] === 2) {\n        return;\n    }\n    client[kResuming] = 2;\n    _resume(client, sync);\n    client[kResuming] = 0;\n    if (client[kRunningIdx] > 256) {\n        client[kQueue].splice(0, client[kRunningIdx]);\n        client[kPendingIdx] -= client[kRunningIdx];\n        client[kRunningIdx] = 0;\n    }\n}\nfunction _resume(client, sync) {\n    while(true){\n        if (client.destroyed) {\n            assert(client[kPending] === 0);\n            return;\n        }\n        if (client[kClosedResolve] && !client[kSize]) {\n            client[kClosedResolve]();\n            client[kClosedResolve] = null;\n            return;\n        }\n        const socket = client[kSocket];\n        if (socket && !socket.destroyed && socket.alpnProtocol !== \"h2\") {\n            if (client[kSize] === 0) {\n                if (!socket[kNoRef] && socket.unref) {\n                    socket.unref();\n                    socket[kNoRef] = true;\n                }\n            } else if (socket[kNoRef] && socket.ref) {\n                socket.ref();\n                socket[kNoRef] = false;\n            }\n            if (client[kSize] === 0) {\n                if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n                    socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n                }\n            } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n                if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n                    const request = client[kQueue][client[kRunningIdx]];\n                    const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n                    socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n                }\n            }\n        }\n        if (client[kBusy]) {\n            client[kNeedDrain] = 2;\n        } else if (client[kNeedDrain] === 2) {\n            if (sync) {\n                client[kNeedDrain] = 1;\n                process.nextTick(emitDrain, client);\n            } else {\n                emitDrain(client);\n            }\n            continue;\n        }\n        if (client[kPending] === 0) {\n            return;\n        }\n        if (client[kRunning] >= (client[kPipelining] || 1)) {\n            return;\n        }\n        const request = client[kQueue][client[kPendingIdx]];\n        if (client[kUrl].protocol === \"https:\" && client[kServerName] !== request.servername) {\n            if (client[kRunning] > 0) {\n                return;\n            }\n            client[kServerName] = request.servername;\n            if (socket && socket.servername !== request.servername) {\n                util.destroy(socket, new InformationalError(\"servername changed\"));\n                return;\n            }\n        }\n        if (client[kConnecting]) {\n            return;\n        }\n        if (!socket && !client[kHTTP2Session]) {\n            connect(client);\n            return;\n        }\n        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n            return;\n        }\n        if (client[kRunning] > 0 && !request.idempotent) {\n            // Non-idempotent request cannot be retried.\n            // Ensure that no other requests are inflight and\n            // could cause failure.\n            return;\n        }\n        if (client[kRunning] > 0 && (request.upgrade || request.method === \"CONNECT\")) {\n            // Don't dispatch an upgrade until all preceding requests have completed.\n            // A misbehaving server might upgrade the connection before all pipelined\n            // request has completed.\n            return;\n        }\n        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n            // Request with stream or iterator body can error while other requests\n            // are inflight and indirectly error those as well.\n            // Ensure this doesn't happen by waiting for inflight\n            // to complete before dispatching.\n            // Request with stream or iterator body cannot be retried.\n            // Ensure that no other requests are inflight and\n            // could cause failure.\n            return;\n        }\n        if (!request.aborted && write(client, request)) {\n            client[kPendingIdx]++;\n        } else {\n            client[kQueue].splice(client[kPendingIdx], 1);\n        }\n    }\n}\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength(method) {\n    return method !== \"GET\" && method !== \"HEAD\" && method !== \"OPTIONS\" && method !== \"TRACE\" && method !== \"CONNECT\";\n}\nfunction write(client, request) {\n    if (client[kHTTPConnVersion] === \"h2\") {\n        writeH2(client, client[kHTTP2Session], request);\n        return;\n    }\n    const { body, method, path, host, upgrade, headers, blocking, reset } = request;\n    // https://tools.ietf.org/html/rfc7231#section-4.3.1\n    // https://tools.ietf.org/html/rfc7231#section-4.3.2\n    // https://tools.ietf.org/html/rfc7231#section-4.3.5\n    // Sending a payload body on a request that does not\n    // expect it can cause undefined behavior on some\n    // servers and corrupt connection state. Do not\n    // re-use the connection for further requests.\n    const expectsPayload = method === \"PUT\" || method === \"POST\" || method === \"PATCH\";\n    if (body && typeof body.read === \"function\") {\n        // Try to read EOF in order to get length.\n        body.read(0);\n    }\n    const bodyLength = util.bodyLength(body);\n    let contentLength = bodyLength;\n    if (contentLength === null) {\n        contentLength = request.contentLength;\n    }\n    if (contentLength === 0 && !expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD NOT send a Content-Length header field when\n        // the request message does not contain a payload body and the method\n        // semantics do not anticipate such a body.\n        contentLength = null;\n    }\n    // https://github.com/nodejs/undici/issues/2046\n    // A user agent may send a Content-Length header with 0 value, this should be allowed.\n    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n        if (client[kStrictContentLength]) {\n            errorRequest(client, request, new RequestContentLengthMismatchError());\n            return false;\n        }\n        process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    const socket = client[kSocket];\n    try {\n        request.onConnect((err)=>{\n            if (request.aborted || request.completed) {\n                return;\n            }\n            errorRequest(client, request, err || new RequestAbortedError());\n            util.destroy(socket, new InformationalError(\"aborted\"));\n        });\n    } catch (err) {\n        errorRequest(client, request, err);\n    }\n    if (request.aborted) {\n        return false;\n    }\n    if (method === \"HEAD\") {\n        // https://github.com/mcollina/undici/issues/258\n        // Close after a HEAD request to interop with misbehaving servers\n        // that may send a body in the response.\n        socket[kReset] = true;\n    }\n    if (upgrade || method === \"CONNECT\") {\n        // On CONNECT or upgrade, block pipeline from dispatching further\n        // requests on this connection.\n        socket[kReset] = true;\n    }\n    if (reset != null) {\n        socket[kReset] = reset;\n    }\n    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n        socket[kReset] = true;\n    }\n    if (blocking) {\n        socket[kBlocking] = true;\n    }\n    let header = `${method} ${path} HTTP/1.1\\r\\n`;\n    if (typeof host === \"string\") {\n        header += `host: ${host}\\r\\n`;\n    } else {\n        header += client[kHostHeader];\n    }\n    if (upgrade) {\n        header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n    } else if (client[kPipelining] && !socket[kReset]) {\n        header += \"connection: keep-alive\\r\\n\";\n    } else {\n        header += \"connection: close\\r\\n\";\n    }\n    if (headers) {\n        header += headers;\n    }\n    if (channels.sendHeaders.hasSubscribers) {\n        channels.sendHeaders.publish({\n            request,\n            headers: header,\n            socket\n        });\n    }\n    /* istanbul ignore else: assertion */ if (!body || bodyLength === 0) {\n        if (contentLength === 0) {\n            socket.write(`${header}content-length: 0\\r\\n\\r\\n`, \"latin1\");\n        } else {\n            assert(contentLength === null, \"no body must not have content length\");\n            socket.write(`${header}\\r\\n`, \"latin1\");\n        }\n        request.onRequestSent();\n    } else if (util.isBuffer(body)) {\n        assert(contentLength === body.byteLength, \"buffer body must have content length\");\n        socket.cork();\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, \"latin1\");\n        socket.write(body);\n        socket.uncork();\n        request.onBodySent(body);\n        request.onRequestSent();\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n    } else if (util.isBlobLike(body)) {\n        if (typeof body.stream === \"function\") {\n            writeIterable({\n                body: body.stream(),\n                client,\n                request,\n                socket,\n                contentLength,\n                header,\n                expectsPayload\n            });\n        } else {\n            writeBlob({\n                body,\n                client,\n                request,\n                socket,\n                contentLength,\n                header,\n                expectsPayload\n            });\n        }\n    } else if (util.isStream(body)) {\n        writeStream({\n            body,\n            client,\n            request,\n            socket,\n            contentLength,\n            header,\n            expectsPayload\n        });\n    } else if (util.isIterable(body)) {\n        writeIterable({\n            body,\n            client,\n            request,\n            socket,\n            contentLength,\n            header,\n            expectsPayload\n        });\n    } else {\n        assert(false);\n    }\n    return true;\n}\nfunction writeH2(client, session, request) {\n    const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;\n    let headers;\n    if (typeof reqHeaders === \"string\") headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());\n    else headers = reqHeaders;\n    if (upgrade) {\n        errorRequest(client, request, new Error(\"Upgrade not supported for H2\"));\n        return false;\n    }\n    try {\n        // TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?\n        request.onConnect((err)=>{\n            if (request.aborted || request.completed) {\n                return;\n            }\n            errorRequest(client, request, err || new RequestAbortedError());\n        });\n    } catch (err) {\n        errorRequest(client, request, err);\n    }\n    if (request.aborted) {\n        return false;\n    }\n    let stream;\n    const h2State = client[kHTTP2SessionState];\n    headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];\n    headers[HTTP2_HEADER_METHOD] = method;\n    if (method === \"CONNECT\") {\n        session.ref();\n        // we are already connected, streams are pending, first request\n        // will create a new stream. We trigger a request to create the stream and wait until\n        // `ready` event is triggered\n        // We disabled endStream to allow the user to write to the stream\n        stream = session.request(headers, {\n            endStream: false,\n            signal\n        });\n        if (stream.id && !stream.pending) {\n            request.onUpgrade(null, null, stream);\n            ++h2State.openStreams;\n        } else {\n            stream.once(\"ready\", ()=>{\n                request.onUpgrade(null, null, stream);\n                ++h2State.openStreams;\n            });\n        }\n        stream.once(\"close\", ()=>{\n            h2State.openStreams -= 1;\n            // TODO(HTTP/2): unref only if current streams count is 0\n            if (h2State.openStreams === 0) session.unref();\n        });\n        return true;\n    }\n    // https://tools.ietf.org/html/rfc7540#section-8.3\n    // :path and :scheme headers must be omited when sending CONNECT\n    headers[HTTP2_HEADER_PATH] = path;\n    headers[HTTP2_HEADER_SCHEME] = \"https\";\n    // https://tools.ietf.org/html/rfc7231#section-4.3.1\n    // https://tools.ietf.org/html/rfc7231#section-4.3.2\n    // https://tools.ietf.org/html/rfc7231#section-4.3.5\n    // Sending a payload body on a request that does not\n    // expect it can cause undefined behavior on some\n    // servers and corrupt connection state. Do not\n    // re-use the connection for further requests.\n    const expectsPayload = method === \"PUT\" || method === \"POST\" || method === \"PATCH\";\n    if (body && typeof body.read === \"function\") {\n        // Try to read EOF in order to get length.\n        body.read(0);\n    }\n    let contentLength = util.bodyLength(body);\n    if (contentLength == null) {\n        contentLength = request.contentLength;\n    }\n    if (contentLength === 0 || !expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD NOT send a Content-Length header field when\n        // the request message does not contain a payload body and the method\n        // semantics do not anticipate such a body.\n        contentLength = null;\n    }\n    // https://github.com/nodejs/undici/issues/2046\n    // A user agent may send a Content-Length header with 0 value, this should be allowed.\n    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n        if (client[kStrictContentLength]) {\n            errorRequest(client, request, new RequestContentLengthMismatchError());\n            return false;\n        }\n        process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    if (contentLength != null) {\n        assert(body, \"no body must not have content length\");\n        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;\n    }\n    session.ref();\n    const shouldEndStream = method === \"GET\" || method === \"HEAD\";\n    if (expectContinue) {\n        headers[HTTP2_HEADER_EXPECT] = \"100-continue\";\n        /**\n     * @type {import('node:http2').ClientHttp2Stream}\n     */ stream = session.request(headers, {\n            endStream: shouldEndStream,\n            signal\n        });\n        stream.once(\"continue\", writeBodyH2);\n    } else {\n        /** @type {import('node:http2').ClientHttp2Stream} */ stream = session.request(headers, {\n            endStream: shouldEndStream,\n            signal\n        });\n        writeBodyH2();\n    }\n    // Increment counter as we have new several streams open\n    ++h2State.openStreams;\n    stream.once(\"response\", (headers)=>{\n        if (request.onHeaders(Number(headers[HTTP2_HEADER_STATUS]), headers, stream.resume.bind(stream), \"\") === false) {\n            stream.pause();\n        }\n    });\n    stream.once(\"end\", ()=>{\n        request.onComplete([]);\n    });\n    stream.on(\"data\", (chunk)=>{\n        if (request.onData(chunk) === false) stream.pause();\n    });\n    stream.once(\"close\", ()=>{\n        h2State.openStreams -= 1;\n        // TODO(HTTP/2): unref only if current streams count is 0\n        if (h2State.openStreams === 0) session.unref();\n    });\n    stream.once(\"error\", function(err) {\n        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n            h2State.streams -= 1;\n            util.destroy(stream, err);\n        }\n    });\n    stream.once(\"frameError\", (type, code)=>{\n        const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n        errorRequest(client, request, err);\n        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n            h2State.streams -= 1;\n            util.destroy(stream, err);\n        }\n    });\n    // stream.on('aborted', () => {\n    //   // TODO(HTTP/2): Support aborted\n    // })\n    // stream.on('timeout', () => {\n    //   // TODO(HTTP/2): Support timeout\n    // })\n    // stream.on('push', headers => {\n    //   // TODO(HTTP/2): Suppor push\n    // })\n    // stream.on('trailers', headers => {\n    //   // TODO(HTTP/2): Support trailers\n    // })\n    return true;\n    function writeBodyH2() {\n        /* istanbul ignore else: assertion */ if (!body) {\n            request.onRequestSent();\n        } else if (util.isBuffer(body)) {\n            assert(contentLength === body.byteLength, \"buffer body must have content length\");\n            stream.cork();\n            stream.write(body);\n            stream.uncork();\n            stream.end();\n            request.onBodySent(body);\n            request.onRequestSent();\n        } else if (util.isBlobLike(body)) {\n            if (typeof body.stream === \"function\") {\n                writeIterable({\n                    client,\n                    request,\n                    contentLength,\n                    h2stream: stream,\n                    expectsPayload,\n                    body: body.stream(),\n                    socket: client[kSocket],\n                    header: \"\"\n                });\n            } else {\n                writeBlob({\n                    body,\n                    client,\n                    request,\n                    contentLength,\n                    expectsPayload,\n                    h2stream: stream,\n                    header: \"\",\n                    socket: client[kSocket]\n                });\n            }\n        } else if (util.isStream(body)) {\n            writeStream({\n                body,\n                client,\n                request,\n                contentLength,\n                expectsPayload,\n                socket: client[kSocket],\n                h2stream: stream,\n                header: \"\"\n            });\n        } else if (util.isIterable(body)) {\n            writeIterable({\n                body,\n                client,\n                request,\n                contentLength,\n                expectsPayload,\n                header: \"\",\n                h2stream: stream,\n                socket: client[kSocket]\n            });\n        } else {\n            assert(false);\n        }\n    }\n}\nfunction writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n    assert(contentLength !== 0 || client[kRunning] === 0, \"stream body cannot be pipelined\");\n    if (client[kHTTPConnVersion] === \"h2\") {\n        // For HTTP/2, is enough to pipe the stream\n        const pipe = pipeline(body, h2stream, (err)=>{\n            if (err) {\n                util.destroy(body, err);\n                util.destroy(h2stream, err);\n            } else {\n                request.onRequestSent();\n            }\n        });\n        pipe.on(\"data\", onPipeData);\n        pipe.once(\"end\", ()=>{\n            pipe.removeListener(\"data\", onPipeData);\n            util.destroy(pipe);\n        });\n        function onPipeData(chunk) {\n            request.onBodySent(chunk);\n        }\n        return;\n    }\n    let finished = false;\n    const writer = new AsyncWriter({\n        socket,\n        request,\n        contentLength,\n        client,\n        expectsPayload,\n        header\n    });\n    const onData = function(chunk) {\n        if (finished) {\n            return;\n        }\n        try {\n            if (!writer.write(chunk) && this.pause) {\n                this.pause();\n            }\n        } catch (err) {\n            util.destroy(this, err);\n        }\n    };\n    const onDrain = function() {\n        if (finished) {\n            return;\n        }\n        if (body.resume) {\n            body.resume();\n        }\n    };\n    const onAbort = function() {\n        onFinished(new RequestAbortedError());\n    };\n    const onFinished = function(err) {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n        socket.off(\"drain\", onDrain).off(\"error\", onFinished);\n        body.removeListener(\"data\", onData).removeListener(\"end\", onFinished).removeListener(\"error\", onFinished).removeListener(\"close\", onAbort);\n        if (!err) {\n            try {\n                writer.end();\n            } catch (er) {\n                err = er;\n            }\n        }\n        writer.destroy(err);\n        if (err && (err.code !== \"UND_ERR_INFO\" || err.message !== \"reset\")) {\n            util.destroy(body, err);\n        } else {\n            util.destroy(body);\n        }\n    };\n    body.on(\"data\", onData).on(\"end\", onFinished).on(\"error\", onFinished).on(\"close\", onAbort);\n    if (body.resume) {\n        body.resume();\n    }\n    socket.on(\"drain\", onDrain).on(\"error\", onFinished);\n}\nasync function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n    assert(contentLength === body.size, \"blob body must have content length\");\n    const isH2 = client[kHTTPConnVersion] === \"h2\";\n    try {\n        if (contentLength != null && contentLength !== body.size) {\n            throw new RequestContentLengthMismatchError();\n        }\n        const buffer = Buffer.from(await body.arrayBuffer());\n        if (isH2) {\n            h2stream.cork();\n            h2stream.write(buffer);\n            h2stream.uncork();\n        } else {\n            socket.cork();\n            socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, \"latin1\");\n            socket.write(buffer);\n            socket.uncork();\n        }\n        request.onBodySent(buffer);\n        request.onRequestSent();\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n        resume(client);\n    } catch (err) {\n        util.destroy(isH2 ? h2stream : socket, err);\n    }\n}\nasync function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n    assert(contentLength !== 0 || client[kRunning] === 0, \"iterator body cannot be pipelined\");\n    let callback = null;\n    function onDrain() {\n        if (callback) {\n            const cb = callback;\n            callback = null;\n            cb();\n        }\n    }\n    const waitForDrain = ()=>new Promise((resolve, reject)=>{\n            assert(callback === null);\n            if (socket[kError]) {\n                reject(socket[kError]);\n            } else {\n                callback = resolve;\n            }\n        });\n    if (client[kHTTPConnVersion] === \"h2\") {\n        h2stream.on(\"close\", onDrain).on(\"drain\", onDrain);\n        try {\n            // It's up to the user to somehow abort the async iterable.\n            for await (const chunk of body){\n                if (socket[kError]) {\n                    throw socket[kError];\n                }\n                const res = h2stream.write(chunk);\n                request.onBodySent(chunk);\n                if (!res) {\n                    await waitForDrain();\n                }\n            }\n        } catch (err) {\n            h2stream.destroy(err);\n        } finally{\n            request.onRequestSent();\n            h2stream.end();\n            h2stream.off(\"close\", onDrain).off(\"drain\", onDrain);\n        }\n        return;\n    }\n    socket.on(\"close\", onDrain).on(\"drain\", onDrain);\n    const writer = new AsyncWriter({\n        socket,\n        request,\n        contentLength,\n        client,\n        expectsPayload,\n        header\n    });\n    try {\n        // It's up to the user to somehow abort the async iterable.\n        for await (const chunk of body){\n            if (socket[kError]) {\n                throw socket[kError];\n            }\n            if (!writer.write(chunk)) {\n                await waitForDrain();\n            }\n        }\n        writer.end();\n    } catch (err) {\n        writer.destroy(err);\n    } finally{\n        socket.off(\"close\", onDrain).off(\"drain\", onDrain);\n    }\n}\nclass AsyncWriter {\n    constructor({ socket, request, contentLength, client, expectsPayload, header }){\n        this.socket = socket;\n        this.request = request;\n        this.contentLength = contentLength;\n        this.client = client;\n        this.bytesWritten = 0;\n        this.expectsPayload = expectsPayload;\n        this.header = header;\n        socket[kWriting] = true;\n    }\n    write(chunk) {\n        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;\n        if (socket[kError]) {\n            throw socket[kError];\n        }\n        if (socket.destroyed) {\n            return false;\n        }\n        const len = Buffer.byteLength(chunk);\n        if (!len) {\n            return true;\n        }\n        // We should defer writing chunks.\n        if (contentLength !== null && bytesWritten + len > contentLength) {\n            if (client[kStrictContentLength]) {\n                throw new RequestContentLengthMismatchError();\n            }\n            process.emitWarning(new RequestContentLengthMismatchError());\n        }\n        socket.cork();\n        if (bytesWritten === 0) {\n            if (!expectsPayload) {\n                socket[kReset] = true;\n            }\n            if (contentLength === null) {\n                socket.write(`${header}transfer-encoding: chunked\\r\\n`, \"latin1\");\n            } else {\n                socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, \"latin1\");\n            }\n        }\n        if (contentLength === null) {\n            socket.write(`\\r\\n${len.toString(16)}\\r\\n`, \"latin1\");\n        }\n        this.bytesWritten += len;\n        const ret = socket.write(chunk);\n        socket.uncork();\n        request.onBodySent(chunk);\n        if (!ret) {\n            if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n                // istanbul ignore else: only for jest\n                if (socket[kParser].timeout.refresh) {\n                    socket[kParser].timeout.refresh();\n                }\n            }\n        }\n        return ret;\n    }\n    end() {\n        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;\n        request.onRequestSent();\n        socket[kWriting] = false;\n        if (socket[kError]) {\n            throw socket[kError];\n        }\n        if (socket.destroyed) {\n            return;\n        }\n        if (bytesWritten === 0) {\n            if (expectsPayload) {\n                // https://tools.ietf.org/html/rfc7230#section-3.3.2\n                // A user agent SHOULD send a Content-Length in a request message when\n                // no Transfer-Encoding is sent and the request method defines a meaning\n                // for an enclosed payload body.\n                socket.write(`${header}content-length: 0\\r\\n\\r\\n`, \"latin1\");\n            } else {\n                socket.write(`${header}\\r\\n`, \"latin1\");\n            }\n        } else if (contentLength === null) {\n            socket.write(\"\\r\\n0\\r\\n\\r\\n\", \"latin1\");\n        }\n        if (contentLength !== null && bytesWritten !== contentLength) {\n            if (client[kStrictContentLength]) {\n                throw new RequestContentLengthMismatchError();\n            } else {\n                process.emitWarning(new RequestContentLengthMismatchError());\n            }\n        }\n        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n            // istanbul ignore else: only for jest\n            if (socket[kParser].timeout.refresh) {\n                socket[kParser].timeout.refresh();\n            }\n        }\n        resume(client);\n    }\n    destroy(err) {\n        const { socket, client } = this;\n        socket[kWriting] = false;\n        if (err) {\n            assert(client[kRunning] <= 1, \"pipeline should only contain this request\");\n            util.destroy(socket, err);\n        }\n    }\n}\nfunction errorRequest(client, request, err) {\n    try {\n        request.onError(err);\n        assert(request.aborted);\n    } catch (err) {\n        client.emit(\"error\", err);\n    }\n}\nmodule.exports = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVk7QUFFWjtBQUVBLHNCQUFzQixHQUV0QixNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNQyxNQUFNRCxtQkFBT0EsQ0FBQztBQUNwQixNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVHLFFBQVEsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUM3QixNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNyQixNQUFNSyxTQUFTTCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQztBQUN4QixNQUFNTyxpQkFBaUJQLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFDSlEsaUNBQWlDLEVBQ2pDQyxrQ0FBa0MsRUFDbENDLG9CQUFvQixFQUNwQkMsbUJBQW1CLEVBQ25CQyxtQkFBbUIsRUFDbkJDLG9CQUFvQixFQUNwQkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEJDLGdCQUFnQixFQUNoQkMsZUFBZSxFQUNmQyw0QkFBNEIsRUFDNUJDLG9CQUFvQixFQUNyQixHQUFHbkIsbUJBQU9BLENBQUM7QUFDWixNQUFNb0IsaUJBQWlCcEIsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUNKcUIsSUFBSSxFQUNKQyxNQUFNLEVBQ05DLFdBQVcsRUFDWEMsT0FBTyxFQUNQQyxLQUFLLEVBQ0xDLE9BQU8sRUFDUEMsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFNBQVMsRUFDVEMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLEtBQUssRUFDTEMsUUFBUSxFQUNSQyxNQUFNLEVBQ05DLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxVQUFVLEVBQ1ZDLE1BQU0sRUFDTkMsd0JBQXdCLEVBQ3hCQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxNQUFNLEVBQ05DLFdBQVcsRUFDWEMsT0FBTyxFQUNQQyxzQkFBc0IsRUFD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eEIsRUFBRSxPQUFPdEssS0FBSztRQUNaaUIsT0FBT0MsSUFBSSxDQUFDLFNBQVNsQjtJQUN2QjtBQUNGO0FBRUF5TixPQUFPcEosT0FBTyxHQUFHcEkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NsaWVudC5qcz8xOTc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1jaGVja1xuXG4ndXNlIHN0cmljdCdcblxuLyogZ2xvYmFsIFdlYkFzc2VtYmx5ICovXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKVxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKVxuY29uc3QgeyBwaXBlbGluZSB9ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpXG5jb25zdCB0aW1lcnMgPSByZXF1aXJlKCcuL3RpbWVycycpXG5jb25zdCBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9jb3JlL3JlcXVlc3QnKVxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCB7XG4gIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gIEhlYWRlcnNUaW1lb3V0RXJyb3IsXG4gIEhlYWRlcnNPdmVyZmxvd0Vycm9yLFxuICBTb2NrZXRFcnJvcixcbiAgSW5mb3JtYXRpb25hbEVycm9yLFxuICBCb2R5VGltZW91dEVycm9yLFxuICBIVFRQUGFyc2VyRXJyb3IsXG4gIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IsXG4gIENsaWVudERlc3Ryb3llZEVycm9yXG59ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4vY29yZS9jb25uZWN0JylcbmNvbnN0IHtcbiAga1VybCxcbiAga1Jlc2V0LFxuICBrU2VydmVyTmFtZSxcbiAga0NsaWVudCxcbiAga0J1c3ksXG4gIGtQYXJzZXIsXG4gIGtDb25uZWN0LFxuICBrQmxvY2tpbmcsXG4gIGtSZXN1bWluZyxcbiAga1J1bm5pbmcsXG4gIGtQZW5kaW5nLFxuICBrU2l6ZSxcbiAga1dyaXRpbmcsXG4gIGtRdWV1ZSxcbiAga0Nvbm5lY3RlZCxcbiAga0Nvbm5lY3RpbmcsXG4gIGtOZWVkRHJhaW4sXG4gIGtOb1JlZixcbiAga0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0LFxuICBrSG9zdEhlYWRlcixcbiAga1BlbmRpbmdJZHgsXG4gIGtSdW5uaW5nSWR4LFxuICBrRXJyb3IsXG4gIGtQaXBlbGluaW5nLFxuICBrU29ja2V0LFxuICBrS2VlcEFsaXZlVGltZW91dFZhbHVlLFxuICBrTWF4SGVhZGVyc1NpemUsXG4gIGtLZWVwQWxpdmVNYXhUaW1lb3V0LFxuICBrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAga0hlYWRlcnNUaW1lb3V0LFxuICBrQm9keVRpbWVvdXQsXG4gIGtTdHJpY3RDb250ZW50TGVuZ3RoLFxuICBrQ29ubmVjdG9yLFxuICBrTWF4UmVkaXJlY3Rpb25zLFxuICBrTWF4UmVxdWVzdHMsXG4gIGtDb3VudGVyLFxuICBrQ2xvc2UsXG4gIGtEZXN0cm95LFxuICBrRGlzcGF0Y2gsXG4gIGtJbnRlcmNlcHRvcnMsXG4gIGtMb2NhbEFkZHJlc3MsXG4gIGtNYXhSZXNwb25zZVNpemUsXG4gIGtIVFRQQ29ublZlcnNpb24sXG4gIC8vIEhUVFAyXG4gIGtIb3N0LFxuICBrSFRUUDJTZXNzaW9uLFxuICBrSFRUUDJTZXNzaW9uU3RhdGUsXG4gIGtIVFRQMkJ1aWxkUmVxdWVzdCxcbiAga0hUVFAyQ29weUhlYWRlcnMsXG4gIGtIVFRQMUJ1aWxkUmVxdWVzdFxufSA9IHJlcXVpcmUoJy4vY29yZS9zeW1ib2xzJylcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2h0dHAyJyl9ICovXG5sZXQgaHR0cDJcbnRyeSB7XG4gIGh0dHAyID0gcmVxdWlyZSgnaHR0cDInKVxufSBjYXRjaCB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgaHR0cDIgPSB7IGNvbnN0YW50czoge30gfVxufVxuXG5jb25zdCB7XG4gIGNvbnN0YW50czoge1xuICAgIEhUVFAyX0hFQURFUl9BVVRIT1JJVFksXG4gICAgSFRUUDJfSEVBREVSX01FVEhPRCxcbiAgICBIVFRQMl9IRUFERVJfUEFUSCxcbiAgICBIVFRQMl9IRUFERVJfU0NIRU1FLFxuICAgIEhUVFAyX0hFQURFUl9DT05URU5UX0xFTkdUSCxcbiAgICBIVFRQMl9IRUFERVJfRVhQRUNULFxuICAgIEhUVFAyX0hFQURFUl9TVEFUVVNcbiAgfVxufSA9IGh0dHAyXG5cbi8vIEV4cGVyaW1lbnRhbFxubGV0IGgyRXhwZXJpbWVudGFsV2FybmVkID0gZmFsc2VcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc11cblxuY29uc3Qga0Nsb3NlZFJlc29sdmUgPSBTeW1ib2woJ2tDbG9zZWRSZXNvbHZlJylcblxuY29uc3QgY2hhbm5lbHMgPSB7fVxuXG50cnkge1xuICBjb25zdCBkaWFnbm9zdGljc0NoYW5uZWwgPSByZXF1aXJlKCdkaWFnbm9zdGljc19jaGFubmVsJylcbiAgY2hhbm5lbHMuc2VuZEhlYWRlcnMgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpzZW5kSGVhZGVycycpXG4gIGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpiZWZvcmVDb25uZWN0JylcbiAgY2hhbm5lbHMuY29ubmVjdEVycm9yID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdEVycm9yJylcbiAgY2hhbm5lbHMuY29ubmVjdGVkID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdGVkJylcbn0gY2F0Y2gge1xuICBjaGFubmVscy5zZW5kSGVhZGVycyA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH1cbiAgY2hhbm5lbHMuYmVmb3JlQ29ubmVjdCA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH1cbiAgY2hhbm5lbHMuY29ubmVjdEVycm9yID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfVxuICBjaGFubmVscy5jb25uZWN0ZWQgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9XG59XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi4vdHlwZXMvY2xpZW50JykuZGVmYXVsdH1cbiAqL1xuY2xhc3MgQ2xpZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmxcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2NsaWVudCcpLkNsaWVudC5PcHRpb25zfSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCB7XG4gICAgaW50ZXJjZXB0b3JzLFxuICAgIG1heEhlYWRlclNpemUsXG4gICAgaGVhZGVyc1RpbWVvdXQsXG4gICAgc29ja2V0VGltZW91dCxcbiAgICByZXF1ZXN0VGltZW91dCxcbiAgICBjb25uZWN0VGltZW91dCxcbiAgICBib2R5VGltZW91dCxcbiAgICBpZGxlVGltZW91dCxcbiAgICBrZWVwQWxpdmUsXG4gICAga2VlcEFsaXZlVGltZW91dCxcbiAgICBtYXhLZWVwQWxpdmVUaW1lb3V0LFxuICAgIGtlZXBBbGl2ZU1heFRpbWVvdXQsXG4gICAga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAgICBzb2NrZXRQYXRoLFxuICAgIHBpcGVsaW5pbmcsXG4gICAgdGxzLFxuICAgIHN0cmljdENvbnRlbnRMZW5ndGgsXG4gICAgbWF4Q2FjaGVkU2Vzc2lvbnMsXG4gICAgbWF4UmVkaXJlY3Rpb25zLFxuICAgIGNvbm5lY3QsXG4gICAgbWF4UmVxdWVzdHNQZXJDbGllbnQsXG4gICAgbG9jYWxBZGRyZXNzLFxuICAgIG1heFJlc3BvbnNlU2l6ZSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5LFxuICAgIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCxcbiAgICAvLyBoMlxuICAgIGFsbG93SDIsXG4gICAgbWF4Q29uY3VycmVudFN0cmVhbXNcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgaWYgKGtlZXBBbGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIGtlZXBBbGl2ZSwgdXNlIHBpcGVsaW5pbmc9MCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAoc29ja2V0VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIHNvY2tldFRpbWVvdXQsIHVzZSBoZWFkZXJzVGltZW91dCAmIGJvZHlUaW1lb3V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIHJlcXVlc3RUaW1lb3V0LCB1c2UgaGVhZGVyc1RpbWVvdXQgJiBib2R5VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAoaWRsZVRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBpZGxlVGltZW91dCwgdXNlIGtlZXBBbGl2ZVRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKG1heEtlZXBBbGl2ZVRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBtYXhLZWVwQWxpdmVUaW1lb3V0LCB1c2Uga2VlcEFsaXZlTWF4VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAobWF4SGVhZGVyU2l6ZSAhPSBudWxsICYmICFOdW1iZXIuaXNGaW5pdGUobWF4SGVhZGVyU2l6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtYXhIZWFkZXJTaXplJylcbiAgICB9XG5cbiAgICBpZiAoc29ja2V0UGF0aCAhPSBudWxsICYmIHR5cGVvZiBzb2NrZXRQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHNvY2tldFBhdGgnKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGNvbm5lY3RUaW1lb3V0KSB8fCBjb25uZWN0VGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29ubmVjdFRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlVGltZW91dCkgfHwga2VlcEFsaXZlVGltZW91dCA8PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVNYXhUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlTWF4VGltZW91dCkgfHwga2VlcEFsaXZlTWF4VGltZW91dCA8PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZU1heFRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkICE9IG51bGwgJiYgIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQnKVxuICAgIH1cblxuICAgIGlmIChoZWFkZXJzVGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihoZWFkZXJzVGltZW91dCkgfHwgaGVhZGVyc1RpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzVGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvJylcbiAgICB9XG5cbiAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIoYm9keVRpbWVvdXQpIHx8IGJvZHlUaW1lb3V0IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignYm9keVRpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVybycpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3QgIT0gbnVsbCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignY29ubmVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVkaXJlY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGlmIChtYXhSZXF1ZXN0c1BlckNsaWVudCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXF1ZXN0c1BlckNsaWVudCkgfHwgbWF4UmVxdWVzdHNQZXJDbGllbnQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZXF1ZXN0c1BlckNsaWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAobG9jYWxBZGRyZXNzICE9IG51bGwgJiYgKHR5cGVvZiBsb2NhbEFkZHJlc3MgIT09ICdzdHJpbmcnIHx8IG5ldC5pc0lQKGxvY2FsQWRkcmVzcykgPT09IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2xvY2FsQWRkcmVzcyBtdXN0IGJlIHZhbGlkIHN0cmluZyBJUCBhZGRyZXNzJylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVzcG9uc2VTaXplICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlc3BvbnNlU2l6ZSkgfHwgbWF4UmVzcG9uc2VTaXplIDwgLTEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlc3BvbnNlU2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgIT0gbnVsbCAmJlxuICAgICAgKCFOdW1iZXIuaXNJbnRlZ2VyKGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCkgfHwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IDwgLTEpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2F1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICAvLyBoMlxuICAgIGlmIChhbGxvd0gyICE9IG51bGwgJiYgdHlwZW9mIGFsbG93SDIgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdhbGxvd0gyIG11c3QgYmUgYSB2YWxpZCBib29sZWFuIHZhbHVlJylcbiAgICB9XG5cbiAgICBpZiAobWF4Q29uY3VycmVudFN0cmVhbXMgIT0gbnVsbCAmJiAodHlwZW9mIG1heENvbmN1cnJlbnRTdHJlYW1zICE9PSAnbnVtYmVyJyB8fCBtYXhDb25jdXJyZW50U3RyZWFtcyA8IDEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENvbmN1cnJlbnRTdHJlYW1zIG11c3QgYmUgYSBwb3NzaXRpdmUgaW50ZWdlciwgZ3JlYXRlciB0aGFuIDAnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHtcbiAgICAgICAgLi4udGxzLFxuICAgICAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICAgICAgYWxsb3dIMixcbiAgICAgICAgc29ja2V0UGF0aCxcbiAgICAgICAgdGltZW91dDogY29ubmVjdFRpbWVvdXQsXG4gICAgICAgIC4uLih1dGlsLm5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5ICYmIGF1dG9TZWxlY3RGYW1pbHkgPyB7IGF1dG9TZWxlY3RGYW1pbHksIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgLi4uY29ubmVjdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gaW50ZXJjZXB0b3JzICYmIGludGVyY2VwdG9ycy5DbGllbnQgJiYgQXJyYXkuaXNBcnJheShpbnRlcmNlcHRvcnMuQ2xpZW50KVxuICAgICAgPyBpbnRlcmNlcHRvcnMuQ2xpZW50XG4gICAgICA6IFtjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yKHsgbWF4UmVkaXJlY3Rpb25zIH0pXVxuICAgIHRoaXNba1VybF0gPSB1dGlsLnBhcnNlT3JpZ2luKHVybClcbiAgICB0aGlzW2tDb25uZWN0b3JdID0gY29ubmVjdFxuICAgIHRoaXNba1NvY2tldF0gPSBudWxsXG4gICAgdGhpc1trUGlwZWxpbmluZ10gPSBwaXBlbGluaW5nICE9IG51bGwgPyBwaXBlbGluaW5nIDogMVxuICAgIHRoaXNba01heEhlYWRlcnNTaXplXSA9IG1heEhlYWRlclNpemUgfHwgaHR0cC5tYXhIZWFkZXJTaXplXG4gICAgdGhpc1trS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdID0ga2VlcEFsaXZlVGltZW91dCA9PSBudWxsID8gNGUzIDoga2VlcEFsaXZlVGltZW91dFxuICAgIHRoaXNba0tlZXBBbGl2ZU1heFRpbWVvdXRdID0ga2VlcEFsaXZlTWF4VGltZW91dCA9PSBudWxsID8gNjAwZTMgOiBrZWVwQWxpdmVNYXhUaW1lb3V0XG4gICAgdGhpc1trS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZF0gPSBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkID09IG51bGwgPyAxZTMgOiBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXG4gICAgdGhpc1trS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IHRoaXNba0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0XVxuICAgIHRoaXNba1NlcnZlck5hbWVdID0gbnVsbFxuICAgIHRoaXNba0xvY2FsQWRkcmVzc10gPSBsb2NhbEFkZHJlc3MgIT0gbnVsbCA/IGxvY2FsQWRkcmVzcyA6IG51bGxcbiAgICB0aGlzW2tSZXN1bWluZ10gPSAwIC8vIDAsIGlkbGUsIDEsIHNjaGVkdWxlZCwgMiByZXN1bWluZ1xuICAgIHRoaXNba05lZWREcmFpbl0gPSAwIC8vIDAsIGlkbGUsIDEsIHNjaGVkdWxlZCwgMiByZXN1bWluZ1xuICAgIHRoaXNba0hvc3RIZWFkZXJdID0gYGhvc3Q6ICR7dGhpc1trVXJsXS5ob3N0bmFtZX0ke3RoaXNba1VybF0ucG9ydCA/IGA6JHt0aGlzW2tVcmxdLnBvcnR9YCA6ICcnfVxcclxcbmBcbiAgICB0aGlzW2tCb2R5VGltZW91dF0gPSBib2R5VGltZW91dCAhPSBudWxsID8gYm9keVRpbWVvdXQgOiAzMDBlM1xuICAgIHRoaXNba0hlYWRlcnNUaW1lb3V0XSA9IGhlYWRlcnNUaW1lb3V0ICE9IG51bGwgPyBoZWFkZXJzVGltZW91dCA6IDMwMGUzXG4gICAgdGhpc1trU3RyaWN0Q29udGVudExlbmd0aF0gPSBzdHJpY3RDb250ZW50TGVuZ3RoID09IG51bGwgPyB0cnVlIDogc3RyaWN0Q29udGVudExlbmd0aFxuICAgIHRoaXNba01heFJlZGlyZWN0aW9uc10gPSBtYXhSZWRpcmVjdGlvbnNcbiAgICB0aGlzW2tNYXhSZXF1ZXN0c10gPSBtYXhSZXF1ZXN0c1BlckNsaWVudFxuICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gbnVsbFxuICAgIHRoaXNba01heFJlc3BvbnNlU2l6ZV0gPSBtYXhSZXNwb25zZVNpemUgPiAtMSA/IG1heFJlc3BvbnNlU2l6ZSA6IC0xXG4gICAgdGhpc1trSFRUUENvbm5WZXJzaW9uXSA9ICdoMSdcblxuICAgIC8vIEhUVFAvMlxuICAgIHRoaXNba0hUVFAyU2Vzc2lvbl0gPSBudWxsXG4gICAgdGhpc1trSFRUUDJTZXNzaW9uU3RhdGVdID0gIWFsbG93SDJcbiAgICAgID8gbnVsbFxuICAgICAgOiB7XG4gICAgICAgIC8vIHN0cmVhbXM6IG51bGwsIC8vIEZpeGVkIHF1ZXVlIG9mIHN0cmVhbXMgLSBGb3IgZnV0dXJlIHN1cHBvcnQgb2YgYHB1c2hgXG4gICAgICAgICAgb3BlblN0cmVhbXM6IDAsIC8vIEtlZXAgdHJhY2sgb2YgdGhlbSB0byBkZWNpZGUgd2V0aGVyIG9yIG5vdCB1bnJlZiB0aGUgc2Vzc2lvblxuICAgICAgICAgIG1heENvbmN1cnJlbnRTdHJlYW1zOiBtYXhDb25jdXJyZW50U3RyZWFtcyAhPSBudWxsID8gbWF4Q29uY3VycmVudFN0cmVhbXMgOiAxMDAgLy8gTWF4IHBlZXJDb25jdXJyZW50U3RyZWFtcyBmb3IgYSBOb2RlIGgyIHNlcnZlclxuICAgICAgICB9XG4gICAgdGhpc1trSG9zdF0gPSBgJHt0aGlzW2tVcmxdLmhvc3RuYW1lfSR7dGhpc1trVXJsXS5wb3J0ID8gYDoke3RoaXNba1VybF0ucG9ydH1gIDogJyd9YFxuXG4gICAgLy8ga1F1ZXVlIGlzIGJ1aWx0IHVwIG9mIDMgc2VjdGlvbnMgc2VwYXJhdGVkIGJ5XG4gICAgLy8gdGhlIGtSdW5uaW5nSWR4IGFuZCBrUGVuZGluZ0lkeCBpbmRpY2VzLlxuICAgIC8vIHwgICBjb21wbGV0ZSAgIHwgICBydW5uaW5nICAgfCAgIHBlbmRpbmcgICB8XG4gICAgLy8gICAgICAgICAgICAgICAgXiBrUnVubmluZ0lkeCBeIGtQZW5kaW5nSWR4IF4ga1F1ZXVlLmxlbmd0aFxuICAgIC8vIGtSdW5uaW5nSWR4IHBvaW50cyB0byB0aGUgZmlyc3QgcnVubmluZyBlbGVtZW50LlxuICAgIC8vIGtQZW5kaW5nSWR4IHBvaW50cyB0byB0aGUgZmlyc3QgcGVuZGluZyBlbGVtZW50LlxuICAgIC8vIFRoaXMgaW1wbGVtZW50cyBhIGZhc3QgcXVldWUgd2l0aCBhbiBhbW9ydGl6ZWRcbiAgICAvLyB0aW1lIG9mIE8oMSkuXG5cbiAgICB0aGlzW2tRdWV1ZV0gPSBbXVxuICAgIHRoaXNba1J1bm5pbmdJZHhdID0gMFxuICAgIHRoaXNba1BlbmRpbmdJZHhdID0gMFxuICB9XG5cbiAgZ2V0IHBpcGVsaW5pbmcgKCkge1xuICAgIHJldHVybiB0aGlzW2tQaXBlbGluaW5nXVxuICB9XG5cbiAgc2V0IHBpcGVsaW5pbmcgKHZhbHVlKSB7XG4gICAgdGhpc1trUGlwZWxpbmluZ10gPSB2YWx1ZVxuICAgIHJlc3VtZSh0aGlzLCB0cnVlKVxuICB9XG5cbiAgZ2V0IFtrUGVuZGluZ10gKCkge1xuICAgIHJldHVybiB0aGlzW2tRdWV1ZV0ubGVuZ3RoIC0gdGhpc1trUGVuZGluZ0lkeF1cbiAgfVxuXG4gIGdldCBba1J1bm5pbmddICgpIHtcbiAgICByZXR1cm4gdGhpc1trUGVuZGluZ0lkeF0gLSB0aGlzW2tSdW5uaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrU2l6ZV0gKCkge1xuICAgIHJldHVybiB0aGlzW2tRdWV1ZV0ubGVuZ3RoIC0gdGhpc1trUnVubmluZ0lkeF1cbiAgfVxuXG4gIGdldCBba0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiAhIXRoaXNba1NvY2tldF0gJiYgIXRoaXNba0Nvbm5lY3RpbmddICYmICF0aGlzW2tTb2NrZXRdLmRlc3Ryb3llZFxuICB9XG5cbiAgZ2V0IFtrQnVzeV0gKCkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXNba1NvY2tldF1cbiAgICByZXR1cm4gKFxuICAgICAgKHNvY2tldCAmJiAoc29ja2V0W2tSZXNldF0gfHwgc29ja2V0W2tXcml0aW5nXSB8fCBzb2NrZXRba0Jsb2NraW5nXSkpIHx8XG4gICAgICAodGhpc1trU2l6ZV0gPj0gKHRoaXNba1BpcGVsaW5pbmddIHx8IDEpKSB8fFxuICAgICAgdGhpc1trUGVuZGluZ10gPiAwXG4gICAgKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlOiBvbmx5IHVzZWQgZm9yIHRlc3QgKi9cbiAgW2tDb25uZWN0XSAoY2IpIHtcbiAgICBjb25uZWN0KHRoaXMpXG4gICAgdGhpcy5vbmNlKCdjb25uZWN0JywgY2IpXG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IG9yaWdpbiA9IG9wdHMub3JpZ2luIHx8IHRoaXNba1VybF0ub3JpZ2luXG5cbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpc1trSFRUUENvbm5WZXJzaW9uXSA9PT0gJ2gyJ1xuICAgICAgPyBSZXF1ZXN0W2tIVFRQMkJ1aWxkUmVxdWVzdF0ob3JpZ2luLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgOiBSZXF1ZXN0W2tIVFRQMUJ1aWxkUmVxdWVzdF0ob3JpZ2luLCBvcHRzLCBoYW5kbGVyKVxuXG4gICAgdGhpc1trUXVldWVdLnB1c2gocmVxdWVzdClcbiAgICBpZiAodGhpc1trUmVzdW1pbmddKSB7XG4gICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH0gZWxzZSBpZiAodXRpbC5ib2R5TGVuZ3RoKHJlcXVlc3QuYm9keSkgPT0gbnVsbCAmJiB1dGlsLmlzSXRlcmFibGUocmVxdWVzdC5ib2R5KSkge1xuICAgICAgLy8gV2FpdCBhIHRpY2sgaW4gY2FzZSBzdHJlYW0vaXRlcmF0b3IgaXMgZW5kZWQgaW4gdGhlIHNhbWUgdGljay5cbiAgICAgIHRoaXNba1Jlc3VtaW5nXSA9IDFcbiAgICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bWUodGhpcywgdHJ1ZSlcbiAgICB9XG5cbiAgICBpZiAodGhpc1trUmVzdW1pbmddICYmIHRoaXNba05lZWREcmFpbl0gIT09IDIgJiYgdGhpc1trQnVzeV0pIHtcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSAyXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNba05lZWREcmFpbl0gPCAyXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgLy8gVE9ETzogZm9yIEgyIHdlIG5lZWQgdG8gZ3JhY2VmdWxseSBmbHVzaCB0aGUgcmVtYWluaW5nIGVucXVldWVkXG4gICAgLy8gcmVxdWVzdCBhbmQgY2xvc2UgZWFjaCBzdHJlYW0uXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAoIXRoaXNba1NpemVdKSB7XG4gICAgICAgIHJlc29sdmUobnVsbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gcmVzb2x2ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldIChlcnIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gdGhpc1trUXVldWVdLnNwbGljZSh0aGlzW2tQZW5kaW5nSWR4XSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICAgIGVycm9yUmVxdWVzdCh0aGlzLCByZXF1ZXN0LCBlcnIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpc1trQ2xvc2VkUmVzb2x2ZV0pIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBTaG91bGQgd2UgZXJyb3IgaGVyZSB3aXRoIENsaWVudERlc3Ryb3llZEVycm9yP1xuICAgICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdKClcbiAgICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNba0hUVFAyU2Vzc2lvbl0gIT0gbnVsbCkge1xuICAgICAgICB1dGlsLmRlc3Ryb3kodGhpc1trSFRUUDJTZXNzaW9uXSwgZXJyKVxuICAgICAgICB0aGlzW2tIVFRQMlNlc3Npb25dID0gbnVsbFxuICAgICAgICB0aGlzW2tIVFRQMlNlc3Npb25TdGF0ZV0gPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpc1trU29ja2V0XSkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuZGVzdHJveSh0aGlzW2tTb2NrZXRdLm9uKCdjbG9zZScsIGNhbGxiYWNrKSwgZXJyKVxuICAgICAgfVxuXG4gICAgICByZXN1bWUodGhpcylcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uSHR0cDJTZXNzaW9uRXJyb3IgKGVycikge1xuICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gPSBlcnJcblxuICBvbkVycm9yKHRoaXNba0NsaWVudF0sIGVycilcbn1cblxuZnVuY3Rpb24gb25IdHRwMkZyYW1lRXJyb3IgKHR5cGUsIGNvZGUsIGlkKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoYEhUVFAvMjogXCJmcmFtZUVycm9yXCIgcmVjZWl2ZWQgLSB0eXBlICR7dHlwZX0sIGNvZGUgJHtjb2RlfWApXG5cbiAgaWYgKGlkID09PSAwKSB7XG4gICAgdGhpc1trU29ja2V0XVtrRXJyb3JdID0gZXJyXG4gICAgb25FcnJvcih0aGlzW2tDbGllbnRdLCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gb25IdHRwMlNlc3Npb25FbmQgKCkge1xuICB1dGlsLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcpKVxuICB1dGlsLmRlc3Ryb3kodGhpc1trU29ja2V0XSwgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcpKVxufVxuXG5mdW5jdGlvbiBvbkhUVFAyR29Bd2F5IChjb2RlKSB7XG4gIGNvbnN0IGNsaWVudCA9IHRoaXNba0NsaWVudF1cbiAgY29uc3QgZXJyID0gbmV3IEluZm9ybWF0aW9uYWxFcnJvcihgSFRUUC8yOiBcIkdPQVdBWVwiIGZyYW1lIHJlY2VpdmVkIHdpdGggY29kZSAke2NvZGV9YClcbiAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuICBjbGllbnRba0hUVFAyU2Vzc2lvbl0gPSBudWxsXG5cbiAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICBhc3NlcnQodGhpc1trUGVuZGluZ10gPT09IDApXG5cbiAgICAvLyBGYWlsIGVudGlyZSBxdWV1ZS5cbiAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgZXJyb3JSZXF1ZXN0KHRoaXMsIHJlcXVlc3QsIGVycilcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDApIHtcbiAgICAvLyBGYWlsIGhlYWQgb2YgcGlwZWxpbmUuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcblxuICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgfVxuXG4gIGNsaWVudFtrUGVuZGluZ0lkeF0gPSBjbGllbnRba1J1bm5pbmdJZHhdXG5cbiAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDApXG5cbiAgY2xpZW50LmVtaXQoJ2Rpc2Nvbm5lY3QnLFxuICAgIGNsaWVudFtrVXJsXSxcbiAgICBbY2xpZW50XSxcbiAgICBlcnJcbiAgKVxuXG4gIHJlc3VtZShjbGllbnQpXG59XG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGxodHRwL2NvbnN0YW50cycpXG5jb25zdCBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gcmVxdWlyZSgnLi9pbnRlcmNlcHRvci9yZWRpcmVjdEludGVyY2VwdG9yJylcbmNvbnN0IEVNUFRZX0JVRiA9IEJ1ZmZlci5hbGxvYygwKVxuXG5hc3luYyBmdW5jdGlvbiBsYXp5bGxodHRwICgpIHtcbiAgY29uc3QgbGxodHRwV2FzbURhdGEgPSBwcm9jZXNzLmVudi5KRVNUX1dPUktFUl9JRCA/IHJlcXVpcmUoJy4vbGxodHRwL2xsaHR0cC13YXNtLmpzJykgOiB1bmRlZmluZWRcblxuICBsZXQgbW9kXG4gIHRyeSB7XG4gICAgbW9kID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShCdWZmZXIuZnJvbShyZXF1aXJlKCcuL2xsaHR0cC9sbGh0dHBfc2ltZC13YXNtLmpzJyksICdiYXNlNjQnKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAvLyBXZSBjb3VsZCBjaGVjayBpZiB0aGUgZXJyb3Igd2FzIGNhdXNlZCBieSB0aGUgc2ltZCBvcHRpb24gbm90XG4gICAgLy8gYmVpbmcgZW5hYmxlZCwgYnV0IHRoZSBvY2N1cnJpbmcgb2YgdGhpcyBvdGhlciBlcnJvclxuICAgIC8vICogaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL2lzc3Vlcy8xMTQ5NVxuICAgIC8vIGdvdCBtZSB0byByZW1vdmUgdGhhdCBjaGVjayB0byBhdm9pZCBicmVha2luZyBOb2RlIDEyLlxuICAgIG1vZCA9IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUoQnVmZmVyLmZyb20obGxodHRwV2FzbURhdGEgfHwgcmVxdWlyZSgnLi9sbGh0dHAvbGxodHRwLXdhc20uanMnKSwgJ2Jhc2U2NCcpKVxuICB9XG5cbiAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG1vZCwge1xuICAgIGVudjoge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5cbiAgICAgIHdhc21fb25fdXJsOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25fc3RhdHVzOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uU3RhdHVzKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25fbWVzc2FnZV9iZWdpbjogKHApID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbk1lc3NhZ2VCZWdpbigpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX2hlYWRlcl9maWVsZDogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkhlYWRlckZpZWxkKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25faGVhZGVyX3ZhbHVlOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyVmFsdWUobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9oZWFkZXJzX2NvbXBsZXRlOiAocCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgc2hvdWxkS2VlcEFsaXZlKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJzQ29tcGxldGUoc3RhdHVzQ29kZSwgQm9vbGVhbih1cGdyYWRlKSwgQm9vbGVhbihzaG91bGRLZWVwQWxpdmUpKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9ib2R5OiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uQm9keShuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlciwgc3RhcnQsIGxlbikpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX21lc3NhZ2VfY29tcGxldGU6IChwKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKSB8fCAwXG4gICAgICB9XG5cbiAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgfVxuICB9KVxufVxuXG5sZXQgbGxodHRwSW5zdGFuY2UgPSBudWxsXG5sZXQgbGxodHRwUHJvbWlzZSA9IGxhenlsbGh0dHAoKVxubGxodHRwUHJvbWlzZS5jYXRjaCgpXG5cbmxldCBjdXJyZW50UGFyc2VyID0gbnVsbFxubGV0IGN1cnJlbnRCdWZmZXJSZWYgPSBudWxsXG5sZXQgY3VycmVudEJ1ZmZlclNpemUgPSAwXG5sZXQgY3VycmVudEJ1ZmZlclB0ciA9IG51bGxcblxuY29uc3QgVElNRU9VVF9IRUFERVJTID0gMVxuY29uc3QgVElNRU9VVF9CT0RZID0gMlxuY29uc3QgVElNRU9VVF9JRExFID0gM1xuXG5jbGFzcyBQYXJzZXIge1xuICBjb25zdHJ1Y3RvciAoY2xpZW50LCBzb2NrZXQsIHsgZXhwb3J0cyB9KSB7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShjbGllbnRba01heEhlYWRlcnNTaXplXSkgJiYgY2xpZW50W2tNYXhIZWFkZXJzU2l6ZV0gPiAwKVxuXG4gICAgdGhpcy5sbGh0dHAgPSBleHBvcnRzXG4gICAgdGhpcy5wdHIgPSB0aGlzLmxsaHR0cC5sbGh0dHBfYWxsb2MoY29uc3RhbnRzLlRZUEUuUkVTUE9OU0UpXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnRcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgIHRoaXMudGltZW91dCA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRWYWx1ZSA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRUeXBlID0gbnVsbFxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMudXBncmFkZSA9IGZhbHNlXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuICAgIHRoaXMuaGVhZGVyc01heFNpemUgPSBjbGllbnRba01heEhlYWRlcnNTaXplXVxuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gZmFsc2VcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gICAgdGhpcy5yZXN1bWUgPSB0aGlzLnJlc3VtZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmJ5dGVzUmVhZCA9IDBcblxuICAgIHRoaXMua2VlcEFsaXZlID0gJydcbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSAnJ1xuICAgIHRoaXMuY29ubmVjdGlvbiA9ICcnXG4gICAgdGhpcy5tYXhSZXNwb25zZVNpemUgPSBjbGllbnRba01heFJlc3BvbnNlU2l6ZV1cbiAgfVxuXG4gIHNldFRpbWVvdXQgKHZhbHVlLCB0eXBlKSB7XG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IHR5cGVcbiAgICBpZiAodmFsdWUgIT09IHRoaXMudGltZW91dFZhbHVlKSB7XG4gICAgICB0aW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lcnMuc2V0VGltZW91dChvblBhcnNlclRpbWVvdXQsIHZhbHVlLCB0aGlzKVxuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgICBpZiAodGhpcy50aW1lb3V0LnVucmVmKSB7XG4gICAgICAgICAgdGhpcy50aW1lb3V0LnVucmVmKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbFxuICAgICAgfVxuICAgICAgdGhpcy50aW1lb3V0VmFsdWUgPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXN1bWUgKCkge1xuICAgIGlmICh0aGlzLnNvY2tldC5kZXN0cm95ZWQgfHwgIXRoaXMucGF1c2VkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbClcbiAgICBhc3NlcnQoY3VycmVudFBhcnNlciA9PSBudWxsKVxuXG4gICAgdGhpcy5sbGh0dHAubGxodHRwX3Jlc3VtZSh0aGlzLnB0cilcblxuICAgIGFzc2VydCh0aGlzLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0JPRFkpXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIHRoaXMuZXhlY3V0ZSh0aGlzLnNvY2tldC5yZWFkKCkgfHwgRU1QVFlfQlVGKSAvLyBGbHVzaCBwYXJzZXIuXG4gICAgdGhpcy5yZWFkTW9yZSgpXG4gIH1cblxuICByZWFkTW9yZSAoKSB7XG4gICAgd2hpbGUgKCF0aGlzLnBhdXNlZCAmJiB0aGlzLnB0cikge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLnNvY2tldC5yZWFkKClcbiAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgdGhpcy5leGVjdXRlKGNodW5rKVxuICAgIH1cbiAgfVxuXG4gIGV4ZWN1dGUgKGRhdGEpIHtcbiAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbClcbiAgICBhc3NlcnQoY3VycmVudFBhcnNlciA9PSBudWxsKVxuICAgIGFzc2VydCghdGhpcy5wYXVzZWQpXG5cbiAgICBjb25zdCB7IHNvY2tldCwgbGxodHRwIH0gPSB0aGlzXG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiBjdXJyZW50QnVmZmVyU2l6ZSkge1xuICAgICAgaWYgKGN1cnJlbnRCdWZmZXJQdHIpIHtcbiAgICAgICAgbGxodHRwLmZyZWUoY3VycmVudEJ1ZmZlclB0cilcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRCdWZmZXJTaXplID0gTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gNDA5NikgKiA0MDk2XG4gICAgICBjdXJyZW50QnVmZmVyUHRyID0gbGxodHRwLm1hbGxvYyhjdXJyZW50QnVmZmVyU2l6ZSlcbiAgICB9XG5cbiAgICBuZXcgVWludDhBcnJheShsbGh0dHAubWVtb3J5LmJ1ZmZlciwgY3VycmVudEJ1ZmZlclB0ciwgY3VycmVudEJ1ZmZlclNpemUpLnNldChkYXRhKVxuXG4gICAgLy8gQ2FsbCBgZXhlY3V0ZWAgb24gdGhlIHdhc20gcGFyc2VyLlxuICAgIC8vIFdlIHBhc3MgdGhlIGBsbGh0dHBfcGFyc2VyYCBwb2ludGVyIGFkZHJlc3MsIHRoZSBwb2ludGVyIGFkZHJlc3Mgb2YgYnVmZmVyIHZpZXcgZGF0YSxcbiAgICAvLyBhbmQgZmluYWxseSB0aGUgbGVuZ3RoIG9mIGJ5dGVzIHRvIHBhcnNlLlxuICAgIC8vIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gZXJyb3IgY29kZSBvciBgY29uc3RhbnRzLkVSUk9SLk9LYC5cbiAgICB0cnkge1xuICAgICAgbGV0IHJldFxuXG4gICAgICB0cnkge1xuICAgICAgICBjdXJyZW50QnVmZmVyUmVmID0gZGF0YVxuICAgICAgICBjdXJyZW50UGFyc2VyID0gdGhpc1xuICAgICAgICByZXQgPSBsbGh0dHAubGxodHRwX2V4ZWN1dGUodGhpcy5wdHIsIGN1cnJlbnRCdWZmZXJQdHIsIGRhdGEubGVuZ3RoKVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYXRjaCAqL1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UGFyc2VyID0gbnVsbFxuICAgICAgICBjdXJyZW50QnVmZmVyUmVmID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCBvZmZzZXQgPSBsbGh0dHAubGxodHRwX2dldF9lcnJvcl9wb3ModGhpcy5wdHIpIC0gY3VycmVudEJ1ZmZlclB0clxuXG4gICAgICBpZiAocmV0ID09PSBjb25zdGFudHMuRVJST1IuUEFVU0VEX1VQR1JBREUpIHtcbiAgICAgICAgdGhpcy5vblVwZ3JhZGUoZGF0YS5zbGljZShvZmZzZXQpKVxuICAgICAgfSBlbHNlIGlmIChyZXQgPT09IGNvbnN0YW50cy5FUlJPUi5QQVVTRUQpIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlXG4gICAgICAgIHNvY2tldC51bnNoaWZ0KGRhdGEuc2xpY2Uob2Zmc2V0KSlcbiAgICAgIH0gZWxzZSBpZiAocmV0ICE9PSBjb25zdGFudHMuRVJST1IuT0spIHtcbiAgICAgICAgY29uc3QgcHRyID0gbGxodHRwLmxsaHR0cF9nZXRfZXJyb3JfcmVhc29uKHRoaXMucHRyKVxuICAgICAgICBsZXQgbWVzc2FnZSA9ICcnXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICAgICAgaWYgKHB0cikge1xuICAgICAgICAgIGNvbnN0IGxlbiA9IG5ldyBVaW50OEFycmF5KGxsaHR0cC5tZW1vcnkuYnVmZmVyLCBwdHIpLmluZGV4T2YoMClcbiAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICdSZXNwb25zZSBkb2VzIG5vdCBtYXRjaCB0aGUgSFRUUC8xLjEgcHJvdG9jb2wgKCcgK1xuICAgICAgICAgICAgQnVmZmVyLmZyb20obGxodHRwLm1lbW9yeS5idWZmZXIsIHB0ciwgbGVuKS50b1N0cmluZygpICtcbiAgICAgICAgICAgICcpJ1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBIVFRQUGFyc2VyRXJyb3IobWVzc2FnZSwgY29uc3RhbnRzLkVSUk9SW3JldF0sIGRhdGEuc2xpY2Uob2Zmc2V0KSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIGVycilcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBhc3NlcnQodGhpcy5wdHIgIT0gbnVsbClcbiAgICBhc3NlcnQoY3VycmVudFBhcnNlciA9PSBudWxsKVxuXG4gICAgdGhpcy5sbGh0dHAubGxodHRwX2ZyZWUodGhpcy5wdHIpXG4gICAgdGhpcy5wdHIgPSBudWxsXG5cbiAgICB0aW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VmFsdWUgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IG51bGxcblxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgfVxuXG4gIG9uU3RhdHVzIChidWYpIHtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBidWYudG9TdHJpbmcoKVxuICB9XG5cbiAgb25NZXNzYWdlQmVnaW4gKCkge1xuICAgIGNvbnN0IHsgc29ja2V0LCBjbGllbnQgfSA9IHRoaXNcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gIH1cblxuICBvbkhlYWRlckZpZWxkIChidWYpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmhlYWRlcnMubGVuZ3RoXG5cbiAgICBpZiAoKGxlbiAmIDEpID09PSAwKSB7XG4gICAgICB0aGlzLmhlYWRlcnMucHVzaChidWYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tsZW4gLSAxXSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuaGVhZGVyc1tsZW4gLSAxXSwgYnVmXSlcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrSGVhZGVyKGJ1Zi5sZW5ndGgpXG4gIH1cblxuICBvbkhlYWRlclZhbHVlIChidWYpIHtcbiAgICBsZXQgbGVuID0gdGhpcy5oZWFkZXJzLmxlbmd0aFxuXG4gICAgaWYgKChsZW4gJiAxKSA9PT0gMSkge1xuICAgICAgdGhpcy5oZWFkZXJzLnB1c2goYnVmKVxuICAgICAgbGVuICs9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzW2xlbiAtIDFdID0gQnVmZmVyLmNvbmNhdChbdGhpcy5oZWFkZXJzW2xlbiAtIDFdLCBidWZdKVxuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHRoaXMuaGVhZGVyc1tsZW4gLSAyXVxuICAgIGlmIChrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAna2VlcC1hbGl2ZScpIHtcbiAgICAgIHRoaXMua2VlcEFsaXZlICs9IGJ1Zi50b1N0cmluZygpXG4gICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAnY29ubmVjdGlvbicpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbiArPSBidWYudG9TdHJpbmcoKVxuICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMTQgJiYga2V5LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJykge1xuICAgICAgdGhpcy5jb250ZW50TGVuZ3RoICs9IGJ1Zi50b1N0cmluZygpXG4gICAgfVxuXG4gICAgdGhpcy50cmFja0hlYWRlcihidWYubGVuZ3RoKVxuICB9XG5cbiAgdHJhY2tIZWFkZXIgKGxlbikge1xuICAgIHRoaXMuaGVhZGVyc1NpemUgKz0gbGVuXG4gICAgaWYgKHRoaXMuaGVhZGVyc1NpemUgPj0gdGhpcy5oZWFkZXJzTWF4U2l6ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHRoaXMuc29ja2V0LCBuZXcgSGVhZGVyc092ZXJmbG93RXJyb3IoKSlcbiAgICB9XG4gIH1cblxuICBvblVwZ3JhZGUgKGhlYWQpIHtcbiAgICBjb25zdCB7IHVwZ3JhZGUsIGNsaWVudCwgc29ja2V0LCBoZWFkZXJzLCBzdGF0dXNDb2RlIH0gPSB0aGlzXG5cbiAgICBhc3NlcnQodXBncmFkZSlcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGFzc2VydChyZXF1ZXN0KVxuXG4gICAgYXNzZXJ0KCFzb2NrZXQuZGVzdHJveWVkKVxuICAgIGFzc2VydChzb2NrZXQgPT09IGNsaWVudFtrU29ja2V0XSlcbiAgICBhc3NlcnQoIXRoaXMucGF1c2VkKVxuICAgIGFzc2VydChyZXF1ZXN0LnVwZ3JhZGUgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJylcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gbnVsbFxuXG4gICAgYXNzZXJ0KHRoaXMuaGVhZGVycy5sZW5ndGggJSAyID09PSAwKVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcblxuICAgIHNvY2tldC51bnNoaWZ0KGhlYWQpXG5cbiAgICBzb2NrZXRba1BhcnNlcl0uZGVzdHJveSgpXG4gICAgc29ja2V0W2tQYXJzZXJdID0gbnVsbFxuXG4gICAgc29ja2V0W2tDbGllbnRdID0gbnVsbFxuICAgIHNvY2tldFtrRXJyb3JdID0gbnVsbFxuICAgIHNvY2tldFxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uU29ja2V0RXJyb3IpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgb25Tb2NrZXRSZWFkYWJsZSlcbiAgICAgIC5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25Tb2NrZXRFbmQpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSlcblxuICAgIGNsaWVudFtrU29ja2V0XSA9IG51bGxcbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuICAgIGNsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigndXBncmFkZScpKVxuXG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3Qub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIGVycilcbiAgICB9XG5cbiAgICByZXN1bWUoY2xpZW50KVxuICB9XG5cbiAgb25IZWFkZXJzQ29tcGxldGUgKHN0YXR1c0NvZGUsIHVwZ3JhZGUsIHNob3VsZEtlZXBBbGl2ZSkge1xuICAgIGNvbnN0IHsgY2xpZW50LCBzb2NrZXQsIGhlYWRlcnMsIHN0YXR1c1RleHQgfSA9IHRoaXNcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBhc3NlcnQoIXRoaXMudXBncmFkZSlcbiAgICBhc3NlcnQodGhpcy5zdGF0dXNDb2RlIDwgMjAwKVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPT09IDEwMCkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFNvY2tldEVycm9yKCdiYWQgcmVzcG9uc2UnLCB1dGlsLmdldFNvY2tldEluZm8oc29ja2V0KSkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICAvKiB0aGlzIGNhbiBvbmx5IGhhcHBlbiBpZiBzZXJ2ZXIgaXMgbWlzYmVoYXZpbmcgKi9cbiAgICBpZiAodXBncmFkZSAmJiAhcmVxdWVzdC51cGdyYWRlKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgU29ja2V0RXJyb3IoJ2JhZCB1cGdyYWRlJywgdXRpbC5nZXRTb2NrZXRJbmZvKHNvY2tldCkpKVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRoaXMudGltZW91dFR5cGUsIFRJTUVPVVRfSEVBREVSUylcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGVcbiAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IChcbiAgICAgIHNob3VsZEtlZXBBbGl2ZSB8fFxuICAgICAgLy8gT3ZlcnJpZGUgbGxodHRwIHZhbHVlIHdoaWNoIGRvZXMgbm90IGFsbG93IGtlZXBBbGl2ZSBmb3IgSEVBRC5cbiAgICAgIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnICYmICFzb2NrZXRba1Jlc2V0XSAmJiB0aGlzLmNvbm5lY3Rpb24udG9Mb3dlckNhc2UoKSA9PT0gJ2tlZXAtYWxpdmUnKVxuICAgIClcblxuICAgIGlmICh0aGlzLnN0YXR1c0NvZGUgPj0gMjAwKSB7XG4gICAgICBjb25zdCBib2R5VGltZW91dCA9IHJlcXVlc3QuYm9keVRpbWVvdXQgIT0gbnVsbFxuICAgICAgICA/IHJlcXVlc3QuYm9keVRpbWVvdXRcbiAgICAgICAgOiBjbGllbnRba0JvZHlUaW1lb3V0XVxuICAgICAgdGhpcy5zZXRUaW1lb3V0KGJvZHlUaW1lb3V0LCBUSU1FT1VUX0JPRFkpXG4gICAgfSBlbHNlIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMSlcbiAgICAgIHRoaXMudXBncmFkZSA9IHRydWVcbiAgICAgIHJldHVybiAyXG4gICAgfVxuXG4gICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAxKVxuICAgICAgdGhpcy51cGdyYWRlID0gdHJ1ZVxuICAgICAgcmV0dXJuIDJcbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5oZWFkZXJzLmxlbmd0aCAlIDIgPT09IDApXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgaWYgKHRoaXMuc2hvdWxkS2VlcEFsaXZlICYmIGNsaWVudFtrUGlwZWxpbmluZ10pIHtcbiAgICAgIGNvbnN0IGtlZXBBbGl2ZVRpbWVvdXQgPSB0aGlzLmtlZXBBbGl2ZSA/IHV0aWwucGFyc2VLZWVwQWxpdmVUaW1lb3V0KHRoaXMua2VlcEFsaXZlKSA6IG51bGxcblxuICAgICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gTWF0aC5taW4oXG4gICAgICAgICAga2VlcEFsaXZlVGltZW91dCAtIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZF0sXG4gICAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVNYXhUaW1lb3V0XVxuICAgICAgICApXG4gICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0gPSB0aW1lb3V0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IGNsaWVudFtrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0b3AgbW9yZSByZXF1ZXN0cyBmcm9tIGJlaW5nIGRpc3BhdGNoZWQuXG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICBsZXQgcGF1c2VcbiAgICB0cnkge1xuICAgICAgcGF1c2UgPSByZXF1ZXN0Lm9uSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCB0aGlzLnJlc3VtZSwgc3RhdHVzVGV4dCkgPT09IGZhbHNlXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJykge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBpZiAoc29ja2V0W2tCbG9ja2luZ10pIHtcbiAgICAgIHNvY2tldFtrQmxvY2tpbmddID0gZmFsc2VcbiAgICAgIHJlc3VtZShjbGllbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdXNlID8gY29uc3RhbnRzLkVSUk9SLlBBVVNFRCA6IDBcbiAgfVxuXG4gIG9uQm9keSAoYnVmKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgc3RhdHVzQ29kZSwgbWF4UmVzcG9uc2VTaXplIH0gPSB0aGlzXG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgYXNzZXJ0KHJlcXVlc3QpXG5cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodGhpcy50aW1lb3V0VHlwZSwgVElNRU9VVF9CT0RZKVxuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGFzc2VydChzdGF0dXNDb2RlID49IDIwMClcblxuICAgIGlmIChtYXhSZXNwb25zZVNpemUgPiAtMSAmJiB0aGlzLmJ5dGVzUmVhZCArIGJ1Zi5sZW5ndGggPiBtYXhSZXNwb25zZVNpemUpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yKCkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICB0aGlzLmJ5dGVzUmVhZCArPSBidWYubGVuZ3RoXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHJlcXVlc3Qub25EYXRhKGJ1ZikgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gIH1cblxuICBvbk1lc3NhZ2VDb21wbGV0ZSAoKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgaGVhZGVycywgY29udGVudExlbmd0aCwgYnl0ZXNSZWFkLCBzaG91bGRLZWVwQWxpdmUgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkICYmICghc3RhdHVzQ29kZSB8fCBzaG91bGRLZWVwQWxpdmUpKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgYXNzZXJ0KHJlcXVlc3QpXG5cbiAgICBhc3NlcnQoc3RhdHVzQ29kZSA+PSAxMDApXG5cbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBudWxsXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJydcbiAgICB0aGlzLmJ5dGVzUmVhZCA9IDBcbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSAnJ1xuICAgIHRoaXMua2VlcEFsaXZlID0gJydcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSAnJ1xuXG4gICAgYXNzZXJ0KHRoaXMuaGVhZGVycy5sZW5ndGggJSAyID09PSAwKVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIGJlIGhhbmRsZWQgYnkgbGxodHRwPyAqL1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnICYmIGNvbnRlbnRMZW5ndGggJiYgYnl0ZXNSZWFkICE9PSBwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCkpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmVxdWVzdC5vbkNvbXBsZXRlKGhlYWRlcnMpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgfVxuXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcblxuICAgIGlmIChzb2NrZXRba1dyaXRpbmddKSB7XG4gICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY2xpZW50W2tSdW5uaW5nXSwgMClcbiAgICAgIC8vIFJlc3BvbnNlIGNvbXBsZXRlZCBiZWZvcmUgcmVxdWVzdC5cbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoIXNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigncmVzZXQnKSlcbiAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEXG4gICAgfSBlbHNlIGlmIChzb2NrZXRba1Jlc2V0XSAmJiBjbGllbnRba1J1bm5pbmddID09PSAwKSB7XG4gICAgICAvLyBEZXN0cm95IHNvY2tldCBvbmNlIGFsbCByZXF1ZXN0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGF0IHRoZSB0YWlsIG9mIHRoZSBwaXBlbGluZSBpcyB0aGUgb25lXG4gICAgICAvLyB0aGF0IHJlcXVlc3RlZCByZXNldCBhbmQgbm8gZnVydGhlciByZXF1ZXN0cyBzaG91bGRcbiAgICAgIC8vIGhhdmUgYmVlbiBxdWV1ZWQgc2luY2UgdGhlbi5cbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoY2xpZW50W2tQaXBlbGluaW5nXSA9PT0gMSkge1xuICAgICAgLy8gV2UgbXVzdCB3YWl0IGEgZnVsbCBldmVudCBsb29wIGN5Y2xlIHRvIHJldXNlIHRoaXMgc29ja2V0IHRvIG1ha2Ugc3VyZVxuICAgICAgLy8gdGhhdCBub24tc3BlYyBjb21wbGlhbnQgc2VydmVycyBhcmUgbm90IGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24gZXZlbiBpZiB0aGV5XG4gICAgICAvLyBzYWlkIHRoZXkgd29uJ3QuXG4gICAgICBzZXRJbW1lZGlhdGUocmVzdW1lLCBjbGllbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VtZShjbGllbnQpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUGFyc2VyVGltZW91dCAocGFyc2VyKSB7XG4gIGNvbnN0IHsgc29ja2V0LCB0aW1lb3V0VHlwZSwgY2xpZW50IH0gPSBwYXJzZXJcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgIGlmICghc29ja2V0W2tXcml0aW5nXSB8fCBzb2NrZXQud3JpdGFibGVOZWVkRHJhaW4gfHwgY2xpZW50W2tSdW5uaW5nXSA+IDEpIHtcbiAgICAgIGFzc2VydCghcGFyc2VyLnBhdXNlZCwgJ2Nhbm5vdCBiZSBwYXVzZWQgd2hpbGUgd2FpdGluZyBmb3IgaGVhZGVycycpXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSGVhZGVyc1RpbWVvdXRFcnJvcigpKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9CT0RZKSB7XG4gICAgaWYgKCFwYXJzZXIucGF1c2VkKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgQm9keVRpbWVvdXRFcnJvcigpKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9JRExFKSB7XG4gICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDAgJiYgY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdKVxuICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3NvY2tldCBpZGxlIHRpbWVvdXQnKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBvblNvY2tldFJlYWRhYmxlICgpIHtcbiAgY29uc3QgeyBba1BhcnNlcl06IHBhcnNlciB9ID0gdGhpc1xuICBpZiAocGFyc2VyKSB7XG4gICAgcGFyc2VyLnJlYWRNb3JlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBvblNvY2tldEVycm9yIChlcnIpIHtcbiAgY29uc3QgeyBba0NsaWVudF06IGNsaWVudCwgW2tQYXJzZXJdOiBwYXJzZXIgfSA9IHRoaXNcblxuICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICBpZiAoY2xpZW50W2tIVFRQQ29ublZlcnNpb25dICE9PSAnaDInKSB7XG4gICAgLy8gT24gTWFjIE9TLCB3ZSBnZXQgYW4gRUNPTk5SRVNFVCBldmVuIGlmIHRoZXJlIGlzIGEgZnVsbCBib2R5IHRvIGJlIGZvcndhcmRlZFxuICAgIC8vIHRvIHRoZSB1c2VyLlxuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VDT05OUkVTRVQnICYmIHBhcnNlci5zdGF0dXNDb2RlICYmICFwYXJzZXIuc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICAvLyBXZSB0cmVhdCBhbGwgaW5jb21pbmcgZGF0YSBzbyBmb3IgYXMgYSB2YWxpZCByZXNwb25zZS5cbiAgICAgIHBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICB0aGlzW2tFcnJvcl0gPSBlcnJcblxuICBvbkVycm9yKHRoaXNba0NsaWVudF0sIGVycilcbn1cblxuZnVuY3Rpb24gb25FcnJvciAoY2xpZW50LCBlcnIpIHtcbiAgaWYgKFxuICAgIGNsaWVudFtrUnVubmluZ10gPT09IDAgJiZcbiAgICBlcnIuY29kZSAhPT0gJ1VORF9FUlJfSU5GTycgJiZcbiAgICBlcnIuY29kZSAhPT0gJ1VORF9FUlJfU09DS0VUJ1xuICApIHtcbiAgICAvLyBFcnJvciBpcyBub3QgY2F1c2VkIGJ5IHJ1bm5pbmcgcmVxdWVzdCBhbmQgbm90IGEgcmVjb3ZlcmFibGVcbiAgICAvLyBzb2NrZXQgZXJyb3IuXG5cbiAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nSWR4XSA9PT0gY2xpZW50W2tSdW5uaW5nSWR4XSlcblxuICAgIGNvbnN0IHJlcXVlc3RzID0gY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUnVubmluZ0lkeF0pXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgfVxuICAgIGFzc2VydChjbGllbnRba1NpemVdID09PSAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uU29ja2V0RW5kICgpIHtcbiAgY29uc3QgeyBba1BhcnNlcl06IHBhcnNlciwgW2tDbGllbnRdOiBjbGllbnQgfSA9IHRoaXNcblxuICBpZiAoY2xpZW50W2tIVFRQQ29ublZlcnNpb25dICE9PSAnaDInKSB7XG4gICAgaWYgKHBhcnNlci5zdGF0dXNDb2RlICYmICFwYXJzZXIuc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICAvLyBXZSB0cmVhdCBhbGwgaW5jb21pbmcgZGF0YSBzbyBmYXIgYXMgYSB2YWxpZCByZXNwb25zZS5cbiAgICAgIHBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICB1dGlsLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSkpXG59XG5cbmZ1bmN0aW9uIG9uU29ja2V0Q2xvc2UgKCkge1xuICBjb25zdCB7IFtrQ2xpZW50XTogY2xpZW50LCBba1BhcnNlcl06IHBhcnNlciB9ID0gdGhpc1xuXG4gIGlmIChjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gPT09ICdoMScgJiYgcGFyc2VyKSB7XG4gICAgaWYgKCF0aGlzW2tFcnJvcl0gJiYgcGFyc2VyLnN0YXR1c0NvZGUgJiYgIXBhcnNlci5zaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgIC8vIFdlIHRyZWF0IGFsbCBpbmNvbWluZyBkYXRhIHNvIGZhciBhcyBhIHZhbGlkIHJlc3BvbnNlLlxuICAgICAgcGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKClcbiAgICB9XG5cbiAgICB0aGlzW2tQYXJzZXJdLmRlc3Ryb3koKVxuICAgIHRoaXNba1BhcnNlcl0gPSBudWxsXG4gIH1cblxuICBjb25zdCBlcnIgPSB0aGlzW2tFcnJvcl0gfHwgbmV3IFNvY2tldEVycm9yKCdjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpcykpXG5cbiAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuXG4gIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ10gPT09IDApXG5cbiAgICAvLyBGYWlsIGVudGlyZSBxdWV1ZS5cbiAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIH1cbiAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiBlcnIuY29kZSAhPT0gJ1VORF9FUlJfSU5GTycpIHtcbiAgICAvLyBGYWlsIGhlYWQgb2YgcGlwZWxpbmUuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcblxuICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgfVxuXG4gIGNsaWVudFtrUGVuZGluZ0lkeF0gPSBjbGllbnRba1J1bm5pbmdJZHhdXG5cbiAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDApXG5cbiAgY2xpZW50LmVtaXQoJ2Rpc2Nvbm5lY3QnLCBjbGllbnRba1VybF0sIFtjbGllbnRdLCBlcnIpXG5cbiAgcmVzdW1lKGNsaWVudClcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29ubmVjdCAoY2xpZW50KSB7XG4gIGFzc2VydCghY2xpZW50W2tDb25uZWN0aW5nXSlcbiAgYXNzZXJ0KCFjbGllbnRba1NvY2tldF0pXG5cbiAgbGV0IHsgaG9zdCwgaG9zdG5hbWUsIHByb3RvY29sLCBwb3J0IH0gPSBjbGllbnRba1VybF1cblxuICAvLyBSZXNvbHZlIGlwdjZcbiAgaWYgKGhvc3RuYW1lWzBdID09PSAnWycpIHtcbiAgICBjb25zdCBpZHggPSBob3N0bmFtZS5pbmRleE9mKCddJylcblxuICAgIGFzc2VydChpZHggIT09IC0xKVxuICAgIGNvbnN0IGlwID0gaG9zdG5hbWUuc3Vic3RyKDEsIGlkeCAtIDEpXG5cbiAgICBhc3NlcnQobmV0LmlzSVAoaXApKVxuICAgIGhvc3RuYW1lID0gaXBcbiAgfVxuXG4gIGNsaWVudFtrQ29ubmVjdGluZ10gPSB0cnVlXG5cbiAgaWYgKGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICBjaGFubmVscy5iZWZvcmVDb25uZWN0LnB1Ymxpc2goe1xuICAgICAgY29ubmVjdFBhcmFtczoge1xuICAgICAgICBob3N0LFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICB9LFxuICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl1cbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzb2NrZXQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjbGllbnRba0Nvbm5lY3Rvcl0oe1xuICAgICAgICBob3N0LFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICB9LCAoZXJyLCBzb2NrZXQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShzb2NrZXQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHt9KSwgbmV3IENsaWVudERlc3Ryb3llZEVycm9yKCkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGllbnRba0Nvbm5lY3RpbmddID0gZmFsc2VcblxuICAgIGFzc2VydChzb2NrZXQpXG5cbiAgICBjb25zdCBpc0gyID0gc29ja2V0LmFscG5Qcm90b2NvbCA9PT0gJ2gyJ1xuICAgIGlmIChpc0gyKSB7XG4gICAgICBpZiAoIWgyRXhwZXJpbWVudGFsV2FybmVkKSB7XG4gICAgICAgIGgyRXhwZXJpbWVudGFsV2FybmVkID0gdHJ1ZVxuICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdIMiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbCwgZXhwZWN0IHRoZW0gdG8gY2hhbmdlIGF0IGFueSB0aW1lLicsIHtcbiAgICAgICAgICBjb2RlOiAnVU5ESUNJLUgyJ1xuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXNzaW9uID0gaHR0cDIuY29ubmVjdChjbGllbnRba1VybF0sIHtcbiAgICAgICAgY3JlYXRlQ29ubmVjdGlvbjogKCkgPT4gc29ja2V0LFxuICAgICAgICBwZWVyTWF4Q29uY3VycmVudFN0cmVhbXM6IGNsaWVudFtrSFRUUDJTZXNzaW9uU3RhdGVdLm1heENvbmN1cnJlbnRTdHJlYW1zXG4gICAgICB9KVxuXG4gICAgICBjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gPSAnaDInXG4gICAgICBzZXNzaW9uW2tDbGllbnRdID0gY2xpZW50XG4gICAgICBzZXNzaW9uW2tTb2NrZXRdID0gc29ja2V0XG4gICAgICBzZXNzaW9uLm9uKCdlcnJvcicsIG9uSHR0cDJTZXNzaW9uRXJyb3IpXG4gICAgICBzZXNzaW9uLm9uKCdmcmFtZUVycm9yJywgb25IdHRwMkZyYW1lRXJyb3IpXG4gICAgICBzZXNzaW9uLm9uKCdlbmQnLCBvbkh0dHAyU2Vzc2lvbkVuZClcbiAgICAgIHNlc3Npb24ub24oJ2dvYXdheScsIG9uSFRUUDJHb0F3YXkpXG4gICAgICBzZXNzaW9uLm9uKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpXG4gICAgICBzZXNzaW9uLnVucmVmKClcblxuICAgICAgY2xpZW50W2tIVFRQMlNlc3Npb25dID0gc2Vzc2lvblxuICAgICAgc29ja2V0W2tIVFRQMlNlc3Npb25dID0gc2Vzc2lvblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWxsaHR0cEluc3RhbmNlKSB7XG4gICAgICAgIGxsaHR0cEluc3RhbmNlID0gYXdhaXQgbGxodHRwUHJvbWlzZVxuICAgICAgICBsbGh0dHBQcm9taXNlID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBzb2NrZXRba05vUmVmXSA9IGZhbHNlXG4gICAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gZmFsc2VcbiAgICAgIHNvY2tldFtrQmxvY2tpbmddID0gZmFsc2VcbiAgICAgIHNvY2tldFtrUGFyc2VyXSA9IG5ldyBQYXJzZXIoY2xpZW50LCBzb2NrZXQsIGxsaHR0cEluc3RhbmNlKVxuICAgIH1cblxuICAgIHNvY2tldFtrQ291bnRlcl0gPSAwXG4gICAgc29ja2V0W2tNYXhSZXF1ZXN0c10gPSBjbGllbnRba01heFJlcXVlc3RzXVxuICAgIHNvY2tldFtrQ2xpZW50XSA9IGNsaWVudFxuICAgIHNvY2tldFtrRXJyb3JdID0gbnVsbFxuXG4gICAgc29ja2V0XG4gICAgICAub24oJ2Vycm9yJywgb25Tb2NrZXRFcnJvcilcbiAgICAgIC5vbigncmVhZGFibGUnLCBvblNvY2tldFJlYWRhYmxlKVxuICAgICAgLm9uKCdlbmQnLCBvblNvY2tldEVuZClcbiAgICAgIC5vbignY2xvc2UnLCBvblNvY2tldENsb3NlKVxuXG4gICAgY2xpZW50W2tTb2NrZXRdID0gc29ja2V0XG5cbiAgICBpZiAoY2hhbm5lbHMuY29ubmVjdGVkLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5jb25uZWN0ZWQucHVibGlzaCh7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHtcbiAgICAgICAgICBob3N0LFxuICAgICAgICAgIGhvc3RuYW1lLFxuICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgICBsb2NhbEFkZHJlc3M6IGNsaWVudFtrTG9jYWxBZGRyZXNzXVxuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXSxcbiAgICAgICAgc29ja2V0XG4gICAgICB9KVxuICAgIH1cbiAgICBjbGllbnQuZW1pdCgnY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGllbnRba0Nvbm5lY3RpbmddID0gZmFsc2VcblxuICAgIGlmIChjaGFubmVscy5jb25uZWN0RXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmNvbm5lY3RFcnJvci5wdWJsaXNoKHtcbiAgICAgICAgY29ubmVjdFBhcmFtczoge1xuICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgcG9ydCxcbiAgICAgICAgICBzZXJ2ZXJuYW1lOiBjbGllbnRba1NlcnZlck5hbWVdLFxuICAgICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RvcjogY2xpZW50W2tDb25uZWN0b3JdLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcbiAgICAgIHdoaWxlIChjbGllbnRba1BlbmRpbmddID4gMCAmJiBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdXS5zZXJ2ZXJuYW1lID09PSBjbGllbnRba1NlcnZlck5hbWVdKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdKytdXG4gICAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihjbGllbnQsIGVycilcbiAgICB9XG5cbiAgICBjbGllbnQuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKVxuICB9XG5cbiAgcmVzdW1lKGNsaWVudClcbn1cblxuZnVuY3Rpb24gZW1pdERyYWluIChjbGllbnQpIHtcbiAgY2xpZW50W2tOZWVkRHJhaW5dID0gMFxuICBjbGllbnQuZW1pdCgnZHJhaW4nLCBjbGllbnRba1VybF0sIFtjbGllbnRdKVxufVxuXG5mdW5jdGlvbiByZXN1bWUgKGNsaWVudCwgc3luYykge1xuICBpZiAoY2xpZW50W2tSZXN1bWluZ10gPT09IDIpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNsaWVudFtrUmVzdW1pbmddID0gMlxuXG4gIF9yZXN1bWUoY2xpZW50LCBzeW5jKVxuICBjbGllbnRba1Jlc3VtaW5nXSA9IDBcblxuICBpZiAoY2xpZW50W2tSdW5uaW5nSWR4XSA+IDI1Nikge1xuICAgIGNsaWVudFtrUXVldWVdLnNwbGljZSgwLCBjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gLT0gY2xpZW50W2tSdW5uaW5nSWR4XVxuICAgIGNsaWVudFtrUnVubmluZ0lkeF0gPSAwXG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc3VtZSAoY2xpZW50LCBzeW5jKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1BlbmRpbmddID09PSAwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0gJiYgIWNsaWVudFtrU2l6ZV0pIHtcbiAgICAgIGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0oKVxuICAgICAgY2xpZW50W2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHNvY2tldCA9IGNsaWVudFtrU29ja2V0XVxuXG4gICAgaWYgKHNvY2tldCAmJiAhc29ja2V0LmRlc3Ryb3llZCAmJiBzb2NrZXQuYWxwblByb3RvY29sICE9PSAnaDInKSB7XG4gICAgICBpZiAoY2xpZW50W2tTaXplXSA9PT0gMCkge1xuICAgICAgICBpZiAoIXNvY2tldFtrTm9SZWZdICYmIHNvY2tldC51bnJlZikge1xuICAgICAgICAgIHNvY2tldC51bnJlZigpXG4gICAgICAgICAgc29ja2V0W2tOb1JlZl0gPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc29ja2V0W2tOb1JlZl0gJiYgc29ja2V0LnJlZikge1xuICAgICAgICBzb2NrZXQucmVmKClcbiAgICAgICAgc29ja2V0W2tOb1JlZl0gPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoY2xpZW50W2tTaXplXSA9PT0gMCkge1xuICAgICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlICE9PSBUSU1FT1VUX0lETEUpIHtcbiAgICAgICAgICBzb2NrZXRba1BhcnNlcl0uc2V0VGltZW91dChjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0sIFRJTUVPVVRfSURMRSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiBzb2NrZXRba1BhcnNlcl0uc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlICE9PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICAgICAgICBjb25zdCBoZWFkZXJzVGltZW91dCA9IHJlcXVlc3QuaGVhZGVyc1RpbWVvdXQgIT0gbnVsbFxuICAgICAgICAgICAgPyByZXF1ZXN0LmhlYWRlcnNUaW1lb3V0XG4gICAgICAgICAgICA6IGNsaWVudFtrSGVhZGVyc1RpbWVvdXRdXG4gICAgICAgICAgc29ja2V0W2tQYXJzZXJdLnNldFRpbWVvdXQoaGVhZGVyc1RpbWVvdXQsIFRJTUVPVVRfSEVBREVSUylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0J1c3ldKSB7XG4gICAgICBjbGllbnRba05lZWREcmFpbl0gPSAyXG4gICAgfSBlbHNlIGlmIChjbGllbnRba05lZWREcmFpbl0gPT09IDIpIHtcbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIGNsaWVudFtrTmVlZERyYWluXSA9IDFcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RHJhaW4sIGNsaWVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXREcmFpbihjbGllbnQpXG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1BlbmRpbmddID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+PSAoY2xpZW50W2tQaXBlbGluaW5nXSB8fCAxKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUGVuZGluZ0lkeF1dXG5cbiAgICBpZiAoY2xpZW50W2tVcmxdLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiBjbGllbnRba1NlcnZlck5hbWVdICE9PSByZXF1ZXN0LnNlcnZlcm5hbWUpIHtcbiAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY2xpZW50W2tTZXJ2ZXJOYW1lXSA9IHJlcXVlc3Quc2VydmVybmFtZVxuXG4gICAgICBpZiAoc29ja2V0ICYmIHNvY2tldC5zZXJ2ZXJuYW1lICE9PSByZXF1ZXN0LnNlcnZlcm5hbWUpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcignc2VydmVybmFtZSBjaGFuZ2VkJykpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0Nvbm5lY3RpbmddKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIXNvY2tldCAmJiAhY2xpZW50W2tIVFRQMlNlc3Npb25dKSB7XG4gICAgICBjb25uZWN0KGNsaWVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkIHx8IHNvY2tldFtrV3JpdGluZ10gfHwgc29ja2V0W2tSZXNldF0gfHwgc29ja2V0W2tCbG9ja2luZ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAhcmVxdWVzdC5pZGVtcG90ZW50KSB7XG4gICAgICAvLyBOb24taWRlbXBvdGVudCByZXF1ZXN0IGNhbm5vdCBiZSByZXRyaWVkLlxuICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gb3RoZXIgcmVxdWVzdHMgYXJlIGluZmxpZ2h0IGFuZFxuICAgICAgLy8gY291bGQgY2F1c2UgZmFpbHVyZS5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAocmVxdWVzdC51cGdyYWRlIHx8IHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpKSB7XG4gICAgICAvLyBEb24ndCBkaXNwYXRjaCBhbiB1cGdyYWRlIHVudGlsIGFsbCBwcmVjZWRpbmcgcmVxdWVzdHMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICAvLyBBIG1pc2JlaGF2aW5nIHNlcnZlciBtaWdodCB1cGdyYWRlIHRoZSBjb25uZWN0aW9uIGJlZm9yZSBhbGwgcGlwZWxpbmVkXG4gICAgICAvLyByZXF1ZXN0IGhhcyBjb21wbGV0ZWQuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgdXRpbC5ib2R5TGVuZ3RoKHJlcXVlc3QuYm9keSkgIT09IDAgJiZcbiAgICAgICh1dGlsLmlzU3RyZWFtKHJlcXVlc3QuYm9keSkgfHwgdXRpbC5pc0FzeW5jSXRlcmFibGUocmVxdWVzdC5ib2R5KSkpIHtcbiAgICAgIC8vIFJlcXVlc3Qgd2l0aCBzdHJlYW0gb3IgaXRlcmF0b3IgYm9keSBjYW4gZXJyb3Igd2hpbGUgb3RoZXIgcmVxdWVzdHNcbiAgICAgIC8vIGFyZSBpbmZsaWdodCBhbmQgaW5kaXJlY3RseSBlcnJvciB0aG9zZSBhcyB3ZWxsLlxuICAgICAgLy8gRW5zdXJlIHRoaXMgZG9lc24ndCBoYXBwZW4gYnkgd2FpdGluZyBmb3IgaW5mbGlnaHRcbiAgICAgIC8vIHRvIGNvbXBsZXRlIGJlZm9yZSBkaXNwYXRjaGluZy5cblxuICAgICAgLy8gUmVxdWVzdCB3aXRoIHN0cmVhbSBvciBpdGVyYXRvciBib2R5IGNhbm5vdCBiZSByZXRyaWVkLlxuICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gb3RoZXIgcmVxdWVzdHMgYXJlIGluZmxpZ2h0IGFuZFxuICAgICAgLy8gY291bGQgY2F1c2UgZmFpbHVyZS5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghcmVxdWVzdC5hYm9ydGVkICYmIHdyaXRlKGNsaWVudCwgcmVxdWVzdCkpIHtcbiAgICAgIGNsaWVudFtrUGVuZGluZ0lkeF0rK1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tQZW5kaW5nSWR4XSwgMSlcbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuZnVuY3Rpb24gc2hvdWxkU2VuZENvbnRlbnRMZW5ndGggKG1ldGhvZCkge1xuICByZXR1cm4gbWV0aG9kICE9PSAnR0VUJyAmJiBtZXRob2QgIT09ICdIRUFEJyAmJiBtZXRob2QgIT09ICdPUFRJT05TJyAmJiBtZXRob2QgIT09ICdUUkFDRScgJiYgbWV0aG9kICE9PSAnQ09OTkVDVCdcbn1cblxuZnVuY3Rpb24gd3JpdGUgKGNsaWVudCwgcmVxdWVzdCkge1xuICBpZiAoY2xpZW50W2tIVFRQQ29ublZlcnNpb25dID09PSAnaDInKSB7XG4gICAgd3JpdGVIMihjbGllbnQsIGNsaWVudFtrSFRUUDJTZXNzaW9uXSwgcmVxdWVzdClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHsgYm9keSwgbWV0aG9kLCBwYXRoLCBob3N0LCB1cGdyYWRlLCBoZWFkZXJzLCBibG9ja2luZywgcmVzZXQgfSA9IHJlcXVlc3RcblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4xXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjJcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuNVxuXG4gIC8vIFNlbmRpbmcgYSBwYXlsb2FkIGJvZHkgb24gYSByZXF1ZXN0IHRoYXQgZG9lcyBub3RcbiAgLy8gZXhwZWN0IGl0IGNhbiBjYXVzZSB1bmRlZmluZWQgYmVoYXZpb3Igb24gc29tZVxuICAvLyBzZXJ2ZXJzIGFuZCBjb3JydXB0IGNvbm5lY3Rpb24gc3RhdGUuIERvIG5vdFxuICAvLyByZS11c2UgdGhlIGNvbm5lY3Rpb24gZm9yIGZ1cnRoZXIgcmVxdWVzdHMuXG5cbiAgY29uc3QgZXhwZWN0c1BheWxvYWQgPSAoXG4gICAgbWV0aG9kID09PSAnUFVUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BPU1QnIHx8XG4gICAgbWV0aG9kID09PSAnUEFUQ0gnXG4gIClcblxuICBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVHJ5IHRvIHJlYWQgRU9GIGluIG9yZGVyIHRvIGdldCBsZW5ndGguXG4gICAgYm9keS5yZWFkKDApXG4gIH1cblxuICBjb25zdCBib2R5TGVuZ3RoID0gdXRpbC5ib2R5TGVuZ3RoKGJvZHkpXG5cbiAgbGV0IGNvbnRlbnRMZW5ndGggPSBib2R5TGVuZ3RoXG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoID0gcmVxdWVzdC5jb250ZW50TGVuZ3RoXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCA9PT0gMCAmJiAhZXhwZWN0c1BheWxvYWQpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG4gICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBOT1Qgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZCB3aGVuXG4gICAgLy8gdGhlIHJlcXVlc3QgbWVzc2FnZSBkb2VzIG5vdCBjb250YWluIGEgcGF5bG9hZCBib2R5IGFuZCB0aGUgbWV0aG9kXG4gICAgLy8gc2VtYW50aWNzIGRvIG5vdCBhbnRpY2lwYXRlIHN1Y2ggYSBib2R5LlxuXG4gICAgY29udGVudExlbmd0aCA9IG51bGxcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDQ2XG4gIC8vIEEgdXNlciBhZ2VudCBtYXkgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciB3aXRoIDAgdmFsdWUsIHRoaXMgc2hvdWxkIGJlIGFsbG93ZWQuXG4gIGlmIChzaG91bGRTZW5kQ29udGVudExlbmd0aChtZXRob2QpICYmIGNvbnRlbnRMZW5ndGggPiAwICYmIHJlcXVlc3QuY29udGVudExlbmd0aCAhPT0gbnVsbCAmJiByZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT09IGNvbnRlbnRMZW5ndGgpIHtcbiAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gIH1cblxuICBjb25zdCBzb2NrZXQgPSBjbGllbnRba1NvY2tldF1cblxuICB0cnkge1xuICAgIHJlcXVlc3Qub25Db25uZWN0KChlcnIpID0+IHtcbiAgICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQgfHwgcmVxdWVzdC5jb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVyciB8fCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdhYm9ydGVkJykpXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICB9XG5cbiAgaWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21jb2xsaW5hL3VuZGljaS9pc3N1ZXMvMjU4XG4gICAgLy8gQ2xvc2UgYWZ0ZXIgYSBIRUFEIHJlcXVlc3QgdG8gaW50ZXJvcCB3aXRoIG1pc2JlaGF2aW5nIHNlcnZlcnNcbiAgICAvLyB0aGF0IG1heSBzZW5kIGEgYm9keSBpbiB0aGUgcmVzcG9uc2UuXG5cbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmICh1cGdyYWRlIHx8IG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgLy8gT24gQ09OTkVDVCBvciB1cGdyYWRlLCBibG9jayBwaXBlbGluZSBmcm9tIGRpc3BhdGNoaW5nIGZ1cnRoZXJcbiAgICAvLyByZXF1ZXN0cyBvbiB0aGlzIGNvbm5lY3Rpb24uXG5cbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmIChyZXNldCAhPSBudWxsKSB7XG4gICAgc29ja2V0W2tSZXNldF0gPSByZXNldFxuICB9XG5cbiAgaWYgKGNsaWVudFtrTWF4UmVxdWVzdHNdICYmIHNvY2tldFtrQ291bnRlcl0rKyA+PSBjbGllbnRba01heFJlcXVlc3RzXSkge1xuICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICB9XG5cbiAgaWYgKGJsb2NraW5nKSB7XG4gICAgc29ja2V0W2tCbG9ja2luZ10gPSB0cnVlXG4gIH1cblxuICBsZXQgaGVhZGVyID0gYCR7bWV0aG9kfSAke3BhdGh9IEhUVFAvMS4xXFxyXFxuYFxuXG4gIGlmICh0eXBlb2YgaG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICBoZWFkZXIgKz0gYGhvc3Q6ICR7aG9zdH1cXHJcXG5gXG4gIH0gZWxzZSB7XG4gICAgaGVhZGVyICs9IGNsaWVudFtrSG9zdEhlYWRlcl1cbiAgfVxuXG4gIGlmICh1cGdyYWRlKSB7XG4gICAgaGVhZGVyICs9IGBjb25uZWN0aW9uOiB1cGdyYWRlXFxyXFxudXBncmFkZTogJHt1cGdyYWRlfVxcclxcbmBcbiAgfSBlbHNlIGlmIChjbGllbnRba1BpcGVsaW5pbmddICYmICFzb2NrZXRba1Jlc2V0XSkge1xuICAgIGhlYWRlciArPSAnY29ubmVjdGlvbjoga2VlcC1hbGl2ZVxcclxcbidcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXIgKz0gJ2Nvbm5lY3Rpb246IGNsb3NlXFxyXFxuJ1xuICB9XG5cbiAgaWYgKGhlYWRlcnMpIHtcbiAgICBoZWFkZXIgKz0gaGVhZGVyc1xuICB9XG5cbiAgaWYgKGNoYW5uZWxzLnNlbmRIZWFkZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuc2VuZEhlYWRlcnMucHVibGlzaCh7IHJlcXVlc3QsIGhlYWRlcnM6IGhlYWRlciwgc29ja2V0IH0pXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogYXNzZXJ0aW9uICovXG4gIGlmICghYm9keSB8fCBib2R5TGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IDApIHtcbiAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6IDBcXHJcXG5cXHJcXG5gLCAnbGF0aW4xJylcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IG51bGwsICdubyBib2R5IG11c3Qgbm90IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1cXHJcXG5gLCAnbGF0aW4xJylcbiAgICB9XG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuYnl0ZUxlbmd0aCwgJ2J1ZmZlciBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG5cbiAgICBzb2NrZXQuY29yaygpXG4gICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogJHtjb250ZW50TGVuZ3RofVxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgIHNvY2tldC53cml0ZShib2R5KVxuICAgIHNvY2tldC51bmNvcmsoKVxuICAgIHJlcXVlc3Qub25Cb2R5U2VudChib2R5KVxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG4gICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgfVxuICB9IGVsc2UgaWYgKHV0aWwuaXNCbG9iTGlrZShib2R5KSkge1xuICAgIGlmICh0eXBlb2YgYm9keS5zdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdyaXRlSXRlcmFibGUoeyBib2R5OiBib2R5LnN0cmVhbSgpLCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZUJsb2IoeyBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KVxuICAgIH1cbiAgfSBlbHNlIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgd3JpdGVTdHJlYW0oeyBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KVxuICB9IGVsc2UgaWYgKHV0aWwuaXNJdGVyYWJsZShib2R5KSkge1xuICAgIHdyaXRlSXRlcmFibGUoeyBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHdyaXRlSDIgKGNsaWVudCwgc2Vzc2lvbiwgcmVxdWVzdCkge1xuICBjb25zdCB7IGJvZHksIG1ldGhvZCwgcGF0aCwgaG9zdCwgdXBncmFkZSwgZXhwZWN0Q29udGludWUsIHNpZ25hbCwgaGVhZGVyczogcmVxSGVhZGVycyB9ID0gcmVxdWVzdFxuXG4gIGxldCBoZWFkZXJzXG4gIGlmICh0eXBlb2YgcmVxSGVhZGVycyA9PT0gJ3N0cmluZycpIGhlYWRlcnMgPSBSZXF1ZXN0W2tIVFRQMkNvcHlIZWFkZXJzXShyZXFIZWFkZXJzLnRyaW0oKSlcbiAgZWxzZSBoZWFkZXJzID0gcmVxSGVhZGVyc1xuXG4gIGlmICh1cGdyYWRlKSB7XG4gICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IEVycm9yKCdVcGdyYWRlIG5vdCBzdXBwb3J0ZWQgZm9yIEgyJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRPRE8oSFRUUC8yKTogU2hvdWxkIHdlIGNhbGwgb25Db25uZWN0IGltbWVkaWF0ZWx5IG9yIG9uIHN0cmVhbSByZWFkeSBldmVudD9cbiAgICByZXF1ZXN0Lm9uQ29ubmVjdCgoZXJyKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdC5hYm9ydGVkIHx8IHJlcXVlc3QuY29tcGxldGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIgfHwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gIH1cblxuICBpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBsZXQgc3RyZWFtXG4gIGNvbnN0IGgyU3RhdGUgPSBjbGllbnRba0hUVFAyU2Vzc2lvblN0YXRlXVxuXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX0FVVEhPUklUWV0gPSBob3N0IHx8IGNsaWVudFtrSG9zdF1cbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfTUVUSE9EXSA9IG1ldGhvZFxuXG4gIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgIHNlc3Npb24ucmVmKClcbiAgICAvLyB3ZSBhcmUgYWxyZWFkeSBjb25uZWN0ZWQsIHN0cmVhbXMgYXJlIHBlbmRpbmcsIGZpcnN0IHJlcXVlc3RcbiAgICAvLyB3aWxsIGNyZWF0ZSBhIG5ldyBzdHJlYW0uIFdlIHRyaWdnZXIgYSByZXF1ZXN0IHRvIGNyZWF0ZSB0aGUgc3RyZWFtIGFuZCB3YWl0IHVudGlsXG4gICAgLy8gYHJlYWR5YCBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICAvLyBXZSBkaXNhYmxlZCBlbmRTdHJlYW0gdG8gYWxsb3cgdGhlIHVzZXIgdG8gd3JpdGUgdG8gdGhlIHN0cmVhbVxuICAgIHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCB7IGVuZFN0cmVhbTogZmFsc2UsIHNpZ25hbCB9KVxuXG4gICAgaWYgKHN0cmVhbS5pZCAmJiAhc3RyZWFtLnBlbmRpbmcpIHtcbiAgICAgIHJlcXVlc3Qub25VcGdyYWRlKG51bGwsIG51bGwsIHN0cmVhbSlcbiAgICAgICsraDJTdGF0ZS5vcGVuU3RyZWFtc1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ub25jZSgncmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHJlcXVlc3Qub25VcGdyYWRlKG51bGwsIG51bGwsIHN0cmVhbSlcbiAgICAgICAgKytoMlN0YXRlLm9wZW5TdHJlYW1zXG4gICAgICB9KVxuICAgIH1cblxuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgIGgyU3RhdGUub3BlblN0cmVhbXMgLT0gMVxuICAgICAgLy8gVE9ETyhIVFRQLzIpOiB1bnJlZiBvbmx5IGlmIGN1cnJlbnQgc3RyZWFtcyBjb3VudCBpcyAwXG4gICAgICBpZiAoaDJTdGF0ZS5vcGVuU3RyZWFtcyA9PT0gMCkgc2Vzc2lvbi51bnJlZigpXG4gICAgfSlcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzU0MCNzZWN0aW9uLTguM1xuICAvLyA6cGF0aCBhbmQgOnNjaGVtZSBoZWFkZXJzIG11c3QgYmUgb21pdGVkIHdoZW4gc2VuZGluZyBDT05ORUNUXG5cbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfUEFUSF0gPSBwYXRoXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX1NDSEVNRV0gPSAnaHR0cHMnXG5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4yXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjVcblxuICAvLyBTZW5kaW5nIGEgcGF5bG9hZCBib2R5IG9uIGEgcmVxdWVzdCB0aGF0IGRvZXMgbm90XG4gIC8vIGV4cGVjdCBpdCBjYW4gY2F1c2UgdW5kZWZpbmVkIGJlaGF2aW9yIG9uIHNvbWVcbiAgLy8gc2VydmVycyBhbmQgY29ycnVwdCBjb25uZWN0aW9uIHN0YXRlLiBEbyBub3RcbiAgLy8gcmUtdXNlIHRoZSBjb25uZWN0aW9uIGZvciBmdXJ0aGVyIHJlcXVlc3RzLlxuXG4gIGNvbnN0IGV4cGVjdHNQYXlsb2FkID0gKFxuICAgIG1ldGhvZCA9PT0gJ1BVVCcgfHxcbiAgICBtZXRob2QgPT09ICdQT1NUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BBVENIJ1xuICApXG5cbiAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRyeSB0byByZWFkIEVPRiBpbiBvcmRlciB0byBnZXQgbGVuZ3RoLlxuICAgIGJvZHkucmVhZCgwKVxuICB9XG5cbiAgbGV0IGNvbnRlbnRMZW5ndGggPSB1dGlsLmJvZHlMZW5ndGgoYm9keSlcblxuICBpZiAoY29udGVudExlbmd0aCA9PSBudWxsKSB7XG4gICAgY29udGVudExlbmd0aCA9IHJlcXVlc3QuY29udGVudExlbmd0aFxuICB9XG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT09IDAgfHwgIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuICAgIC8vIEEgdXNlciBhZ2VudCBTSE9VTEQgTk9UIHNlbmQgYSBDb250ZW50LUxlbmd0aCBoZWFkZXIgZmllbGQgd2hlblxuICAgIC8vIHRoZSByZXF1ZXN0IG1lc3NhZ2UgZG9lcyBub3QgY29udGFpbiBhIHBheWxvYWQgYm9keSBhbmQgdGhlIG1ldGhvZFxuICAgIC8vIHNlbWFudGljcyBkbyBub3QgYW50aWNpcGF0ZSBzdWNoIGEgYm9keS5cblxuICAgIGNvbnRlbnRMZW5ndGggPSBudWxsXG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjA0NlxuICAvLyBBIHVzZXIgYWdlbnQgbWF5IHNlbmQgYSBDb250ZW50LUxlbmd0aCBoZWFkZXIgd2l0aCAwIHZhbHVlLCB0aGlzIHNob3VsZCBiZSBhbGxvd2VkLlxuICBpZiAoc2hvdWxkU2VuZENvbnRlbnRMZW5ndGgobWV0aG9kKSAmJiBjb250ZW50TGVuZ3RoID4gMCAmJiByZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiByZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT09IGNvbnRlbnRMZW5ndGgpIHtcbiAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsKSB7XG4gICAgYXNzZXJ0KGJvZHksICdubyBib2R5IG11c3Qgbm90IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0NPTlRFTlRfTEVOR1RIXSA9IGAke2NvbnRlbnRMZW5ndGh9YFxuICB9XG5cbiAgc2Vzc2lvbi5yZWYoKVxuXG4gIGNvbnN0IHNob3VsZEVuZFN0cmVhbSA9IG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnSEVBRCdcbiAgaWYgKGV4cGVjdENvbnRpbnVlKSB7XG4gICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfRVhQRUNUXSA9ICcxMDAtY29udGludWUnXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydCgnbm9kZTpodHRwMicpLkNsaWVudEh0dHAyU3RyZWFtfVxuICAgICAqL1xuICAgIHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCB7IGVuZFN0cmVhbTogc2hvdWxkRW5kU3RyZWFtLCBzaWduYWwgfSlcblxuICAgIHN0cmVhbS5vbmNlKCdjb250aW51ZScsIHdyaXRlQm9keUgyKVxuICB9IGVsc2Uge1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCdub2RlOmh0dHAyJykuQ2xpZW50SHR0cDJTdHJlYW19ICovXG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHtcbiAgICAgIGVuZFN0cmVhbTogc2hvdWxkRW5kU3RyZWFtLFxuICAgICAgc2lnbmFsXG4gICAgfSlcbiAgICB3cml0ZUJvZHlIMigpXG4gIH1cblxuICAvLyBJbmNyZW1lbnQgY291bnRlciBhcyB3ZSBoYXZlIG5ldyBzZXZlcmFsIHN0cmVhbXMgb3BlblxuICArK2gyU3RhdGUub3BlblN0cmVhbXNcblxuICBzdHJlYW0ub25jZSgncmVzcG9uc2UnLCBoZWFkZXJzID0+IHtcbiAgICBpZiAocmVxdWVzdC5vbkhlYWRlcnMoTnVtYmVyKGhlYWRlcnNbSFRUUDJfSEVBREVSX1NUQVRVU10pLCBoZWFkZXJzLCBzdHJlYW0ucmVzdW1lLmJpbmQoc3RyZWFtKSwgJycpID09PSBmYWxzZSkge1xuICAgICAgc3RyZWFtLnBhdXNlKClcbiAgICB9XG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2VuZCcsICgpID0+IHtcbiAgICByZXF1ZXN0Lm9uQ29tcGxldGUoW10pXG4gIH0pXG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgaWYgKHJlcXVlc3Qub25EYXRhKGNodW5rKSA9PT0gZmFsc2UpIHN0cmVhbS5wYXVzZSgpXG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgIGgyU3RhdGUub3BlblN0cmVhbXMgLT0gMVxuICAgIC8vIFRPRE8oSFRUUC8yKTogdW5yZWYgb25seSBpZiBjdXJyZW50IHN0cmVhbXMgY291bnQgaXMgMFxuICAgIGlmIChoMlN0YXRlLm9wZW5TdHJlYW1zID09PSAwKSBzZXNzaW9uLnVucmVmKClcbiAgfSlcblxuICBzdHJlYW0ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsaWVudFtrSFRUUDJTZXNzaW9uXSAmJiAhY2xpZW50W2tIVFRQMlNlc3Npb25dLmRlc3Ryb3llZCAmJiAhdGhpcy5jbG9zZWQgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICBoMlN0YXRlLnN0cmVhbXMgLT0gMVxuICAgICAgdXRpbC5kZXN0cm95KHN0cmVhbSwgZXJyKVxuICAgIH1cbiAgfSlcblxuICBzdHJlYW0ub25jZSgnZnJhbWVFcnJvcicsICh0eXBlLCBjb2RlKSA9PiB7XG4gICAgY29uc3QgZXJyID0gbmV3IEluZm9ybWF0aW9uYWxFcnJvcihgSFRUUC8yOiBcImZyYW1lRXJyb3JcIiByZWNlaXZlZCAtIHR5cGUgJHt0eXBlfSwgY29kZSAke2NvZGV9YClcbiAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG5cbiAgICBpZiAoY2xpZW50W2tIVFRQMlNlc3Npb25dICYmICFjbGllbnRba0hUVFAyU2Vzc2lvbl0uZGVzdHJveWVkICYmICF0aGlzLmNsb3NlZCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIGgyU3RhdGUuc3RyZWFtcyAtPSAxXG4gICAgICB1dGlsLmRlc3Ryb3koc3RyZWFtLCBlcnIpXG4gICAgfVxuICB9KVxuXG4gIC8vIHN0cmVhbS5vbignYWJvcnRlZCcsICgpID0+IHtcbiAgLy8gICAvLyBUT0RPKEhUVFAvMik6IFN1cHBvcnQgYWJvcnRlZFxuICAvLyB9KVxuXG4gIC8vIHN0cmVhbS5vbigndGltZW91dCcsICgpID0+IHtcbiAgLy8gICAvLyBUT0RPKEhUVFAvMik6IFN1cHBvcnQgdGltZW91dFxuICAvLyB9KVxuXG4gIC8vIHN0cmVhbS5vbigncHVzaCcsIGhlYWRlcnMgPT4ge1xuICAvLyAgIC8vIFRPRE8oSFRUUC8yKTogU3VwcG9yIHB1c2hcbiAgLy8gfSlcblxuICAvLyBzdHJlYW0ub24oJ3RyYWlsZXJzJywgaGVhZGVycyA9PiB7XG4gIC8vICAgLy8gVE9ETyhIVFRQLzIpOiBTdXBwb3J0IHRyYWlsZXJzXG4gIC8vIH0pXG5cbiAgcmV0dXJuIHRydWVcblxuICBmdW5jdGlvbiB3cml0ZUJvZHlIMiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGFzc2VydGlvbiAqL1xuICAgIGlmICghYm9keSkge1xuICAgICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBib2R5LmJ5dGVMZW5ndGgsICdidWZmZXIgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgICAgc3RyZWFtLmNvcmsoKVxuICAgICAgc3RyZWFtLndyaXRlKGJvZHkpXG4gICAgICBzdHJlYW0udW5jb3JrKClcbiAgICAgIHN0cmVhbS5lbmQoKVxuICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGJvZHkpXG4gICAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0Jsb2JMaWtlKGJvZHkpKSB7XG4gICAgICBpZiAodHlwZW9mIGJvZHkuc3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdyaXRlSXRlcmFibGUoe1xuICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgaDJzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgICBleHBlY3RzUGF5bG9hZCxcbiAgICAgICAgICBib2R5OiBib2R5LnN0cmVhbSgpLFxuICAgICAgICAgIHNvY2tldDogY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICAgIGhlYWRlcjogJydcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQmxvYih7XG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICAgIGV4cGVjdHNQYXlsb2FkLFxuICAgICAgICAgIGgyc3RyZWFtOiBzdHJlYW0sXG4gICAgICAgICAgaGVhZGVyOiAnJyxcbiAgICAgICAgICBzb2NrZXQ6IGNsaWVudFtrU29ja2V0XVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgd3JpdGVTdHJlYW0oe1xuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgIGV4cGVjdHNQYXlsb2FkLFxuICAgICAgICBzb2NrZXQ6IGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgaDJzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgaGVhZGVyOiAnJ1xuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNJdGVyYWJsZShib2R5KSkge1xuICAgICAgd3JpdGVJdGVyYWJsZSh7XG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgZXhwZWN0c1BheWxvYWQsXG4gICAgICAgIGhlYWRlcjogJycsXG4gICAgICAgIGgyc3RyZWFtOiBzdHJlYW0sXG4gICAgICAgIHNvY2tldDogY2xpZW50W2tTb2NrZXRdXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3RyZWFtICh7IGgyc3RyZWFtLCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsICdzdHJlYW0gYm9keSBjYW5ub3QgYmUgcGlwZWxpbmVkJylcblxuICBpZiAoY2xpZW50W2tIVFRQQ29ublZlcnNpb25dID09PSAnaDInKSB7XG4gICAgLy8gRm9yIEhUVFAvMiwgaXMgZW5vdWdoIHRvIHBpcGUgdGhlIHN0cmVhbVxuICAgIGNvbnN0IHBpcGUgPSBwaXBlbGluZShcbiAgICAgIGJvZHksXG4gICAgICBoMnN0cmVhbSxcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgICAgICAgdXRpbC5kZXN0cm95KGgyc3RyZWFtLCBlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcblxuICAgIHBpcGUub24oJ2RhdGEnLCBvblBpcGVEYXRhKVxuICAgIHBpcGUub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgcGlwZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uUGlwZURhdGEpXG4gICAgICB1dGlsLmRlc3Ryb3kocGlwZSlcbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gb25QaXBlRGF0YSAoY2h1bmspIHtcbiAgICAgIHJlcXVlc3Qub25Cb2R5U2VudChjaHVuaylcbiAgICB9XG5cbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBmaW5pc2hlZCA9IGZhbHNlXG5cbiAgY29uc3Qgd3JpdGVyID0gbmV3IEFzeW5jV3JpdGVyKHsgc29ja2V0LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSlcblxuICBjb25zdCBvbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAoIXdyaXRlci53cml0ZShjaHVuaykgJiYgdGhpcy5wYXVzZSkge1xuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveSh0aGlzLCBlcnIpXG4gICAgfVxuICB9XG4gIGNvbnN0IG9uRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYm9keS5yZXN1bWUpIHtcbiAgICAgIGJvZHkucmVzdW1lKClcbiAgICB9XG4gIH1cbiAgY29uc3Qgb25BYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkZpbmlzaGVkKG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpXG4gIH1cbiAgY29uc3Qgb25GaW5pc2hlZCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZpbmlzaGVkID0gdHJ1ZVxuXG4gICAgYXNzZXJ0KHNvY2tldC5kZXN0cm95ZWQgfHwgKHNvY2tldFtrV3JpdGluZ10gJiYgY2xpZW50W2tSdW5uaW5nXSA8PSAxKSlcblxuICAgIHNvY2tldFxuICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICAgICAgLm9mZignZXJyb3InLCBvbkZpbmlzaGVkKVxuXG4gICAgYm9keVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRmluaXNoZWQpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25BYm9ydClcblxuICAgIGlmICghZXJyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3cml0ZXIuZW5kKClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGVyciA9IGVyXG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVyLmRlc3Ryb3koZXJyKVxuXG4gICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgIT09ICdVTkRfRVJSX0lORk8nIHx8IGVyci5tZXNzYWdlICE9PSAncmVzZXQnKSkge1xuICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5kZXN0cm95KGJvZHkpXG4gICAgfVxuICB9XG5cbiAgYm9keVxuICAgIC5vbignZGF0YScsIG9uRGF0YSlcbiAgICAub24oJ2VuZCcsIG9uRmluaXNoZWQpXG4gICAgLm9uKCdlcnJvcicsIG9uRmluaXNoZWQpXG4gICAgLm9uKCdjbG9zZScsIG9uQWJvcnQpXG5cbiAgaWYgKGJvZHkucmVzdW1lKSB7XG4gICAgYm9keS5yZXN1bWUoKVxuICB9XG5cbiAgc29ja2V0XG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG4gICAgLm9uKCdlcnJvcicsIG9uRmluaXNoZWQpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQmxvYiAoeyBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQgfSkge1xuICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gYm9keS5zaXplLCAnYmxvYiBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG5cbiAgY29uc3QgaXNIMiA9IGNsaWVudFtrSFRUUENvbm5WZXJzaW9uXSA9PT0gJ2gyJ1xuICB0cnkge1xuICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgY29udGVudExlbmd0aCAhPT0gYm9keS5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBib2R5LmFycmF5QnVmZmVyKCkpXG5cbiAgICBpZiAoaXNIMikge1xuICAgICAgaDJzdHJlYW0uY29yaygpXG4gICAgICBoMnN0cmVhbS53cml0ZShidWZmZXIpXG4gICAgICBoMnN0cmVhbS51bmNvcmsoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQuY29yaygpXG4gICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICBzb2NrZXQud3JpdGUoYnVmZmVyKVxuICAgICAgc29ja2V0LnVuY29yaygpXG4gICAgfVxuXG4gICAgcmVxdWVzdC5vbkJvZHlTZW50KGJ1ZmZlcilcbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuXG4gICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgfVxuXG4gICAgcmVzdW1lKGNsaWVudClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdXRpbC5kZXN0cm95KGlzSDIgPyBoMnN0cmVhbSA6IHNvY2tldCwgZXJyKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSXRlcmFibGUgKHsgaDJzdHJlYW0sIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ2l0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgbGV0IGNhbGxiYWNrID0gbnVsbFxuICBmdW5jdGlvbiBvbkRyYWluICgpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgY2IoKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHdhaXRGb3JEcmFpbiA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhc3NlcnQoY2FsbGJhY2sgPT09IG51bGwpXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHJlamVjdChzb2NrZXRba0Vycm9yXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSByZXNvbHZlXG4gICAgfVxuICB9KVxuXG4gIGlmIChjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gPT09ICdoMicpIHtcbiAgICBoMnN0cmVhbVxuICAgICAgLm9uKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgICAub24oJ2RyYWluJywgb25EcmFpbilcblxuICAgIHRyeSB7XG4gICAgICAvLyBJdCdzIHVwIHRvIHRoZSB1c2VyIHRvIHNvbWVob3cgYWJvcnQgdGhlIGFzeW5jIGl0ZXJhYmxlLlxuICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBib2R5KSB7XG4gICAgICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXMgPSBoMnN0cmVhbS53cml0ZShjaHVuaylcbiAgICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGNodW5rKVxuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgIGF3YWl0IHdhaXRGb3JEcmFpbigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGgyc3RyZWFtLmRlc3Ryb3koZXJyKVxuICAgIH0gZmluYWxseSB7XG4gICAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuICAgICAgaDJzdHJlYW0uZW5kKClcbiAgICAgIGgyc3RyZWFtXG4gICAgICAgIC5vZmYoJ2Nsb3NlJywgb25EcmFpbilcbiAgICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICAgIH1cblxuICAgIHJldHVyblxuICB9XG5cbiAgc29ja2V0XG4gICAgLm9uKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG5cbiAgY29uc3Qgd3JpdGVyID0gbmV3IEFzeW5jV3JpdGVyKHsgc29ja2V0LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSlcbiAgdHJ5IHtcbiAgICAvLyBJdCdzIHVwIHRvIHRoZSB1c2VyIHRvIHNvbWVob3cgYWJvcnQgdGhlIGFzeW5jIGl0ZXJhYmxlLlxuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgICB9XG5cbiAgICAgIGlmICghd3JpdGVyLndyaXRlKGNodW5rKSkge1xuICAgICAgICBhd2FpdCB3YWl0Rm9yRHJhaW4oKVxuICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlci5lbmQoKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB3cml0ZXIuZGVzdHJveShlcnIpXG4gIH0gZmluYWxseSB7XG4gICAgc29ja2V0XG4gICAgICAub2ZmKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgICAub2ZmKCdkcmFpbicsIG9uRHJhaW4pXG4gIH1cbn1cblxuY2xhc3MgQXN5bmNXcml0ZXIge1xuICBjb25zdHJ1Y3RvciAoeyBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KSB7XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gICAgdGhpcy5jb250ZW50TGVuZ3RoID0gY29udGVudExlbmd0aFxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwXG4gICAgdGhpcy5leHBlY3RzUGF5bG9hZCA9IGV4cGVjdHNQYXlsb2FkXG4gICAgdGhpcy5oZWFkZXIgPSBoZWFkZXJcblxuICAgIHNvY2tldFtrV3JpdGluZ10gPSB0cnVlXG4gIH1cblxuICB3cml0ZSAoY2h1bmspIHtcbiAgICBjb25zdCB7IHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBieXRlc1dyaXR0ZW4sIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmspXG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gV2Ugc2hvdWxkIGRlZmVyIHdyaXRpbmcgY2h1bmtzLlxuICAgIGlmIChjb250ZW50TGVuZ3RoICE9PSBudWxsICYmIGJ5dGVzV3JpdHRlbiArIGxlbiA+IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICB9XG5cbiAgICBzb2NrZXQuY29yaygpXG5cbiAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG4gICAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfXRyYW5zZmVyLWVuY29kaW5nOiBjaHVua2VkXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgIHNvY2tldC53cml0ZShgXFxyXFxuJHtsZW4udG9TdHJpbmcoMTYpfVxcclxcbmAsICdsYXRpbjEnKVxuICAgIH1cblxuICAgIHRoaXMuYnl0ZXNXcml0dGVuICs9IGxlblxuXG4gICAgY29uc3QgcmV0ID0gc29ja2V0LndyaXRlKGNodW5rKVxuXG4gICAgc29ja2V0LnVuY29yaygpXG5cbiAgICByZXF1ZXN0Lm9uQm9keVNlbnQoY2h1bmspXG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0ICYmIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgICAgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBlbmQgKCkge1xuICAgIGNvbnN0IHsgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGJ5dGVzV3JpdHRlbiwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciwgcmVxdWVzdCB9ID0gdGhpc1xuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgaWYgKGV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAgICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBzZW5kIGEgQ29udGVudC1MZW5ndGggaW4gYSByZXF1ZXN0IG1lc3NhZ2Ugd2hlblxuICAgICAgICAvLyBubyBUcmFuc2Zlci1FbmNvZGluZyBpcyBzZW50IGFuZCB0aGUgcmVxdWVzdCBtZXRob2QgZGVmaW5lcyBhIG1lYW5pbmdcbiAgICAgICAgLy8gZm9yIGFuIGVuY2xvc2VkIHBheWxvYWQgYm9keS5cblxuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAwXFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfVxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgc29ja2V0LndyaXRlKCdcXHJcXG4wXFxyXFxuXFxyXFxuJywgJ2xhdGluMScpXG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgYnl0ZXNXcml0dGVuICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dCAmJiBzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VtZShjbGllbnQpXG4gIH1cblxuICBkZXN0cm95IChlcnIpIHtcbiAgICBjb25zdCB7IHNvY2tldCwgY2xpZW50IH0gPSB0aGlzXG5cbiAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddIDw9IDEsICdwaXBlbGluZSBzaG91bGQgb25seSBjb250YWluIHRoaXMgcmVxdWVzdCcpXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yUmVxdWVzdCAoY2xpZW50LCByZXF1ZXN0LCBlcnIpIHtcbiAgdHJ5IHtcbiAgICByZXF1ZXN0Lm9uRXJyb3IoZXJyKVxuICAgIGFzc2VydChyZXF1ZXN0LmFib3J0ZWQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNsaWVudC5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudFxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJuZXQiLCJodHRwIiwicGlwZWxpbmUiLCJ1dGlsIiwidGltZXJzIiwiUmVxdWVzdCIsIkRpc3BhdGNoZXJCYXNlIiwiUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIiwiUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsIkhlYWRlcnNUaW1lb3V0RXJyb3IiLCJIZWFkZXJzT3ZlcmZsb3dFcnJvciIsIlNvY2tldEVycm9yIiwiSW5mb3JtYXRpb25hbEVycm9yIiwiQm9keVRpbWVvdXRFcnJvciIsIkhUVFBQYXJzZXJFcnJvciIsIlJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IiLCJDbGllbnREZXN0cm95ZWRFcnJvciIsImJ1aWxkQ29ubmVjdG9yIiwia1VybCIsImtSZXNldCIsImtTZXJ2ZXJOYW1lIiwia0NsaWVudCIsImtCdXN5Iiwia1BhcnNlciIsImtDb25uZWN0Iiwia0Jsb2NraW5nIiwia1Jlc3VtaW5nIiwia1J1bm5pbmciLCJrUGVuZGluZyIsImtTaXplIiwia1dyaXRpbmciLCJrUXVldWUiLCJrQ29ubmVjdGVkIiwia0Nvbm5lY3RpbmciLCJrTmVlZERyYWluIiwia05vUmVmIiwia0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0Iiwia0hvc3RIZWFkZXIiLCJrUGVuZGluZ0lkeCIsImtSdW5uaW5nSWR4Iiwia0Vycm9yIiwia1BpcGVsaW5pbmciLCJrU29ja2V0Iiwia0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSIsImtNYXhIZWFkZXJzU2l6ZSIsImtLZWVwQWxpdmVNYXhUaW1lb3V0Iiwia0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQiLCJrSGVhZGVyc1RpbWVvdXQiLCJrQm9keVRpbWVvdXQiLCJrU3RyaWN0Q29udGVudExlbmd0aCIsImtDb25uZWN0b3IiLCJrTWF4UmVkaXJlY3Rpb25zIiwia01heFJlcXVlc3RzIiwia0NvdW50ZXIiLCJrQ2xvc2UiLCJrRGVzdHJveSIsImtEaXNwYXRjaCIsImtJbnRlcmNlcHRvcnMiLCJrTG9jYWxBZGRyZXNzIiwia01heFJlc3BvbnNlU2l6ZSIsImtIVFRQQ29ublZlcnNpb24iLCJrSG9zdCIsImtIVFRQMlNlc3Npb24iLCJrSFRUUDJTZXNzaW9uU3RhdGUiLCJrSFRUUDJCdWlsZFJlcXVlc3QiLCJrSFRUUDJDb3B5SGVhZGVycyIsImtIVFRQMUJ1aWxkUmVxdWVzdCIsImh0dHAyIiwiY29uc3RhbnRzIiwiSFRUUDJfSEVBREVSX0FVVEhPUklUWSIsIkhUVFAyX0hFQURFUl9NRVRIT0QiLCJIVFRQMl9IRUFERVJfUEFUSCIsIkhUVFAyX0hFQURFUl9TQ0hFTUUiLCJIVFRQMl9IRUFERVJfQ09OVEVOVF9MRU5HVEgiLCJIVFRQMl9IRUFERVJfRVhQRUNUIiwiSFRUUDJfSEVBREVSX1NUQVRVUyIsImgyRXhwZXJpbWVudGFsV2FybmVkIiwiRmFzdEJ1ZmZlciIsIkJ1ZmZlciIsIlN5bWJvbCIsInNwZWNpZXMiLCJrQ2xvc2VkUmVzb2x2ZSIsImNoYW5uZWxzIiwiZGlhZ25vc3RpY3NDaGFubmVsIiwic2VuZEhlYWRlcnMiLCJjaGFubmVsIiwiYmVmb3JlQ29ubmVjdCIsImNvbm5lY3RFcnJvciIsImNvbm5lY3RlZCIsImhhc1N1YnNjcmliZXJzIiwiQ2xpZW50IiwiY29uc3RydWN0b3IiLCJ1cmwiLCJpbnRlcmNlcHRvcnMiLCJtYXhIZWFkZXJTaXplIiwiaGVhZGVyc1RpbWVvdXQiLCJzb2NrZXRUaW1lb3V0IiwicmVxdWVzdFRpbWVvdXQiLCJjb25uZWN0VGltZW91dCIsImJvZHlUaW1lb3V0IiwiaWRsZVRpbWVvdXQiLCJrZWVwQWxpdmUiLCJrZWVwQWxpdmVUaW1lb3V0IiwibWF4S2VlcEFsaXZlVGltZW91dCIsImtlZXBBbGl2ZU1heFRpbWVvdXQiLCJrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkIiwic29ja2V0UGF0aCIsInBpcGVsaW5pbmciLCJ0bHMiLCJzdHJpY3RDb250ZW50TGVuZ3RoIiwibWF4Q2FjaGVkU2Vzc2lvbnMiLCJtYXhSZWRpcmVjdGlvbnMiLCJjb25uZWN0IiwibWF4UmVxdWVzdHNQZXJDbGllbnQiLCJsb2NhbEFkZHJlc3MiLCJtYXhSZXNwb25zZVNpemUiLCJhdXRvU2VsZWN0RmFtaWx5IiwiYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IiwiYWxsb3dIMiIsIm1heENvbmN1cnJlbnRTdHJlYW1zIiwidW5kZWZpbmVkIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpc0ludGVnZXIiLCJpc0lQIiwidGltZW91dCIsIm5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5IiwiQXJyYXkiLCJpc0FycmF5IiwiY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciIsInBhcnNlT3JpZ2luIiwiaG9zdG5hbWUiLCJwb3J0Iiwib3BlblN0cmVhbXMiLCJ2YWx1ZSIsInJlc3VtZSIsImxlbmd0aCIsImRlc3Ryb3llZCIsInNvY2tldCIsImNiIiwib25jZSIsIm9wdHMiLCJoYW5kbGVyIiwib3JpZ2luIiwicmVxdWVzdCIsInB1c2giLCJib2R5TGVuZ3RoIiwiYm9keSIsImlzSXRlcmFibGUiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsImVyciIsInJlcXVlc3RzIiwic3BsaWNlIiwiaSIsImVycm9yUmVxdWVzdCIsImNhbGxiYWNrIiwiZGVzdHJveSIsInF1ZXVlTWljcm90YXNrIiwib24iLCJvbkh0dHAyU2Vzc2lvbkVycm9yIiwiY29kZSIsIm9uRXJyb3IiLCJvbkh0dHAyRnJhbWVFcnJvciIsInR5cGUiLCJpZCIsIm9uSHR0cDJTZXNzaW9uRW5kIiwib25IVFRQMkdvQXdheSIsImNsaWVudCIsImVtaXQiLCJFTVBUWV9CVUYiLCJhbGxvYyIsImxhenlsbGh0dHAiLCJsbGh0dHBXYXNtRGF0YSIsImVudiIsIkpFU1RfV09SS0VSX0lEIiwibW9kIiwiV2ViQXNzZW1ibHkiLCJjb21waWxlIiwiZnJvbSIsImUiLCJpbnN0YW50aWF0ZSIsIndhc21fb25fdXJsIiwicCIsImF0IiwibGVuIiwid2FzbV9vbl9zdGF0dXMiLCJzdHJpY3RFcXVhbCIsImN1cnJlbnRQYXJzZXIiLCJwdHIiLCJzdGFydCIsImN1cnJlbnRCdWZmZXJQdHIiLCJjdXJyZW50QnVmZmVyUmVmIiwiYnl0ZU9mZnNldCIsIm9uU3RhdHVzIiwiYnVmZmVyIiwid2FzbV9vbl9tZXNzYWdlX2JlZ2luIiwib25NZXNzYWdlQmVnaW4iLCJ3YXNtX29uX2hlYWRlcl9maWVsZCIsIm9uSGVhZGVyRmllbGQiLCJ3YXNtX29uX2hlYWRlcl92YWx1ZSIsIm9uSGVhZGVyVmFsdWUiLCJ3YXNtX29uX2hlYWRlcnNfY29tcGxldGUiLCJzdGF0dXNDb2RlIiwidXBncmFkZSIsInNob3VsZEtlZXBBbGl2ZSIsIm9uSGVhZGVyc0NvbXBsZXRlIiwiQm9vbGVhbiIsIndhc21fb25fYm9keSIsIm9uQm9keSIsIndhc21fb25fbWVzc2FnZV9jb21wbGV0ZSIsIm9uTWVzc2FnZUNvbXBsZXRlIiwibGxodHRwSW5zdGFuY2UiLCJsbGh0dHBQcm9taXNlIiwiY2F0Y2giLCJjdXJyZW50QnVmZmVyU2l6ZSIsIlRJTUVPVVRfSEVBREVSUyIsIlRJTUVPVVRfQk9EWSIsIlRJTUVPVVRfSURMRSIsIlBhcnNlciIsImV4cG9ydHMiLCJsbGh0dHAiLCJsbGh0dHBfYWxsb2MiLCJUWVBFIiwiUkVTUE9OU0UiLCJ0aW1lb3V0VmFsdWUiLCJ0aW1lb3V0VHlwZSIsInN0YXR1c1RleHQiLCJoZWFkZXJzIiwiaGVhZGVyc1NpemUiLCJoZWFkZXJzTWF4U2l6ZSIsInBhdXNlZCIsImJpbmQiLCJieXRlc1JlYWQiLCJjb250ZW50TGVuZ3RoIiwiY29ubmVjdGlvbiIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJvblBhcnNlclRpbWVvdXQiLCJ1bnJlZiIsInJlZnJlc2giLCJsbGh0dHBfcmVzdW1lIiwiZXhlY3V0ZSIsInJlYWQiLCJyZWFkTW9yZSIsImNodW5rIiwiZGF0YSIsImZyZWUiLCJNYXRoIiwiY2VpbCIsIm1hbGxvYyIsIlVpbnQ4QXJyYXkiLCJtZW1vcnkiLCJzZXQiLCJyZXQiLCJsbGh0dHBfZXhlY3V0ZSIsIm9mZnNldCIsImxsaHR0cF9nZXRfZXJyb3JfcG9zIiwiRVJST1IiLCJQQVVTRURfVVBHUkFERSIsIm9uVXBncmFkZSIsInNsaWNlIiwiUEFVU0VEIiwidW5zaGlmdCIsIk9LIiwibGxodHRwX2dldF9lcnJvcl9yZWFzb24iLCJtZXNzYWdlIiwiaW5kZXhPZiIsInRvU3RyaW5nIiwibGxodHRwX2ZyZWUiLCJidWYiLCJjb25jYXQiLCJ0cmFja0hlYWRlciIsImtleSIsInRvTG93ZXJDYXNlIiwiaGVhZCIsIm1ldGhvZCIsInJlbW92ZUxpc3RlbmVyIiwib25Tb2NrZXRFcnJvciIsIm9uU29ja2V0UmVhZGFibGUiLCJvblNvY2tldEVuZCIsIm9uU29ja2V0Q2xvc2UiLCJnZXRTb2NrZXRJbmZvIiwicGFyc2VLZWVwQWxpdmVUaW1lb3V0IiwibWluIiwicGF1c2UiLCJvbkhlYWRlcnMiLCJvbkRhdGEiLCJwYXJzZUludCIsIm9uQ29tcGxldGUiLCJzZXRJbW1lZGlhdGUiLCJwYXJzZXIiLCJ3cml0YWJsZU5lZWREcmFpbiIsImhvc3QiLCJwcm90b2NvbCIsImlkeCIsImlwIiwic3Vic3RyIiwicHVibGlzaCIsImNvbm5lY3RQYXJhbXMiLCJzZXJ2ZXJuYW1lIiwiY29ubmVjdG9yIiwicmVqZWN0IiwiaXNIMiIsImFscG5Qcm90b2NvbCIsImVtaXRXYXJuaW5nIiwic2Vzc2lvbiIsImNyZWF0ZUNvbm5lY3Rpb24iLCJwZWVyTWF4Q29uY3VycmVudFN0cmVhbXMiLCJlcnJvciIsImVtaXREcmFpbiIsInN5bmMiLCJfcmVzdW1lIiwicmVmIiwiaWRlbXBvdGVudCIsImlzU3RyZWFtIiwiaXNBc3luY0l0ZXJhYmxlIiwiYWJvcnRlZCIsIndyaXRlIiwic2hvdWxkU2VuZENvbnRlbnRMZW5ndGgiLCJ3cml0ZUgyIiwicGF0aCIsImJsb2NraW5nIiwicmVzZXQiLCJleHBlY3RzUGF5bG9hZCIsIm9uQ29ubmVjdCIsImNvbXBsZXRlZCIsImhlYWRlciIsIm9uUmVxdWVzdFNlbnQiLCJpc0J1ZmZlciIsImJ5dGVMZW5ndGgiLCJjb3JrIiwidW5jb3JrIiwib25Cb2R5U2VudCIsImlzQmxvYkxpa2UiLCJzdHJlYW0iLCJ3cml0ZUl0ZXJhYmxlIiwid3JpdGVCbG9iIiwid3JpdGVTdHJlYW0iLCJleHBlY3RDb250aW51ZSIsInNpZ25hbCIsInJlcUhlYWRlcnMiLCJ0cmltIiwiRXJyb3IiLCJoMlN0YXRlIiwiZW5kU3RyZWFtIiwicGVuZGluZyIsInNob3VsZEVuZFN0cmVhbSIsIndyaXRlQm9keUgyIiwiY2xvc2VkIiwic3RyZWFtcyIsImVuZCIsImgyc3RyZWFtIiwicGlwZSIsIm9uUGlwZURhdGEiLCJmaW5pc2hlZCIsIndyaXRlciIsIkFzeW5jV3JpdGVyIiwib25EcmFpbiIsIm9uQWJvcnQiLCJvbkZpbmlzaGVkIiwib2ZmIiwiZXIiLCJzaXplIiwiYXJyYXlCdWZmZXIiLCJ3YWl0Rm9yRHJhaW4iLCJyZXMiLCJieXRlc1dyaXR0ZW4iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/client.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/compat/dispatcher-weakref.js":
/*!******************************************************************!*\
  !*** ../../node_modules/undici/lib/compat/dispatcher-weakref.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/* istanbul ignore file: only for Node 12 */ const { kConnected, kSize } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nclass CompatWeakRef {\n    constructor(value){\n        this.value = value;\n    }\n    deref() {\n        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? undefined : this.value;\n    }\n}\nclass CompatFinalizer {\n    constructor(finalizer){\n        this.finalizer = finalizer;\n    }\n    register(dispatcher, key) {\n        if (dispatcher.on) {\n            dispatcher.on(\"disconnect\", ()=>{\n                if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {\n                    this.finalizer(key);\n                }\n            });\n        }\n    }\n}\nmodule.exports = function() {\n    // FIXME: remove workaround when the Node bug is fixed\n    // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\n    if (process.env.NODE_V8_COVERAGE) {\n        return {\n            WeakRef: CompatWeakRef,\n            FinalizationRegistry: CompatFinalizer\n        };\n    }\n    return {\n        WeakRef: global.WeakRef || CompatWeakRef,\n        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29tcGF0L2Rpc3BhdGNoZXItd2Vha3JlZi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLDBDQUEwQyxHQUUxQyxNQUFNLEVBQUVBLFVBQVUsRUFBRUMsS0FBSyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRXRDLE1BQU1DO0lBQ0pDLFlBQWFDLEtBQUssQ0FBRTtRQUNsQixJQUFJLENBQUNBLEtBQUssR0FBR0E7SUFDZjtJQUVBQyxRQUFTO1FBQ1AsT0FBTyxJQUFJLENBQUNELEtBQUssQ0FBQ0wsV0FBVyxLQUFLLEtBQUssSUFBSSxDQUFDSyxLQUFLLENBQUNKLE1BQU0sS0FBSyxJQUN6RE0sWUFDQSxJQUFJLENBQUNGLEtBQUs7SUFDaEI7QUFDRjtBQUVBLE1BQU1HO0lBQ0pKLFlBQWFLLFNBQVMsQ0FBRTtRQUN0QixJQUFJLENBQUNBLFNBQVMsR0FBR0E7SUFDbkI7SUFFQUMsU0FBVUMsVUFBVSxFQUFFQyxHQUFHLEVBQUU7UUFDekIsSUFBSUQsV0FBV0UsRUFBRSxFQUFFO1lBQ2pCRixXQUFXRSxFQUFFLENBQUMsY0FBYztnQkFDMUIsSUFBSUYsVUFBVSxDQUFDWCxXQUFXLEtBQUssS0FBS1csVUFBVSxDQUFDVixNQUFNLEtBQUssR0FBRztvQkFDM0QsSUFBSSxDQUFDUSxTQUFTLENBQUNHO2dCQUNqQjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUFFLE9BQU9DLE9BQU8sR0FBRztJQUNmLHNEQUFzRDtJQUN0RCxzRUFBc0U7SUFDdEUsSUFBSUMsUUFBUUMsR0FBRyxDQUFDQyxnQkFBZ0IsRUFBRTtRQUNoQyxPQUFPO1lBQ0xDLFNBQVNoQjtZQUNUaUIsc0JBQXNCWjtRQUN4QjtJQUNGO0lBQ0EsT0FBTztRQUNMVyxTQUFTRSxPQUFPRixPQUFPLElBQUloQjtRQUMzQmlCLHNCQUFzQkMsT0FBT0Qsb0JBQW9CLElBQUlaO0lBQ3ZEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvbXBhdC9kaXNwYXRjaGVyLXdlYWtyZWYuanM/YWY5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyogaXN0YW5idWwgaWdub3JlIGZpbGU6IG9ubHkgZm9yIE5vZGUgMTIgKi9cblxuY29uc3QgeyBrQ29ubmVjdGVkLCBrU2l6ZSB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcblxuY2xhc3MgQ29tcGF0V2Vha1JlZiB7XG4gIGNvbnN0cnVjdG9yICh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgZGVyZWYgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlW2tDb25uZWN0ZWRdID09PSAwICYmIHRoaXMudmFsdWVba1NpemVdID09PSAwXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiB0aGlzLnZhbHVlXG4gIH1cbn1cblxuY2xhc3MgQ29tcGF0RmluYWxpemVyIHtcbiAgY29uc3RydWN0b3IgKGZpbmFsaXplcikge1xuICAgIHRoaXMuZmluYWxpemVyID0gZmluYWxpemVyXG4gIH1cblxuICByZWdpc3RlciAoZGlzcGF0Y2hlciwga2V5KSB7XG4gICAgaWYgKGRpc3BhdGNoZXIub24pIHtcbiAgICAgIGRpc3BhdGNoZXIub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGlmIChkaXNwYXRjaGVyW2tDb25uZWN0ZWRdID09PSAwICYmIGRpc3BhdGNoZXJba1NpemVdID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5maW5hbGl6ZXIoa2V5KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRklYTUU6IHJlbW92ZSB3b3JrYXJvdW5kIHdoZW4gdGhlIE5vZGUgYnVnIGlzIGZpeGVkXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkzNDQjaXNzdWVjb21tZW50LTE3NDE3NzYzMDhcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfVjhfQ09WRVJBR0UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgV2Vha1JlZjogQ29tcGF0V2Vha1JlZixcbiAgICAgIEZpbmFsaXphdGlvblJlZ2lzdHJ5OiBDb21wYXRGaW5hbGl6ZXJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBXZWFrUmVmOiBnbG9iYWwuV2Vha1JlZiB8fCBDb21wYXRXZWFrUmVmLFxuICAgIEZpbmFsaXphdGlvblJlZ2lzdHJ5OiBnbG9iYWwuRmluYWxpemF0aW9uUmVnaXN0cnkgfHwgQ29tcGF0RmluYWxpemVyXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJrQ29ubmVjdGVkIiwia1NpemUiLCJyZXF1aXJlIiwiQ29tcGF0V2Vha1JlZiIsImNvbnN0cnVjdG9yIiwidmFsdWUiLCJkZXJlZiIsInVuZGVmaW5lZCIsIkNvbXBhdEZpbmFsaXplciIsImZpbmFsaXplciIsInJlZ2lzdGVyIiwiZGlzcGF0Y2hlciIsImtleSIsIm9uIiwibW9kdWxlIiwiZXhwb3J0cyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX1Y4X0NPVkVSQUdFIiwiV2Vha1JlZiIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiZ2xvYmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/compat/dispatcher-weakref.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/cookies/constants.js":
/*!**********************************************************!*\
  !*** ../../node_modules/undici/lib/cookies/constants.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size\nconst maxAttributeValueSize = 1024;\n// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size\nconst maxNameValuePairSize = 4096;\nmodule.exports = {\n    maxAttributeValueSize,\n    maxNameValuePairSize\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSwyRUFBMkU7QUFDM0UsTUFBTUEsd0JBQXdCO0FBRTlCLDJFQUEyRTtBQUMzRSxNQUFNQyx1QkFBdUI7QUFFN0JDLE9BQU9DLE9BQU8sR0FBRztJQUNmSDtJQUNBQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL2NvbnN0YW50cy5qcz83MzgyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jY29va2llLW1heGltdW0tYXR0cmlidXRlLXZhbHVlLXNpemVcbmNvbnN0IG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSA9IDEwMjRcblxuLy8gaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI2Nvb2tpZS1tYXhpbXVtLW5hbWUtdmFsdWUtcGFpci1zaXplXG5jb25zdCBtYXhOYW1lVmFsdWVQYWlyU2l6ZSA9IDQwOTZcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSxcbiAgbWF4TmFtZVZhbHVlUGFpclNpemVcbn1cbiJdLCJuYW1lcyI6WyJtYXhBdHRyaWJ1dGVWYWx1ZVNpemUiLCJtYXhOYW1lVmFsdWVQYWlyU2l6ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/cookies/constants.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/cookies/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/cookies/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { parseSetCookie } = __webpack_require__(/*! ./parse */ \"(rsc)/../../node_modules/undici/lib/cookies/parse.js\");\nconst { stringify, getHeadersList } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/cookies/util.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(rsc)/../../node_modules/undici/lib/fetch/headers.js\");\n/**\n * @typedef {Object} Cookie\n * @property {string} name\n * @property {string} value\n * @property {Date|number|undefined} expires\n * @property {number|undefined} maxAge\n * @property {string|undefined} domain\n * @property {string|undefined} path\n * @property {boolean|undefined} secure\n * @property {boolean|undefined} httpOnly\n * @property {'Strict'|'Lax'|'None'} sameSite\n * @property {string[]} unparsed\n */ /**\n * @param {Headers} headers\n * @returns {Record<string, string>}\n */ function getCookies(headers) {\n    webidl.argumentLengthCheck(arguments, 1, {\n        header: \"getCookies\"\n    });\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    const cookie = headers.get(\"cookie\");\n    const out = {};\n    if (!cookie) {\n        return out;\n    }\n    for (const piece of cookie.split(\";\")){\n        const [name, ...value] = piece.split(\"=\");\n        out[name.trim()] = value.join(\"=\");\n    }\n    return out;\n}\n/**\n * @param {Headers} headers\n * @param {string} name\n * @param {{ path?: string, domain?: string }|undefined} attributes\n * @returns {void}\n */ function deleteCookie(headers, name, attributes) {\n    webidl.argumentLengthCheck(arguments, 2, {\n        header: \"deleteCookie\"\n    });\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    name = webidl.converters.DOMString(name);\n    attributes = webidl.converters.DeleteCookieAttributes(attributes);\n    // Matches behavior of\n    // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278\n    setCookie(headers, {\n        name,\n        value: \"\",\n        expires: new Date(0),\n        ...attributes\n    });\n}\n/**\n * @param {Headers} headers\n * @returns {Cookie[]}\n */ function getSetCookies(headers) {\n    webidl.argumentLengthCheck(arguments, 1, {\n        header: \"getSetCookies\"\n    });\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    const cookies = getHeadersList(headers).cookies;\n    if (!cookies) {\n        return [];\n    }\n    // In older versions of undici, cookies is a list of name:value.\n    return cookies.map((pair)=>parseSetCookie(Array.isArray(pair) ? pair[1] : pair));\n}\n/**\n * @param {Headers} headers\n * @param {Cookie} cookie\n * @returns {void}\n */ function setCookie(headers, cookie) {\n    webidl.argumentLengthCheck(arguments, 2, {\n        header: \"setCookie\"\n    });\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    cookie = webidl.converters.Cookie(cookie);\n    const str = stringify(cookie);\n    if (str) {\n        headers.append(\"Set-Cookie\", stringify(cookie));\n    }\n}\nwebidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"path\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"domain\",\n        defaultValue: null\n    }\n]);\nwebidl.converters.Cookie = webidl.dictionaryConverter([\n    {\n        converter: webidl.converters.DOMString,\n        key: \"name\"\n    },\n    {\n        converter: webidl.converters.DOMString,\n        key: \"value\"\n    },\n    {\n        converter: webidl.nullableConverter((value)=>{\n            if (typeof value === \"number\") {\n                return webidl.converters[\"unsigned long long\"](value);\n            }\n            return new Date(value);\n        }),\n        key: \"expires\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters[\"long long\"]),\n        key: \"maxAge\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"domain\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"path\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.boolean),\n        key: \"secure\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.boolean),\n        key: \"httpOnly\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.converters.USVString,\n        key: \"sameSite\",\n        allowedValues: [\n            \"Strict\",\n            \"Lax\",\n            \"None\"\n        ]\n    },\n    {\n        converter: webidl.sequenceConverter(webidl.converters.DOMString),\n        key: \"unparsed\",\n        defaultValue: []\n    }\n]);\nmodule.exports = {\n    getCookies,\n    deleteCookie,\n    getSetCookies,\n    setCookie\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsY0FBYyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ25DLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxjQUFjLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDOUMsTUFBTSxFQUFFRyxNQUFNLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFSSxPQUFPLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFFNUI7Ozs7Ozs7Ozs7OztDQVlDLEdBRUQ7OztDQUdDLEdBQ0QsU0FBU0ssV0FBWUMsT0FBTztJQUMxQkgsT0FBT0ksbUJBQW1CLENBQUNDLFdBQVcsR0FBRztRQUFFQyxRQUFRO0lBQWE7SUFFaEVOLE9BQU9PLFVBQVUsQ0FBQ0osU0FBU0YsU0FBUztRQUFFTyxRQUFRO0lBQU07SUFFcEQsTUFBTUMsU0FBU04sUUFBUU8sR0FBRyxDQUFDO0lBQzNCLE1BQU1DLE1BQU0sQ0FBQztJQUViLElBQUksQ0FBQ0YsUUFBUTtRQUNYLE9BQU9FO0lBQ1Q7SUFFQSxLQUFLLE1BQU1DLFNBQVNILE9BQU9JLEtBQUssQ0FBQyxLQUFNO1FBQ3JDLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHQyxNQUFNLEdBQUdILE1BQU1DLEtBQUssQ0FBQztRQUVyQ0YsR0FBRyxDQUFDRyxLQUFLRSxJQUFJLEdBQUcsR0FBR0QsTUFBTUUsSUFBSSxDQUFDO0lBQ2hDO0lBRUEsT0FBT047QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU08sYUFBY2YsT0FBTyxFQUFFVyxJQUFJLEVBQUVLLFVBQVU7SUFDOUNuQixPQUFPSSxtQkFBbUIsQ0FBQ0MsV0FBVyxHQUFHO1FBQUVDLFFBQVE7SUFBZTtJQUVsRU4sT0FBT08sVUFBVSxDQUFDSixTQUFTRixTQUFTO1FBQUVPLFFBQVE7SUFBTTtJQUVwRE0sT0FBT2QsT0FBT29CLFVBQVUsQ0FB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VSxDQUFDb0IsT0FBTztRQUM3REYsS0FBSztRQUNMQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsV0FBV3BDLE9BQU9vQixVQUFVLENBQUNxQixTQUFTO1FBQ3RDSCxLQUFLO1FBQ0xJLGVBQWU7WUFBQztZQUFVO1lBQU87U0FBTztJQUMxQztJQUNBO1FBQ0VOLFdBQVdwQyxPQUFPMkMsaUJBQWlCLENBQUMzQyxPQUFPb0IsVUFBVSxDQUFDQyxTQUFTO1FBQy9EaUIsS0FBSztRQUNMQyxjQUFjLEVBQUU7SUFDbEI7Q0FDRDtBQUVESyxPQUFPQyxPQUFPLEdBQUc7SUFDZjNDO0lBQ0FnQjtJQUNBUTtJQUNBSDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL2luZGV4LmpzPzUxYzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcGFyc2VTZXRDb29raWUgfSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyBzdHJpbmdpZnksIGdldEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IEhlYWRlcnMgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2hlYWRlcnMnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvb2tpZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZVxuICogQHByb3BlcnR5IHtEYXRlfG51bWJlcnx1bmRlZmluZWR9IGV4cGlyZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfHVuZGVmaW5lZH0gbWF4QWdlXG4gKiBAcHJvcGVydHkge3N0cmluZ3x1bmRlZmluZWR9IGRvbWFpblxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBwYXRoXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58dW5kZWZpbmVkfSBzZWN1cmVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnx1bmRlZmluZWR9IGh0dHBPbmx5XG4gKiBAcHJvcGVydHkgeydTdHJpY3QnfCdMYXgnfCdOb25lJ30gc2FtZVNpdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHVucGFyc2VkXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBnZXRDb29raWVzIChoZWFkZXJzKSB7XG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdnZXRDb29raWVzJyB9KVxuXG4gIHdlYmlkbC5icmFuZENoZWNrKGhlYWRlcnMsIEhlYWRlcnMsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gIGNvbnN0IGNvb2tpZSA9IGhlYWRlcnMuZ2V0KCdjb29raWUnKVxuICBjb25zdCBvdXQgPSB7fVxuXG4gIGlmICghY29va2llKSB7XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgZm9yIChjb25zdCBwaWVjZSBvZiBjb29raWUuc3BsaXQoJzsnKSkge1xuICAgIGNvbnN0IFtuYW1lLCAuLi52YWx1ZV0gPSBwaWVjZS5zcGxpdCgnPScpXG5cbiAgICBvdXRbbmFtZS50cmltKCldID0gdmFsdWUuam9pbignPScpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IHBhdGg/OiBzdHJpbmcsIGRvbWFpbj86IHN0cmluZyB9fHVuZGVmaW5lZH0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZUNvb2tpZSAoaGVhZGVycywgbmFtZSwgYXR0cmlidXRlcykge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnZGVsZXRlQ29va2llJyB9KVxuXG4gIHdlYmlkbC5icmFuZENoZWNrKGhlYWRlcnMsIEhlYWRlcnMsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcobmFtZSlcbiAgYXR0cmlidXRlcyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRlbGV0ZUNvb2tpZUF0dHJpYnV0ZXMoYXR0cmlidXRlcylcblxuICAvLyBNYXRjaGVzIGJlaGF2aW9yIG9mXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZW5vbGFuZC9kZW5vX3N0ZC9ibG9iLzYzODI3YjE2MzMwYjgyNDg5YTA0NjE0MDI3YzMzYjc5MDRlMDhiZTUvaHR0cC9jb29raWUudHMjTDI3OFxuICBzZXRDb29raWUoaGVhZGVycywge1xuICAgIG5hbWUsXG4gICAgdmFsdWU6ICcnLFxuICAgIGV4cGlyZXM6IG5ldyBEYXRlKDApLFxuICAgIC4uLmF0dHJpYnV0ZXNcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtDb29raWVbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2V0Q29va2llcyAoaGVhZGVycykge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnZ2V0U2V0Q29va2llcycgfSlcblxuICB3ZWJpZGwuYnJhbmRDaGVjayhoZWFkZXJzLCBIZWFkZXJzLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICBjb25zdCBjb29raWVzID0gZ2V0SGVhZGVyc0xpc3QoaGVhZGVycykuY29va2llc1xuXG4gIGlmICghY29va2llcykge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLy8gSW4gb2xkZXIgdmVyc2lvbnMgb2YgdW5kaWNpLCBjb29raWVzIGlzIGEgbGlzdCBvZiBuYW1lOnZhbHVlLlxuICByZXR1cm4gY29va2llcy5tYXAoKHBhaXIpID0+IHBhcnNlU2V0Q29va2llKEFycmF5LmlzQXJyYXkocGFpcikgPyBwYWlyWzFdIDogcGFpcikpXG59XG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcGFyYW0ge0Nvb2tpZX0gY29va2llXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gc2V0Q29va2llIChoZWFkZXJzLCBjb29raWUpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCB7IGhlYWRlcjogJ3NldENvb2tpZScgfSlcblxuICB3ZWJpZGwuYnJhbmRDaGVjayhoZWFkZXJzLCBIZWFkZXJzLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICBjb29raWUgPSB3ZWJpZGwuY29udmVydGVycy5Db29raWUoY29va2llKVxuXG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShjb29raWUpXG5cbiAgaWYgKHN0cikge1xuICAgIGhlYWRlcnMuYXBwZW5kKCdTZXQtQ29va2llJywgc3RyaW5naWZ5KGNvb2tpZSkpXG4gIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuRGVsZXRlQ29va2llQXR0cmlidXRlcyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAncGF0aCcsXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ2RvbWFpbicsXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkNvb2tpZSA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGtleTogJ25hbWUnXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBrZXk6ICd2YWx1ZSdcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSh2YWx1ZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKVxuICAgIH0pLFxuICAgIGtleTogJ2V4cGlyZXMnLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnNbJ2xvbmcgbG9uZyddKSxcbiAgICBrZXk6ICdtYXhBZ2UnLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdkb21haW4nLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdwYXRoJyxcbiAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4pLFxuICAgIGtleTogJ3NlY3VyZScsXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ib29sZWFuKSxcbiAgICBrZXk6ICdodHRwT25seScsXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBrZXk6ICdzYW1lU2l0ZScsXG4gICAgYWxsb3dlZFZhbHVlczogWydTdHJpY3QnLCAnTGF4JywgJ05vbmUnXVxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICd1bnBhcnNlZCcsXG4gICAgZGVmYXVsdFZhbHVlOiBbXVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29va2llcyxcbiAgZGVsZXRlQ29va2llLFxuICBnZXRTZXRDb29raWVzLFxuICBzZXRDb29raWVcbn1cbiJdLCJuYW1lcyI6WyJwYXJzZVNldENvb2tpZSIsInJlcXVpcmUiLCJzdHJpbmdpZnkiLCJnZXRIZWFkZXJzTGlzdCIsIndlYmlkbCIsIkhlYWRlcnMiLCJnZXRDb29raWVzIiwiaGVhZGVycyIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJoZWFkZXIiLCJicmFuZENoZWNrIiwic3RyaWN0IiwiY29va2llIiwiZ2V0Iiwib3V0IiwicGllY2UiLCJzcGxpdCIsIm5hbWUiLCJ2YWx1ZSIsInRyaW0iLCJqb2luIiwiZGVsZXRlQ29va2llIiwiYXR0cmlidXRlcyIsImNvbnZlcnRlcnMiLCJET01TdHJpbmciLCJEZWxldGVDb29raWVBdHRyaWJ1dGVzIiwic2V0Q29va2llIiwiZXhwaXJlcyIsIkRhdGUiLCJnZXRTZXRDb29raWVzIiwiY29va2llcyIsIm1hcCIsInBhaXIiLCJBcnJheSIsImlzQXJyYXkiLCJDb29raWUiLCJzdHIiLCJhcHBlbmQiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwiY29udmVydGVyIiwibnVsbGFibGVDb252ZXJ0ZXIiLCJrZXkiLCJkZWZhdWx0VmFsdWUiLCJib29sZWFuIiwiVVNWU3RyaW5nIiwiYWxsb3dlZFZhbHVlcyIsInNlcXVlbmNlQ29udmVydGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/cookies/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/cookies/parse.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/cookies/parse.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/undici/lib/cookies/constants.js\");\nconst { isCTLExcludingHtab } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/cookies/util.js\");\nconst { collectASequenceOfCodePointsFast } = __webpack_require__(/*! ../fetch/dataURL */ \"(rsc)/../../node_modules/undici/lib/fetch/dataURL.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */ function parseSetCookie(header) {\n    // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n    //    character (CTL characters excluding HTAB): Abort these steps and\n    //    ignore the set-cookie-string entirely.\n    if (isCTLExcludingHtab(header)) {\n        return null;\n    }\n    let nameValuePair = \"\";\n    let unparsedAttributes = \"\";\n    let name = \"\";\n    let value = \"\";\n    // 2. If the set-cookie-string contains a %x3B (\";\") character:\n    if (header.includes(\";\")) {\n        // 1. The name-value-pair string consists of the characters up to,\n        //    but not including, the first %x3B (\";\"), and the unparsed-\n        //    attributes consist of the remainder of the set-cookie-string\n        //    (including the %x3B (\";\") in question).\n        const position = {\n            position: 0\n        };\n        nameValuePair = collectASequenceOfCodePointsFast(\";\", header, position);\n        unparsedAttributes = header.slice(position.position);\n    } else {\n        // Otherwise:\n        // 1. The name-value-pair string consists of all the characters\n        //    contained in the set-cookie-string, and the unparsed-\n        //    attributes is the empty string.\n        nameValuePair = header;\n    }\n    // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n    //    the name string is empty, and the value string is the value of\n    //    name-value-pair.\n    if (!nameValuePair.includes(\"=\")) {\n        value = nameValuePair;\n    } else {\n        //    Otherwise, the name string consists of the characters up to, but\n        //    not including, the first %x3D (\"=\") character, and the (possibly\n        //    empty) value string consists of the characters after the first\n        //    %x3D (\"=\") character.\n        const position = {\n            position: 0\n        };\n        name = collectASequenceOfCodePointsFast(\"=\", nameValuePair, position);\n        value = nameValuePair.slice(position.position + 1);\n    }\n    // 4. Remove any leading or trailing WSP characters from the name\n    //    string and the value string.\n    name = name.trim();\n    value = value.trim();\n    // 5. If the sum of the lengths of the name string and the value string\n    //    is more than 4096 octets, abort these steps and ignore the set-\n    //    cookie-string entirely.\n    if (name.length + value.length > maxNameValuePairSize) {\n        return null;\n    }\n    // 6. The cookie-name is the name string, and the cookie-value is the\n    //    value string.\n    return {\n        name,\n        value,\n        ...parseUnparsedAttributes(unparsedAttributes)\n    };\n}\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */ function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {\n    // 1. If the unparsed-attributes string is empty, skip the rest of\n    //    these steps.\n    if (unparsedAttributes.length === 0) {\n        return cookieAttributeList;\n    }\n    // 2. Discard the first character of the unparsed-attributes (which\n    //    will be a %x3B (\";\") character).\n    assert(unparsedAttributes[0] === \";\");\n    unparsedAttributes = unparsedAttributes.slice(1);\n    let cookieAv = \"\";\n    // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n    //    character:\n    if (unparsedAttributes.includes(\";\")) {\n        // 1. Consume the characters of the unparsed-attributes up to, but\n        //    not including, the first %x3B (\";\") character.\n        cookieAv = collectASequenceOfCodePointsFast(\";\", unparsedAttributes, {\n            position: 0\n        });\n        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);\n    } else {\n        // Otherwise:\n        // 1. Consume the remainder of the unparsed-attributes.\n        cookieAv = unparsedAttributes;\n        unparsedAttributes = \"\";\n    }\n    // Let the cookie-av string be the characters consumed in this step.\n    let attributeName = \"\";\n    let attributeValue = \"\";\n    // 4. If the cookie-av string contains a %x3D (\"=\") character:\n    if (cookieAv.includes(\"=\")) {\n        // 1. The (possibly empty) attribute-name string consists of the\n        //    characters up to, but not including, the first %x3D (\"=\")\n        //    character, and the (possibly empty) attribute-value string\n        //    consists of the characters after the first %x3D (\"=\")\n        //    character.\n        const position = {\n            position: 0\n        };\n        attributeName = collectASequenceOfCodePointsFast(\"=\", cookieAv, position);\n        attributeValue = cookieAv.slice(position.position + 1);\n    } else {\n        // Otherwise:\n        // 1. The attribute-name string consists of the entire cookie-av\n        //    string, and the attribute-value string is empty.\n        attributeName = cookieAv;\n    }\n    // 5. Remove any leading or trailing WSP characters from the attribute-\n    //    name string and the attribute-value string.\n    attributeName = attributeName.trim();\n    attributeValue = attributeValue.trim();\n    // 6. If the attribute-value is longer than 1024 octets, ignore the\n    //    cookie-av string and return to Step 1 of this algorithm.\n    if (attributeValue.length > maxAttributeValueSize) {\n        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n    }\n    // 7. Process the attribute-name and attribute-value according to the\n    //    requirements in the following subsections.  (Notice that\n    //    attributes with unrecognized attribute-names are ignored.)\n    const attributeNameLowercase = attributeName.toLowerCase();\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n    // If the attribute-name case-insensitively matches the string\n    // \"Expires\", the user agent MUST process the cookie-av as follows.\n    if (attributeNameLowercase === \"expires\") {\n        // 1. Let the expiry-time be the result of parsing the attribute-value\n        //    as cookie-date (see Section 5.1.1).\n        const expiryTime = new Date(attributeValue);\n        // 2. If the attribute-value failed to parse as a cookie date, ignore\n        //    the cookie-av.\n        cookieAttributeList.expires = expiryTime;\n    } else if (attributeNameLowercase === \"max-age\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n        // If the attribute-name case-insensitively matches the string \"Max-\n        // Age\", the user agent MUST process the cookie-av as follows.\n        // 1. If the first character of the attribute-value is not a DIGIT or a\n        //    \"-\" character, ignore the cookie-av.\n        const charCode = attributeValue.charCodeAt(0);\n        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== \"-\") {\n            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n        }\n        // 2. If the remainder of attribute-value contains a non-DIGIT\n        //    character, ignore the cookie-av.\n        if (!/^\\d+$/.test(attributeValue)) {\n            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n        }\n        // 3. Let delta-seconds be the attribute-value converted to an integer.\n        const deltaSeconds = Number(attributeValue);\n        // 4. Let cookie-age-limit be the maximum age of the cookie (which\n        //    SHOULD be 400 days or less, see Section 4.1.2.2).\n        // 5. Set delta-seconds to the smaller of its present value and cookie-\n        //    age-limit.\n        // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n        // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n        //    time be the earliest representable date and time.  Otherwise, let\n        //    the expiry-time be the current date and time plus delta-seconds\n        //    seconds.\n        // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n        // 7. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Max-Age and an attribute-value of expiry-time.\n        cookieAttributeList.maxAge = deltaSeconds;\n    } else if (attributeNameLowercase === \"domain\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n        // If the attribute-name case-insensitively matches the string \"Domain\",\n        // the user agent MUST process the cookie-av as follows.\n        // 1. Let cookie-domain be the attribute-value.\n        let cookieDomain = attributeValue;\n        // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n        //    cookie-domain without its leading %x2E (\".\").\n        if (cookieDomain[0] === \".\") {\n            cookieDomain = cookieDomain.slice(1);\n        }\n        // 3. Convert the cookie-domain to lower case.\n        cookieDomain = cookieDomain.toLowerCase();\n        // 4. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Domain and an attribute-value of cookie-domain.\n        cookieAttributeList.domain = cookieDomain;\n    } else if (attributeNameLowercase === \"path\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n        // If the attribute-name case-insensitively matches the string \"Path\",\n        // the user agent MUST process the cookie-av as follows.\n        // 1. If the attribute-value is empty or if the first character of the\n        //    attribute-value is not %x2F (\"/\"):\n        let cookiePath = \"\";\n        if (attributeValue.length === 0 || attributeValue[0] !== \"/\") {\n            // 1. Let cookie-path be the default-path.\n            cookiePath = \"/\";\n        } else {\n            // Otherwise:\n            // 1. Let cookie-path be the attribute-value.\n            cookiePath = attributeValue;\n        }\n        // 2. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Path and an attribute-value of cookie-path.\n        cookieAttributeList.path = cookiePath;\n    } else if (attributeNameLowercase === \"secure\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n        // If the attribute-name case-insensitively matches the string \"Secure\",\n        // the user agent MUST append an attribute to the cookie-attribute-list\n        // with an attribute-name of Secure and an empty attribute-value.\n        cookieAttributeList.secure = true;\n    } else if (attributeNameLowercase === \"httponly\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n        // If the attribute-name case-insensitively matches the string\n        // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n        // attribute-list with an attribute-name of HttpOnly and an empty\n        // attribute-value.\n        cookieAttributeList.httpOnly = true;\n    } else if (attributeNameLowercase === \"samesite\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n        // If the attribute-name case-insensitively matches the string\n        // \"SameSite\", the user agent MUST process the cookie-av as follows:\n        // 1. Let enforcement be \"Default\".\n        let enforcement = \"Default\";\n        const attributeValueLowercase = attributeValue.toLowerCase();\n        // 2. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"None\", set enforcement to \"None\".\n        if (attributeValueLowercase.includes(\"none\")) {\n            enforcement = \"None\";\n        }\n        // 3. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"Strict\", set enforcement to \"Strict\".\n        if (attributeValueLowercase.includes(\"strict\")) {\n            enforcement = \"Strict\";\n        }\n        // 4. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"Lax\", set enforcement to \"Lax\".\n        if (attributeValueLowercase.includes(\"lax\")) {\n            enforcement = \"Lax\";\n        }\n        // 5. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of \"SameSite\" and an attribute-value of\n        //    enforcement.\n        cookieAttributeList.sameSite = enforcement;\n    } else {\n        cookieAttributeList.unparsed ??= [];\n        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);\n    }\n    // 8. Return to Step 1 of this algorithm.\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n}\nmodule.exports = {\n    parseSetCookie,\n    parseUnparsedAttributes\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsb0JBQW9CLEVBQUVDLHFCQUFxQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ2hFLE1BQU0sRUFBRUMsa0JBQWtCLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDdkMsTUFBTSxFQUFFRSxnQ0FBZ0MsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUNyRCxNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQztBQUV2Qjs7Ozs7Q0FLQyxHQUNELFNBQVNJLGVBQWdCQyxNQUFNO0lBQzdCLGtFQUFrRTtJQUNsRSxzRUFBc0U7SUFDdEUsNENBQTRDO0lBQzVDLElBQUlKLG1CQUFtQkksU0FBUztRQUM5QixPQUFPO0lBQ1Q7SUFFQSxJQUFJQyxnQkFBZ0I7SUFDcEIsSUFBSUMscUJBQXFCO0lBQ3pCLElBQUlDLE9BQU87SUFDWCxJQUFJQyxRQUFRO0lBRVosK0RBQStEO0lBQy9ELElBQUlKLE9BQU9LLFFBQVEsQ0FBQyxNQUFNO1FBQ3hCLGtFQUFrRTtRQUNsRSxnRUFBZ0U7UUFDaEUsa0VBQWtFO1FBQ2xFLDZDQUE2QztRQUM3QyxNQUFNQyxXQUFXO1lBQUVBLFVBQVU7UUFBRTtRQUUvQkwsZ0JBQWdCSixpQ0FBaUMsS0FBS0csUUFBUU07UUFDOURKLHFCQUFxQkYsT0FBT08sS0FBSyxDQUFDRCxTQUFTQSxRQUFRO0lBQ3JELE9BQU87UUFDTCxhQUFhO1FBRWIsK0RBQStEO1FBQy9ELDJEQUEyRDtRQUMzRCxxQ0FBcUM7UUFDckNMLGdCQUFnQkQ7SUFDbEI7SUFFQSxzRUFBc0U7SUFDdEUsb0VBQW9FO0lBQ3BFLHNCQUFzQjtJQUN0QixJQUFJLENBQUNDLGNBQWNJLFFBQVEsQ0FBQyxNQUFNO1FBQ2hDRCxRQUFRSDtJQUNWLE9BQU87UUFDTCxzRUFBc0U7UUFDdEUsc0VBQXNFO1FBQ3RFLG9FQUFvRTtRQUNwRSwyQkFBMkI7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RUEwQixPQUFPQyxPQUFPLEdBQUc7SUFDZnZDO0lBQ0FXO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Nvb2tpZXMvcGFyc2UuanM/NzQ2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBtYXhOYW1lVmFsdWVQYWlyU2l6ZSwgbWF4QXR0cmlidXRlVmFsdWVTaXplIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGlzQ1RMRXhjbHVkaW5nSHRhYiB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGFVUkwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUGFyc2VzIHRoZSBmaWVsZC12YWx1ZSBhdHRyaWJ1dGVzIG9mIGEgc2V0LWNvb2tpZSBoZWFkZXIgc3RyaW5nLlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40XG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKiBAcmV0dXJucyBpZiB0aGUgaGVhZGVyIGlzIGludmFsaWQsIG51bGwgd2lsbCBiZSByZXR1cm5lZFxuICovXG5mdW5jdGlvbiBwYXJzZVNldENvb2tpZSAoaGVhZGVyKSB7XG4gIC8vIDEuIElmIHRoZSBzZXQtY29va2llLXN0cmluZyBjb250YWlucyBhICV4MDAtMDggLyAleDBBLTFGIC8gJXg3RlxuICAvLyAgICBjaGFyYWN0ZXIgKENUTCBjaGFyYWN0ZXJzIGV4Y2x1ZGluZyBIVEFCKTogQWJvcnQgdGhlc2Ugc3RlcHMgYW5kXG4gIC8vICAgIGlnbm9yZSB0aGUgc2V0LWNvb2tpZS1zdHJpbmcgZW50aXJlbHkuXG4gIGlmIChpc0NUTEV4Y2x1ZGluZ0h0YWIoaGVhZGVyKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgbmFtZVZhbHVlUGFpciA9ICcnXG4gIGxldCB1bnBhcnNlZEF0dHJpYnV0ZXMgPSAnJ1xuICBsZXQgbmFtZSA9ICcnXG4gIGxldCB2YWx1ZSA9ICcnXG5cbiAgLy8gMi4gSWYgdGhlIHNldC1jb29raWUtc3RyaW5nIGNvbnRhaW5zIGEgJXgzQiAoXCI7XCIpIGNoYXJhY3RlcjpcbiAgaWYgKGhlYWRlci5pbmNsdWRlcygnOycpKSB7XG4gICAgLy8gMS4gVGhlIG5hbWUtdmFsdWUtcGFpciBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgdXAgdG8sXG4gICAgLy8gICAgYnV0IG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNCIChcIjtcIiksIGFuZCB0aGUgdW5wYXJzZWQtXG4gICAgLy8gICAgYXR0cmlidXRlcyBjb25zaXN0IG9mIHRoZSByZW1haW5kZXIgb2YgdGhlIHNldC1jb29raWUtc3RyaW5nXG4gICAgLy8gICAgKGluY2x1ZGluZyB0aGUgJXgzQiAoXCI7XCIpIGluIHF1ZXN0aW9uKS5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gICAgbmFtZVZhbHVlUGFpciA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KCc7JywgaGVhZGVyLCBwb3NpdGlvbilcbiAgICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSBoZWFkZXIuc2xpY2UocG9zaXRpb24ucG9zaXRpb24pXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gVGhlIG5hbWUtdmFsdWUtcGFpciBzdHJpbmcgY29uc2lzdHMgb2YgYWxsIHRoZSBjaGFyYWN0ZXJzXG4gICAgLy8gICAgY29udGFpbmVkIGluIHRoZSBzZXQtY29va2llLXN0cmluZywgYW5kIHRoZSB1bnBhcnNlZC1cbiAgICAvLyAgICBhdHRyaWJ1dGVzIGlzIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgbmFtZVZhbHVlUGFpciA9IGhlYWRlclxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIG5hbWUtdmFsdWUtcGFpciBzdHJpbmcgbGFja3MgYSAleDNEIChcIj1cIikgY2hhcmFjdGVyLCB0aGVuXG4gIC8vICAgIHRoZSBuYW1lIHN0cmluZyBpcyBlbXB0eSwgYW5kIHRoZSB2YWx1ZSBzdHJpbmcgaXMgdGhlIHZhbHVlIG9mXG4gIC8vICAgIG5hbWUtdmFsdWUtcGFpci5cbiAgaWYgKCFuYW1lVmFsdWVQYWlyLmluY2x1ZGVzKCc9JykpIHtcbiAgICB2YWx1ZSA9IG5hbWVWYWx1ZVBhaXJcbiAgfSBlbHNlIHtcbiAgICAvLyAgICBPdGhlcndpc2UsIHRoZSBuYW1lIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyB1cCB0bywgYnV0XG4gICAgLy8gICAgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0QgKFwiPVwiKSBjaGFyYWN0ZXIsIGFuZCB0aGUgKHBvc3NpYmx5XG4gICAgLy8gICAgZW1wdHkpIHZhbHVlIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyBhZnRlciB0aGUgZmlyc3RcbiAgICAvLyAgICAleDNEIChcIj1cIikgY2hhcmFjdGVyLlxuICAgIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG4gICAgbmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgJz0nLFxuICAgICAgbmFtZVZhbHVlUGFpcixcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICAgIHZhbHVlID0gbmFtZVZhbHVlUGFpci5zbGljZShwb3NpdGlvbi5wb3NpdGlvbiArIDEpXG4gIH1cblxuICAvLyA0LiBSZW1vdmUgYW55IGxlYWRpbmcgb3IgdHJhaWxpbmcgV1NQIGNoYXJhY3RlcnMgZnJvbSB0aGUgbmFtZVxuICAvLyAgICBzdHJpbmcgYW5kIHRoZSB2YWx1ZSBzdHJpbmcuXG4gIG5hbWUgPSBuYW1lLnRyaW0oKVxuICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gIC8vIDUuIElmIHRoZSBzdW0gb2YgdGhlIGxlbmd0aHMgb2YgdGhlIG5hbWUgc3RyaW5nIGFuZCB0aGUgdmFsdWUgc3RyaW5nXG4gIC8vICAgIGlzIG1vcmUgdGhhbiA0MDk2IG9jdGV0cywgYWJvcnQgdGhlc2Ugc3RlcHMgYW5kIGlnbm9yZSB0aGUgc2V0LVxuICAvLyAgICBjb29raWUtc3RyaW5nIGVudGlyZWx5LlxuICBpZiAobmFtZS5sZW5ndGggKyB2YWx1ZS5sZW5ndGggPiBtYXhOYW1lVmFsdWVQYWlyU2l6ZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyA2LiBUaGUgY29va2llLW5hbWUgaXMgdGhlIG5hbWUgc3RyaW5nLCBhbmQgdGhlIGNvb2tpZS12YWx1ZSBpcyB0aGVcbiAgLy8gICAgdmFsdWUgc3RyaW5nLlxuICByZXR1cm4ge1xuICAgIG5hbWUsIHZhbHVlLCAuLi5wYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIHJlbWFpbmluZyBhdHRyaWJ1dGVzIG9mIGEgc2V0LWNvb2tpZSBoZWFkZXJcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNFxuICogQHBhcmFtIHtzdHJpbmd9IHVucGFyc2VkQXR0cmlidXRlc1xuICogQHBhcmFtIHtbT2JqZWN0LjxzdHJpbmcsIHVua25vd24+XT17fX0gY29va2llQXR0cmlidXRlTGlzdFxuICovXG5mdW5jdGlvbiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyAodW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0ID0ge30pIHtcbiAgLy8gMS4gSWYgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgc3RyaW5nIGlzIGVtcHR5LCBza2lwIHRoZSByZXN0IG9mXG4gIC8vICAgIHRoZXNlIHN0ZXBzLlxuICBpZiAodW5wYXJzZWRBdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjb29raWVBdHRyaWJ1dGVMaXN0XG4gIH1cblxuICAvLyAyLiBEaXNjYXJkIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgKHdoaWNoXG4gIC8vICAgIHdpbGwgYmUgYSAleDNCIChcIjtcIikgY2hhcmFjdGVyKS5cbiAgYXNzZXJ0KHVucGFyc2VkQXR0cmlidXRlc1swXSA9PT0gJzsnKVxuICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSB1bnBhcnNlZEF0dHJpYnV0ZXMuc2xpY2UoMSlcblxuICBsZXQgY29va2llQXYgPSAnJ1xuXG4gIC8vIDMuIElmIHRoZSByZW1haW5pbmcgdW5wYXJzZWQtYXR0cmlidXRlcyBjb250YWlucyBhICV4M0IgKFwiO1wiKVxuICAvLyAgICBjaGFyYWN0ZXI6XG4gIGlmICh1bnBhcnNlZEF0dHJpYnV0ZXMuaW5jbHVkZXMoJzsnKSkge1xuICAgIC8vIDEuIENvbnN1bWUgdGhlIGNoYXJhY3RlcnMgb2YgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgdXAgdG8sIGJ1dFxuICAgIC8vICAgIG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNCIChcIjtcIikgY2hhcmFjdGVyLlxuICAgIGNvb2tpZUF2ID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAnOycsXG4gICAgICB1bnBhcnNlZEF0dHJpYnV0ZXMsXG4gICAgICB7IHBvc2l0aW9uOiAwIH1cbiAgICApXG4gICAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gdW5wYXJzZWRBdHRyaWJ1dGVzLnNsaWNlKGNvb2tpZUF2Lmxlbmd0aClcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBDb25zdW1lIHRoZSByZW1haW5kZXIgb2YgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMuXG4gICAgY29va2llQXYgPSB1bnBhcnNlZEF0dHJpYnV0ZXNcbiAgICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSAnJ1xuICB9XG5cbiAgLy8gTGV0IHRoZSBjb29raWUtYXYgc3RyaW5nIGJlIHRoZSBjaGFyYWN0ZXJzIGNvbnN1bWVkIGluIHRoaXMgc3RlcC5cblxuICBsZXQgYXR0cmlidXRlTmFtZSA9ICcnXG4gIGxldCBhdHRyaWJ1dGVWYWx1ZSA9ICcnXG5cbiAgLy8gNC4gSWYgdGhlIGNvb2tpZS1hdiBzdHJpbmcgY29udGFpbnMgYSAleDNEIChcIj1cIikgY2hhcmFjdGVyOlxuICBpZiAoY29va2llQXYuaW5jbHVkZXMoJz0nKSkge1xuICAgIC8vIDEuIFRoZSAocG9zc2libHkgZW1wdHkpIGF0dHJpYnV0ZS1uYW1lIHN0cmluZyBjb25zaXN0cyBvZiB0aGVcbiAgICAvLyAgICBjaGFyYWN0ZXJzIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0QgKFwiPVwiKVxuICAgIC8vICAgIGNoYXJhY3RlciwgYW5kIHRoZSAocG9zc2libHkgZW1wdHkpIGF0dHJpYnV0ZS12YWx1ZSBzdHJpbmdcbiAgICAvLyAgICBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyBhZnRlciB0aGUgZmlyc3QgJXgzRCAoXCI9XCIpXG4gICAgLy8gICAgY2hhcmFjdGVyLlxuICAgIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgICBhdHRyaWJ1dGVOYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAnPScsXG4gICAgICBjb29raWVBdixcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICAgIGF0dHJpYnV0ZVZhbHVlID0gY29va2llQXYuc2xpY2UocG9zaXRpb24ucG9zaXRpb24gKyAxKVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIFRoZSBhdHRyaWJ1dGUtbmFtZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGVudGlyZSBjb29raWUtYXZcbiAgICAvLyAgICBzdHJpbmcsIGFuZCB0aGUgYXR0cmlidXRlLXZhbHVlIHN0cmluZyBpcyBlbXB0eS5cbiAgICBhdHRyaWJ1dGVOYW1lID0gY29va2llQXZcbiAgfVxuXG4gIC8vIDUuIFJlbW92ZSBhbnkgbGVhZGluZyBvciB0cmFpbGluZyBXU1AgY2hhcmFjdGVycyBmcm9tIHRoZSBhdHRyaWJ1dGUtXG4gIC8vICAgIG5hbWUgc3RyaW5nIGFuZCB0aGUgYXR0cmlidXRlLXZhbHVlIHN0cmluZy5cbiAgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWUudHJpbSgpXG4gIGF0dHJpYnV0ZVZhbHVlID0gYXR0cmlidXRlVmFsdWUudHJpbSgpXG5cbiAgLy8gNi4gSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBsb25nZXIgdGhhbiAxMDI0IG9jdGV0cywgaWdub3JlIHRoZVxuICAvLyAgICBjb29raWUtYXYgc3RyaW5nIGFuZCByZXR1cm4gdG8gU3RlcCAxIG9mIHRoaXMgYWxnb3JpdGhtLlxuICBpZiAoYXR0cmlidXRlVmFsdWUubGVuZ3RoID4gbWF4QXR0cmlidXRlVmFsdWVTaXplKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbiAgfVxuXG4gIC8vIDcuIFByb2Nlc3MgdGhlIGF0dHJpYnV0ZS1uYW1lIGFuZCBhdHRyaWJ1dGUtdmFsdWUgYWNjb3JkaW5nIHRvIHRoZVxuICAvLyAgICByZXF1aXJlbWVudHMgaW4gdGhlIGZvbGxvd2luZyBzdWJzZWN0aW9ucy4gIChOb3RpY2UgdGhhdFxuICAvLyAgICBhdHRyaWJ1dGVzIHdpdGggdW5yZWNvZ25pemVkIGF0dHJpYnV0ZS1uYW1lcyBhcmUgaWdub3JlZC4pXG4gIGNvbnN0IGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPSBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKClcblxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjFcbiAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmdcbiAgLy8gXCJFeHBpcmVzXCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG4gIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnZXhwaXJlcycpIHtcbiAgICAvLyAxLiBMZXQgdGhlIGV4cGlyeS10aW1lIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyB0aGUgYXR0cmlidXRlLXZhbHVlXG4gICAgLy8gICAgYXMgY29va2llLWRhdGUgKHNlZSBTZWN0aW9uIDUuMS4xKS5cbiAgICBjb25zdCBleHBpcnlUaW1lID0gbmV3IERhdGUoYXR0cmlidXRlVmFsdWUpXG5cbiAgICAvLyAyLiBJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGZhaWxlZCB0byBwYXJzZSBhcyBhIGNvb2tpZSBkYXRlLCBpZ25vcmVcbiAgICAvLyAgICB0aGUgY29va2llLWF2LlxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5leHBpcmVzID0gZXhwaXJ5VGltZVxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdtYXgtYWdlJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuMlxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiTWF4LVxuICAgIC8vIEFnZVwiLCB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuXG4gICAgLy8gMS4gSWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIG5vdCBhIERJR0lUIG9yIGFcbiAgICAvLyAgICBcIi1cIiBjaGFyYWN0ZXIsIGlnbm9yZSB0aGUgY29va2llLWF2LlxuICAgIGNvbnN0IGNoYXJDb2RlID0gYXR0cmlidXRlVmFsdWUuY2hhckNvZGVBdCgwKVxuXG4gICAgaWYgKChjaGFyQ29kZSA8IDQ4IHx8IGNoYXJDb2RlID4gNTcpICYmIGF0dHJpYnV0ZVZhbHVlWzBdICE9PSAnLScpIHtcbiAgICAgIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhlIHJlbWFpbmRlciBvZiBhdHRyaWJ1dGUtdmFsdWUgY29udGFpbnMgYSBub24tRElHSVRcbiAgICAvLyAgICBjaGFyYWN0ZXIsIGlnbm9yZSB0aGUgY29va2llLWF2LlxuICAgIGlmICghL15cXGQrJC8udGVzdChhdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IGRlbHRhLXNlY29uZHMgYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlci5cbiAgICBjb25zdCBkZWx0YVNlY29uZHMgPSBOdW1iZXIoYXR0cmlidXRlVmFsdWUpXG5cbiAgICAvLyA0LiBMZXQgY29va2llLWFnZS1saW1pdCBiZSB0aGUgbWF4aW11bSBhZ2Ugb2YgdGhlIGNvb2tpZSAod2hpY2hcbiAgICAvLyAgICBTSE9VTEQgYmUgNDAwIGRheXMgb3IgbGVzcywgc2VlIFNlY3Rpb24gNC4xLjIuMikuXG5cbiAgICAvLyA1LiBTZXQgZGVsdGEtc2Vjb25kcyB0byB0aGUgc21hbGxlciBvZiBpdHMgcHJlc2VudCB2YWx1ZSBhbmQgY29va2llLVxuICAgIC8vICAgIGFnZS1saW1pdC5cbiAgICAvLyBkZWx0YVNlY29uZHMgPSBNYXRoLm1pbihkZWx0YVNlY29uZHMgKiAxMDAwLCBtYXhFeHBpcmVzTXMpXG5cbiAgICAvLyA2LiBJZiBkZWx0YS1zZWNvbmRzIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvICgwKSwgbGV0IGV4cGlyeS1cbiAgICAvLyAgICB0aW1lIGJlIHRoZSBlYXJsaWVzdCByZXByZXNlbnRhYmxlIGRhdGUgYW5kIHRpbWUuICBPdGhlcndpc2UsIGxldFxuICAgIC8vICAgIHRoZSBleHBpcnktdGltZSBiZSB0aGUgY3VycmVudCBkYXRlIGFuZCB0aW1lIHBsdXMgZGVsdGEtc2Vjb25kc1xuICAgIC8vICAgIHNlY29uZHMuXG4gICAgLy8gY29uc3QgZXhwaXJ5VGltZSA9IGRlbHRhU2Vjb25kcyA8PSAwID8gRGF0ZS5ub3coKSA6IERhdGUubm93KCkgKyBkZWx0YVNlY29uZHNcblxuICAgIC8vIDcuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgTWF4LUFnZSBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mIGV4cGlyeS10aW1lLlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QubWF4QWdlID0gZGVsdGFTZWNvbmRzXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ2RvbWFpbicpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjNcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIkRvbWFpblwiLFxuICAgIC8vIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG5cbiAgICAvLyAxLiBMZXQgY29va2llLWRvbWFpbiBiZSB0aGUgYXR0cmlidXRlLXZhbHVlLlxuICAgIGxldCBjb29raWVEb21haW4gPSBhdHRyaWJ1dGVWYWx1ZVxuXG4gICAgLy8gMi4gSWYgY29va2llLWRvbWFpbiBzdGFydHMgd2l0aCAleDJFIChcIi5cIiksIGxldCBjb29raWUtZG9tYWluIGJlXG4gICAgLy8gICAgY29va2llLWRvbWFpbiB3aXRob3V0IGl0cyBsZWFkaW5nICV4MkUgKFwiLlwiKS5cbiAgICBpZiAoY29va2llRG9tYWluWzBdID09PSAnLicpIHtcbiAgICAgIGNvb2tpZURvbWFpbiA9IGNvb2tpZURvbWFpbi5zbGljZSgxKVxuICAgIH1cblxuICAgIC8vIDMuIENvbnZlcnQgdGhlIGNvb2tpZS1kb21haW4gdG8gbG93ZXIgY2FzZS5cbiAgICBjb29raWVEb21haW4gPSBjb29raWVEb21haW4udG9Mb3dlckNhc2UoKVxuXG4gICAgLy8gNC4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBEb21haW4gYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZiBjb29raWUtZG9tYWluLlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QuZG9tYWluID0gY29va2llRG9tYWluXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ3BhdGgnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC40XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJQYXRoXCIsXG4gICAgLy8gdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cblxuICAgIC8vIDEuIElmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgZW1wdHkgb3IgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGVcbiAgICAvLyAgICBhdHRyaWJ1dGUtdmFsdWUgaXMgbm90ICV4MkYgKFwiL1wiKTpcbiAgICBsZXQgY29va2llUGF0aCA9ICcnXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCA9PT0gMCB8fCBhdHRyaWJ1dGVWYWx1ZVswXSAhPT0gJy8nKSB7XG4gICAgICAvLyAxLiBMZXQgY29va2llLXBhdGggYmUgdGhlIGRlZmF1bHQtcGF0aC5cbiAgICAgIGNvb2tpZVBhdGggPSAnLydcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgICAvLyAxLiBMZXQgY29va2llLXBhdGggYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZS5cbiAgICAgIGNvb2tpZVBhdGggPSBhdHRyaWJ1dGVWYWx1ZVxuICAgIH1cblxuICAgIC8vIDIuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgUGF0aCBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mIGNvb2tpZS1wYXRoLlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QucGF0aCA9IGNvb2tpZVBhdGhcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnc2VjdXJlJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuNVxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiU2VjdXJlXCIsXG4gICAgLy8gdGhlIHVzZXIgYWdlbnQgTVVTVCBhcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3RcbiAgICAvLyB3aXRoIGFuIGF0dHJpYnV0ZS1uYW1lIG9mIFNlY3VyZSBhbmQgYW4gZW1wdHkgYXR0cmlidXRlLXZhbHVlLlxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5zZWN1cmUgPSB0cnVlXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ2h0dHBvbmx5Jykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuNlxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nXG4gICAgLy8gXCJIdHRwT25seVwiLCB0aGUgdXNlciBhZ2VudCBNVVNUIGFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1cbiAgICAvLyBhdHRyaWJ1dGUtbGlzdCB3aXRoIGFuIGF0dHJpYnV0ZS1uYW1lIG9mIEh0dHBPbmx5IGFuZCBhbiBlbXB0eVxuICAgIC8vIGF0dHJpYnV0ZS12YWx1ZS5cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QuaHR0cE9ubHkgPSB0cnVlXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ3NhbWVzaXRlJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuN1xuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nXG4gICAgLy8gXCJTYW1lU2l0ZVwiLCB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzOlxuXG4gICAgLy8gMS4gTGV0IGVuZm9yY2VtZW50IGJlIFwiRGVmYXVsdFwiLlxuICAgIGxldCBlbmZvcmNlbWVudCA9ICdEZWZhdWx0J1xuXG4gICAgY29uc3QgYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UgPSBhdHRyaWJ1dGVWYWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgLy8gMi4gSWYgY29va2llLWF2J3MgYXR0cmlidXRlLXZhbHVlIGlzIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgICAvLyAgICBcIk5vbmVcIiwgc2V0IGVuZm9yY2VtZW50IHRvIFwiTm9uZVwiLlxuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZS5pbmNsdWRlcygnbm9uZScpKSB7XG4gICAgICBlbmZvcmNlbWVudCA9ICdOb25lJ1xuICAgIH1cblxuICAgIC8vIDMuIElmIGNvb2tpZS1hdidzIGF0dHJpYnV0ZS12YWx1ZSBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gICAgLy8gICAgXCJTdHJpY3RcIiwgc2V0IGVuZm9yY2VtZW50IHRvIFwiU3RyaWN0XCIuXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlLmluY2x1ZGVzKCdzdHJpY3QnKSkge1xuICAgICAgZW5mb3JjZW1lbnQgPSAnU3RyaWN0J1xuICAgIH1cblxuICAgIC8vIDQuIElmIGNvb2tpZS1hdidzIGF0dHJpYnV0ZS12YWx1ZSBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gICAgLy8gICAgXCJMYXhcIiwgc2V0IGVuZm9yY2VtZW50IHRvIFwiTGF4XCIuXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlLmluY2x1ZGVzKCdsYXgnKSkge1xuICAgICAgZW5mb3JjZW1lbnQgPSAnTGF4J1xuICAgIH1cblxuICAgIC8vIDUuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgXCJTYW1lU2l0ZVwiIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2ZcbiAgICAvLyAgICBlbmZvcmNlbWVudC5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnNhbWVTaXRlID0gZW5mb3JjZW1lbnRcbiAgfSBlbHNlIHtcbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnVucGFyc2VkID8/PSBbXVxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC51bnBhcnNlZC5wdXNoKGAke2F0dHJpYnV0ZU5hbWV9PSR7YXR0cmlidXRlVmFsdWV9YClcbiAgfVxuXG4gIC8vIDguIFJldHVybiB0byBTdGVwIDEgb2YgdGhpcyBhbGdvcml0aG0uXG4gIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZVNldENvb2tpZSxcbiAgcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXNcbn1cbiJdLCJuYW1lcyI6WyJtYXhOYW1lVmFsdWVQYWlyU2l6ZSIsIm1heEF0dHJpYnV0ZVZhbHVlU2l6ZSIsInJlcXVpcmUiLCJpc0NUTEV4Y2x1ZGluZ0h0YWIiLCJjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCIsImFzc2VydCIsInBhcnNlU2V0Q29va2llIiwiaGVhZGVyIiwibmFtZVZhbHVlUGFpciIsInVucGFyc2VkQXR0cmlidXRlcyIsIm5hbWUiLCJ2YWx1ZSIsImluY2x1ZGVzIiwicG9zaXRpb24iLCJzbGljZSIsInRyaW0iLCJsZW5ndGgiLCJwYXJzZVVucGFyc2VkQXR0cmlidXRlcyIsImNvb2tpZUF0dHJpYnV0ZUxpc3QiLCJjb29raWVBdiIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVWYWx1ZSIsImF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UiLCJ0b0xvd2VyQ2FzZSIsImV4cGlyeVRpbWUiLCJEYXRlIiwiZXhwaXJlcyIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsInRlc3QiLCJkZWx0YVNlY29uZHMiLCJOdW1iZXIiLCJtYXhBZ2UiLCJjb29raWVEb21haW4iLCJkb21haW4iLCJjb29raWVQYXRoIiwicGF0aCIsInNlY3VyZSIsImh0dHBPbmx5IiwiZW5mb3JjZW1lbnQiLCJhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZSIsInNhbWVTaXRlIiwidW5wYXJzZWQiLCJwdXNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/cookies/parse.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/cookies/util.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/cookies/util.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nfunction isCTLExcludingHtab(value) {\n    if (value.length === 0) {\n        return false;\n    }\n    for (const char of value){\n        const code = char.charCodeAt(0);\n        if (code >= 0x00 || code <= 0x08 || code >= 0x0A || code <= 0x1F || code === 0x7F) {\n            return false;\n        }\n    }\n}\n/**\n CHAR           = <any US-ASCII character (octets 0 - 127)>\n token          = 1*<any CHAR except CTLs or separators>\n separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                | \",\" | \";\" | \":\" | \"\\\" | <\">\n                | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                | \"{\" | \"}\" | SP | HT\n * @param {string} name\n */ function validateCookieName(name) {\n    for (const char of name){\n        const code = char.charCodeAt(0);\n        if (code <= 0x20 || code > 0x7F || char === \"(\" || char === \")\" || char === \">\" || char === \"<\" || char === \"@\" || char === \",\" || char === \";\" || char === \":\" || char === \"\\\\\" || char === '\"' || char === \"/\" || char === \"[\" || char === \"]\" || char === \"?\" || char === \"=\" || char === \"{\" || char === \"}\") {\n            throw new Error(\"Invalid cookie name\");\n        }\n    }\n}\n/**\n cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n                       ; US-ASCII characters excluding CTLs,\n                       ; whitespace DQUOTE, comma, semicolon,\n                       ; and backslash\n * @param {string} value\n */ function validateCookieValue(value) {\n    for (const char of value){\n        const code = char.charCodeAt(0);\n        if (code < 0x21 || // exclude CTLs (0-31)\n        code === 0x22 || code === 0x2C || code === 0x3B || code === 0x5C || code > 0x7E // non-ascii\n        ) {\n            throw new Error(\"Invalid header value\");\n        }\n    }\n}\n/**\n * path-value        = <any CHAR except CTLs or \";\">\n * @param {string} path\n */ function validateCookiePath(path) {\n    for (const char of path){\n        const code = char.charCodeAt(0);\n        if (code < 0x21 || char === \";\") {\n            throw new Error(\"Invalid cookie path\");\n        }\n    }\n}\n/**\n * I have no idea why these values aren't allowed to be honest,\n * but Deno tests these. - Khafra\n * @param {string} domain\n */ function validateCookieDomain(domain) {\n    if (domain.startsWith(\"-\") || domain.endsWith(\".\") || domain.endsWith(\"-\")) {\n        throw new Error(\"Invalid cookie domain\");\n    }\n}\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n * @param {number|Date} date\n  IMF-fixdate  = day-name \",\" SP date1 SP time-of-day SP GMT\n  ; fixed length/zone/capitalization subset of the format\n  ; see Section 3.3 of [RFC5322]\n\n  day-name     = %x4D.6F.6E ; \"Mon\", case-sensitive\n              / %x54.75.65 ; \"Tue\", case-sensitive\n              / %x57.65.64 ; \"Wed\", case-sensitive\n              / %x54.68.75 ; \"Thu\", case-sensitive\n              / %x46.72.69 ; \"Fri\", case-sensitive\n              / %x53.61.74 ; \"Sat\", case-sensitive\n              / %x53.75.6E ; \"Sun\", case-sensitive\n  date1        = day SP month SP year\n                  ; e.g., 02 Jun 1982\n\n  day          = 2DIGIT\n  month        = %x4A.61.6E ; \"Jan\", case-sensitive\n              / %x46.65.62 ; \"Feb\", case-sensitive\n              / %x4D.61.72 ; \"Mar\", case-sensitive\n              / %x41.70.72 ; \"Apr\", case-sensitive\n              / %x4D.61.79 ; \"May\", case-sensitive\n              / %x4A.75.6E ; \"Jun\", case-sensitive\n              / %x4A.75.6C ; \"Jul\", case-sensitive\n              / %x41.75.67 ; \"Aug\", case-sensitive\n              / %x53.65.70 ; \"Sep\", case-sensitive\n              / %x4F.63.74 ; \"Oct\", case-sensitive\n              / %x4E.6F.76 ; \"Nov\", case-sensitive\n              / %x44.65.63 ; \"Dec\", case-sensitive\n  year         = 4DIGIT\n\n  GMT          = %x47.4D.54 ; \"GMT\", case-sensitive\n\n  time-of-day  = hour \":\" minute \":\" second\n              ; 00:00:00 - 23:59:60 (leap second)\n\n  hour         = 2DIGIT\n  minute       = 2DIGIT\n  second       = 2DIGIT\n */ function toIMFDate(date) {\n    if (typeof date === \"number\") {\n        date = new Date(date);\n    }\n    const days = [\n        \"Sun\",\n        \"Mon\",\n        \"Tue\",\n        \"Wed\",\n        \"Thu\",\n        \"Fri\",\n        \"Sat\"\n    ];\n    const months = [\n        \"Jan\",\n        \"Feb\",\n        \"Mar\",\n        \"Apr\",\n        \"May\",\n        \"Jun\",\n        \"Jul\",\n        \"Aug\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Dec\"\n    ];\n    const dayName = days[date.getUTCDay()];\n    const day = date.getUTCDate().toString().padStart(2, \"0\");\n    const month = months[date.getUTCMonth()];\n    const year = date.getUTCFullYear();\n    const hour = date.getUTCHours().toString().padStart(2, \"0\");\n    const minute = date.getUTCMinutes().toString().padStart(2, \"0\");\n    const second = date.getUTCSeconds().toString().padStart(2, \"0\");\n    return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;\n}\n/**\n max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\n                       ; In practice, both expires-av and max-age-av\n                       ; are limited to dates representable by the\n                       ; user agent.\n * @param {number} maxAge\n */ function validateCookieMaxAge(maxAge) {\n    if (maxAge < 0) {\n        throw new Error(\"Invalid cookie max-age\");\n    }\n}\n/**\n * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1\n * @param {import('./index').Cookie} cookie\n */ function stringify(cookie) {\n    if (cookie.name.length === 0) {\n        return null;\n    }\n    validateCookieName(cookie.name);\n    validateCookieValue(cookie.value);\n    const out = [\n        `${cookie.name}=${cookie.value}`\n    ];\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2\n    if (cookie.name.startsWith(\"__Secure-\")) {\n        cookie.secure = true;\n    }\n    if (cookie.name.startsWith(\"__Host-\")) {\n        cookie.secure = true;\n        cookie.domain = null;\n        cookie.path = \"/\";\n    }\n    if (cookie.secure) {\n        out.push(\"Secure\");\n    }\n    if (cookie.httpOnly) {\n        out.push(\"HttpOnly\");\n    }\n    if (typeof cookie.maxAge === \"number\") {\n        validateCookieMaxAge(cookie.maxAge);\n        out.push(`Max-Age=${cookie.maxAge}`);\n    }\n    if (cookie.domain) {\n        validateCookieDomain(cookie.domain);\n        out.push(`Domain=${cookie.domain}`);\n    }\n    if (cookie.path) {\n        validateCookiePath(cookie.path);\n        out.push(`Path=${cookie.path}`);\n    }\n    if (cookie.expires && cookie.expires.toString() !== \"Invalid Date\") {\n        out.push(`Expires=${toIMFDate(cookie.expires)}`);\n    }\n    if (cookie.sameSite) {\n        out.push(`SameSite=${cookie.sameSite}`);\n    }\n    for (const part of cookie.unparsed){\n        if (!part.includes(\"=\")) {\n            throw new Error(\"Invalid unparsed\");\n        }\n        const [key, ...value] = part.split(\"=\");\n        out.push(`${key.trim()}=${value.join(\"=\")}`);\n    }\n    return out.join(\"; \");\n}\nlet kHeadersListNode;\nfunction getHeadersList(headers) {\n    if (headers[kHeadersList]) {\n        return headers[kHeadersList];\n    }\n    if (!kHeadersListNode) {\n        kHeadersListNode = Object.getOwnPropertySymbols(headers).find((symbol)=>symbol.description === \"headers list\");\n        assert(kHeadersListNode, \"Headers cannot be parsed\");\n    }\n    const headersList = headers[kHeadersListNode];\n    assert(headersList);\n    return headersList;\n}\nmodule.exports = {\n    isCTLExcludingHtab,\n    stringify,\n    getHeadersList\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFakMsU0FBU0UsbUJBQW9CQyxLQUFLO0lBQ2hDLElBQUlBLE1BQU1DLE1BQU0sS0FBSyxHQUFHO1FBQ3RCLE9BQU87SUFDVDtJQUVBLEtBQUssTUFBTUMsUUFBUUYsTUFBTztRQUN4QixNQUFNRyxPQUFPRCxLQUFLRSxVQUFVLENBQUM7UUFFN0IsSUFDRSxRQUFTLFFBQVFELFFBQVEsUUFDeEJBLFFBQVEsUUFBUUEsUUFBUSxRQUN6QkEsU0FBUyxNQUNUO1lBQ0EsT0FBTztRQUNUO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0UsbUJBQW9CQyxJQUFJO0lBQy9CLEtBQUssTUFBTUosUUFBUUksS0FBTTtRQUN2QixNQUFNSCxPQUFPRCxLQUFLRSxVQUFVLENBQUM7UUFFN0IsSUFDRSxRQUFTLFFBQVFELE9BQU8sUUFDeEJELFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLFFBQ1RBLFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsT0FDVEEsU0FBUyxLQUNUO1lBQ0EsTUFBTSxJQUFJSyxNQUFNO1FBQ2xCO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxvQkFBcUJSLEtBQUs7SUFDakMsS0FBSyxNQUFNRSxRQUFRRixNQUFPO1FBQ3hCLE1BQU1HLE9BQU9ELEtBQUtFLFVBQVUsQ0FBQztRQUU3QixJQUNFRCxPQUFPLFFBQVEsc0JBQXNCO1FBQ3JDQSxTQUFTLFFBQ1RB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Q0FBQyxLQUFLLENBQUM7SUFDN0M7SUFFQSxPQUFPWixJQUFJWSxJQUFJLENBQUM7QUFDbEI7QUFFQSxJQUFJQztBQUVKLFNBQVNDLGVBQWdCQyxPQUFPO0lBQzlCLElBQUlBLE9BQU8sQ0FBQ3pELGFBQWEsRUFBRTtRQUN6QixPQUFPeUQsT0FBTyxDQUFDekQsYUFBYTtJQUM5QjtJQUVBLElBQUksQ0FBQ3VELGtCQUFrQjtRQUNyQkEsbUJBQW1CRyxPQUFPQyxxQkFBcUIsQ0FBQ0YsU0FBU0csSUFBSSxDQUMzRCxDQUFDQyxTQUFXQSxPQUFPQyxXQUFXLEtBQUs7UUFHckNoRSxPQUFPeUQsa0JBQWtCO0lBQzNCO0lBRUEsTUFBTVEsY0FBY04sT0FBTyxDQUFDRixpQkFBaUI7SUFDN0N6RCxPQUFPaUU7SUFFUCxPQUFPQTtBQUNUO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUNmaEU7SUFDQXVDO0lBQ0FnQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL3V0aWwuanM/MmY0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsga0hlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuXG5mdW5jdGlvbiBpc0NUTEV4Y2x1ZGluZ0h0YWIgKHZhbHVlKSB7XG4gIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAoY29uc3QgY2hhciBvZiB2YWx1ZSkge1xuICAgIGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMClcblxuICAgIGlmIChcbiAgICAgIChjb2RlID49IDB4MDAgfHwgY29kZSA8PSAweDA4KSB8fFxuICAgICAgKGNvZGUgPj0gMHgwQSB8fCBjb2RlIDw9IDB4MUYpIHx8XG4gICAgICBjb2RlID09PSAweDdGXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gQ0hBUiAgICAgICAgICAgPSA8YW55IFVTLUFTQ0lJIGNoYXJhY3RlciAob2N0ZXRzIDAgLSAxMjcpPlxuIHRva2VuICAgICAgICAgID0gMSo8YW55IENIQVIgZXhjZXB0IENUTHMgb3Igc2VwYXJhdG9ycz5cbiBzZXBhcmF0b3JzICAgICA9IFwiKFwiIHwgXCIpXCIgfCBcIjxcIiB8IFwiPlwiIHwgXCJAXCJcbiAgICAgICAgICAgICAgICB8IFwiLFwiIHwgXCI7XCIgfCBcIjpcIiB8IFwiXFxcIiB8IDxcIj5cbiAgICAgICAgICAgICAgICB8IFwiL1wiIHwgXCJbXCIgfCBcIl1cIiB8IFwiP1wiIHwgXCI9XCJcbiAgICAgICAgICAgICAgICB8IFwie1wiIHwgXCJ9XCIgfCBTUCB8IEhUXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZU5hbWUgKG5hbWUpIHtcbiAgZm9yIChjb25zdCBjaGFyIG9mIG5hbWUpIHtcbiAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICBpZiAoXG4gICAgICAoY29kZSA8PSAweDIwIHx8IGNvZGUgPiAweDdGKSB8fFxuICAgICAgY2hhciA9PT0gJygnIHx8XG4gICAgICBjaGFyID09PSAnKScgfHxcbiAgICAgIGNoYXIgPT09ICc+JyB8fFxuICAgICAgY2hhciA9PT0gJzwnIHx8XG4gICAgICBjaGFyID09PSAnQCcgfHxcbiAgICAgIGNoYXIgPT09ICcsJyB8fFxuICAgICAgY2hhciA9PT0gJzsnIHx8XG4gICAgICBjaGFyID09PSAnOicgfHxcbiAgICAgIGNoYXIgPT09ICdcXFxcJyB8fFxuICAgICAgY2hhciA9PT0gJ1wiJyB8fFxuICAgICAgY2hhciA9PT0gJy8nIHx8XG4gICAgICBjaGFyID09PSAnWycgfHxcbiAgICAgIGNoYXIgPT09ICddJyB8fFxuICAgICAgY2hhciA9PT0gJz8nIHx8XG4gICAgICBjaGFyID09PSAnPScgfHxcbiAgICAgIGNoYXIgPT09ICd7JyB8fFxuICAgICAgY2hhciA9PT0gJ30nXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIG5hbWUnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiBjb29raWUtdmFsdWUgICAgICA9ICpjb29raWUtb2N0ZXQgLyAoIERRVU9URSAqY29va2llLW9jdGV0IERRVU9URSApXG4gY29va2llLW9jdGV0ICAgICAgPSAleDIxIC8gJXgyMy0yQiAvICV4MkQtM0EgLyAleDNDLTVCIC8gJXg1RC03RVxuICAgICAgICAgICAgICAgICAgICAgICA7IFVTLUFTQ0lJIGNoYXJhY3RlcnMgZXhjbHVkaW5nIENUTHMsXG4gICAgICAgICAgICAgICAgICAgICAgIDsgd2hpdGVzcGFjZSBEUVVPVEUsIGNvbW1hLCBzZW1pY29sb24sXG4gICAgICAgICAgICAgICAgICAgICAgIDsgYW5kIGJhY2tzbGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llVmFsdWUgKHZhbHVlKSB7XG4gIGZvciAoY29uc3QgY2hhciBvZiB2YWx1ZSkge1xuICAgIGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMClcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPCAweDIxIHx8IC8vIGV4Y2x1ZGUgQ1RMcyAoMC0zMSlcbiAgICAgIGNvZGUgPT09IDB4MjIgfHxcbiAgICAgIGNvZGUgPT09IDB4MkMgfHxcbiAgICAgIGNvZGUgPT09IDB4M0IgfHxcbiAgICAgIGNvZGUgPT09IDB4NUMgfHxcbiAgICAgIGNvZGUgPiAweDdFIC8vIG5vbi1hc2NpaVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhlYWRlciB2YWx1ZScpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogcGF0aC12YWx1ZSAgICAgICAgPSA8YW55IENIQVIgZXhjZXB0IENUTHMgb3IgXCI7XCI+XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZVBhdGggKHBhdGgpIHtcbiAgZm9yIChjb25zdCBjaGFyIG9mIHBhdGgpIHtcbiAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICBpZiAoY29kZSA8IDB4MjEgfHwgY2hhciA9PT0gJzsnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIHBhdGgnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEkgaGF2ZSBubyBpZGVhIHdoeSB0aGVzZSB2YWx1ZXMgYXJlbid0IGFsbG93ZWQgdG8gYmUgaG9uZXN0LFxuICogYnV0IERlbm8gdGVzdHMgdGhlc2UuIC0gS2hhZnJhXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llRG9tYWluIChkb21haW4pIHtcbiAgaWYgKFxuICAgIGRvbWFpbi5zdGFydHNXaXRoKCctJykgfHxcbiAgICBkb21haW4uZW5kc1dpdGgoJy4nKSB8fFxuICAgIGRvbWFpbi5lbmRzV2l0aCgnLScpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgZG9tYWluJylcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzEjc2VjdGlvbi03LjEuMS4xXG4gKiBAcGFyYW0ge251bWJlcnxEYXRlfSBkYXRlXG4gIElNRi1maXhkYXRlICA9IGRheS1uYW1lIFwiLFwiIFNQIGRhdGUxIFNQIHRpbWUtb2YtZGF5IFNQIEdNVFxuICA7IGZpeGVkIGxlbmd0aC96b25lL2NhcGl0YWxpemF0aW9uIHN1YnNldCBvZiB0aGUgZm9ybWF0XG4gIDsgc2VlIFNlY3Rpb24gMy4zIG9mIFtSRkM1MzIyXVxuXG4gIGRheS1uYW1lICAgICA9ICV4NEQuNkYuNkUgOyBcIk1vblwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTQuNzUuNjUgOyBcIlR1ZVwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTcuNjUuNjQgOyBcIldlZFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTQuNjguNzUgOyBcIlRodVwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDYuNzIuNjkgOyBcIkZyaVwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTMuNjEuNzQgOyBcIlNhdFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTMuNzUuNkUgOyBcIlN1blwiLCBjYXNlLXNlbnNpdGl2ZVxuICBkYXRlMSAgICAgICAgPSBkYXkgU1AgbW9udGggU1AgeWVhclxuICAgICAgICAgICAgICAgICAgOyBlLmcuLCAwMiBKdW4gMTk4MlxuXG4gIGRheSAgICAgICAgICA9IDJESUdJVFxuICBtb250aCAgICAgICAgPSAleDRBLjYxLjZFIDsgXCJKYW5cIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQ2LjY1LjYyIDsgXCJGZWJcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDRELjYxLjcyIDsgXCJNYXJcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQxLjcwLjcyIDsgXCJBcHJcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDRELjYxLjc5IDsgXCJNYXlcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDRBLjc1LjZFIDsgXCJKdW5cIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDRBLjc1LjZDIDsgXCJKdWxcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQxLjc1LjY3IDsgXCJBdWdcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDUzLjY1LjcwIDsgXCJTZXBcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDRGLjYzLjc0IDsgXCJPY3RcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDRFLjZGLjc2IDsgXCJOb3ZcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQ0LjY1LjYzIDsgXCJEZWNcIiwgY2FzZS1zZW5zaXRpdmVcbiAgeWVhciAgICAgICAgID0gNERJR0lUXG5cbiAgR01UICAgICAgICAgID0gJXg0Ny40RC41NCA7IFwiR01UXCIsIGNhc2Utc2Vuc2l0aXZlXG5cbiAgdGltZS1vZi1kYXkgID0gaG91ciBcIjpcIiBtaW51dGUgXCI6XCIgc2Vjb25kXG4gICAgICAgICAgICAgIDsgMDA6MDA6MDAgLSAyMzo1OTo2MCAobGVhcCBzZWNvbmQpXG5cbiAgaG91ciAgICAgICAgID0gMkRJR0lUXG4gIG1pbnV0ZSAgICAgICA9IDJESUdJVFxuICBzZWNvbmQgICAgICAgPSAyRElHSVRcbiAqL1xuZnVuY3Rpb24gdG9JTUZEYXRlIChkYXRlKSB7XG4gIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSlcbiAgfVxuXG4gIGNvbnN0IGRheXMgPSBbXG4gICAgJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsXG4gICAgJ1RodScsICdGcmknLCAnU2F0J1xuICBdXG5cbiAgY29uc3QgbW9udGhzID0gW1xuICAgICdKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsXG4gICAgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ1xuICBdXG5cbiAgY29uc3QgZGF5TmFtZSA9IGRheXNbZGF0ZS5nZXRVVENEYXkoKV1cbiAgY29uc3QgZGF5ID0gZGF0ZS5nZXRVVENEYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpXG4gIGNvbnN0IG1vbnRoID0gbW9udGhzW2RhdGUuZ2V0VVRDTW9udGgoKV1cbiAgY29uc3QgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKVxuICBjb25zdCBob3VyID0gZGF0ZS5nZXRVVENIb3VycygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKVxuICBjb25zdCBtaW51dGUgPSBkYXRlLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJylcbiAgY29uc3Qgc2Vjb25kID0gZGF0ZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpXG5cbiAgcmV0dXJuIGAke2RheU5hbWV9LCAke2RheX0gJHttb250aH0gJHt5ZWFyfSAke2hvdXJ9OiR7bWludXRlfToke3NlY29uZH0gR01UYFxufVxuXG4vKipcbiBtYXgtYWdlLWF2ICAgICAgICA9IFwiTWF4LUFnZT1cIiBub24temVyby1kaWdpdCAqRElHSVRcbiAgICAgICAgICAgICAgICAgICAgICAgOyBJbiBwcmFjdGljZSwgYm90aCBleHBpcmVzLWF2IGFuZCBtYXgtYWdlLWF2XG4gICAgICAgICAgICAgICAgICAgICAgIDsgYXJlIGxpbWl0ZWQgdG8gZGF0ZXMgcmVwcmVzZW50YWJsZSBieSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgOyB1c2VyIGFnZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEFnZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZU1heEFnZSAobWF4QWdlKSB7XG4gIGlmIChtYXhBZ2UgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBtYXgtYWdlJylcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzYyNjUjc2VjdGlvbi00LjEuMVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5Db29raWV9IGNvb2tpZVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkgKGNvb2tpZSkge1xuICBpZiAoY29va2llLm5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhbGlkYXRlQ29va2llTmFtZShjb29raWUubmFtZSlcbiAgdmFsaWRhdGVDb29raWVWYWx1ZShjb29raWUudmFsdWUpXG5cbiAgY29uc3Qgb3V0ID0gW2Ake2Nvb2tpZS5uYW1lfT0ke2Nvb2tpZS52YWx1ZX1gXVxuXG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLWNvb2tpZS1wcmVmaXhlcy0wMCNzZWN0aW9uLTMuMVxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1jb29raWUtcHJlZml4ZXMtMDAjc2VjdGlvbi0zLjJcbiAgaWYgKGNvb2tpZS5uYW1lLnN0YXJ0c1dpdGgoJ19fU2VjdXJlLScpKSB7XG4gICAgY29va2llLnNlY3VyZSA9IHRydWVcbiAgfVxuXG4gIGlmIChjb29raWUubmFtZS5zdGFydHNXaXRoKCdfX0hvc3QtJykpIHtcbiAgICBjb29raWUuc2VjdXJlID0gdHJ1ZVxuICAgIGNvb2tpZS5kb21haW4gPSBudWxsXG4gICAgY29va2llLnBhdGggPSAnLydcbiAgfVxuXG4gIGlmIChjb29raWUuc2VjdXJlKSB7XG4gICAgb3V0LnB1c2goJ1NlY3VyZScpXG4gIH1cblxuICBpZiAoY29va2llLmh0dHBPbmx5KSB7XG4gICAgb3V0LnB1c2goJ0h0dHBPbmx5JylcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29va2llLm1heEFnZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YWxpZGF0ZUNvb2tpZU1heEFnZShjb29raWUubWF4QWdlKVxuICAgIG91dC5wdXNoKGBNYXgtQWdlPSR7Y29va2llLm1heEFnZX1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5kb21haW4pIHtcbiAgICB2YWxpZGF0ZUNvb2tpZURvbWFpbihjb29raWUuZG9tYWluKVxuICAgIG91dC5wdXNoKGBEb21haW49JHtjb29raWUuZG9tYWlufWApXG4gIH1cblxuICBpZiAoY29va2llLnBhdGgpIHtcbiAgICB2YWxpZGF0ZUNvb2tpZVBhdGgoY29va2llLnBhdGgpXG4gICAgb3V0LnB1c2goYFBhdGg9JHtjb29raWUucGF0aH1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5leHBpcmVzICYmIGNvb2tpZS5leHBpcmVzLnRvU3RyaW5nKCkgIT09ICdJbnZhbGlkIERhdGUnKSB7XG4gICAgb3V0LnB1c2goYEV4cGlyZXM9JHt0b0lNRkRhdGUoY29va2llLmV4cGlyZXMpfWApXG4gIH1cblxuICBpZiAoY29va2llLnNhbWVTaXRlKSB7XG4gICAgb3V0LnB1c2goYFNhbWVTaXRlPSR7Y29va2llLnNhbWVTaXRlfWApXG4gIH1cblxuICBmb3IgKGNvbnN0IHBhcnQgb2YgY29va2llLnVucGFyc2VkKSB7XG4gICAgaWYgKCFwYXJ0LmluY2x1ZGVzKCc9JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bnBhcnNlZCcpXG4gICAgfVxuXG4gICAgY29uc3QgW2tleSwgLi4udmFsdWVdID0gcGFydC5zcGxpdCgnPScpXG5cbiAgICBvdXQucHVzaChgJHtrZXkudHJpbSgpfT0ke3ZhbHVlLmpvaW4oJz0nKX1gKVxuICB9XG5cbiAgcmV0dXJuIG91dC5qb2luKCc7ICcpXG59XG5cbmxldCBrSGVhZGVyc0xpc3ROb2RlXG5cbmZ1bmN0aW9uIGdldEhlYWRlcnNMaXN0IChoZWFkZXJzKSB7XG4gIGlmIChoZWFkZXJzW2tIZWFkZXJzTGlzdF0pIHtcbiAgICByZXR1cm4gaGVhZGVyc1trSGVhZGVyc0xpc3RdXG4gIH1cblxuICBpZiAoIWtIZWFkZXJzTGlzdE5vZGUpIHtcbiAgICBrSGVhZGVyc0xpc3ROb2RlID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhoZWFkZXJzKS5maW5kKFxuICAgICAgKHN5bWJvbCkgPT4gc3ltYm9sLmRlc2NyaXB0aW9uID09PSAnaGVhZGVycyBsaXN0J1xuICAgIClcblxuICAgIGFzc2VydChrSGVhZGVyc0xpc3ROb2RlLCAnSGVhZGVycyBjYW5ub3QgYmUgcGFyc2VkJylcbiAgfVxuXG4gIGNvbnN0IGhlYWRlcnNMaXN0ID0gaGVhZGVyc1trSGVhZGVyc0xpc3ROb2RlXVxuICBhc3NlcnQoaGVhZGVyc0xpc3QpXG5cbiAgcmV0dXJuIGhlYWRlcnNMaXN0XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0NUTEV4Y2x1ZGluZ0h0YWIsXG4gIHN0cmluZ2lmeSxcbiAgZ2V0SGVhZGVyc0xpc3Rcbn1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwia0hlYWRlcnNMaXN0IiwiaXNDVExFeGNsdWRpbmdIdGFiIiwidmFsdWUiLCJsZW5ndGgiLCJjaGFyIiwiY29kZSIsImNoYXJDb2RlQXQiLCJ2YWxpZGF0ZUNvb2tpZU5hbWUiLCJuYW1lIiwiRXJyb3IiLCJ2YWxpZGF0ZUNvb2tpZVZhbHVlIiwidmFsaWRhdGVDb29raWVQYXRoIiwicGF0aCIsInZhbGlkYXRlQ29va2llRG9tYWluIiwiZG9tYWluIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidG9JTUZEYXRlIiwiZGF0ZSIsIkRhdGUiLCJkYXlzIiwibW9udGhzIiwiZGF5TmFtZSIsImdldFVUQ0RheSIsImRheSIsImdldFVUQ0RhdGUiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwibW9udGgiLCJnZXRVVENNb250aCIsInllYXIiLCJnZXRVVENGdWxsWWVhciIsImhvdXIiLCJnZXRVVENIb3VycyIsIm1pbnV0ZSIsImdldFVUQ01pbnV0ZXMiLCJzZWNvbmQiLCJnZXRVVENTZWNvbmRzIiwidmFsaWRhdGVDb29raWVNYXhBZ2UiLCJtYXhBZ2UiLCJzdHJpbmdpZnkiLCJjb29raWUiLCJvdXQiLCJzZWN1cmUiLCJwdXNoIiwiaHR0cE9ubHkiLCJleHBpcmVzIiwic2FtZVNpdGUiLCJwYXJ0IiwidW5wYXJzZWQiLCJpbmNsdWRlcyIsImtleSIsInNwbGl0IiwidHJpbSIsImpvaW4iLCJrSGVhZGVyc0xpc3ROb2RlIiwiZ2V0SGVhZGVyc0xpc3QiLCJoZWFkZXJzIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmluZCIsInN5bWJvbCIsImRlc2NyaXB0aW9uIiwiaGVhZGVyc0xpc3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/cookies/util.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/core/connect.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/core/connect.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst net = __webpack_require__(/*! net */ \"net\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst util = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nlet tls // include tls conditionally since it is not always available\n;\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\nlet SessionCache;\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {\n    SessionCache = class WeakSessionCache {\n        constructor(maxCachedSessions){\n            this._maxCachedSessions = maxCachedSessions;\n            this._sessionCache = new Map();\n            this._sessionRegistry = new global.FinalizationRegistry((key)=>{\n                if (this._sessionCache.size < this._maxCachedSessions) {\n                    return;\n                }\n                const ref = this._sessionCache.get(key);\n                if (ref !== undefined && ref.deref() === undefined) {\n                    this._sessionCache.delete(key);\n                }\n            });\n        }\n        get(sessionKey) {\n            const ref = this._sessionCache.get(sessionKey);\n            return ref ? ref.deref() : null;\n        }\n        set(sessionKey, session) {\n            if (this._maxCachedSessions === 0) {\n                return;\n            }\n            this._sessionCache.set(sessionKey, new WeakRef(session));\n            this._sessionRegistry.register(session, sessionKey);\n        }\n    };\n} else {\n    SessionCache = class SimpleSessionCache {\n        constructor(maxCachedSessions){\n            this._maxCachedSessions = maxCachedSessions;\n            this._sessionCache = new Map();\n        }\n        get(sessionKey) {\n            return this._sessionCache.get(sessionKey);\n        }\n        set(sessionKey, session) {\n            if (this._maxCachedSessions === 0) {\n                return;\n            }\n            if (this._sessionCache.size >= this._maxCachedSessions) {\n                // remove the oldest session\n                const { value: oldestKey } = this._sessionCache.keys().next();\n                this._sessionCache.delete(oldestKey);\n            }\n            this._sessionCache.set(sessionKey, session);\n        }\n    };\n}\nfunction buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {\n    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n        throw new InvalidArgumentError(\"maxCachedSessions must be a positive integer or zero\");\n    }\n    const options = {\n        path: socketPath,\n        ...opts\n    };\n    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);\n    timeout = timeout == null ? 10e3 : timeout;\n    allowH2 = allowH2 != null ? allowH2 : false;\n    return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n        let socket;\n        if (protocol === \"https:\") {\n            if (!tls) {\n                tls = __webpack_require__(/*! tls */ \"tls\");\n            }\n            servername = servername || options.servername || util.getServerName(host) || null;\n            const sessionKey = servername || hostname;\n            const session = sessionCache.get(sessionKey) || null;\n            assert(sessionKey);\n            socket = tls.connect({\n                highWaterMark: 16384,\n                ...options,\n                servername,\n                session,\n                localAddress,\n                // TODO(HTTP/2): Add support for h2c\n                ALPNProtocols: allowH2 ? [\n                    \"http/1.1\",\n                    \"h2\"\n                ] : [\n                    \"http/1.1\"\n                ],\n                socket: httpSocket,\n                port: port || 443,\n                host: hostname\n            });\n            socket.on(\"session\", function(session) {\n                // TODO (fix): Can a session become invalid once established? Don't think so?\n                sessionCache.set(sessionKey, session);\n            });\n        } else {\n            assert(!httpSocket, \"httpSocket can only be sent on TLS update\");\n            socket = net.connect({\n                highWaterMark: 64 * 1024,\n                ...options,\n                localAddress,\n                port: port || 80,\n                host: hostname\n            });\n        }\n        // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n        if (options.keepAlive == null || options.keepAlive) {\n            const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay;\n            socket.setKeepAlive(true, keepAliveInitialDelay);\n        }\n        const cancelTimeout = setupTimeout(()=>onConnectTimeout(socket), timeout);\n        socket.setNoDelay(true).once(protocol === \"https:\" ? \"secureConnect\" : \"connect\", function() {\n            cancelTimeout();\n            if (callback) {\n                const cb = callback;\n                callback = null;\n                cb(null, this);\n            }\n        }).on(\"error\", function(err) {\n            cancelTimeout();\n            if (callback) {\n                const cb = callback;\n                callback = null;\n                cb(err);\n            }\n        });\n        return socket;\n    };\n}\nfunction setupTimeout(onConnectTimeout, timeout) {\n    if (!timeout) {\n        return ()=>{};\n    }\n    let s1 = null;\n    let s2 = null;\n    const timeoutId = setTimeout(()=>{\n        // setImmediate is added to make sure that we priotorise socket error events over timeouts\n        s1 = setImmediate(()=>{\n            if (process.platform === \"win32\") {\n                // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n                s2 = setImmediate(()=>onConnectTimeout());\n            } else {\n                onConnectTimeout();\n            }\n        });\n    }, timeout);\n    return ()=>{\n        clearTimeout(timeoutId);\n        clearImmediate(s1);\n        clearImmediate(s2);\n    };\n}\nfunction onConnectTimeout(socket) {\n    util.destroy(socket, new ConnectTimeoutError());\n}\nmodule.exports = buildConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9jb25uZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUUsT0FBT0YsbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFRyxvQkFBb0IsRUFBRUMsbUJBQW1CLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFFOUQsSUFBSUssSUFBSSw2REFBNkQ7O0FBRXJFLG1EQUFtRDtBQUNuRCx3REFBd0Q7QUFDeEQsdURBQXVEO0FBQ3ZELHFCQUFxQjtBQUVyQixJQUFJQztBQUNKLHNEQUFzRDtBQUN0RCxzRUFBc0U7QUFDdEUsSUFBSUMsT0FBT0Msb0JBQW9CLElBQUksQ0FBQ0MsUUFBUUMsR0FBRyxDQUFDQyxnQkFBZ0IsRUFBRTtJQUNoRUwsZUFBZSxNQUFNTTtRQUNuQkMsWUFBYUMsaUJBQWlCLENBQUU7WUFDOUIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBR0Q7WUFDMUIsSUFBSSxDQUFDRSxhQUFhLEdBQUcsSUFBSUM7WUFDekIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxJQUFJWCxPQUFPQyxvQkFBb0IsQ0FBQyxDQUFDVztnQkFDdkQsSUFBSSxJQUFJLENBQUNILGFBQWEsQ0FBQ0ksSUFBSSxHQUFHLElBQUksQ0FBQ0wsa0JBQWtCLEVBQUU7b0JBQ3JEO2dCQUNGO2dCQUVBLE1BQU1NLE1BQU0sSUFBSSxDQUFDTCxhQUFhLENBQUNNLEdBQUcsQ0FBQ0g7Z0JBQ25DLElBQUlFLFFBQVFFLGFBQWFGLElBQUlHLEtBQUssT0FBT0QsV0FBVztvQkFDbEQsSUFBSSxDQUFDUCxhQUFhLENBQUNTLE1BQU0sQ0FBQ047Z0JBQzVCO1lBQ0Y7UUFDRjtRQUVBRyxJQUFLSSxVQUFVLEVBQUU7WUFDZixNQUFNTCxNQUFNLElBQUksQ0FBQ0wsYUFBYSxDQUFDTSxHQUFHLENBQUNJO1lBQ25DLE9BQU9M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QUFlUDtRQUNmTyxlQUFlTjtJQUNqQjtBQUNGO0FBRUEsU0FBU04saUJBQWtCVixNQUFNO0lBQy9CckQsS0FBSzRFLE9BQU8sQ0FBQ3ZCLFFBQVEsSUFBSW5EO0FBQzNCO0FBRUEyRSxPQUFPQyxPQUFPLEdBQUc1QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9jb25uZWN0LmpzPzBhMTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBDb25uZWN0VGltZW91dEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5cbmxldCB0bHMgLy8gaW5jbHVkZSB0bHMgY29uZGl0aW9uYWxseSBzaW5jZSBpdCBpcyBub3QgYWx3YXlzIGF2YWlsYWJsZVxuXG4vLyBUT0RPOiBzZXNzaW9uIHJlLXVzZSBkb2VzIG5vdCB3YWl0IGZvciB0aGUgZmlyc3Rcbi8vIGNvbm5lY3Rpb24gdG8gcmVzb2x2ZSB0aGUgc2Vzc2lvbiBhbmQgbWlnaHQgdGhlcmVmb3JlXG4vLyByZXNvbHZlIHRoZSBzYW1lIHNlcnZlcm5hbWUgbXVsdGlwbGUgdGltZXMgZXZlbiB3aGVuXG4vLyByZS11c2UgaXMgZW5hYmxlZC5cblxubGV0IFNlc3Npb25DYWNoZVxuLy8gRklYTUU6IHJlbW92ZSB3b3JrYXJvdW5kIHdoZW4gdGhlIE5vZGUgYnVnIGlzIGZpeGVkXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MzQ0I2lzc3VlY29tbWVudC0xNzQxNzc2MzA4XG5pZiAoZ2xvYmFsLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmICFwcm9jZXNzLmVudi5OT0RFX1Y4X0NPVkVSQUdFKSB7XG4gIFNlc3Npb25DYWNoZSA9IGNsYXNzIFdlYWtTZXNzaW9uQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yIChtYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgdGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPSBtYXhDYWNoZWRTZXNzaW9uc1xuICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlID0gbmV3IE1hcCgpXG4gICAgICB0aGlzLl9zZXNzaW9uUmVnaXN0cnkgPSBuZXcgZ2xvYmFsLkZpbmFsaXphdGlvblJlZ2lzdHJ5KChrZXkpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3Nlc3Npb25DYWNoZS5zaXplIDwgdGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuX3Nlc3Npb25DYWNoZS5nZXQoa2V5KVxuICAgICAgICBpZiAocmVmICE9PSB1bmRlZmluZWQgJiYgcmVmLmRlcmVmKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5kZWxldGUoa2V5KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGdldCAoc2Vzc2lvbktleSkge1xuICAgICAgY29uc3QgcmVmID0gdGhpcy5fc2Vzc2lvbkNhY2hlLmdldChzZXNzaW9uS2V5KVxuICAgICAgcmV0dXJuIHJlZiA/IHJlZi5kZXJlZigpIDogbnVsbFxuICAgIH1cblxuICAgIHNldCAoc2Vzc2lvbktleSwgc2Vzc2lvbikge1xuICAgICAgaWYgKHRoaXMuX21heENhY2hlZFNlc3Npb25zID09PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUuc2V0KHNlc3Npb25LZXksIG5ldyBXZWFrUmVmKHNlc3Npb24pKVxuICAgICAgdGhpcy5fc2Vzc2lvblJlZ2lzdHJ5LnJlZ2lzdGVyKHNlc3Npb24sIHNlc3Npb25LZXkpXG4gICAgfVxuICB9XG59IGVsc2Uge1xuICBTZXNzaW9uQ2FjaGUgPSBjbGFzcyBTaW1wbGVTZXNzaW9uQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yIChtYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgdGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPSBtYXhDYWNoZWRTZXNzaW9uc1xuICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlID0gbmV3IE1hcCgpXG4gICAgfVxuXG4gICAgZ2V0IChzZXNzaW9uS2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbkNhY2hlLmdldChzZXNzaW9uS2V5KVxuICAgIH1cblxuICAgIHNldCAoc2Vzc2lvbktleSwgc2Vzc2lvbikge1xuICAgICAgaWYgKHRoaXMuX21heENhY2hlZFNlc3Npb25zID09PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc2Vzc2lvbkNhY2hlLnNpemUgPj0gdGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGRlc3Qgc2Vzc2lvblxuICAgICAgICBjb25zdCB7IHZhbHVlOiBvbGRlc3RLZXkgfSA9IHRoaXMuX3Nlc3Npb25DYWNoZS5rZXlzKCkubmV4dCgpXG4gICAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5kZWxldGUob2xkZXN0S2V5KVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUuc2V0KHNlc3Npb25LZXksIHNlc3Npb24pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQ29ubmVjdG9yICh7IGFsbG93SDIsIG1heENhY2hlZFNlc3Npb25zLCBzb2NrZXRQYXRoLCB0aW1lb3V0LCAuLi5vcHRzIH0pIHtcbiAgaWYgKG1heENhY2hlZFNlc3Npb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heENhY2hlZFNlc3Npb25zKSB8fCBtYXhDYWNoZWRTZXNzaW9ucyA8IDApKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhDYWNoZWRTZXNzaW9ucyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvJylcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSB7IHBhdGg6IHNvY2tldFBhdGgsIC4uLm9wdHMgfVxuICBjb25zdCBzZXNzaW9uQ2FjaGUgPSBuZXcgU2Vzc2lvbkNhY2hlKG1heENhY2hlZFNlc3Npb25zID09IG51bGwgPyAxMDAgOiBtYXhDYWNoZWRTZXNzaW9ucylcbiAgdGltZW91dCA9IHRpbWVvdXQgPT0gbnVsbCA/IDEwZTMgOiB0aW1lb3V0XG4gIGFsbG93SDIgPSBhbGxvd0gyICE9IG51bGwgPyBhbGxvd0gyIDogZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbm5lY3QgKHsgaG9zdG5hbWUsIGhvc3QsIHByb3RvY29sLCBwb3J0LCBzZXJ2ZXJuYW1lLCBsb2NhbEFkZHJlc3MsIGh0dHBTb2NrZXQgfSwgY2FsbGJhY2spIHtcbiAgICBsZXQgc29ja2V0XG4gICAgaWYgKHByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgaWYgKCF0bHMpIHtcbiAgICAgICAgdGxzID0gcmVxdWlyZSgndGxzJylcbiAgICAgIH1cbiAgICAgIHNlcnZlcm5hbWUgPSBzZXJ2ZXJuYW1lIHx8IG9wdGlvbnMuc2VydmVybmFtZSB8fCB1dGlsLmdldFNlcnZlck5hbWUoaG9zdCkgfHwgbnVsbFxuXG4gICAgICBjb25zdCBzZXNzaW9uS2V5ID0gc2VydmVybmFtZSB8fCBob3N0bmFtZVxuICAgICAgY29uc3Qgc2Vzc2lvbiA9IHNlc3Npb25DYWNoZS5nZXQoc2Vzc2lvbktleSkgfHwgbnVsbFxuXG4gICAgICBhc3NlcnQoc2Vzc2lvbktleSlcblxuICAgICAgc29ja2V0ID0gdGxzLmNvbm5lY3Qoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiAxNjM4NCwgLy8gVExTIGluIG5vZGUgY2FuJ3QgaGF2ZSBiaWdnZXIgSFdNIGFueXdheS4uLlxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzZXJ2ZXJuYW1lLFxuICAgICAgICBzZXNzaW9uLFxuICAgICAgICBsb2NhbEFkZHJlc3MsXG4gICAgICAgIC8vIFRPRE8oSFRUUC8yKTogQWRkIHN1cHBvcnQgZm9yIGgyY1xuICAgICAgICBBTFBOUHJvdG9jb2xzOiBhbGxvd0gyID8gWydodHRwLzEuMScsICdoMiddIDogWydodHRwLzEuMSddLFxuICAgICAgICBzb2NrZXQ6IGh0dHBTb2NrZXQsIC8vIHVwZ3JhZGUgc29ja2V0IGNvbm5lY3Rpb25cbiAgICAgICAgcG9ydDogcG9ydCB8fCA0NDMsXG4gICAgICAgIGhvc3Q6IGhvc3RuYW1lXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXRcbiAgICAgICAgLm9uKCdzZXNzaW9uJywgZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBDYW4gYSBzZXNzaW9uIGJlY29tZSBpbnZhbGlkIG9uY2UgZXN0YWJsaXNoZWQ/IERvbid0IHRoaW5rIHNvP1xuICAgICAgICAgIHNlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgc2Vzc2lvbilcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KCFodHRwU29ja2V0LCAnaHR0cFNvY2tldCBjYW4gb25seSBiZSBzZW50IG9uIFRMUyB1cGRhdGUnKVxuICAgICAgc29ja2V0ID0gbmV0LmNvbm5lY3Qoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiA2NCAqIDEwMjQsIC8vIFNhbWUgYXMgbm9kZWpzIGZzIHN0cmVhbXMuXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGxvY2FsQWRkcmVzcyxcbiAgICAgICAgcG9ydDogcG9ydCB8fCA4MCxcbiAgICAgICAgaG9zdDogaG9zdG5hbWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gU2V0IFRDUCBrZWVwIGFsaXZlIG9wdGlvbnMgb24gdGhlIHNvY2tldCBoZXJlIGluc3RlYWQgb2YgaW4gY29ubmVjdCgpIGZvciB0aGUgY2FzZSBvZiBhc3NpZ25pbmcgdGhlIHNvY2tldFxuICAgIGlmIChvcHRpb25zLmtlZXBBbGl2ZSA9PSBudWxsIHx8IG9wdGlvbnMua2VlcEFsaXZlKSB7XG4gICAgICBjb25zdCBrZWVwQWxpdmVJbml0aWFsRGVsYXkgPSBvcHRpb25zLmtlZXBBbGl2ZUluaXRpYWxEZWxheSA9PT0gdW5kZWZpbmVkID8gNjBlMyA6IG9wdGlvbnMua2VlcEFsaXZlSW5pdGlhbERlbGF5XG4gICAgICBzb2NrZXQuc2V0S2VlcEFsaXZlKHRydWUsIGtlZXBBbGl2ZUluaXRpYWxEZWxheSlcbiAgICB9XG5cbiAgICBjb25zdCBjYW5jZWxUaW1lb3V0ID0gc2V0dXBUaW1lb3V0KCgpID0+IG9uQ29ubmVjdFRpbWVvdXQoc29ja2V0KSwgdGltZW91dClcblxuICAgIHNvY2tldFxuICAgICAgLnNldE5vRGVsYXkodHJ1ZSlcbiAgICAgIC5vbmNlKHByb3RvY29sID09PSAnaHR0cHM6JyA/ICdzZWN1cmVDb25uZWN0JyA6ICdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5jZWxUaW1lb3V0KClcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICAgICAgY2IobnVsbCwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNhbmNlbFRpbWVvdXQoKVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IG51bGxcbiAgICAgICAgICBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICByZXR1cm4gc29ja2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBUaW1lb3V0IChvbkNvbm5lY3RUaW1lb3V0LCB0aW1lb3V0KSB7XG4gIGlmICghdGltZW91dCkge1xuICAgIHJldHVybiAoKSA9PiB7fVxuICB9XG5cbiAgbGV0IHMxID0gbnVsbFxuICBsZXQgczIgPSBudWxsXG4gIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIC8vIHNldEltbWVkaWF0ZSBpcyBhZGRlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBwcmlvdG9yaXNlIHNvY2tldCBlcnJvciBldmVudHMgb3ZlciB0aW1lb3V0c1xuICAgIHMxID0gc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgIC8vIFdpbmRvd3MgbmVlZHMgYW4gZXh0cmEgc2V0SW1tZWRpYXRlIHByb2JhYmx5IGR1ZSB0byBpbXBsZW1lbnRhdGlvbiBkaWZmZXJlbmNlcyBpbiB0aGUgc29ja2V0IGxvZ2ljXG4gICAgICAgIHMyID0gc2V0SW1tZWRpYXRlKCgpID0+IG9uQ29ubmVjdFRpbWVvdXQoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uQ29ubmVjdFRpbWVvdXQoKVxuICAgICAgfVxuICAgIH0pXG4gIH0sIHRpbWVvdXQpXG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICBjbGVhckltbWVkaWF0ZShzMSlcbiAgICBjbGVhckltbWVkaWF0ZShzMilcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNvbm5lY3RUaW1lb3V0IChzb2NrZXQpIHtcbiAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IENvbm5lY3RUaW1lb3V0RXJyb3IoKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWlsZENvbm5lY3RvclxuIl0sIm5hbWVzIjpbIm5ldCIsInJlcXVpcmUiLCJhc3NlcnQiLCJ1dGlsIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJDb25uZWN0VGltZW91dEVycm9yIiwidGxzIiwiU2Vzc2lvbkNhY2hlIiwiZ2xvYmFsIiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9WOF9DT1ZFUkFHRSIsIldlYWtTZXNzaW9uQ2FjaGUiLCJjb25zdHJ1Y3RvciIsIm1heENhY2hlZFNlc3Npb25zIiwiX21heENhY2hlZFNlc3Npb25zIiwiX3Nlc3Npb25DYWNoZSIsIk1hcCIsIl9zZXNzaW9uUmVnaXN0cnkiLCJrZXkiLCJzaXplIiwicmVmIiwiZ2V0IiwidW5kZWZpbmVkIiwiZGVyZWYiLCJkZWxldGUiLCJzZXNzaW9uS2V5Iiwic2V0Iiwic2Vzc2lvbiIsIldlYWtSZWYiLCJyZWdpc3RlciIsIlNpbXBsZVNlc3Npb25DYWNoZSIsInZhbHVlIiwib2xkZXN0S2V5Iiwia2V5cyIsIm5leHQiLCJidWlsZENvbm5lY3RvciIsImFsbG93SDIiLCJzb2NrZXRQYXRoIiwidGltZW91dCIsIm9wdHMiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJvcHRpb25zIiwicGF0aCIsInNlc3Npb25DYWNoZSIsImNvbm5lY3QiLCJob3N0bmFtZSIsImhvc3QiLCJwcm90b2NvbCIsInBvcnQiLCJzZXJ2ZXJuYW1lIiwibG9jYWxBZGRyZXNzIiwiaHR0cFNvY2tldCIsImNhbGxiYWNrIiwic29ja2V0IiwiZ2V0U2VydmVyTmFtZSIsImhpZ2hXYXRlck1hcmsiLCJBTFBOUHJvdG9jb2xzIiwib24iLCJrZWVwQWxpdmUiLCJrZWVwQWxpdmVJbml0aWFsRGVsYXkiLCJzZXRLZWVwQWxpdmUiLCJjYW5jZWxUaW1lb3V0Iiwic2V0dXBUaW1lb3V0Iiwib25Db25uZWN0VGltZW91dCIsInNldE5vRGVsYXkiLCJvbmNlIiwiY2IiLCJlcnIiLCJzMSIsInMyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsInNldEltbWVkaWF0ZSIsInBsYXRmb3JtIiwiY2xlYXJUaW1lb3V0IiwiY2xlYXJJbW1lZGlhdGUiLCJkZXN0cm95IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/core/connect.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/core/errors.js":
/*!****************************************************!*\
  !*** ../../node_modules/undici/lib/core/errors.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nclass UndiciError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"UndiciError\";\n        this.code = \"UND_ERR\";\n    }\n}\nclass ConnectTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ConnectTimeoutError);\n        this.name = \"ConnectTimeoutError\";\n        this.message = message || \"Connect Timeout Error\";\n        this.code = \"UND_ERR_CONNECT_TIMEOUT\";\n    }\n}\nclass HeadersTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, HeadersTimeoutError);\n        this.name = \"HeadersTimeoutError\";\n        this.message = message || \"Headers Timeout Error\";\n        this.code = \"UND_ERR_HEADERS_TIMEOUT\";\n    }\n}\nclass HeadersOverflowError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, HeadersOverflowError);\n        this.name = \"HeadersOverflowError\";\n        this.message = message || \"Headers Overflow Error\";\n        this.code = \"UND_ERR_HEADERS_OVERFLOW\";\n    }\n}\nclass BodyTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, BodyTimeoutError);\n        this.name = \"BodyTimeoutError\";\n        this.message = message || \"Body Timeout Error\";\n        this.code = \"UND_ERR_BODY_TIMEOUT\";\n    }\n}\nclass ResponseStatusCodeError extends UndiciError {\n    constructor(message, statusCode, headers, body){\n        super(message);\n        Error.captureStackTrace(this, ResponseStatusCodeError);\n        this.name = \"ResponseStatusCodeError\";\n        this.message = message || \"Response Status Code Error\";\n        this.code = \"UND_ERR_RESPONSE_STATUS_CODE\";\n        this.body = body;\n        this.status = statusCode;\n        this.statusCode = statusCode;\n        this.headers = headers;\n    }\n}\nclass InvalidArgumentError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, InvalidArgumentError);\n        this.name = \"InvalidArgumentError\";\n        this.message = message || \"Invalid Argument Error\";\n        this.code = \"UND_ERR_INVALID_ARG\";\n    }\n}\nclass InvalidReturnValueError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, InvalidReturnValueError);\n        this.name = \"InvalidReturnValueError\";\n        this.message = message || \"Invalid Return Value Error\";\n        this.code = \"UND_ERR_INVALID_RETURN_VALUE\";\n    }\n}\nclass RequestAbortedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, RequestAbortedError);\n        this.name = \"AbortError\";\n        this.message = message || \"Request aborted\";\n        this.code = \"UND_ERR_ABORTED\";\n    }\n}\nclass InformationalError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, InformationalError);\n        this.name = \"InformationalError\";\n        this.message = message || \"Request information\";\n        this.code = \"UND_ERR_INFO\";\n    }\n}\nclass RequestContentLengthMismatchError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, RequestContentLengthMismatchError);\n        this.name = \"RequestContentLengthMismatchError\";\n        this.message = message || \"Request body length does not match content-length header\";\n        this.code = \"UND_ERR_REQ_CONTENT_LENGTH_MISMATCH\";\n    }\n}\nclass ResponseContentLengthMismatchError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ResponseContentLengthMismatchError);\n        this.name = \"ResponseContentLengthMismatchError\";\n        this.message = message || \"Response body length does not match content-length header\";\n        this.code = \"UND_ERR_RES_CONTENT_LENGTH_MISMATCH\";\n    }\n}\nclass ClientDestroyedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ClientDestroyedError);\n        this.name = \"ClientDestroyedError\";\n        this.message = message || \"The client is destroyed\";\n        this.code = \"UND_ERR_DESTROYED\";\n    }\n}\nclass ClientClosedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ClientClosedError);\n        this.name = \"ClientClosedError\";\n        this.message = message || \"The client is closed\";\n        this.code = \"UND_ERR_CLOSED\";\n    }\n}\nclass SocketError extends UndiciError {\n    constructor(message, socket){\n        super(message);\n        Error.captureStackTrace(this, SocketError);\n        this.name = \"SocketError\";\n        this.message = message || \"Socket error\";\n        this.code = \"UND_ERR_SOCKET\";\n        this.socket = socket;\n    }\n}\nclass NotSupportedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, NotSupportedError);\n        this.name = \"NotSupportedError\";\n        this.message = message || \"Not supported error\";\n        this.code = \"UND_ERR_NOT_SUPPORTED\";\n    }\n}\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, NotSupportedError);\n        this.name = \"MissingUpstreamError\";\n        this.message = message || \"No upstream has been added to the BalancedPool\";\n        this.code = \"UND_ERR_BPL_MISSING_UPSTREAM\";\n    }\n}\nclass HTTPParserError extends Error {\n    constructor(message, code, data){\n        super(message);\n        Error.captureStackTrace(this, HTTPParserError);\n        this.name = \"HTTPParserError\";\n        this.code = code ? `HPE_${code}` : undefined;\n        this.data = data ? data.toString() : undefined;\n    }\n}\nclass ResponseExceededMaxSizeError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ResponseExceededMaxSizeError);\n        this.name = \"ResponseExceededMaxSizeError\";\n        this.message = message || \"Response content exceeded max size\";\n        this.code = \"UND_ERR_RES_EXCEEDED_MAX_SIZE\";\n    }\n}\nmodule.exports = {\n    HTTPParserError,\n    UndiciError,\n    HeadersTimeoutError,\n    HeadersOverflowError,\n    BodyTimeoutError,\n    RequestContentLengthMismatchError,\n    ConnectTimeoutError,\n    ResponseStatusCodeError,\n    InvalidArgumentError,\n    InvalidReturnValueError,\n    RequestAbortedError,\n    ClientDestroyedError,\n    ClientClosedError,\n    InformationalError,\n    SocketError,\n    NotSupportedError,\n    ResponseContentLengthMismatchError,\n    BalancedPoolMissingUpstreamError,\n    ResponseExceededMaxSizeError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxvQkFBb0JDO0lBQ3hCQyxZQUFhQyxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsTUFBTUMsNEJBQTRCTjtJQUNoQ0UsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTkYsTUFBTU0saUJBQWlCLENBQUMsSUFBSSxFQUFFRDtRQUM5QixJQUFJLENBQUNGLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1HLDRCQUE0QlI7SUFDaENFLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ05GLE1BQU1NLGlCQUFpQixDQUFDLElBQUksRUFBRUM7UUFDOUIsSUFBSSxDQUFDSixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNELE9BQU8sR0FBR0EsV0FBVztRQUMxQixJQUFJLENBQUNFLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxNQUFNSSw2QkFBNkJUO0lBQ2pDRSxZQUFhQyxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTtRQUNORixNQUFNTSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVFO1FBQzlCLElBQUksQ0FBQ0wsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsTUFBTUsseUJBQXlCVjtJQUM3QkUsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTkYsTUFBTU0saUJBQWlCLENBQUMsSUFBSSxFQUFFRztRQUM5QixJQUFJLENBQUNOLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1NLGdDQUFnQ1g7SUFDcENFLFlBQWFDLE9BQU8sRUFBRVMsVUFBVSxFQUFFQyxPQUFPLEVBQUVDLElBQUksQ0FBRTtRQUMvQyxLQUFLLENBQUNYO1FBQ05GLE1BQU1NLGlCQUFpQixDQUFDLElBQUksRUFBRUk7UUFDOUIsSUFBSSxDQUFDUCxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNELE9BQU8sR0FBR0EsV0FBVztRQUMxQixJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ1MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsTUFBTSxHQUFHSDtRQUNkLElBQUksQ0FBQ0EsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLE9BQU8sR0FBR0E7SUFDakI7QUFDRjtBQUVBLE1BQU1HLDZCQUE2QmhCO0lBQ2pDRSxZQUFhQyxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTtRQUNORixNQUFNTSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVTO1FBQzlCLElBQUksQ0FBQ1osSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsTUFBTVksZ0NBQWdDakI7SUFDcENFLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ05GLE1BQU1NLGlCQUFpQixDQUFDLElBQUksRUFBRVU7UUFDOUIsSUFBSSxDQUFDYixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNELE9BQU8sR0FBR0EsV0FBVztRQUMxQixJQUFJLENBQUNFLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxNQUFNYSw0QkFBNEJsQjtJQUNoQ0UsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTkYsTUFBTU0saUJBQWlCLENBQUMsSUFBSSxFQUFFVztRQUM5QixJQUFJLENBQUNkLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1jLDJCQUEyQm5CO0lBQy9CRSxZQUFhQyxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTtRQUNORixNQUFNTSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVZO1FBQzlCLElBQUksQ0FBQ2YsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsTUFBTWUsMENBQTBDcEI7SUFDOUNFLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ05GLE1BQU1NLGlCQUFpQixDQUFDLElBQUksRUFBRWE7UUFDOUIsSUFBSSxDQUFDaEIsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsTUFBTWdCLDJDQUEyQ3JCO0lBQy9DRSxZQUFhQyxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTtRQUNORixNQUFNTSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVjO1FBQzlCLElBQUksQ0FBQ2pCLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1pQiw2QkFBNkJ0QjtJQUNqQ0UsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTkYsTUFBTU0saUJBQWlCLENBQUMsSUFBSSxFQUFFZTtRQUM5QixJQUFJLENBQUNsQixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNELE9BQU8sR0FBR0EsV0FBVztRQUMxQixJQUFJLENBQUNFLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxNQUFNa0IsMEJBQTBCdkI7SUFDOUJFLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ05GLE1BQU1NLGlCQUFpQixDQUFDLElBQUksRUFBRWdCO1FBQzlCLElBQUksQ0FBQ25CLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1tQixvQkFBb0J4QjtJQUN4QkUsWUFBYUMsT0FBTyxFQUFFc0IsTUFBTSxDQUFFO1FBQzVCLEtBQUssQ0FBQ3RCO1FBQ05GLE1BQU1NLGlCQUFpQixDQUFDLElBQUksRUFBRWlCO1FBQzlCLElBQUksQ0FBQ3BCLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDb0IsTUFBTSxHQUFHQTtJQUNoQjtBQUNGO0FBRUEsTUFBTUMsMEJBQTBCMUI7SUFDOUJFLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ05GLE1BQU1NLGlCQUFpQixDQUFDLElBQUksRUFBRW1CO1FBQzlCLElBQUksQ0FBQ3RCLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1zQix5Q0FBeUMzQjtJQUM3Q0UsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTkYsTUFBTU0saUJBQWlCLENBQUMsSUFBSSxFQUFFbUI7UUFDOUIsSUFBSSxDQUFDdEIsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsTUFBTXVCLHdCQUF3QjNCO0lBQzVCQyxZQUFhQyxPQUFPLEVBQUVFLElBQUksRUFBRXdCLElBQUksQ0FBRTtRQUNoQyxLQUFLLENBQUMxQjtRQUNORixNQUFNTSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVxQjtRQUM5QixJQUFJLENBQUN4QixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLElBQUksR0FBR0EsT0FBTyxDQUFDLElBQUksRUFBRUEsS0FBSyxDQUFDLEdBQUd5QjtRQUNuQyxJQUFJLENBQUNELElBQUksR0FBR0EsT0FBT0EsS0FBS0UsUUFBUSxLQUFLRDtJQUN2QztBQUNGO0FBRUEsTUFBTUUscUNBQXFDaEM7SUFDekNFLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ05GLE1BQU1NLGlCQUFpQixDQUFDLElBQUksRUFBRXlCO1FBQzlCLElBQUksQ0FBQzVCLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBNEIsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZOO0lBQ0E1QjtJQUNBUTtJQUNBQztJQUNBQztJQUNBVTtJQUNBZDtJQUNBSztJQUNBSztJQUNBQztJQUNBQztJQUNBSTtJQUNBQztJQUNBSjtJQUNBSztJQUNBRTtJQUNBTDtJQUNBTTtJQUNBSztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Vycm9ycy5qcz84MDQ5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jbGFzcyBVbmRpY2lFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdVbmRpY2lFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUidcbiAgfVxufVxuXG5jbGFzcyBDb25uZWN0VGltZW91dEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ29ubmVjdFRpbWVvdXRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnQ29ubmVjdFRpbWVvdXRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdDb25uZWN0IFRpbWVvdXQgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQ09OTkVDVF9USU1FT1VUJ1xuICB9XG59XG5cbmNsYXNzIEhlYWRlcnNUaW1lb3V0RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBIZWFkZXJzVGltZW91dEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdIZWFkZXJzVGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0hlYWRlcnMgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9IRUFERVJTX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgSGVhZGVyc092ZXJmbG93RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBIZWFkZXJzT3ZlcmZsb3dFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnSGVhZGVyc092ZXJmbG93RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSGVhZGVycyBPdmVyZmxvdyBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9IRUFERVJTX09WRVJGTE9XJ1xuICB9XG59XG5cbmNsYXNzIEJvZHlUaW1lb3V0RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBCb2R5VGltZW91dEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdCb2R5VGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0JvZHkgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9CT0RZX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVzcG9uc2UgU3RhdHVzIENvZGUgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUkVTUE9OU0VfU1RBVFVTX0NPREUnXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzQ29kZVxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGVcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gIH1cbn1cblxuY2xhc3MgSW52YWxpZEFyZ3VtZW50RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnZhbGlkQXJndW1lbnRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnSW52YWxpZEFyZ3VtZW50RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSW52YWxpZCBBcmd1bWVudCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9JTlZBTElEX0FSRydcbiAgfVxufVxuXG5jbGFzcyBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdJbnZhbGlkIFJldHVybiBWYWx1ZSBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSdcbiAgfVxufVxuXG5jbGFzcyBSZXF1ZXN0QWJvcnRlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVxdWVzdEFib3J0ZWRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGFib3J0ZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQUJPUlRFRCdcbiAgfVxufVxuXG5jbGFzcyBJbmZvcm1hdGlvbmFsRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbmZvcm1hdGlvbmFsRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0luZm9ybWF0aW9uYWxFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGluZm9ybWF0aW9uJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0lORk8nXG4gIH1cbn1cblxuY2xhc3MgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVxdWVzdCBib2R5IGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBjb250ZW50LWxlbmd0aCBoZWFkZXInXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUkVRX0NPTlRFTlRfTEVOR1RIX01JU01BVENIJ1xuICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVNfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnXG4gIH1cbn1cblxuY2xhc3MgQ2xpZW50RGVzdHJveWVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDbGllbnREZXN0cm95ZWRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnQ2xpZW50RGVzdHJveWVkRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhlIGNsaWVudCBpcyBkZXN0cm95ZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfREVTVFJPWUVEJ1xuICB9XG59XG5cbmNsYXNzIENsaWVudENsb3NlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ2xpZW50Q2xvc2VkRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0NsaWVudENsb3NlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSBjbGllbnQgaXMgY2xvc2VkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0NMT1NFRCdcbiAgfVxufVxuXG5jbGFzcyBTb2NrZXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIHNvY2tldCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgU29ja2V0RXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ1NvY2tldEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1NvY2tldCBlcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9TT0NLRVQnXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgfVxufVxuXG5jbGFzcyBOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE5vdFN1cHBvcnRlZEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdOb3RTdXBwb3J0ZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdOb3Qgc3VwcG9ydGVkIGVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX05PVF9TVVBQT1JURUQnXG4gIH1cbn1cblxuY2xhc3MgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBOb3RTdXBwb3J0ZWRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnTWlzc2luZ1Vwc3RyZWFtRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnTm8gdXBzdHJlYW0gaGFzIGJlZW4gYWRkZWQgdG8gdGhlIEJhbGFuY2VkUG9vbCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9CUExfTUlTU0lOR19VUFNUUkVBTSdcbiAgfVxufVxuXG5jbGFzcyBIVFRQUGFyc2VyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBjb2RlLCBkYXRhKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBIVFRQUGFyc2VyRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0hUVFBQYXJzZXJFcnJvcidcbiAgICB0aGlzLmNvZGUgPSBjb2RlID8gYEhQRV8ke2NvZGV9YCA6IHVuZGVmaW5lZFxuICAgIHRoaXMuZGF0YSA9IGRhdGEgPyBkYXRhLnRvU3RyaW5nKCkgOiB1bmRlZmluZWRcbiAgfVxufVxuXG5jbGFzcyBSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXNwb25zZSBjb250ZW50IGV4Y2VlZGVkIG1heCBzaXplJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU19FWENFRURFRF9NQVhfU0laRSdcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSFRUUFBhcnNlckVycm9yLFxuICBVbmRpY2lFcnJvcixcbiAgSGVhZGVyc1RpbWVvdXRFcnJvcixcbiAgSGVhZGVyc092ZXJmbG93RXJyb3IsXG4gIEJvZHlUaW1lb3V0RXJyb3IsXG4gIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgQ29ubmVjdFRpbWVvdXRFcnJvcixcbiAgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgQ2xpZW50RGVzdHJveWVkRXJyb3IsXG4gIENsaWVudENsb3NlZEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIFNvY2tldEVycm9yLFxuICBOb3RTdXBwb3J0ZWRFcnJvcixcbiAgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsXG4gIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3Jcbn1cbiJdLCJuYW1lcyI6WyJVbmRpY2lFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsImNvZGUiLCJDb25uZWN0VGltZW91dEVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJIZWFkZXJzVGltZW91dEVycm9yIiwiSGVhZGVyc092ZXJmbG93RXJyb3IiLCJCb2R5VGltZW91dEVycm9yIiwiUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IiLCJzdGF0dXNDb2RlIiwiaGVhZGVycyIsImJvZHkiLCJzdGF0dXMiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkludmFsaWRSZXR1cm5WYWx1ZUVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsIkluZm9ybWF0aW9uYWxFcnJvciIsIlJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciIsIlJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IiLCJDbGllbnREZXN0cm95ZWRFcnJvciIsIkNsaWVudENsb3NlZEVycm9yIiwiU29ja2V0RXJyb3IiLCJzb2NrZXQiLCJOb3RTdXBwb3J0ZWRFcnJvciIsIkJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yIiwiSFRUUFBhcnNlckVycm9yIiwiZGF0YSIsInVuZGVmaW5lZCIsInRvU3RyaW5nIiwiUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/core/errors.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/core/request.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/core/request.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { InvalidArgumentError, NotSupportedError } = __webpack_require__(/*! ./errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst util = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\n// tokenRegExp and headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n */ const tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/;\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */ const headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/;\nconst kHandler = Symbol(\"handler\");\nconst channels = {};\nlet extractBody;\ntry {\n    const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\n    channels.create = diagnosticsChannel.channel(\"undici:request:create\");\n    channels.bodySent = diagnosticsChannel.channel(\"undici:request:bodySent\");\n    channels.headers = diagnosticsChannel.channel(\"undici:request:headers\");\n    channels.trailers = diagnosticsChannel.channel(\"undici:request:trailers\");\n    channels.error = diagnosticsChannel.channel(\"undici:request:error\");\n} catch  {\n    channels.create = {\n        hasSubscribers: false\n    };\n    channels.bodySent = {\n        hasSubscribers: false\n    };\n    channels.headers = {\n        hasSubscribers: false\n    };\n    channels.trailers = {\n        hasSubscribers: false\n    };\n    channels.error = {\n        hasSubscribers: false\n    };\n}\nclass Request {\n    constructor(origin, { path, method, body, headers, query, idempotent, blocking, upgrade, headersTimeout, bodyTimeout, reset, throwOnError, expectContinue }, handler){\n        if (typeof path !== \"string\") {\n            throw new InvalidArgumentError(\"path must be a string\");\n        } else if (path[0] !== \"/\" && !(path.startsWith(\"http://\") || path.startsWith(\"https://\")) && method !== \"CONNECT\") {\n            throw new InvalidArgumentError(\"path must be an absolute URL or start with a slash\");\n        } else if (invalidPathRegex.exec(path) !== null) {\n            throw new InvalidArgumentError(\"invalid request path\");\n        }\n        if (typeof method !== \"string\") {\n            throw new InvalidArgumentError(\"method must be a string\");\n        } else if (tokenRegExp.exec(method) === null) {\n            throw new InvalidArgumentError(\"invalid request method\");\n        }\n        if (upgrade && typeof upgrade !== \"string\") {\n            throw new InvalidArgumentError(\"upgrade must be a string\");\n        }\n        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n            throw new InvalidArgumentError(\"invalid headersTimeout\");\n        }\n        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n            throw new InvalidArgumentError(\"invalid bodyTimeout\");\n        }\n        if (reset != null && typeof reset !== \"boolean\") {\n            throw new InvalidArgumentError(\"invalid reset\");\n        }\n        if (expectContinue != null && typeof expectContinue !== \"boolean\") {\n            throw new InvalidArgumentError(\"invalid expectContinue\");\n        }\n        this.headersTimeout = headersTimeout;\n        this.bodyTimeout = bodyTimeout;\n        this.throwOnError = throwOnError === true;\n        this.method = method;\n        this.abort = null;\n        if (body == null) {\n            this.body = null;\n        } else if (util.isStream(body)) {\n            this.body = body;\n            const rState = this.body._readableState;\n            if (!rState || !rState.autoDestroy) {\n                this.endHandler = function autoDestroy() {\n                    util.destroy(this);\n                };\n                this.body.on(\"end\", this.endHandler);\n            }\n            this.errorHandler = (err)=>{\n                if (this.abort) {\n                    this.abort(err);\n                } else {\n                    this.error = err;\n                }\n            };\n            this.body.on(\"error\", this.errorHandler);\n        } else if (util.isBuffer(body)) {\n            this.body = body.byteLength ? body : null;\n        } else if (ArrayBuffer.isView(body)) {\n            this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;\n        } else if (body instanceof ArrayBuffer) {\n            this.body = body.byteLength ? Buffer.from(body) : null;\n        } else if (typeof body === \"string\") {\n            this.body = body.length ? Buffer.from(body) : null;\n        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {\n            this.body = body;\n        } else {\n            throw new InvalidArgumentError(\"body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable\");\n        }\n        this.completed = false;\n        this.aborted = false;\n        this.upgrade = upgrade || null;\n        this.path = query ? util.buildURL(path, query) : path;\n        this.origin = origin;\n        this.idempotent = idempotent == null ? method === \"HEAD\" || method === \"GET\" : idempotent;\n        this.blocking = blocking == null ? false : blocking;\n        this.reset = reset == null ? null : reset;\n        this.host = null;\n        this.contentLength = null;\n        this.contentType = null;\n        this.headers = \"\";\n        // Only for H2\n        this.expectContinue = expectContinue != null ? expectContinue : false;\n        if (Array.isArray(headers)) {\n            if (headers.length % 2 !== 0) {\n                throw new InvalidArgumentError(\"headers array must be even\");\n            }\n            for(let i = 0; i < headers.length; i += 2){\n                processHeader(this, headers[i], headers[i + 1]);\n            }\n        } else if (headers && typeof headers === \"object\") {\n            const keys = Object.keys(headers);\n            for(let i = 0; i < keys.length; i++){\n                const key = keys[i];\n                processHeader(this, key, headers[key]);\n            }\n        } else if (headers != null) {\n            throw new InvalidArgumentError(\"headers must be an object or an array\");\n        }\n        if (util.isFormDataLike(this.body)) {\n            if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {\n                throw new InvalidArgumentError(\"Form-Data bodies are only supported in node v16.8 and newer.\");\n            }\n            if (!extractBody) {\n                extractBody = (__webpack_require__(/*! ../fetch/body.js */ \"(rsc)/../../node_modules/undici/lib/fetch/body.js\").extractBody);\n            }\n            const [bodyStream, contentType] = extractBody(body);\n            if (this.contentType == null) {\n                this.contentType = contentType;\n                this.headers += `content-type: ${contentType}\\r\\n`;\n            }\n            this.body = bodyStream.stream;\n            this.contentLength = bodyStream.length;\n        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {\n            this.contentType = body.type;\n            this.headers += `content-type: ${body.type}\\r\\n`;\n        }\n        util.validateHandler(handler, method, upgrade);\n        this.servername = util.getServerName(this.host);\n        this[kHandler] = handler;\n        if (channels.create.hasSubscribers) {\n            channels.create.publish({\n                request: this\n            });\n        }\n    }\n    onBodySent(chunk) {\n        if (this[kHandler].onBodySent) {\n            try {\n                this[kHandler].onBodySent(chunk);\n            } catch (err) {\n                this.onError(err);\n            }\n        }\n    }\n    onRequestSent() {\n        if (channels.bodySent.hasSubscribers) {\n            channels.bodySent.publish({\n                request: this\n            });\n        }\n        if (this[kHandler].onRequestSent) {\n            try {\n                this[kHandler].onRequestSent();\n            } catch (err) {\n                this.onError(err);\n            }\n        }\n    }\n    onConnect(abort) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        if (this.error) {\n            abort(this.error);\n        } else {\n            this.abort = abort;\n            return this[kHandler].onConnect(abort);\n        }\n    }\n    onHeaders(statusCode, headers, resume, statusText) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        if (channels.headers.hasSubscribers) {\n            channels.headers.publish({\n                request: this,\n                response: {\n                    statusCode,\n                    headers,\n                    statusText\n                }\n            });\n        }\n        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);\n    }\n    onData(chunk) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onData(chunk);\n    }\n    onUpgrade(statusCode, headers, socket) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onUpgrade(statusCode, headers, socket);\n    }\n    onComplete(trailers) {\n        this.onFinally();\n        assert(!this.aborted);\n        this.completed = true;\n        if (channels.trailers.hasSubscribers) {\n            channels.trailers.publish({\n                request: this,\n                trailers\n            });\n        }\n        return this[kHandler].onComplete(trailers);\n    }\n    onError(error) {\n        this.onFinally();\n        if (channels.error.hasSubscribers) {\n            channels.error.publish({\n                request: this,\n                error\n            });\n        }\n        if (this.aborted) {\n            return;\n        }\n        this.aborted = true;\n        return this[kHandler].onError(error);\n    }\n    onFinally() {\n        if (this.errorHandler) {\n            this.body.off(\"error\", this.errorHandler);\n            this.errorHandler = null;\n        }\n        if (this.endHandler) {\n            this.body.off(\"end\", this.endHandler);\n            this.endHandler = null;\n        }\n    }\n    // TODO: adjust to support H2\n    addHeader(key, value) {\n        processHeader(this, key, value);\n        return this;\n    }\n    static [kHTTP1BuildRequest](origin, opts, handler) {\n        // TODO: Migrate header parsing here, to make Requests\n        // HTTP agnostic\n        return new Request(origin, opts, handler);\n    }\n    static [kHTTP2BuildRequest](origin, opts, handler) {\n        const headers = opts.headers;\n        opts = {\n            ...opts,\n            headers: null\n        };\n        const request = new Request(origin, opts, handler);\n        request.headers = {};\n        if (Array.isArray(headers)) {\n            if (headers.length % 2 !== 0) {\n                throw new InvalidArgumentError(\"headers array must be even\");\n            }\n            for(let i = 0; i < headers.length; i += 2){\n                processHeader(request, headers[i], headers[i + 1], true);\n            }\n        } else if (headers && typeof headers === \"object\") {\n            const keys = Object.keys(headers);\n            for(let i = 0; i < keys.length; i++){\n                const key = keys[i];\n                processHeader(request, key, headers[key], true);\n            }\n        } else if (headers != null) {\n            throw new InvalidArgumentError(\"headers must be an object or an array\");\n        }\n        return request;\n    }\n    static [kHTTP2CopyHeaders](raw) {\n        const rawHeaders = raw.split(\"\\r\\n\");\n        const headers = {};\n        for (const header of rawHeaders){\n            const [key, value] = header.split(\": \");\n            if (value == null || value.length === 0) continue;\n            if (headers[key]) headers[key] += `,${value}`;\n            else headers[key] = value;\n        }\n        return headers;\n    }\n}\nfunction processHeaderValue(key, val, skipAppend) {\n    if (val && typeof val === \"object\") {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n    }\n    val = val != null ? `${val}` : \"\";\n    if (headerCharRegex.exec(val) !== null) {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n    }\n    return skipAppend ? val : `${key}: ${val}\\r\\n`;\n}\nfunction processHeader(request, key, val, skipAppend = false) {\n    if (val && typeof val === \"object\" && !Array.isArray(val)) {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n    } else if (val === undefined) {\n        return;\n    }\n    if (request.host === null && key.length === 4 && key.toLowerCase() === \"host\") {\n        if (headerCharRegex.exec(val) !== null) {\n            throw new InvalidArgumentError(`invalid ${key} header`);\n        }\n        // Consumed by Client\n        request.host = val;\n    } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === \"content-length\") {\n        request.contentLength = parseInt(val, 10);\n        if (!Number.isFinite(request.contentLength)) {\n            throw new InvalidArgumentError(\"invalid content-length header\");\n        }\n    } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === \"content-type\") {\n        request.contentType = val;\n        if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);\n        else request.headers += processHeaderValue(key, val);\n    } else if (key.length === 17 && key.toLowerCase() === \"transfer-encoding\") {\n        throw new InvalidArgumentError(\"invalid transfer-encoding header\");\n    } else if (key.length === 10 && key.toLowerCase() === \"connection\") {\n        const value = typeof val === \"string\" ? val.toLowerCase() : null;\n        if (value !== \"close\" && value !== \"keep-alive\") {\n            throw new InvalidArgumentError(\"invalid connection header\");\n        } else if (value === \"close\") {\n            request.reset = true;\n        }\n    } else if (key.length === 10 && key.toLowerCase() === \"keep-alive\") {\n        throw new InvalidArgumentError(\"invalid keep-alive header\");\n    } else if (key.length === 7 && key.toLowerCase() === \"upgrade\") {\n        throw new InvalidArgumentError(\"invalid upgrade header\");\n    } else if (key.length === 6 && key.toLowerCase() === \"expect\") {\n        throw new NotSupportedError(\"expect header not supported\");\n    } else if (tokenRegExp.exec(key) === null) {\n        throw new InvalidArgumentError(\"invalid header key\");\n    } else {\n        if (Array.isArray(val)) {\n            for(let i = 0; i < val.length; i++){\n                if (skipAppend) {\n                    if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;\n                    else request.headers[key] = processHeaderValue(key, val[i], skipAppend);\n                } else {\n                    request.headers += processHeaderValue(key, val[i]);\n                }\n            }\n        } else {\n            if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);\n            else request.headers += processHeaderValue(key, val);\n        }\n    }\n}\nmodule.exports = Request;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSxvQkFBb0IsRUFDcEJDLGlCQUFpQixFQUNsQixHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUUsa0JBQWtCLEVBQUVDLGlCQUFpQixFQUFFQyxrQkFBa0IsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUM5RSxNQUFNSyxPQUFPTCxtQkFBT0EsQ0FBQztBQUVyQix3REFBd0Q7QUFDeEQsK0RBQStEO0FBRS9EOzs7O0NBSUMsR0FDRCxNQUFNTSxjQUFjO0FBRXBCOzs7OztDQUtDLEdBQ0QsTUFBTUMsa0JBQWtCO0FBRXhCLGtGQUFrRjtBQUNsRixNQUFNQyxtQkFBbUI7QUFFekIsTUFBTUMsV0FBV0MsT0FBTztBQUV4QixNQUFNQyxXQUFXLENBQUM7QUFFbEIsSUFBSUM7QUFFSixJQUFJO0lBQ0YsTUFBTUMscUJBQXFCYixtQkFBT0EsQ0FBQztJQUNuQ1csU0FBU0csTUFBTSxHQUFHRCxtQkFBbUJFLE9BQU8sQ0FBQztJQUM3Q0osU0FBU0ssUUFBUSxHQUFHSCxtQkFBbUJFLE9BQU8sQ0FBQztJQUMvQ0osU0FBU00sT0FBTyxHQUFHSixtQkFBbUJFLE9BQU8sQ0FBQztJQUM5Q0osU0FBU08sUUFBUSxHQUFHTCxtQkFBbUJFLE9BQU8sQ0FBQztJQUMvQ0osU0FBU1EsS0FBSyxHQUFHTixtQkFBbUJFLE9BQU8sQ0FBQztBQUM5QyxFQUFFLE9BQU07SUFDTkosU0FBU0csTUFBTSxHQUFHO1FBQUVNLGdCQUFnQjtJQUFNO0lBQzFDVCxTQUFTSyxRQUFRLEdBQUc7UUFBRUksZ0JBQWdCO0lBQU07SUFDNUNULFNBQVNNLE9BQU8sR0FBRztRQUFFRyxnQkFBZ0I7SUFBTTtJQUMzQ1QsU0FBU08sUUFBUSxHQUFHO1FBQUVFLGdCQUFnQjtJQUFNO0lBQzVDVCxT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d0MsWUFBWTtvQkFDZCxJQUFJMUIsUUFBUXBFLE9BQU8sQ0FBQzBELElBQUksRUFBRVUsUUFBUXBFLE9BQU8sQ0FBQzBELElBQUksSUFBSSxDQUFDLENBQUMsRUFBRWtDLG1CQUFtQmxDLEtBQUttQyxHQUFHLENBQUN2QyxFQUFFLEVBQUV3QyxZQUFZLENBQUM7eUJBQzlGMUIsUUFBUXBFLE9BQU8sQ0FBQzBELElBQUksR0FBR2tDLG1CQUFtQmxDLEtBQUttQyxHQUFHLENBQUN2QyxFQUFFLEVBQUV3QztnQkFDOUQsT0FBTztvQkFDTDFCLFFBQVFwRSxPQUFPLElBQUk0RixtQkFBbUJsQyxLQUFLbUMsR0FBRyxDQUFDdkMsRUFBRTtnQkFDbkQ7WUFDRjtRQUNGLE9BQU87WUFDTCxJQUFJd0MsWUFBWTFCLFFBQVFwRSxPQUFPLENBQUMwRCxJQUFJLEdBQUdrQyxtQkFBbUJsQyxLQUFLbUMsS0FBS0M7aUJBQy9EMUIsUUFBUXBFLE9BQU8sSUFBSTRGLG1CQUFtQmxDLEtBQUttQztRQUNsRDtJQUNGO0FBQ0Y7QUFFQUssT0FBT0MsT0FBTyxHQUFHL0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvcmVxdWVzdC5qcz84ZTc4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBOb3RTdXBwb3J0ZWRFcnJvclxufSA9IHJlcXVpcmUoJy4vZXJyb3JzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IGtIVFRQMkJ1aWxkUmVxdWVzdCwga0hUVFAyQ29weUhlYWRlcnMsIGtIVFRQMUJ1aWxkUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vLyB0b2tlblJlZ0V4cCBhbmQgaGVhZGVyQ2hhclJlZ2V4IGhhdmUgYmVlbiBsaWZ0ZWQgZnJvbVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFpbi9saWIvX2h0dHBfY29tbW9uLmpzXG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCB0aGUgZ2l2ZW4gdmFsIGlzIGEgdmFsaWQgSFRUUCB0b2tlblxuICogcGVyIHRoZSBydWxlcyBkZWZpbmVkIGluIFJGQyA3MjMwXG4gKiBTZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjIuNlxuICovXG5jb25zdCB0b2tlblJlZ0V4cCA9IC9eW1xcXl9gYS16QS1aXFwtMC05ISMkJSYnKisufH5dKyQvXG5cbi8qKlxuICogTWF0Y2hlcyBpZiB2YWwgY29udGFpbnMgYW4gaW52YWxpZCBmaWVsZC12Y2hhclxuICogIGZpZWxkLXZhbHVlICAgID0gKiggZmllbGQtY29udGVudCAvIG9icy1mb2xkIClcbiAqICBmaWVsZC1jb250ZW50ICA9IGZpZWxkLXZjaGFyIFsgMSooIFNQIC8gSFRBQiApIGZpZWxkLXZjaGFyIF1cbiAqICBmaWVsZC12Y2hhciAgICA9IFZDSEFSIC8gb2JzLXRleHRcbiAqL1xuY29uc3QgaGVhZGVyQ2hhclJlZ2V4ID0gL1teXFx0XFx4MjAtXFx4N2VcXHg4MC1cXHhmZl0vXG5cbi8vIFZlcmlmaWVzIHRoYXQgYSBnaXZlbiBwYXRoIGlzIHZhbGlkIGRvZXMgbm90IGNvbnRhaW4gY29udHJvbCBjaGFycyBcXHgwMCB0byBcXHgyMFxuY29uc3QgaW52YWxpZFBhdGhSZWdleCA9IC9bXlxcdTAwMjEtXFx1MDBmZl0vXG5cbmNvbnN0IGtIYW5kbGVyID0gU3ltYm9sKCdoYW5kbGVyJylcblxuY29uc3QgY2hhbm5lbHMgPSB7fVxuXG5sZXQgZXh0cmFjdEJvZHlcblxudHJ5IHtcbiAgY29uc3QgZGlhZ25vc3RpY3NDaGFubmVsID0gcmVxdWlyZSgnZGlhZ25vc3RpY3NfY2hhbm5lbCcpXG4gIGNoYW5uZWxzLmNyZWF0ZSA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpjcmVhdGUnKVxuICBjaGFubmVscy5ib2R5U2VudCA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpib2R5U2VudCcpXG4gIGNoYW5uZWxzLmhlYWRlcnMgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6aGVhZGVycycpXG4gIGNoYW5uZWxzLnRyYWlsZXJzID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OnRyYWlsZXJzJylcbiAgY2hhbm5lbHMuZXJyb3IgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6ZXJyb3InKVxufSBjYXRjaCB7XG4gIGNoYW5uZWxzLmNyZWF0ZSA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH1cbiAgY2hhbm5lbHMuYm9keVNlbnQgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9XG4gIGNoYW5uZWxzLmhlYWRlcnMgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9XG4gIGNoYW5uZWxzLnRyYWlsZXJzID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfVxuICBjaGFubmVscy5lcnJvciA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH1cbn1cblxuY2xhc3MgUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIHtcbiAgICBwYXRoLFxuICAgIG1ldGhvZCxcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG4gICAgcXVlcnksXG4gICAgaWRlbXBvdGVudCxcbiAgICBibG9ja2luZyxcbiAgICB1cGdyYWRlLFxuICAgIGhlYWRlcnNUaW1lb3V0LFxuICAgIGJvZHlUaW1lb3V0LFxuICAgIHJlc2V0LFxuICAgIHRocm93T25FcnJvcixcbiAgICBleHBlY3RDb250aW51ZVxuICB9LCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdwYXRoIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBwYXRoWzBdICE9PSAnLycgJiZcbiAgICAgICEocGF0aC5zdGFydHNXaXRoKCdodHRwOi8vJykgfHwgcGF0aC5zdGFydHNXaXRoKCdodHRwczovLycpKSAmJlxuICAgICAgbWV0aG9kICE9PSAnQ09OTkVDVCdcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncGF0aCBtdXN0IGJlIGFuIGFic29sdXRlIFVSTCBvciBzdGFydCB3aXRoIGEgc2xhc2gnKVxuICAgIH0gZWxzZSBpZiAoaW52YWxpZFBhdGhSZWdleC5leGVjKHBhdGgpICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgcmVxdWVzdCBwYXRoJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWV0aG9kIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH0gZWxzZSBpZiAodG9rZW5SZWdFeHAuZXhlYyhtZXRob2QpID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgcmVxdWVzdCBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmICh1cGdyYWRlICYmIHR5cGVvZiB1cGdyYWRlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1cGdyYWRlIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cblxuICAgIGlmIChoZWFkZXJzVGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGhlYWRlcnNUaW1lb3V0KSB8fCBoZWFkZXJzVGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGVhZGVyc1RpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChib2R5VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGJvZHlUaW1lb3V0KSB8fCBib2R5VGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgYm9keVRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChyZXNldCAhPSBudWxsICYmIHR5cGVvZiByZXNldCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgcmVzZXQnKVxuICAgIH1cblxuICAgIGlmIChleHBlY3RDb250aW51ZSAhPSBudWxsICYmIHR5cGVvZiBleHBlY3RDb250aW51ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgZXhwZWN0Q29udGludWUnKVxuICAgIH1cblxuICAgIHRoaXMuaGVhZGVyc1RpbWVvdXQgPSBoZWFkZXJzVGltZW91dFxuXG4gICAgdGhpcy5ib2R5VGltZW91dCA9IGJvZHlUaW1lb3V0XG5cbiAgICB0aGlzLnRocm93T25FcnJvciA9IHRocm93T25FcnJvciA9PT0gdHJ1ZVxuXG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2RcblxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG5cbiAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJvZHkgPSBudWxsXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5XG5cbiAgICAgIGNvbnN0IHJTdGF0ZSA9IHRoaXMuYm9keS5fcmVhZGFibGVTdGF0ZVxuICAgICAgaWYgKCFyU3RhdGUgfHwgIXJTdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICB0aGlzLmVuZEhhbmRsZXIgPSBmdW5jdGlvbiBhdXRvRGVzdHJveSAoKSB7XG4gICAgICAgICAgdXRpbC5kZXN0cm95KHRoaXMpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5Lm9uKCdlbmQnLCB0aGlzLmVuZEhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICB0aGlzLmFib3J0KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5vbignZXJyb3InLCB0aGlzLmVycm9ySGFuZGxlcilcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkuYnl0ZUxlbmd0aCA/IGJvZHkgOiBudWxsXG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkuYnVmZmVyLmJ5dGVMZW5ndGggPyBCdWZmZXIuZnJvbShib2R5LmJ1ZmZlciwgYm9keS5ieXRlT2Zmc2V0LCBib2R5LmJ5dGVMZW5ndGgpIDogbnVsbFxuICAgIH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ5dGVMZW5ndGggPyBCdWZmZXIuZnJvbShib2R5KSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keS5sZW5ndGggPyBCdWZmZXIuZnJvbShib2R5KSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNGb3JtRGF0YUxpa2UoYm9keSkgfHwgdXRpbC5pc0l0ZXJhYmxlKGJvZHkpIHx8IHV0aWwuaXNCbG9iTGlrZShib2R5KSkge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2JvZHkgbXVzdCBiZSBhIHN0cmluZywgYSBCdWZmZXIsIGEgUmVhZGFibGUgc3RyZWFtLCBhbiBpdGVyYWJsZSwgb3IgYW4gYXN5bmMgaXRlcmFibGUnKVxuICAgIH1cblxuICAgIHRoaXMuY29tcGxldGVkID0gZmFsc2VcblxuICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlXG5cbiAgICB0aGlzLnVwZ3JhZGUgPSB1cGdyYWRlIHx8IG51bGxcblxuICAgIHRoaXMucGF0aCA9IHF1ZXJ5ID8gdXRpbC5idWlsZFVSTChwYXRoLCBxdWVyeSkgOiBwYXRoXG5cbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpblxuXG4gICAgdGhpcy5pZGVtcG90ZW50ID0gaWRlbXBvdGVudCA9PSBudWxsXG4gICAgICA/IG1ldGhvZCA9PT0gJ0hFQUQnIHx8IG1ldGhvZCA9PT0gJ0dFVCdcbiAgICAgIDogaWRlbXBvdGVudFxuXG4gICAgdGhpcy5ibG9ja2luZyA9IGJsb2NraW5nID09IG51bGwgPyBmYWxzZSA6IGJsb2NraW5nXG5cbiAgICB0aGlzLnJlc2V0ID0gcmVzZXQgPT0gbnVsbCA/IG51bGwgOiByZXNldFxuXG4gICAgdGhpcy5ob3N0ID0gbnVsbFxuXG4gICAgdGhpcy5jb250ZW50TGVuZ3RoID0gbnVsbFxuXG4gICAgdGhpcy5jb250ZW50VHlwZSA9IG51bGxcblxuICAgIHRoaXMuaGVhZGVycyA9ICcnXG5cbiAgICAvLyBPbmx5IGZvciBIMlxuICAgIHRoaXMuZXhwZWN0Q29udGludWUgPSBleHBlY3RDb250aW51ZSAhPSBudWxsID8gZXhwZWN0Q29udGludWUgOiBmYWxzZVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGlmIChoZWFkZXJzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIGFycmF5IG11c3QgYmUgZXZlbicpXG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgcHJvY2Vzc0hlYWRlcih0aGlzLCBoZWFkZXJzW2ldLCBoZWFkZXJzW2kgKyAxXSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywga2V5LCBoZWFkZXJzW2tleV0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBtdXN0IGJlIGFuIG9iamVjdCBvciBhbiBhcnJheScpXG4gICAgfVxuXG4gICAgaWYgKHV0aWwuaXNGb3JtRGF0YUxpa2UodGhpcy5ib2R5KSkge1xuICAgICAgaWYgKHV0aWwubm9kZU1ham9yIDwgMTYgfHwgKHV0aWwubm9kZU1ham9yID09PSAxNiAmJiB1dGlsLm5vZGVNaW5vciA8IDgpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignRm9ybS1EYXRhIGJvZGllcyBhcmUgb25seSBzdXBwb3J0ZWQgaW4gbm9kZSB2MTYuOCBhbmQgbmV3ZXIuJylcbiAgICAgIH1cblxuICAgICAgaWYgKCFleHRyYWN0Qm9keSkge1xuICAgICAgICBleHRyYWN0Qm9keSA9IHJlcXVpcmUoJy4uL2ZldGNoL2JvZHkuanMnKS5leHRyYWN0Qm9keVxuICAgICAgfVxuXG4gICAgICBjb25zdCBbYm9keVN0cmVhbSwgY29udGVudFR5cGVdID0gZXh0cmFjdEJvZHkoYm9keSlcbiAgICAgIGlmICh0aGlzLmNvbnRlbnRUeXBlID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlXG4gICAgICAgIHRoaXMuaGVhZGVycyArPSBgY29udGVudC10eXBlOiAke2NvbnRlbnRUeXBlfVxcclxcbmBcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keSA9IGJvZHlTdHJlYW0uc3RyZWFtXG4gICAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSBib2R5U3RyZWFtLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0Jsb2JMaWtlKGJvZHkpICYmIHRoaXMuY29udGVudFR5cGUgPT0gbnVsbCAmJiBib2R5LnR5cGUpIHtcbiAgICAgIHRoaXMuY29udGVudFR5cGUgPSBib2R5LnR5cGVcbiAgICAgIHRoaXMuaGVhZGVycyArPSBgY29udGVudC10eXBlOiAke2JvZHkudHlwZX1cXHJcXG5gXG4gICAgfVxuXG4gICAgdXRpbC52YWxpZGF0ZUhhbmRsZXIoaGFuZGxlciwgbWV0aG9kLCB1cGdyYWRlKVxuXG4gICAgdGhpcy5zZXJ2ZXJuYW1lID0gdXRpbC5nZXRTZXJ2ZXJOYW1lKHRoaXMuaG9zdClcblxuICAgIHRoaXNba0hhbmRsZXJdID0gaGFuZGxlclxuXG4gICAgaWYgKGNoYW5uZWxzLmNyZWF0ZS5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuY3JlYXRlLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzIH0pXG4gICAgfVxuICB9XG5cbiAgb25Cb2R5U2VudCAoY2h1bmspIHtcbiAgICBpZiAodGhpc1trSGFuZGxlcl0ub25Cb2R5U2VudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpc1trSGFuZGxlcl0ub25Cb2R5U2VudChjaHVuaylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uUmVxdWVzdFNlbnQgKCkge1xuICAgIGlmIChjaGFubmVscy5ib2R5U2VudC5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuYm9keVNlbnQucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpc1trSGFuZGxlcl0ub25SZXF1ZXN0U2VudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpc1trSGFuZGxlcl0ub25SZXF1ZXN0U2VudCgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0KSB7XG4gICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpXG4gICAgYXNzZXJ0KCF0aGlzLmNvbXBsZXRlZClcblxuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICBhYm9ydCh0aGlzLmVycm9yKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkNvbm5lY3QoYWJvcnQpXG4gICAgfVxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgaWYgKGNoYW5uZWxzLmhlYWRlcnMuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmhlYWRlcnMucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMsIHJlc3BvbnNlOiB7IHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c1RleHQgfSB9KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25EYXRhKGNodW5rKVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIHRoaXMub25GaW5hbGx5KClcblxuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuXG4gICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlXG4gICAgaWYgKGNoYW5uZWxzLnRyYWlsZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy50cmFpbGVycy5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgdHJhaWxlcnMgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQ29tcGxldGUodHJhaWxlcnMpXG4gIH1cblxuICBvbkVycm9yIChlcnJvcikge1xuICAgIHRoaXMub25GaW5hbGx5KClcblxuICAgIGlmIChjaGFubmVscy5lcnJvci5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuZXJyb3IucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMsIGVycm9yIH0pXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuYWJvcnRlZCA9IHRydWVcbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25FcnJvcihlcnJvcilcbiAgfVxuXG4gIG9uRmluYWxseSAoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICB0aGlzLmJvZHkub2ZmKCdlcnJvcicsIHRoaXMuZXJyb3JIYW5kbGVyKVxuICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5kSGFuZGxlcikge1xuICAgICAgdGhpcy5ib2R5Lm9mZignZW5kJywgdGhpcy5lbmRIYW5kbGVyKVxuICAgICAgdGhpcy5lbmRIYW5kbGVyID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IGFkanVzdCB0byBzdXBwb3J0IEgyXG4gIGFkZEhlYWRlciAoa2V5LCB2YWx1ZSkge1xuICAgIHByb2Nlc3NIZWFkZXIodGhpcywga2V5LCB2YWx1ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhdGljIFtrSFRUUDFCdWlsZFJlcXVlc3RdIChvcmlnaW4sIG9wdHMsIGhhbmRsZXIpIHtcbiAgICAvLyBUT0RPOiBNaWdyYXRlIGhlYWRlciBwYXJzaW5nIGhlcmUsIHRvIG1ha2UgUmVxdWVzdHNcbiAgICAvLyBIVFRQIGFnbm9zdGljXG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9yaWdpbiwgb3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIHN0YXRpYyBba0hUVFAyQnVpbGRSZXF1ZXN0XSAob3JpZ2luLCBvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG9wdHMuaGVhZGVyc1xuICAgIG9wdHMgPSB7IC4uLm9wdHMsIGhlYWRlcnM6IG51bGwgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KG9yaWdpbiwgb3B0cywgaGFuZGxlcilcblxuICAgIHJlcXVlc3QuaGVhZGVycyA9IHt9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgYXJyYXkgbXVzdCBiZSBldmVuJylcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwcm9jZXNzSGVhZGVyKHJlcXVlc3QsIGhlYWRlcnNbaV0sIGhlYWRlcnNbaSArIDFdLCB0cnVlKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgcHJvY2Vzc0hlYWRlcihyZXF1ZXN0LCBrZXksIGhlYWRlcnNba2V5XSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5JylcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdFxuICB9XG5cbiAgc3RhdGljIFtrSFRUUDJDb3B5SGVhZGVyc10gKHJhdykge1xuICAgIGNvbnN0IHJhd0hlYWRlcnMgPSByYXcuc3BsaXQoJ1xcclxcbicpXG4gICAgY29uc3QgaGVhZGVycyA9IHt9XG5cbiAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiByYXdIZWFkZXJzKSB7XG4gICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBoZWFkZXIuc3BsaXQoJzogJylcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwKSBjb250aW51ZVxuXG4gICAgICBpZiAoaGVhZGVyc1trZXldKSBoZWFkZXJzW2tleV0gKz0gYCwke3ZhbHVlfWBcbiAgICAgIGVsc2UgaGVhZGVyc1trZXldID0gdmFsdWVcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NIZWFkZXJWYWx1ZSAoa2V5LCB2YWwsIHNraXBBcHBlbmQpIHtcbiAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgfVxuXG4gIHZhbCA9IHZhbCAhPSBudWxsID8gYCR7dmFsfWAgOiAnJ1xuXG4gIGlmIChoZWFkZXJDaGFyUmVnZXguZXhlYyh2YWwpICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICB9XG5cbiAgcmV0dXJuIHNraXBBcHBlbmQgPyB2YWwgOiBgJHtrZXl9OiAke3ZhbH1cXHJcXG5gXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIgKHJlcXVlc3QsIGtleSwgdmFsLCBza2lwQXBwZW5kID0gZmFsc2UpIHtcbiAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKSkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gIH0gZWxzZSBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChcbiAgICByZXF1ZXN0Lmhvc3QgPT09IG51bGwgJiZcbiAgICBrZXkubGVuZ3RoID09PSA0ICYmXG4gICAga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdob3N0J1xuICApIHtcbiAgICBpZiAoaGVhZGVyQ2hhclJlZ2V4LmV4ZWModmFsKSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICAgIH1cbiAgICAvLyBDb25zdW1lZCBieSBDbGllbnRcbiAgICByZXF1ZXN0Lmhvc3QgPSB2YWxcbiAgfSBlbHNlIGlmIChcbiAgICByZXF1ZXN0LmNvbnRlbnRMZW5ndGggPT09IG51bGwgJiZcbiAgICBrZXkubGVuZ3RoID09PSAxNCAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1sZW5ndGgnXG4gICkge1xuICAgIHJlcXVlc3QuY29udGVudExlbmd0aCA9IHBhcnNlSW50KHZhbCwgMTApXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocmVxdWVzdC5jb250ZW50TGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcicpXG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIHJlcXVlc3QuY29udGVudFR5cGUgPT09IG51bGwgJiZcbiAgICBrZXkubGVuZ3RoID09PSAxMiAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJ1xuICApIHtcbiAgICByZXF1ZXN0LmNvbnRlbnRUeXBlID0gdmFsXG4gICAgaWYgKHNraXBBcHBlbmQpIHJlcXVlc3QuaGVhZGVyc1trZXldID0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsLCBza2lwQXBwZW5kKVxuICAgIGVsc2UgcmVxdWVzdC5oZWFkZXJzICs9IHByb2Nlc3NIZWFkZXJWYWx1ZShrZXksIHZhbClcbiAgfSBlbHNlIGlmIChcbiAgICBrZXkubGVuZ3RoID09PSAxNyAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAndHJhbnNmZXItZW5jb2RpbmcnXG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCB0cmFuc2Zlci1lbmNvZGluZyBoZWFkZXInKVxuICB9IGVsc2UgaWYgKFxuICAgIGtleS5sZW5ndGggPT09IDEwICYmXG4gICAga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb25uZWN0aW9uJ1xuICApIHtcbiAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gdmFsLnRvTG93ZXJDYXNlKCkgOiBudWxsXG4gICAgaWYgKHZhbHVlICE9PSAnY2xvc2UnICYmIHZhbHVlICE9PSAna2VlcC1hbGl2ZScpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb25uZWN0aW9uIGhlYWRlcicpXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgcmVxdWVzdC5yZXNldCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAga2V5Lmxlbmd0aCA9PT0gMTAgJiZcbiAgICBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2tlZXAtYWxpdmUnXG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBrZWVwLWFsaXZlIGhlYWRlcicpXG4gIH0gZWxzZSBpZiAoXG4gICAga2V5Lmxlbmd0aCA9PT0gNyAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAndXBncmFkZSdcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHVwZ3JhZGUgaGVhZGVyJylcbiAgfSBlbHNlIGlmIChcbiAgICBrZXkubGVuZ3RoID09PSA2ICYmXG4gICAga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdleHBlY3QnXG4gICkge1xuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcignZXhwZWN0IGhlYWRlciBub3Qgc3VwcG9ydGVkJylcbiAgfSBlbHNlIGlmICh0b2tlblJlZ0V4cC5leGVjKGtleSkgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGVhZGVyIGtleScpXG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNraXBBcHBlbmQpIHtcbiAgICAgICAgICBpZiAocmVxdWVzdC5oZWFkZXJzW2tleV0pIHJlcXVlc3QuaGVhZGVyc1trZXldICs9IGAsJHtwcm9jZXNzSGVhZGVyVmFsdWUoa2V5LCB2YWxbaV0sIHNraXBBcHBlbmQpfWBcbiAgICAgICAgICBlbHNlIHJlcXVlc3QuaGVhZGVyc1trZXldID0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsW2ldLCBza2lwQXBwZW5kKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcXVlc3QuaGVhZGVycyArPSBwcm9jZXNzSGVhZGVyVmFsdWUoa2V5LCB2YWxbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNraXBBcHBlbmQpIHJlcXVlc3QuaGVhZGVyc1trZXldID0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsLCBza2lwQXBwZW5kKVxuICAgICAgZWxzZSByZXF1ZXN0LmhlYWRlcnMgKz0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RcbiJdLCJuYW1lcyI6WyJJbnZhbGlkQXJndW1lbnRFcnJvciIsIk5vdFN1cHBvcnRlZEVycm9yIiwicmVxdWlyZSIsImFzc2VydCIsImtIVFRQMkJ1aWxkUmVxdWVzdCIsImtIVFRQMkNvcHlIZWFkZXJzIiwia0hUVFAxQnVpbGRSZXF1ZXN0IiwidXRpbCIsInRva2VuUmVnRXhwIiwiaGVhZGVyQ2hhclJlZ2V4IiwiaW52YWxpZFBhdGhSZWdleCIsImtIYW5kbGVyIiwiU3ltYm9sIiwiY2hhbm5lbHMiLCJleHRyYWN0Qm9keSIsImRpYWdub3N0aWNzQ2hhbm5lbCIsImNyZWF0ZSIsImNoYW5uZWwiLCJib2R5U2VudCIsImhlYWRlcnMiLCJ0cmFpbGVycyIsImVycm9yIiwiaGFzU3Vic2NyaWJlcnMiLCJSZXF1ZXN0IiwiY29uc3RydWN0b3IiLCJvcmlnaW4iLCJwYXRoIiwibWV0aG9kIiwiYm9keSIsInF1ZXJ5IiwiaWRlbXBvdGVudCIsImJsb2NraW5nIiwidXBncmFkZSIsImhlYWRlcnNUaW1lb3V0IiwiYm9keVRpbWVvdXQiLCJyZXNldCIsInRocm93T25FcnJvciIsImV4cGVjdENvbnRpbnVlIiwiaGFuZGxlciIsInN0YXJ0c1dpdGgiLCJleGVjIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJhYm9ydCIsImlzU3RyZWFtIiwiclN0YXRlIiwiX3JlYWRhYmxlU3RhdGUiLCJhdXRvRGVzdHJveSIsImVuZEhhbmRsZXIiLCJkZXN0cm95Iiwib24iLCJlcnJvckhhbmRsZXIiLCJlcnIiLCJpc0J1ZmZlciIsImJ5dGVMZW5ndGgiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJieXRlT2Zmc2V0IiwibGVuZ3RoIiwiaXNGb3JtRGF0YUxpa2UiLCJpc0l0ZXJhYmxlIiwiaXNCbG9iTGlrZSIsImNvbXBsZXRlZCIsImFib3J0ZWQiLCJidWlsZFVSTCIsImhvc3QiLCJjb250ZW50TGVuZ3RoIiwiY29udGVudFR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJpIiwicHJvY2Vzc0hlYWRlciIsImtleXMiLCJPYmplY3QiLCJrZXkiLCJub2RlTWFqb3IiLCJub2RlTWlub3IiLCJib2R5U3RyZWFtIiwic3RyZWFtIiwidHlwZSIsInZhbGlkYXRlSGFuZGxlciIsInNlcnZlcm5hbWUiLCJnZXRTZXJ2ZXJOYW1lIiwicHVibGlzaCIsInJlcXVlc3QiLCJvbkJvZHlTZW50IiwiY2h1bmsiLCJvbkVycm9yIiwib25SZXF1ZXN0U2VudCIsIm9uQ29ubmVjdCIsIm9uSGVhZGVycyIsInN0YXR1c0NvZGUiLCJyZXN1bWUiLCJzdGF0dXNUZXh0IiwicmVzcG9uc2UiLCJvbkRhdGEiLCJvblVwZ3JhZGUiLCJzb2NrZXQiLCJvbkNvbXBsZXRlIiwib25GaW5hbGx5Iiwib2ZmIiwiYWRkSGVhZGVyIiwidmFsdWUiLCJvcHRzIiwicmF3IiwicmF3SGVhZGVycyIsInNwbGl0IiwiaGVhZGVyIiwicHJvY2Vzc0hlYWRlclZhbHVlIiwidmFsIiwic2tpcEFwcGVuZCIsInVuZGVmaW5lZCIsInRvTG93ZXJDYXNlIiwicGFyc2VJbnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/core/request.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/core/symbols.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/core/symbols.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("module.exports = {\n    kClose: Symbol(\"close\"),\n    kDestroy: Symbol(\"destroy\"),\n    kDispatch: Symbol(\"dispatch\"),\n    kUrl: Symbol(\"url\"),\n    kWriting: Symbol(\"writing\"),\n    kResuming: Symbol(\"resuming\"),\n    kQueue: Symbol(\"queue\"),\n    kConnect: Symbol(\"connect\"),\n    kConnecting: Symbol(\"connecting\"),\n    kHeadersList: Symbol(\"headers list\"),\n    kKeepAliveDefaultTimeout: Symbol(\"default keep alive timeout\"),\n    kKeepAliveMaxTimeout: Symbol(\"max keep alive timeout\"),\n    kKeepAliveTimeoutThreshold: Symbol(\"keep alive timeout threshold\"),\n    kKeepAliveTimeoutValue: Symbol(\"keep alive timeout\"),\n    kKeepAlive: Symbol(\"keep alive\"),\n    kHeadersTimeout: Symbol(\"headers timeout\"),\n    kBodyTimeout: Symbol(\"body timeout\"),\n    kServerName: Symbol(\"server name\"),\n    kLocalAddress: Symbol(\"local address\"),\n    kHost: Symbol(\"host\"),\n    kNoRef: Symbol(\"no ref\"),\n    kBodyUsed: Symbol(\"used\"),\n    kRunning: Symbol(\"running\"),\n    kBlocking: Symbol(\"blocking\"),\n    kPending: Symbol(\"pending\"),\n    kSize: Symbol(\"size\"),\n    kBusy: Symbol(\"busy\"),\n    kQueued: Symbol(\"queued\"),\n    kFree: Symbol(\"free\"),\n    kConnected: Symbol(\"connected\"),\n    kClosed: Symbol(\"closed\"),\n    kNeedDrain: Symbol(\"need drain\"),\n    kReset: Symbol(\"reset\"),\n    kDestroyed: Symbol.for(\"nodejs.stream.destroyed\"),\n    kMaxHeadersSize: Symbol(\"max headers size\"),\n    kRunningIdx: Symbol(\"running index\"),\n    kPendingIdx: Symbol(\"pending index\"),\n    kError: Symbol(\"error\"),\n    kClients: Symbol(\"clients\"),\n    kClient: Symbol(\"client\"),\n    kParser: Symbol(\"parser\"),\n    kOnDestroyed: Symbol(\"destroy callbacks\"),\n    kPipelining: Symbol(\"pipelining\"),\n    kSocket: Symbol(\"socket\"),\n    kHostHeader: Symbol(\"host header\"),\n    kConnector: Symbol(\"connector\"),\n    kStrictContentLength: Symbol(\"strict content length\"),\n    kMaxRedirections: Symbol(\"maxRedirections\"),\n    kMaxRequests: Symbol(\"maxRequestsPerClient\"),\n    kProxy: Symbol(\"proxy agent options\"),\n    kCounter: Symbol(\"socket request counter\"),\n    kInterceptors: Symbol(\"dispatch interceptors\"),\n    kMaxResponseSize: Symbol(\"max response size\"),\n    kHTTP2Session: Symbol(\"http2Session\"),\n    kHTTP2SessionState: Symbol(\"http2Session state\"),\n    kHTTP2BuildRequest: Symbol(\"http2 build request\"),\n    kHTTP1BuildRequest: Symbol(\"http1 build request\"),\n    kHTTP2CopyHeaders: Symbol(\"http2 copy headers\"),\n    kHTTPConnVersion: Symbol(\"http connection version\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvc3ltYm9scy5qcz81YzRjIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICBrQ2xvc2U6IFN5bWJvbCgnY2xvc2UnKSxcbiAga0Rlc3Ryb3k6IFN5bWJvbCgnZGVzdHJveScpLFxuICBrRGlzcGF0Y2g6IFN5bWJvbCgnZGlzcGF0Y2gnKSxcbiAga1VybDogU3ltYm9sKCd1cmwnKSxcbiAga1dyaXRpbmc6IFN5bWJvbCgnd3JpdGluZycpLFxuICBrUmVzdW1pbmc6IFN5bWJvbCgncmVzdW1pbmcnKSxcbiAga1F1ZXVlOiBTeW1ib2woJ3F1ZXVlJyksXG4gIGtDb25uZWN0OiBTeW1ib2woJ2Nvbm5lY3QnKSxcbiAga0Nvbm5lY3Rpbmc6IFN5bWJvbCgnY29ubmVjdGluZycpLFxuICBrSGVhZGVyc0xpc3Q6IFN5bWJvbCgnaGVhZGVycyBsaXN0JyksXG4gIGtLZWVwQWxpdmVEZWZhdWx0VGltZW91dDogU3ltYm9sKCdkZWZhdWx0IGtlZXAgYWxpdmUgdGltZW91dCcpLFxuICBrS2VlcEFsaXZlTWF4VGltZW91dDogU3ltYm9sKCdtYXgga2VlcCBhbGl2ZSB0aW1lb3V0JyksXG4gIGtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkOiBTeW1ib2woJ2tlZXAgYWxpdmUgdGltZW91dCB0aHJlc2hvbGQnKSxcbiAga0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZTogU3ltYm9sKCdrZWVwIGFsaXZlIHRpbWVvdXQnKSxcbiAga0tlZXBBbGl2ZTogU3ltYm9sKCdrZWVwIGFsaXZlJyksXG4gIGtIZWFkZXJzVGltZW91dDogU3ltYm9sKCdoZWFkZXJzIHRpbWVvdXQnKSxcbiAga0JvZHlUaW1lb3V0OiBTeW1ib2woJ2JvZHkgdGltZW91dCcpLFxuICBrU2VydmVyTmFtZTogU3ltYm9sKCdzZXJ2ZXIgbmFtZScpLFxuICBrTG9jYWxBZGRyZXNzOiBTeW1ib2woJ2xvY2FsIGFkZHJlc3MnKSxcbiAga0hvc3Q6IFN5bWJvbCgnaG9zdCcpLFxuICBrTm9SZWY6IFN5bWJvbCgnbm8gcmVmJyksXG4gIGtCb2R5VXNlZDogU3ltYm9sKCd1c2VkJyksXG4gIGtSdW5uaW5nOiBTeW1ib2woJ3J1bm5pbmcnKSxcbiAga0Jsb2NraW5nOiBTeW1ib2woJ2Jsb2NraW5nJyksXG4gIGtQZW5kaW5nOiBTeW1ib2woJ3BlbmRpbmcnKSxcbiAga1NpemU6IFN5bWJvbCgnc2l6ZScpLFxuICBrQnVzeTogU3ltYm9sKCdidXN5JyksXG4gIGtRdWV1ZWQ6IFN5bWJvbCgncXVldWVkJyksXG4gIGtGcmVlOiBTeW1ib2woJ2ZyZWUnKSxcbiAga0Nvbm5lY3RlZDogU3ltYm9sKCdjb25uZWN0ZWQnKSxcbiAga0Nsb3NlZDogU3ltYm9sKCdjbG9zZWQnKSxcbiAga05lZWREcmFpbjogU3ltYm9sKCduZWVkIGRyYWluJyksXG4gIGtSZXNldDogU3ltYm9sKCdyZXNldCcpLFxuICBrRGVzdHJveWVkOiBTeW1ib2wuZm9yKCdub2RlanMuc3RyZWFtLmRlc3Ryb3llZCcpLFxuICBrTWF4SGVhZGVyc1NpemU6IFN5bWJvbCgnbWF4IGhlYWRlcnMgc2l6ZScpLFxuICBrUnVubmluZ0lkeDogU3ltYm9sKCdydW5uaW5nIGluZGV4JyksXG4gIGtQZW5kaW5nSWR4OiBTeW1ib2woJ3BlbmRpbmcgaW5kZXgnKSxcbiAga0Vycm9yOiBTeW1ib2woJ2Vycm9yJyksXG4gIGtDbGllbnRzOiBTeW1ib2woJ2NsaWVudHMnKSxcbiAga0NsaWVudDogU3ltYm9sKCdjbGllbnQnKSxcbiAga1BhcnNlcjogU3ltYm9sKCdwYXJzZXInKSxcbiAga09uRGVzdHJveWVkOiBTeW1ib2woJ2Rlc3Ryb3kgY2FsbGJhY2tzJyksXG4gIGtQaXBlbGluaW5nOiBTeW1ib2woJ3BpcGVsaW5pbmcnKSxcbiAga1NvY2tldDogU3ltYm9sKCdzb2NrZXQnKSxcbiAga0hvc3RIZWFkZXI6IFN5bWJvbCgnaG9zdCBoZWFkZXInKSxcbiAga0Nvbm5lY3RvcjogU3ltYm9sKCdjb25uZWN0b3InKSxcbiAga1N0cmljdENvbnRlbnRMZW5ndGg6IFN5bWJvbCgnc3RyaWN0IGNvbnRlbnQgbGVuZ3RoJyksXG4gIGtNYXhSZWRpcmVjdGlvbnM6IFN5bWJvbCgnbWF4UmVkaXJlY3Rpb25zJyksXG4gIGtNYXhSZXF1ZXN0czogU3ltYm9sKCdtYXhSZXF1ZXN0c1BlckNsaWVudCcpLFxuICBrUHJveHk6IFN5bWJvbCgncHJveHkgYWdlbnQgb3B0aW9ucycpLFxuICBrQ291bnRlcjogU3ltYm9sKCdzb2NrZXQgcmVxdWVzdCBjb3VudGVyJyksXG4gIGtJbnRlcmNlcHRvcnM6IFN5bWJvbCgnZGlzcGF0Y2ggaW50ZXJjZXB0b3JzJyksXG4gIGtNYXhSZXNwb25zZVNpemU6IFN5bWJvbCgnbWF4IHJlc3BvbnNlIHNpemUnKSxcbiAga0hUVFAyU2Vzc2lvbjogU3ltYm9sKCdodHRwMlNlc3Npb24nKSxcbiAga0hUVFAyU2Vzc2lvblN0YXRlOiBTeW1ib2woJ2h0dHAyU2Vzc2lvbiBzdGF0ZScpLFxuICBrSFRUUDJCdWlsZFJlcXVlc3Q6IFN5bWJvbCgnaHR0cDIgYnVpbGQgcmVxdWVzdCcpLFxuICBrSFRUUDFCdWlsZFJlcXVlc3Q6IFN5bWJvbCgnaHR0cDEgYnVpbGQgcmVxdWVzdCcpLFxuICBrSFRUUDJDb3B5SGVhZGVyczogU3ltYm9sKCdodHRwMiBjb3B5IGhlYWRlcnMnKSxcbiAga0hUVFBDb25uVmVyc2lvbjogU3ltYm9sKCdodHRwIGNvbm5lY3Rpb24gdmVyc2lvbicpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtDbG9zZSIsIlN5bWJvbCIsImtEZXN0cm95Iiwia0Rpc3BhdGNoIiwia1VybCIsImtXcml0aW5nIiwia1Jlc3VtaW5nIiwia1F1ZXVlIiwia0Nvbm5lY3QiLCJrQ29ubmVjdGluZyIsImtIZWFkZXJzTGlzdCIsImtLZWVwQWxpdmVEZWZhdWx0VGltZW91dCIsImtLZWVwQWxpdmVNYXhUaW1lb3V0Iiwia0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQiLCJrS2VlcEFsaXZlVGltZW91dFZhbHVlIiwia0tlZXBBbGl2ZSIsImtIZWFkZXJzVGltZW91dCIsImtCb2R5VGltZW91dCIsImtTZXJ2ZXJOYW1lIiwia0xvY2FsQWRkcmVzcyIsImtIb3N0Iiwia05vUmVmIiwia0JvZHlVc2VkIiwia1J1bm5pbmciLCJrQmxvY2tpbmciLCJrUGVuZGluZyIsImtTaXplIiwia0J1c3kiLCJrUXVldWVkIiwia0ZyZWUiLCJrQ29ubmVjdGVkIiwia0Nsb3NlZCIsImtOZWVkRHJhaW4iLCJrUmVzZXQiLCJrRGVzdHJveWVkIiwiZm9yIiwia01heEhlYWRlcnNTaXplIiwia1J1bm5pbmdJZHgiLCJrUGVuZGluZ0lkeCIsImtFcnJvciIsImtDbGllbnRzIiwia0NsaWVudCIsImtQYXJzZXIiLCJrT25EZXN0cm95ZWQiLCJrUGlwZWxpbmluZyIsImtTb2NrZXQiLCJrSG9zdEhlYWRlciIsImtDb25uZWN0b3IiLCJrU3RyaWN0Q29udGVudExlbmd0aCIsImtNYXhSZWRpcmVjdGlvbnMiLCJrTWF4UmVxdWVzdHMiLCJrUHJveHkiLCJrQ291bnRlciIsImtJbnRlcmNlcHRvcnMiLCJrTWF4UmVzcG9uc2VTaXplIiwia0hUVFAyU2Vzc2lvbiIsImtIVFRQMlNlc3Npb25TdGF0ZSIsImtIVFRQMkJ1aWxkUmVxdWVzdCIsImtIVFRQMUJ1aWxkUmVxdWVzdCIsImtIVFRQMkNvcHlIZWFkZXJzIiwia0hUVFBDb25uVmVyc2lvbiJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxRQUFRQyxPQUFPO0lBQ2ZDLFVBQVVELE9BQU87SUFDakJFLFdBQVdGLE9BQU87SUFDbEJHLE1BQU1ILE9BQU87SUFDYkksVUFBVUosT0FBTztJQUNqQkssV0FBV0wsT0FBTztJQUNsQk0sUUFBUU4sT0FBTztJQUNmTyxVQUFVUCxPQUFPO0lBQ2pCUSxhQUFhUixPQUFPO0lBQ3BCUyxjQUFjVCxPQUFPO0lBQ3JCVSwwQkFBMEJWLE9BQU87SUFDakNXLHNCQUFzQlgsT0FBTztJQUM3QlksNEJBQTRCWixPQUFPO0lBQ25DYSx3QkFBd0JiLE9BQU87SUFDL0JjLFlBQVlkLE9BQU87SUFDbkJlLGlCQUFpQmYsT0FBTztJQUN4QmdCLGNBQWNoQixPQUFPO0lBQ3JCaUIsYUFBYWpCLE9BQU87SUFDcEJrQixlQUFlbEIsT0FBTztJQUN0Qm1CLE9BQU9uQixPQUFPO0lBQ2RvQixRQUFRcEIsT0FBTztJQUNmcUIsV0FBV3JCLE9BQU87SUFDbEJzQixVQUFVdEIsT0FBTztJQUNqQnVCLFdBQVd2QixPQUFPO0lBQ2xCd0IsVUFBVXhCLE9BQU87SUFDakJ5QixPQUFPekIsT0FBTztJQUNkMEIsT0FBTzFCLE9BQU87SUFDZDJCLFNBQVMzQixPQUFPO0lBQ2hCNEIsT0FBTzVCLE9BQU87SUFDZDZCLFlBQVk3QixPQUFPO0lBQ25COEIsU0FBUzlCLE9BQU87SUFDaEIrQixZQUFZL0IsT0FBTztJQUNuQmdDLFFBQVFoQyxPQUFPO0lBQ2ZpQyxZQUFZakMsT0FBT2tDLEdBQUcsQ0FBQztJQUN2QkMsaUJBQWlCbkMsT0FBTztJQUN4Qm9DLGFBQWFwQyxPQUFPO0lBQ3BCcUMsYUFBYXJDLE9BQU87SUFDcEJzQyxRQUFRdEMsT0FBTztJQUNmdUMsVUFBVXZDLE9BQU87SUFDakJ3QyxTQUFTeEMsT0FBTztJQUNoQnlDLFNBQVN6QyxPQUFPO0lBQ2hCMEMsY0FBYzFDLE9BQU87SUFDckIyQyxhQUFhM0MsT0FBTztJQUNwQjRDLFNBQVM1QyxPQUFPO0lBQ2hCNkMsYUFBYTdDLE9BQU87SUFDcEI4QyxZQUFZOUMsT0FBTztJQUNuQitDLHNCQUFzQi9DLE9BQU87SUFDN0JnRCxrQkFBa0JoRCxPQUFPO0lBQ3pCaUQsY0FBY2pELE9BQU87SUFDckJrRCxRQUFRbEQsT0FBTztJQUNmbUQsVUFBVW5ELE9BQU87SUFDakJvRCxlQUFlcEQsT0FBTztJQUN0QnFELGtCQUFrQnJELE9BQU87SUFDekJzRCxlQUFldEQsT0FBTztJQUN0QnVELG9CQUFvQnZELE9BQU87SUFDM0J3RCxvQkFBb0J4RCxPQUFPO0lBQzNCeUQsb0JBQW9CekQsT0FBTztJQUMzQjBELG1CQUFtQjFELE9BQU87SUFDMUIyRCxrQkFBa0IzRCxPQUFPO0FBQzNCIiwiZmlsZSI6Iihyc2MpLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvc3ltYm9scy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/core/symbols.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/core/util.js":
/*!**************************************************!*\
  !*** ../../node_modules/undici/lib/core/util.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { kDestroyed, kBodyUsed } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst { IncomingMessage } = __webpack_require__(/*! http */ \"http\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ./errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\nconst nodeUtil = __webpack_require__(/*! util */ \"util\");\nconst { stringify } = __webpack_require__(/*! querystring */ \"querystring\");\nconst [nodeMajor, nodeMinor] = process.versions.node.split(\".\").map((v)=>Number(v));\nfunction nop() {}\nfunction isStream(obj) {\n    return obj && typeof obj === \"object\" && typeof obj.pipe === \"function\" && typeof obj.on === \"function\";\n}\n// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\nfunction isBlobLike(object) {\n    return Blob && object instanceof Blob || object && typeof object === \"object\" && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n}\nfunction buildURL(url, queryParams) {\n    if (url.includes(\"?\") || url.includes(\"#\")) {\n        throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".');\n    }\n    const stringified = stringify(queryParams);\n    if (stringified) {\n        url += \"?\" + stringified;\n    }\n    return url;\n}\nfunction parseURL(url) {\n    if (typeof url === \"string\") {\n        url = new URL(url);\n        if (!/^https?:/.test(url.origin || url.protocol)) {\n            throw new InvalidArgumentError(\"Invalid URL protocol: the URL must start with `http:` or `https:`.\");\n        }\n        return url;\n    }\n    if (!url || typeof url !== \"object\") {\n        throw new InvalidArgumentError(\"Invalid URL: The URL argument must be a non-null object.\");\n    }\n    if (!/^https?:/.test(url.origin || url.protocol)) {\n        throw new InvalidArgumentError(\"Invalid URL protocol: the URL must start with `http:` or `https:`.\");\n    }\n    if (!(url instanceof URL)) {\n        if (url.port != null && url.port !== \"\" && !Number.isFinite(parseInt(url.port))) {\n            throw new InvalidArgumentError(\"Invalid URL: port must be a valid integer or a string representation of an integer.\");\n        }\n        if (url.path != null && typeof url.path !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL path: the path must be a string or null/undefined.\");\n        }\n        if (url.pathname != null && typeof url.pathname !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL pathname: the pathname must be a string or null/undefined.\");\n        }\n        if (url.hostname != null && typeof url.hostname !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL hostname: the hostname must be a string or null/undefined.\");\n        }\n        if (url.origin != null && typeof url.origin !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL origin: the origin must be a string or null/undefined.\");\n        }\n        const port = url.port != null ? url.port : url.protocol === \"https:\" ? 443 : 80;\n        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;\n        let path = url.path != null ? url.path : `${url.pathname || \"\"}${url.search || \"\"}`;\n        if (origin.endsWith(\"/\")) {\n            origin = origin.substring(0, origin.length - 1);\n        }\n        if (path && !path.startsWith(\"/\")) {\n            path = `/${path}`;\n        }\n        // new URL(path, origin) is unsafe when `path` contains an absolute URL\n        // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:\n        // If first parameter is a relative URL, second param is required, and will be used as the base URL.\n        // If first parameter is an absolute URL, a given second param will be ignored.\n        url = new URL(origin + path);\n    }\n    return url;\n}\nfunction parseOrigin(url) {\n    url = parseURL(url);\n    if (url.pathname !== \"/\" || url.search || url.hash) {\n        throw new InvalidArgumentError(\"invalid url\");\n    }\n    return url;\n}\nfunction getHostname(host) {\n    if (host[0] === \"[\") {\n        const idx = host.indexOf(\"]\");\n        assert(idx !== -1);\n        return host.substr(1, idx - 1);\n    }\n    const idx = host.indexOf(\":\");\n    if (idx === -1) return host;\n    return host.substr(0, idx);\n}\n// IP addresses are not valid server names per RFC6066\n// > Currently, the only server names supported are DNS hostnames\nfunction getServerName(host) {\n    if (!host) {\n        return null;\n    }\n    assert.strictEqual(typeof host, \"string\");\n    const servername = getHostname(host);\n    if (net.isIP(servername)) {\n        return \"\";\n    }\n    return servername;\n}\nfunction deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nfunction isAsyncIterable(obj) {\n    return !!(obj != null && typeof obj[Symbol.asyncIterator] === \"function\");\n}\nfunction isIterable(obj) {\n    return !!(obj != null && (typeof obj[Symbol.iterator] === \"function\" || typeof obj[Symbol.asyncIterator] === \"function\"));\n}\nfunction bodyLength(body) {\n    if (body == null) {\n        return 0;\n    } else if (isStream(body)) {\n        const state = body._readableState;\n        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;\n    } else if (isBlobLike(body)) {\n        return body.size != null ? body.size : null;\n    } else if (isBuffer(body)) {\n        return body.byteLength;\n    }\n    return null;\n}\nfunction isDestroyed(stream) {\n    return !stream || !!(stream.destroyed || stream[kDestroyed]);\n}\nfunction isReadableAborted(stream) {\n    const state = stream && stream._readableState;\n    return isDestroyed(stream) && state && !state.endEmitted;\n}\nfunction destroy(stream, err) {\n    if (stream == null || !isStream(stream) || isDestroyed(stream)) {\n        return;\n    }\n    if (typeof stream.destroy === \"function\") {\n        if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n            // See: https://github.com/nodejs/node/pull/38505/files\n            stream.socket = null;\n        }\n        stream.destroy(err);\n    } else if (err) {\n        process.nextTick((stream, err)=>{\n            stream.emit(\"error\", err);\n        }, stream, err);\n    }\n    if (stream.destroyed !== true) {\n        stream[kDestroyed] = true;\n    }\n}\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/;\nfunction parseKeepAliveTimeout(val) {\n    const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);\n    return m ? parseInt(m[1], 10) * 1000 : null;\n}\nfunction parseHeaders(headers, obj = {}) {\n    // For H2 support\n    if (!Array.isArray(headers)) return headers;\n    for(let i = 0; i < headers.length; i += 2){\n        const key = headers[i].toString().toLowerCase();\n        let val = obj[key];\n        if (!val) {\n            if (Array.isArray(headers[i + 1])) {\n                obj[key] = headers[i + 1];\n            } else {\n                obj[key] = headers[i + 1].toString(\"utf8\");\n            }\n        } else {\n            if (!Array.isArray(val)) {\n                val = [\n                    val\n                ];\n                obj[key] = val;\n            }\n            val.push(headers[i + 1].toString(\"utf8\"));\n        }\n    }\n    // See https://github.com/nodejs/node/pull/46528\n    if (\"content-length\" in obj && \"content-disposition\" in obj) {\n        obj[\"content-disposition\"] = Buffer.from(obj[\"content-disposition\"]).toString(\"latin1\");\n    }\n    return obj;\n}\nfunction parseRawHeaders(headers) {\n    const ret = [];\n    let hasContentLength = false;\n    let contentDispositionIdx = -1;\n    for(let n = 0; n < headers.length; n += 2){\n        const key = headers[n + 0].toString();\n        const val = headers[n + 1].toString(\"utf8\");\n        if (key.length === 14 && (key === \"content-length\" || key.toLowerCase() === \"content-length\")) {\n            ret.push(key, val);\n            hasContentLength = true;\n        } else if (key.length === 19 && (key === \"content-disposition\" || key.toLowerCase() === \"content-disposition\")) {\n            contentDispositionIdx = ret.push(key, val) - 1;\n        } else {\n            ret.push(key, val);\n        }\n    }\n    // See https://github.com/nodejs/node/pull/46528\n    if (hasContentLength && contentDispositionIdx !== -1) {\n        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString(\"latin1\");\n    }\n    return ret;\n}\nfunction isBuffer(buffer) {\n    // See, https://github.com/mcollina/undici/pull/319\n    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);\n}\nfunction validateHandler(handler, method, upgrade) {\n    if (!handler || typeof handler !== \"object\") {\n        throw new InvalidArgumentError(\"handler must be an object\");\n    }\n    if (typeof handler.onConnect !== \"function\") {\n        throw new InvalidArgumentError(\"invalid onConnect method\");\n    }\n    if (typeof handler.onError !== \"function\") {\n        throw new InvalidArgumentError(\"invalid onError method\");\n    }\n    if (typeof handler.onBodySent !== \"function\" && handler.onBodySent !== undefined) {\n        throw new InvalidArgumentError(\"invalid onBodySent method\");\n    }\n    if (upgrade || method === \"CONNECT\") {\n        if (typeof handler.onUpgrade !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onUpgrade method\");\n        }\n    } else {\n        if (typeof handler.onHeaders !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onHeaders method\");\n        }\n        if (typeof handler.onData !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onData method\");\n        }\n        if (typeof handler.onComplete !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onComplete method\");\n        }\n    }\n}\n// A body is disturbed if it has been read from and it cannot\n// be re-used without losing state or data.\nfunction isDisturbed(body) {\n    return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] // TODO (fix): Why is body[kBodyUsed] needed?\n     : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));\n}\nfunction isErrored(body) {\n    return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));\n}\nfunction isReadable(body) {\n    return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));\n}\nfunction getSocketInfo(socket) {\n    return {\n        localAddress: socket.localAddress,\n        localPort: socket.localPort,\n        remoteAddress: socket.remoteAddress,\n        remotePort: socket.remotePort,\n        remoteFamily: socket.remoteFamily,\n        timeout: socket.timeout,\n        bytesWritten: socket.bytesWritten,\n        bytesRead: socket.bytesRead\n    };\n}\nasync function* convertIterableToBuffer(iterable) {\n    for await (const chunk of iterable){\n        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);\n    }\n}\nlet ReadableStream;\nfunction ReadableStreamFrom(iterable) {\n    if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    if (ReadableStream.from) {\n        return ReadableStream.from(convertIterableToBuffer(iterable));\n    }\n    let iterator;\n    return new ReadableStream({\n        async start () {\n            iterator = iterable[Symbol.asyncIterator]();\n        },\n        async pull (controller) {\n            const { done, value } = await iterator.next();\n            if (done) {\n                queueMicrotask(()=>{\n                    controller.close();\n                });\n            } else {\n                const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);\n                controller.enqueue(new Uint8Array(buf));\n            }\n            return controller.desiredSize > 0;\n        },\n        async cancel (reason) {\n            await iterator.return();\n        }\n    }, 0);\n}\n// The chunk should be a FormData instance and contains\n// all the required methods.\nfunction isFormDataLike(object) {\n    return object && typeof object === \"object\" && typeof object.append === \"function\" && typeof object.delete === \"function\" && typeof object.get === \"function\" && typeof object.getAll === \"function\" && typeof object.has === \"function\" && typeof object.set === \"function\" && object[Symbol.toStringTag] === \"FormData\";\n}\nfunction throwIfAborted(signal) {\n    if (!signal) {\n        return;\n    }\n    if (typeof signal.throwIfAborted === \"function\") {\n        signal.throwIfAborted();\n    } else {\n        if (signal.aborted) {\n            // DOMException not available < v17.0.0\n            const err = new Error(\"The operation was aborted\");\n            err.name = \"AbortError\";\n            throw err;\n        }\n    }\n}\nlet events;\nfunction addAbortListener(signal, listener) {\n    if (typeof Symbol.dispose === \"symbol\") {\n        if (!events) {\n            events = __webpack_require__(/*! events */ \"events\");\n        }\n        if (typeof events.addAbortListener === \"function\" && \"aborted\" in signal) {\n            return events.addAbortListener(signal, listener);\n        }\n    }\n    if (\"addEventListener\" in signal) {\n        signal.addEventListener(\"abort\", listener, {\n            once: true\n        });\n        return ()=>signal.removeEventListener(\"abort\", listener);\n    }\n    signal.addListener(\"abort\", listener);\n    return ()=>signal.removeListener(\"abort\", listener);\n}\nconst hasToWellFormed = !!String.prototype.toWellFormed;\n/**\n * @param {string} val\n */ function toUSVString(val) {\n    if (hasToWellFormed) {\n        return `${val}`.toWellFormed();\n    } else if (nodeUtil.toUSVString) {\n        return nodeUtil.toUSVString(val);\n    }\n    return `${val}`;\n}\nconst kEnumerableProperty = Object.create(null);\nkEnumerableProperty.enumerable = true;\nmodule.exports = {\n    kEnumerableProperty,\n    nop,\n    isDisturbed,\n    isErrored,\n    isReadable,\n    toUSVString,\n    isReadableAborted,\n    isBlobLike,\n    parseOrigin,\n    parseURL,\n    getServerName,\n    isStream,\n    isIterable,\n    isAsyncIterable,\n    isDestroyed,\n    parseRawHeaders,\n    parseHeaders,\n    parseKeepAliveTimeout,\n    destroy,\n    bodyLength,\n    deepClone,\n    ReadableStreamFrom,\n    isBuffer,\n    validateHandler,\n    getSocketInfo,\n    isFormDataLike,\n    buildURL,\n    throwIfAborted,\n    addAbortListener,\n    nodeMajor,\n    nodeMinor,\n    nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUMxQyxNQUFNLEVBQUVHLGVBQWUsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUNwQyxNQUFNSSxTQUFTSixtQkFBT0EsQ0FBQztBQUN2QixNQUFNSyxNQUFNTCxtQkFBT0EsQ0FBQztBQUNwQixNQUFNLEVBQUVNLG9CQUFvQixFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ3pDLE1BQU0sRUFBRU8sSUFBSSxFQUFFLEdBQUdQLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1RLFdBQVdSLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBRVMsU0FBUyxFQUFFLEdBQUdULG1CQUFPQSxDQUFDO0FBRTlCLE1BQU0sQ0FBQ1UsV0FBV0MsVUFBVSxHQUFHQyxRQUFRQyxRQUFRLENBQUNDLElBQUksQ0FBQ0MsS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0MsT0FBT0Q7QUFFaEYsU0FBU0UsT0FBUTtBQUVqQixTQUFTQyxTQUFVQyxHQUFHO0lBQ3BCLE9BQU9BLE9BQU8sT0FBT0EsUUFBUSxZQUFZLE9BQU9BLElBQUlDLElBQUksS0FBSyxjQUFjLE9BQU9ELElBQUlFLEVBQUUsS0FBSztBQUMvRjtBQUVBLG1JQUFtSTtBQUNuSSxTQUFTQyxXQUFZQyxNQUFNO0lBQ3pCLE9BQU8sUUFBU0Esa0JBQWtCbEIsUUFDaENrQixVQUNBLE9BQU9BLFdBQVcsWUFDakIsUUFBT0EsT0FBT3JCLE1BQU0sS0FBSyxjQUN4QixPQUFPcUIsT0FBT0MsV0FBVyxLQUFLLFVBQVMsS0FDekMsZ0JBQWdCQyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csT0FBT0MsV0FBVyxDQUFDO0FBRW5EO0FBRUEsU0FBU0MsU0FB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O0lBRUEsT0FBTyxDQUFDLEVBQUVBLElBQUksQ0FBQztBQUNqQjtBQUVBLE1BQU00RixzQkFBc0JwRyxPQUFPcUcsTUFBTSxDQUFDO0FBQzFDRCxvQkFBb0JFLFVBQVUsR0FBRztBQUVqQ0MsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZKO0lBQ0FySztJQUNBMEc7SUFDQUc7SUFDQUU7SUFDQXFEO0lBQ0F2RztJQUNBeEQ7SUFDQTJCO0lBQ0FmO0lBQ0FzQjtJQUNBdEM7SUFDQStDO0lBQ0FGO0lBQ0FhO0lBQ0E0QjtJQUNBVjtJQUNBTDtJQUNBVDtJQUNBYjtJQUNBUDtJQUNBa0Y7SUFDQXBFO0lBQ0FxQztJQUNBa0I7SUFDQTRCO0lBQ0FqSTtJQUNBd0k7SUFDQUs7SUFDQWpLO0lBQ0FDO0lBQ0FrTCx5QkFBeUJuTCxZQUFZLE1BQU9BLGNBQWMsTUFBTUMsYUFBYTtBQUMvRSIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS91dGlsLmpzP2VhMDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IGtEZXN0cm95ZWQsIGtCb2R5VXNlZCB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgSW5jb21pbmdNZXNzYWdlIH0gPSByZXF1aXJlKCdodHRwJylcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxuY29uc3QgeyBCbG9iIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3Qgbm9kZVV0aWwgPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSByZXF1aXJlKCdxdWVyeXN0cmluZycpXG5cbmNvbnN0IFtub2RlTWFqb3IsIG5vZGVNaW5vcl0gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKS5tYXAodiA9PiBOdW1iZXIodikpXG5cbmZ1bmN0aW9uIG5vcCAoKSB7fVxuXG5mdW5jdGlvbiBpc1N0cmVhbSAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai5waXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbidcbn1cblxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvZmV0Y2gtYmxvYi9ibG9iLzhhYjU4N2QzNDA4MGRlOTQxNDBiNTRmMDcxNjg0NTFlN2QwYjY1NWUvaW5kZXguanMjTDIyOS1MMjQxIChNSVQgTGljZW5zZSlcbmZ1bmN0aW9uIGlzQmxvYkxpa2UgKG9iamVjdCkge1xuICByZXR1cm4gKEJsb2IgJiYgb2JqZWN0IGluc3RhbmNlb2YgQmxvYikgfHwgKFxuICAgIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgKHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nKSAmJlxuICAgIC9eKEJsb2J8RmlsZSkkLy50ZXN0KG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddKVxuICApXG59XG5cbmZ1bmN0aW9uIGJ1aWxkVVJMICh1cmwsIHF1ZXJ5UGFyYW1zKSB7XG4gIGlmICh1cmwuaW5jbHVkZXMoJz8nKSB8fCB1cmwuaW5jbHVkZXMoJyMnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkgcGFyYW1zIGNhbm5vdCBiZSBwYXNzZWQgd2hlbiB1cmwgYWxyZWFkeSBjb250YWlucyBcIj9cIiBvciBcIiNcIi4nKVxuICB9XG5cbiAgY29uc3Qgc3RyaW5naWZpZWQgPSBzdHJpbmdpZnkocXVlcnlQYXJhbXMpXG5cbiAgaWYgKHN0cmluZ2lmaWVkKSB7XG4gICAgdXJsICs9ICc/JyArIHN0cmluZ2lmaWVkXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIHBhcnNlVVJMICh1cmwpIHtcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpXG5cbiAgICBpZiAoIS9eaHR0cHM/Oi8udGVzdCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcHJvdG9jb2w6IHRoZSBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJylcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsXG4gIH1cblxuICBpZiAoIXVybCB8fCB0eXBlb2YgdXJsICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkw6IFRoZSBVUkwgYXJndW1lbnQgbXVzdCBiZSBhIG5vbi1udWxsIG9iamVjdC4nKVxuICB9XG5cbiAgaWYgKCEvXmh0dHBzPzovLnRlc3QodXJsLm9yaWdpbiB8fCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwcm90b2NvbDogdGhlIFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKVxuICB9XG5cbiAgaWYgKCEodXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIGlmICh1cmwucG9ydCAhPSBudWxsICYmIHVybC5wb3J0ICE9PSAnJyAmJiAhTnVtYmVyLmlzRmluaXRlKHBhcnNlSW50KHVybC5wb3J0KSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkw6IHBvcnQgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgb3IgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlci4nKVxuICAgIH1cblxuICAgIGlmICh1cmwucGF0aCAhPSBudWxsICYmIHR5cGVvZiB1cmwucGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcGF0aDogdGhlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGlmICh1cmwucGF0aG5hbWUgIT0gbnVsbCAmJiB0eXBlb2YgdXJsLnBhdGhuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwYXRobmFtZTogdGhlIHBhdGhuYW1lIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAodXJsLmhvc3RuYW1lICE9IG51bGwgJiYgdHlwZW9mIHVybC5ob3N0bmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgaG9zdG5hbWU6IHRoZSBob3N0bmFtZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwvdW5kZWZpbmVkLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5vcmlnaW4gIT0gbnVsbCAmJiB0eXBlb2YgdXJsLm9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgb3JpZ2luOiB0aGUgb3JpZ2luIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBjb25zdCBwb3J0ID0gdXJsLnBvcnQgIT0gbnVsbFxuICAgICAgPyB1cmwucG9ydFxuICAgICAgOiAodXJsLnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwKVxuICAgIGxldCBvcmlnaW4gPSB1cmwub3JpZ2luICE9IG51bGxcbiAgICAgID8gdXJsLm9yaWdpblxuICAgICAgOiBgJHt1cmwucHJvdG9jb2x9Ly8ke3VybC5ob3N0bmFtZX06JHtwb3J0fWBcbiAgICBsZXQgcGF0aCA9IHVybC5wYXRoICE9IG51bGxcbiAgICAgID8gdXJsLnBhdGhcbiAgICAgIDogYCR7dXJsLnBhdGhuYW1lIHx8ICcnfSR7dXJsLnNlYXJjaCB8fCAnJ31gXG5cbiAgICBpZiAob3JpZ2luLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgIG9yaWdpbiA9IG9yaWdpbi5zdWJzdHJpbmcoMCwgb3JpZ2luLmxlbmd0aCAtIDEpXG4gICAgfVxuXG4gICAgaWYgKHBhdGggJiYgIXBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICBwYXRoID0gYC8ke3BhdGh9YFxuICAgIH1cbiAgICAvLyBuZXcgVVJMKHBhdGgsIG9yaWdpbikgaXMgdW5zYWZlIHdoZW4gYHBhdGhgIGNvbnRhaW5zIGFuIGFic29sdXRlIFVSTFxuICAgIC8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9VUkw6XG4gICAgLy8gSWYgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmVsYXRpdmUgVVJMLCBzZWNvbmQgcGFyYW0gaXMgcmVxdWlyZWQsIGFuZCB3aWxsIGJlIHVzZWQgYXMgdGhlIGJhc2UgVVJMLlxuICAgIC8vIElmIGZpcnN0IHBhcmFtZXRlciBpcyBhbiBhYnNvbHV0ZSBVUkwsIGEgZ2l2ZW4gc2Vjb25kIHBhcmFtIHdpbGwgYmUgaWdub3JlZC5cbiAgICB1cmwgPSBuZXcgVVJMKG9yaWdpbiArIHBhdGgpXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIHBhcnNlT3JpZ2luICh1cmwpIHtcbiAgdXJsID0gcGFyc2VVUkwodXJsKVxuXG4gIGlmICh1cmwucGF0aG5hbWUgIT09ICcvJyB8fCB1cmwuc2VhcmNoIHx8IHVybC5oYXNoKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHVybCcpXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIGdldEhvc3RuYW1lIChob3N0KSB7XG4gIGlmIChob3N0WzBdID09PSAnWycpIHtcbiAgICBjb25zdCBpZHggPSBob3N0LmluZGV4T2YoJ10nKVxuXG4gICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG4gICAgcmV0dXJuIGhvc3Quc3Vic3RyKDEsIGlkeCAtIDEpXG4gIH1cblxuICBjb25zdCBpZHggPSBob3N0LmluZGV4T2YoJzonKVxuICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIGhvc3RcblxuICByZXR1cm4gaG9zdC5zdWJzdHIoMCwgaWR4KVxufVxuXG4vLyBJUCBhZGRyZXNzZXMgYXJlIG5vdCB2YWxpZCBzZXJ2ZXIgbmFtZXMgcGVyIFJGQzYwNjZcbi8vID4gQ3VycmVudGx5LCB0aGUgb25seSBzZXJ2ZXIgbmFtZXMgc3VwcG9ydGVkIGFyZSBETlMgaG9zdG5hbWVzXG5mdW5jdGlvbiBnZXRTZXJ2ZXJOYW1lIChob3N0KSB7XG4gIGlmICghaG9zdCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIGhvc3QsICdzdHJpbmcnKVxuXG4gIGNvbnN0IHNlcnZlcm5hbWUgPSBnZXRIb3N0bmFtZShob3N0KVxuICBpZiAobmV0LmlzSVAoc2VydmVybmFtZSkpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIHJldHVybiBzZXJ2ZXJuYW1lXG59XG5cbmZ1bmN0aW9uIGRlZXBDbG9uZSAob2JqKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpXG59XG5cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJylcbn1cblxuZnVuY3Rpb24gaXNJdGVyYWJsZSAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJiAodHlwZW9mIG9ialtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSlcbn1cblxuZnVuY3Rpb24gYm9keUxlbmd0aCAoYm9keSkge1xuICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDBcbiAgfSBlbHNlIGlmIChpc1N0cmVhbShib2R5KSkge1xuICAgIGNvbnN0IHN0YXRlID0gYm9keS5fcmVhZGFibGVTdGF0ZVxuICAgIHJldHVybiBzdGF0ZSAmJiBzdGF0ZS5vYmplY3RNb2RlID09PSBmYWxzZSAmJiBzdGF0ZS5lbmRlZCA9PT0gdHJ1ZSAmJiBOdW1iZXIuaXNGaW5pdGUoc3RhdGUubGVuZ3RoKVxuICAgICAgPyBzdGF0ZS5sZW5ndGhcbiAgICAgIDogbnVsbFxuICB9IGVsc2UgaWYgKGlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS5zaXplICE9IG51bGwgPyBib2R5LnNpemUgOiBudWxsXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYm9keSkpIHtcbiAgICByZXR1cm4gYm9keS5ieXRlTGVuZ3RoXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0Rlc3Ryb3llZCAoc3RyZWFtKSB7XG4gIHJldHVybiAhc3RyZWFtIHx8ICEhKHN0cmVhbS5kZXN0cm95ZWQgfHwgc3RyZWFtW2tEZXN0cm95ZWRdKVxufVxuXG5mdW5jdGlvbiBpc1JlYWRhYmxlQWJvcnRlZCAoc3RyZWFtKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICByZXR1cm4gaXNEZXN0cm95ZWQoc3RyZWFtKSAmJiBzdGF0ZSAmJiAhc3RhdGUuZW5kRW1pdHRlZFxufVxuXG5mdW5jdGlvbiBkZXN0cm95IChzdHJlYW0sIGVycikge1xuICBpZiAoc3RyZWFtID09IG51bGwgfHwgIWlzU3RyZWFtKHN0cmVhbSkgfHwgaXNEZXN0cm95ZWQoc3RyZWFtKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3RyZWFtKS5jb25zdHJ1Y3RvciA9PT0gSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzM4NTA1L2ZpbGVzXG4gICAgICBzdHJlYW0uc29ja2V0ID0gbnVsbFxuICAgIH1cblxuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKChzdHJlYW0sIGVycikgPT4ge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH0sIHN0cmVhbSwgZXJyKVxuICB9XG5cbiAgaWYgKHN0cmVhbS5kZXN0cm95ZWQgIT09IHRydWUpIHtcbiAgICBzdHJlYW1ba0Rlc3Ryb3llZF0gPSB0cnVlXG4gIH1cbn1cblxuY29uc3QgS0VFUEFMSVZFX1RJTUVPVVRfRVhQUiA9IC90aW1lb3V0PShcXGQrKS9cbmZ1bmN0aW9uIHBhcnNlS2VlcEFsaXZlVGltZW91dCAodmFsKSB7XG4gIGNvbnN0IG0gPSB2YWwudG9TdHJpbmcoKS5tYXRjaChLRUVQQUxJVkVfVElNRU9VVF9FWFBSKVxuICByZXR1cm4gbSA/IHBhcnNlSW50KG1bMV0sIDEwKSAqIDEwMDAgOiBudWxsXG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyAoaGVhZGVycywgb2JqID0ge30pIHtcbiAgLy8gRm9yIEgyIHN1cHBvcnRcbiAgaWYgKCFBcnJheS5pc0FycmF5KGhlYWRlcnMpKSByZXR1cm4gaGVhZGVyc1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IGtleSA9IGhlYWRlcnNbaV0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpXG4gICAgbGV0IHZhbCA9IG9ialtrZXldXG5cbiAgICBpZiAoIXZhbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyc1tpICsgMV0pKSB7XG4gICAgICAgIG9ialtrZXldID0gaGVhZGVyc1tpICsgMV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gaGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ3V0ZjgnKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YWwgPSBbdmFsXVxuICAgICAgICBvYmpba2V5XSA9IHZhbFxuICAgICAgfVxuICAgICAgdmFsLnB1c2goaGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ3V0ZjgnKSlcbiAgICB9XG4gIH1cblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvNDY1MjhcbiAgaWYgKCdjb250ZW50LWxlbmd0aCcgaW4gb2JqICYmICdjb250ZW50LWRpc3Bvc2l0aW9uJyBpbiBvYmopIHtcbiAgICBvYmpbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXSA9IEJ1ZmZlci5mcm9tKG9ialsnY29udGVudC1kaXNwb3NpdGlvbiddKS50b1N0cmluZygnbGF0aW4xJylcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gcGFyc2VSYXdIZWFkZXJzIChoZWFkZXJzKSB7XG4gIGNvbnN0IHJldCA9IFtdXG4gIGxldCBoYXNDb250ZW50TGVuZ3RoID0gZmFsc2VcbiAgbGV0IGNvbnRlbnREaXNwb3NpdGlvbklkeCA9IC0xXG5cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBoZWFkZXJzLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgY29uc3Qga2V5ID0gaGVhZGVyc1tuICsgMF0udG9TdHJpbmcoKVxuICAgIGNvbnN0IHZhbCA9IGhlYWRlcnNbbiArIDFdLnRvU3RyaW5nKCd1dGY4JylcblxuICAgIGlmIChrZXkubGVuZ3RoID09PSAxNCAmJiAoa2V5ID09PSAnY29udGVudC1sZW5ndGgnIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1sZW5ndGgnKSkge1xuICAgICAgcmV0LnB1c2goa2V5LCB2YWwpXG4gICAgICBoYXNDb250ZW50TGVuZ3RoID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMTkgJiYgKGtleSA9PT0gJ2NvbnRlbnQtZGlzcG9zaXRpb24nIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1kaXNwb3NpdGlvbicpKSB7XG4gICAgICBjb250ZW50RGlzcG9zaXRpb25JZHggPSByZXQucHVzaChrZXksIHZhbCkgLSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wdXNoKGtleSwgdmFsKVxuICAgIH1cbiAgfVxuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80NjUyOFxuICBpZiAoaGFzQ29udGVudExlbmd0aCAmJiBjb250ZW50RGlzcG9zaXRpb25JZHggIT09IC0xKSB7XG4gICAgcmV0W2NvbnRlbnREaXNwb3NpdGlvbklkeF0gPSBCdWZmZXIuZnJvbShyZXRbY29udGVudERpc3Bvc2l0aW9uSWR4XSkudG9TdHJpbmcoJ2xhdGluMScpXG4gIH1cblxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChidWZmZXIpIHtcbiAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbWNvbGxpbmEvdW5kaWNpL3B1bGwvMzE5XG4gIHJldHVybiBidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSGFuZGxlciAoaGFuZGxlciwgbWV0aG9kLCB1cGdyYWRlKSB7XG4gIGlmICghaGFuZGxlciB8fCB0eXBlb2YgaGFuZGxlciAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hhbmRsZXIgbXVzdCBiZSBhbiBvYmplY3QnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQ29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkNvbm5lY3QgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkJvZHlTZW50ICE9PSAnZnVuY3Rpb24nICYmIGhhbmRsZXIub25Cb2R5U2VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uQm9keVNlbnQgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh1cGdyYWRlIHx8IG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uVXBncmFkZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uVXBncmFkZSBtZXRob2QnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25IZWFkZXJzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25IZWFkZXJzIG1ldGhvZCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRGF0YSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRGF0YSBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkNvbXBsZXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25Db21wbGV0ZSBtZXRob2QnKVxuICAgIH1cbiAgfVxufVxuXG4vLyBBIGJvZHkgaXMgZGlzdHVyYmVkIGlmIGl0IGhhcyBiZWVuIHJlYWQgZnJvbSBhbmQgaXQgY2Fubm90XG4vLyBiZSByZS11c2VkIHdpdGhvdXQgbG9zaW5nIHN0YXRlIG9yIGRhdGEuXG5mdW5jdGlvbiBpc0Rpc3R1cmJlZCAoYm9keSkge1xuICByZXR1cm4gISEoYm9keSAmJiAoXG4gICAgc3RyZWFtLmlzRGlzdHVyYmVkXG4gICAgICA/IHN0cmVhbS5pc0Rpc3R1cmJlZChib2R5KSB8fCBib2R5W2tCb2R5VXNlZF0gLy8gVE9ETyAoZml4KTogV2h5IGlzIGJvZHlba0JvZHlVc2VkXSBuZWVkZWQ/XG4gICAgICA6IGJvZHlba0JvZHlVc2VkXSB8fFxuICAgICAgICBib2R5LnJlYWRhYmxlRGlkUmVhZCB8fFxuICAgICAgICAoYm9keS5fcmVhZGFibGVTdGF0ZSAmJiBib2R5Ll9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkKSB8fFxuICAgICAgICBpc1JlYWRhYmxlQWJvcnRlZChib2R5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0Vycm9yZWQgKGJvZHkpIHtcbiAgcmV0dXJuICEhKGJvZHkgJiYgKFxuICAgIHN0cmVhbS5pc0Vycm9yZWRcbiAgICAgID8gc3RyZWFtLmlzRXJyb3JlZChib2R5KVxuICAgICAgOiAvc3RhdGU6ICdlcnJvcmVkJy8udGVzdChub2RlVXRpbC5pbnNwZWN0KGJvZHkpXG4gICAgICApKSlcbn1cblxuZnVuY3Rpb24gaXNSZWFkYWJsZSAoYm9keSkge1xuICByZXR1cm4gISEoYm9keSAmJiAoXG4gICAgc3RyZWFtLmlzUmVhZGFibGVcbiAgICAgID8gc3RyZWFtLmlzUmVhZGFibGUoYm9keSlcbiAgICAgIDogL3N0YXRlOiAncmVhZGFibGUnLy50ZXN0KG5vZGVVdGlsLmluc3BlY3QoYm9keSlcbiAgICAgICkpKVxufVxuXG5mdW5jdGlvbiBnZXRTb2NrZXRJbmZvIChzb2NrZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2NhbEFkZHJlc3M6IHNvY2tldC5sb2NhbEFkZHJlc3MsXG4gICAgbG9jYWxQb3J0OiBzb2NrZXQubG9jYWxQb3J0LFxuICAgIHJlbW90ZUFkZHJlc3M6IHNvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgIHJlbW90ZVBvcnQ6IHNvY2tldC5yZW1vdGVQb3J0LFxuICAgIHJlbW90ZUZhbWlseTogc29ja2V0LnJlbW90ZUZhbWlseSxcbiAgICB0aW1lb3V0OiBzb2NrZXQudGltZW91dCxcbiAgICBieXRlc1dyaXR0ZW46IHNvY2tldC5ieXRlc1dyaXR0ZW4sXG4gICAgYnl0ZXNSZWFkOiBzb2NrZXQuYnl0ZXNSZWFkXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gKiBjb252ZXJ0SXRlcmFibGVUb0J1ZmZlciAoaXRlcmFibGUpIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpdGVyYWJsZSkge1xuICAgIHlpZWxkIEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgPyBjaHVuayA6IEJ1ZmZlci5mcm9tKGNodW5rKVxuICB9XG59XG5cbmxldCBSZWFkYWJsZVN0cmVhbVxuZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tIChpdGVyYWJsZSkge1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtKSB7XG4gICAgUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0vd2ViJykuUmVhZGFibGVTdHJlYW1cbiAgfVxuXG4gIGlmIChSZWFkYWJsZVN0cmVhbS5mcm9tKSB7XG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtLmZyb20oY29udmVydEl0ZXJhYmxlVG9CdWZmZXIoaXRlcmFibGUpKVxuICB9XG5cbiAgbGV0IGl0ZXJhdG9yXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAge1xuICAgICAgYXN5bmMgc3RhcnQgKCkge1xuICAgICAgICBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpXG4gICAgICB9LFxuICAgICAgYXN5bmMgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KClcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgPyB2YWx1ZSA6IEJ1ZmZlci5mcm9tKHZhbHVlKVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLmRlc2lyZWRTaXplID4gMFxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCAocmVhc29uKSB7XG4gICAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybigpXG4gICAgICB9XG4gICAgfSxcbiAgICAwXG4gIClcbn1cblxuLy8gVGhlIGNodW5rIHNob3VsZCBiZSBhIEZvcm1EYXRhIGluc3RhbmNlIGFuZCBjb250YWluc1xuLy8gYWxsIHRoZSByZXF1aXJlZCBtZXRob2RzLlxuZnVuY3Rpb24gaXNGb3JtRGF0YUxpa2UgKG9iamVjdCkge1xuICByZXR1cm4gKFxuICAgIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5hcHBlbmQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmRlbGV0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuZ2V0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5nZXRBbGwgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmhhcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3Quc2V0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgb2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGb3JtRGF0YSdcbiAgKVxufVxuXG5mdW5jdGlvbiB0aHJvd0lmQWJvcnRlZCAoc2lnbmFsKSB7XG4gIGlmICghc2lnbmFsKSB7IHJldHVybiB9XG4gIGlmICh0eXBlb2Ygc2lnbmFsLnRocm93SWZBYm9ydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2lnbmFsLnRocm93SWZBYm9ydGVkKClcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIC8vIERPTUV4Y2VwdGlvbiBub3QgYXZhaWxhYmxlIDwgdjE3LjAuMFxuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkJylcbiAgICAgIGVyci5uYW1lID0gJ0Fib3J0RXJyb3InXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxubGV0IGV2ZW50c1xuZnVuY3Rpb24gYWRkQWJvcnRMaXN0ZW5lciAoc2lnbmFsLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIFN5bWJvbC5kaXNwb3NlID09PSAnc3ltYm9sJykge1xuICAgIGlmICghZXZlbnRzKSB7XG4gICAgICBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGV2ZW50cy5hZGRBYm9ydExpc3RlbmVyID09PSAnZnVuY3Rpb24nICYmICdhYm9ydGVkJyBpbiBzaWduYWwpIHtcbiAgICAgIHJldHVybiBldmVudHMuYWRkQWJvcnRMaXN0ZW5lcihzaWduYWwsIGxpc3RlbmVyKVxuICAgIH1cbiAgfVxuICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHNpZ25hbCkge1xuICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSlcbiAgICByZXR1cm4gKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpXG4gIH1cbiAgc2lnbmFsLmFkZExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKVxuICByZXR1cm4gKCkgPT4gc2lnbmFsLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKVxufVxuXG5jb25zdCBoYXNUb1dlbGxGb3JtZWQgPSAhIVN0cmluZy5wcm90b3R5cGUudG9XZWxsRm9ybWVkXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICovXG5mdW5jdGlvbiB0b1VTVlN0cmluZyAodmFsKSB7XG4gIGlmIChoYXNUb1dlbGxGb3JtZWQpIHtcbiAgICByZXR1cm4gYCR7dmFsfWAudG9XZWxsRm9ybWVkKClcbiAgfSBlbHNlIGlmIChub2RlVXRpbC50b1VTVlN0cmluZykge1xuICAgIHJldHVybiBub2RlVXRpbC50b1VTVlN0cmluZyh2YWwpXG4gIH1cblxuICByZXR1cm4gYCR7dmFsfWBcbn1cblxuY29uc3Qga0VudW1lcmFibGVQcm9wZXJ0eSA9IE9iamVjdC5jcmVhdGUobnVsbClcbmtFbnVtZXJhYmxlUHJvcGVydHkuZW51bWVyYWJsZSA9IHRydWVcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG5vcCxcbiAgaXNEaXN0dXJiZWQsXG4gIGlzRXJyb3JlZCxcbiAgaXNSZWFkYWJsZSxcbiAgdG9VU1ZTdHJpbmcsXG4gIGlzUmVhZGFibGVBYm9ydGVkLFxuICBpc0Jsb2JMaWtlLFxuICBwYXJzZU9yaWdpbixcbiAgcGFyc2VVUkwsXG4gIGdldFNlcnZlck5hbWUsXG4gIGlzU3RyZWFtLFxuICBpc0l0ZXJhYmxlLFxuICBpc0FzeW5jSXRlcmFibGUsXG4gIGlzRGVzdHJveWVkLFxuICBwYXJzZVJhd0hlYWRlcnMsXG4gIHBhcnNlSGVhZGVycyxcbiAgcGFyc2VLZWVwQWxpdmVUaW1lb3V0LFxuICBkZXN0cm95LFxuICBib2R5TGVuZ3RoLFxuICBkZWVwQ2xvbmUsXG4gIFJlYWRhYmxlU3RyZWFtRnJvbSxcbiAgaXNCdWZmZXIsXG4gIHZhbGlkYXRlSGFuZGxlcixcbiAgZ2V0U29ja2V0SW5mbyxcbiAgaXNGb3JtRGF0YUxpa2UsXG4gIGJ1aWxkVVJMLFxuICB0aHJvd0lmQWJvcnRlZCxcbiAgYWRkQWJvcnRMaXN0ZW5lcixcbiAgbm9kZU1ham9yLFxuICBub2RlTWlub3IsXG4gIG5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5OiBub2RlTWFqb3IgPiAxOCB8fCAobm9kZU1ham9yID09PSAxOCAmJiBub2RlTWlub3IgPj0gMTMpXG59XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsImtEZXN0cm95ZWQiLCJrQm9keVVzZWQiLCJJbmNvbWluZ01lc3NhZ2UiLCJzdHJlYW0iLCJuZXQiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkJsb2IiLCJub2RlVXRpbCIsInN0cmluZ2lmeSIsIm5vZGVNYWpvciIsIm5vZGVNaW5vciIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJzcGxpdCIsIm1hcCIsInYiLCJOdW1iZXIiLCJub3AiLCJpc1N0cmVhbSIsIm9iaiIsInBpcGUiLCJvbiIsImlzQmxvYkxpa2UiLCJvYmplY3QiLCJhcnJheUJ1ZmZlciIsInRlc3QiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImJ1aWxkVVJMIiwidXJsIiwicXVlcnlQYXJhbXMiLCJpbmNsdWRlcyIsIkVycm9yIiwic3RyaW5naWZpZWQiLCJwYXJzZVVSTCIsIlVSTCIsIm9yaWdpbiIsInByb3RvY29sIiwicG9ydCIsImlzRmluaXRlIiwicGFyc2VJbnQiLCJwYXRoIiwicGF0aG5hbWUiLCJob3N0bmFtZSIsInNlYXJjaCIsImVuZHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwic3RhcnRzV2l0aCIsInBhcnNlT3JpZ2luIiwiaGFzaCIsImdldEhvc3RuYW1lIiwiaG9zdCIsImlkeCIsImluZGV4T2YiLCJzdWJzdHIiLCJnZXRTZXJ2ZXJOYW1lIiwic3RyaWN0RXF1YWwiLCJzZXJ2ZXJuYW1lIiwiaXNJUCIsImRlZXBDbG9uZSIsIkpTT04iLCJwYXJzZSIsImlzQXN5bmNJdGVyYWJsZSIsImFzeW5jSXRlcmF0b3IiLCJpc0l0ZXJhYmxlIiwiaXRlcmF0b3IiLCJib2R5TGVuZ3RoIiwiYm9keSIsInN0YXRlIiwiX3JlYWRhYmxlU3RhdGUiLCJvYmplY3RNb2RlIiwiZW5kZWQiLCJzaXplIiwiaXNCdWZmZXIiLCJieXRlTGVuZ3RoIiwiaXNEZXN0cm95ZWQiLCJkZXN0cm95ZWQiLCJpc1JlYWRhYmxlQWJvcnRlZCIsImVuZEVtaXR0ZWQiLCJkZXN0cm95IiwiZXJyIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsInNvY2tldCIsIm5leHRUaWNrIiwiZW1pdCIsIktFRVBBTElWRV9USU1FT1VUX0VYUFIiLCJwYXJzZUtlZXBBbGl2ZVRpbWVvdXQiLCJ2YWwiLCJtIiwidG9TdHJpbmciLCJtYXRjaCIsInBhcnNlSGVhZGVycyIsImhlYWRlcnMiLCJBcnJheSIsImlzQXJyYXkiLCJpIiwia2V5IiwidG9Mb3dlckNhc2UiLCJwdXNoIiwiQnVmZmVyIiwiZnJvbSIsInBhcnNlUmF3SGVhZGVycyIsInJldCIsImhhc0NvbnRlbnRMZW5ndGgiLCJjb250ZW50RGlzcG9zaXRpb25JZHgiLCJuIiwiYnVmZmVyIiwiVWludDhBcnJheSIsInZhbGlkYXRlSGFuZGxlciIsImhhbmRsZXIiLCJtZXRob2QiLCJ1cGdyYWRlIiwib25Db25uZWN0Iiwib25FcnJvciIsIm9uQm9keVNlbnQiLCJ1bmRlZmluZWQiLCJvblVwZ3JhZGUiLCJvbkhlYWRlcnMiLCJvbkRhdGEiLCJvbkNvbXBsZXRlIiwiaXNEaXN0dXJiZWQiLCJyZWFkYWJsZURpZFJlYWQiLCJkYXRhRW1pdHRlZCIsImlzRXJyb3JlZCIsImluc3BlY3QiLCJpc1JlYWRhYmxlIiwiZ2V0U29ja2V0SW5mbyIsImxvY2FsQWRkcmVzcyIsImxvY2FsUG9ydCIsInJlbW90ZUFkZHJlc3MiLCJyZW1vdGVQb3J0IiwicmVtb3RlRmFtaWx5IiwidGltZW91dCIsImJ5dGVzV3JpdHRlbiIsImJ5dGVzUmVhZCIsImNvbnZlcnRJdGVyYWJsZVRvQnVmZmVyIiwiaXRlcmFibGUiLCJjaHVuayIsIlJlYWRhYmxlU3RyZWFtIiwiUmVhZGFibGVTdHJlYW1Gcm9tIiwic3RhcnQiLCJwdWxsIiwiY29udHJvbGxlciIsImRvbmUiLCJ2YWx1ZSIsIm5leHQiLCJxdWV1ZU1pY3JvdGFzayIsImNsb3NlIiwiYnVmIiwiZW5xdWV1ZSIsImRlc2lyZWRTaXplIiwiY2FuY2VsIiwicmVhc29uIiwicmV0dXJuIiwiaXNGb3JtRGF0YUxpa2UiLCJhcHBlbmQiLCJkZWxldGUiLCJnZXQiLCJnZXRBbGwiLCJoYXMiLCJzZXQiLCJ0aHJvd0lmQWJvcnRlZCIsInNpZ25hbCIsImFib3J0ZWQiLCJuYW1lIiwiZXZlbnRzIiwiYWRkQWJvcnRMaXN0ZW5lciIsImxpc3RlbmVyIiwiZGlzcG9zZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJoYXNUb1dlbGxGb3JtZWQiLCJTdHJpbmciLCJwcm90b3R5cGUiLCJ0b1dlbGxGb3JtZWQiLCJ0b1VTVlN0cmluZyIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJjcmVhdGUiLCJlbnVtZXJhYmxlIiwibW9kdWxlIiwiZXhwb3J0cyIsIm5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/core/util.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/dispatcher-base.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/dispatcher-base.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(rsc)/../../node_modules/undici/lib/dispatcher.js\");\nconst { ClientDestroyedError, ClientClosedError, InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst { kDestroy, kClose, kDispatch, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst kDestroyed = Symbol(\"destroyed\");\nconst kClosed = Symbol(\"closed\");\nconst kOnDestroyed = Symbol(\"onDestroyed\");\nconst kOnClosed = Symbol(\"onClosed\");\nconst kInterceptedDispatch = Symbol(\"Intercepted Dispatch\");\nclass DispatcherBase extends Dispatcher {\n    constructor(){\n        super();\n        this[kDestroyed] = false;\n        this[kOnDestroyed] = null;\n        this[kClosed] = false;\n        this[kOnClosed] = [];\n    }\n    get destroyed() {\n        return this[kDestroyed];\n    }\n    get closed() {\n        return this[kClosed];\n    }\n    get interceptors() {\n        return this[kInterceptors];\n    }\n    set interceptors(newInterceptors) {\n        if (newInterceptors) {\n            for(let i = newInterceptors.length - 1; i >= 0; i--){\n                const interceptor = this[kInterceptors][i];\n                if (typeof interceptor !== \"function\") {\n                    throw new InvalidArgumentError(\"interceptor must be an function\");\n                }\n            }\n        }\n        this[kInterceptors] = newInterceptors;\n    }\n    close(callback) {\n        if (callback === undefined) {\n            return new Promise((resolve, reject)=>{\n                this.close((err, data)=>{\n                    return err ? reject(err) : resolve(data);\n                });\n            });\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        if (this[kDestroyed]) {\n            queueMicrotask(()=>callback(new ClientDestroyedError(), null));\n            return;\n        }\n        if (this[kClosed]) {\n            if (this[kOnClosed]) {\n                this[kOnClosed].push(callback);\n            } else {\n                queueMicrotask(()=>callback(null, null));\n            }\n            return;\n        }\n        this[kClosed] = true;\n        this[kOnClosed].push(callback);\n        const onClosed = ()=>{\n            const callbacks = this[kOnClosed];\n            this[kOnClosed] = null;\n            for(let i = 0; i < callbacks.length; i++){\n                callbacks[i](null, null);\n            }\n        };\n        // Should not error.\n        this[kClose]().then(()=>this.destroy()).then(()=>{\n            queueMicrotask(onClosed);\n        });\n    }\n    destroy(err, callback) {\n        if (typeof err === \"function\") {\n            callback = err;\n            err = null;\n        }\n        if (callback === undefined) {\n            return new Promise((resolve, reject)=>{\n                this.destroy(err, (err, data)=>{\n                    return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data);\n                });\n            });\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        if (this[kDestroyed]) {\n            if (this[kOnDestroyed]) {\n                this[kOnDestroyed].push(callback);\n            } else {\n                queueMicrotask(()=>callback(null, null));\n            }\n            return;\n        }\n        if (!err) {\n            err = new ClientDestroyedError();\n        }\n        this[kDestroyed] = true;\n        this[kOnDestroyed] = this[kOnDestroyed] || [];\n        this[kOnDestroyed].push(callback);\n        const onDestroyed = ()=>{\n            const callbacks = this[kOnDestroyed];\n            this[kOnDestroyed] = null;\n            for(let i = 0; i < callbacks.length; i++){\n                callbacks[i](null, null);\n            }\n        };\n        // Should not error.\n        this[kDestroy](err).then(()=>{\n            queueMicrotask(onDestroyed);\n        });\n    }\n    [kInterceptedDispatch](opts, handler) {\n        if (!this[kInterceptors] || this[kInterceptors].length === 0) {\n            this[kInterceptedDispatch] = this[kDispatch];\n            return this[kDispatch](opts, handler);\n        }\n        let dispatch = this[kDispatch].bind(this);\n        for(let i = this[kInterceptors].length - 1; i >= 0; i--){\n            dispatch = this[kInterceptors][i](dispatch);\n        }\n        this[kInterceptedDispatch] = dispatch;\n        return dispatch(opts, handler);\n    }\n    dispatch(opts, handler) {\n        if (!handler || typeof handler !== \"object\") {\n            throw new InvalidArgumentError(\"handler must be an object\");\n        }\n        try {\n            if (!opts || typeof opts !== \"object\") {\n                throw new InvalidArgumentError(\"opts must be an object.\");\n            }\n            if (this[kDestroyed] || this[kOnDestroyed]) {\n                throw new ClientDestroyedError();\n            }\n            if (this[kClosed]) {\n                throw new ClientClosedError();\n            }\n            return this[kInterceptedDispatch](opts, handler);\n        } catch (err) {\n            if (typeof handler.onError !== \"function\") {\n                throw new InvalidArgumentError(\"invalid onError method\");\n            }\n            handler.onError(err);\n            return false;\n        }\n    }\n}\nmodule.exports = DispatcherBase;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci1iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUNKQyxvQkFBb0IsRUFDcEJDLGlCQUFpQixFQUNqQkMsb0JBQW9CLEVBQ3JCLEdBQUdILG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFSSxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxhQUFhLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFFL0QsTUFBTVEsYUFBYUMsT0FBTztBQUMxQixNQUFNQyxVQUFVRCxPQUFPO0FBQ3ZCLE1BQU1FLGVBQWVGLE9BQU87QUFDNUIsTUFBTUcsWUFBWUgsT0FBTztBQUN6QixNQUFNSSx1QkFBdUJKLE9BQU87QUFFcEMsTUFBTUssdUJBQXVCZjtJQUMzQmdCLGFBQWU7UUFDYixLQUFLO1FBRUwsSUFBSSxDQUFDUCxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDRyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDRCxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDRSxVQUFVLEdBQUcsRUFBRTtJQUN0QjtJQUVBLElBQUlJLFlBQWE7UUFDZixPQUFPLElBQUksQ0FBQ1IsV0FBVztJQUN6QjtJQUVBLElBQUlTLFNBQVU7UUFDWixPQUFPLElBQUksQ0FBQ1AsUUFBUTtJQUN0QjtJQUVBLElBQUlRLGVBQWdCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDWCxjQUFjO0lBQzVCO0lBRUEsSUFBSVcsYUFBY0MsZUFBZSxFQUFFO1FBQ2pDLElBQUlBLGlCQUFpQjtZQUNuQixJQUFLLElBQUlDLElBQUlELGdCQUFnQkUsTUFBTSxHQUFHLEdBQUdELEtBQUssR0FBR0EsSUFBSztnQkFDcEQsTUFBTUUsY0FBYyxJQUFJLENBQUNmLGNBQWMsQ0FBQ2EsRUFBRTtnQkFDMUMsSUFBSSxPQUFPRSxnQkFBZ0IsWUFBWTtvQkFDckMsTUFBTSxJQUFJ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LENBQUNiO1lBRWhCLE9BQU87UUFDVDtJQUNGO0FBQ0Y7QUFFQWMsT0FBT0MsT0FBTyxHQUFHOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXItYmFzZS5qcz8xODZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyJylcbmNvbnN0IHtcbiAgQ2xpZW50RGVzdHJveWVkRXJyb3IsXG4gIENsaWVudENsb3NlZEVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvclxufSA9IHJlcXVpcmUoJy4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBrRGVzdHJveSwga0Nsb3NlLCBrRGlzcGF0Y2gsIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4vY29yZS9zeW1ib2xzJylcblxuY29uc3Qga0Rlc3Ryb3llZCA9IFN5bWJvbCgnZGVzdHJveWVkJylcbmNvbnN0IGtDbG9zZWQgPSBTeW1ib2woJ2Nsb3NlZCcpXG5jb25zdCBrT25EZXN0cm95ZWQgPSBTeW1ib2woJ29uRGVzdHJveWVkJylcbmNvbnN0IGtPbkNsb3NlZCA9IFN5bWJvbCgnb25DbG9zZWQnKVxuY29uc3Qga0ludGVyY2VwdGVkRGlzcGF0Y2ggPSBTeW1ib2woJ0ludGVyY2VwdGVkIERpc3BhdGNoJylcblxuY2xhc3MgRGlzcGF0Y2hlckJhc2UgZXh0ZW5kcyBEaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXNba0Rlc3Ryb3llZF0gPSBmYWxzZVxuICAgIHRoaXNba09uRGVzdHJveWVkXSA9IG51bGxcbiAgICB0aGlzW2tDbG9zZWRdID0gZmFsc2VcbiAgICB0aGlzW2tPbkNsb3NlZF0gPSBbXVxuICB9XG5cbiAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Rlc3Ryb3llZF1cbiAgfVxuXG4gIGdldCBjbG9zZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tDbG9zZWRdXG4gIH1cblxuICBnZXQgaW50ZXJjZXB0b3JzICgpIHtcbiAgICByZXR1cm4gdGhpc1trSW50ZXJjZXB0b3JzXVxuICB9XG5cbiAgc2V0IGludGVyY2VwdG9ycyAobmV3SW50ZXJjZXB0b3JzKSB7XG4gICAgaWYgKG5ld0ludGVyY2VwdG9ycykge1xuICAgICAgZm9yIChsZXQgaSA9IG5ld0ludGVyY2VwdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvciA9IHRoaXNba0ludGVyY2VwdG9yc11baV1cbiAgICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW50ZXJjZXB0b3IgbXVzdCBiZSBhbiBmdW5jdGlvbicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gbmV3SW50ZXJjZXB0b3JzXG4gIH1cblxuICBjbG9zZSAoY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZSgoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgIH1cblxuICAgIGlmICh0aGlzW2tEZXN0cm95ZWRdKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKSwgbnVsbCkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpc1trQ2xvc2VkXSkge1xuICAgICAgaWYgKHRoaXNba09uQ2xvc2VkXSkge1xuICAgICAgICB0aGlzW2tPbkNsb3NlZF0ucHVzaChjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG51bGwsIG51bGwpKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpc1trQ2xvc2VkXSA9IHRydWVcbiAgICB0aGlzW2tPbkNsb3NlZF0ucHVzaChjYWxsYmFjaylcblxuICAgIGNvbnN0IG9uQ2xvc2VkID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpc1trT25DbG9zZWRdXG4gICAgICB0aGlzW2tPbkNsb3NlZF0gPSBudWxsXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0obnVsbCwgbnVsbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaG91bGQgbm90IGVycm9yLlxuICAgIHRoaXNba0Nsb3NlXSgpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmRlc3Ryb3koKSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2sob25DbG9zZWQpXG4gICAgICB9KVxuICB9XG5cbiAgZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgZXJyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGVyclxuICAgICAgZXJyID0gbnVsbFxuICAgIH1cblxuICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3koZXJyLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVyciA/IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgbmV2ZXIgZXJyb3IgKi8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0pIHtcbiAgICAgIGlmICh0aGlzW2tPbkRlc3Ryb3llZF0pIHtcbiAgICAgICAgdGhpc1trT25EZXN0cm95ZWRdLnB1c2goY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhudWxsLCBudWxsKSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghZXJyKSB7XG4gICAgICBlcnIgPSBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKVxuICAgIH1cblxuICAgIHRoaXNba0Rlc3Ryb3llZF0gPSB0cnVlXG4gICAgdGhpc1trT25EZXN0cm95ZWRdID0gdGhpc1trT25EZXN0cm95ZWRdIHx8IFtdXG4gICAgdGhpc1trT25EZXN0cm95ZWRdLnB1c2goY2FsbGJhY2spXG5cbiAgICBjb25zdCBvbkRlc3Ryb3llZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXNba09uRGVzdHJveWVkXVxuICAgICAgdGhpc1trT25EZXN0cm95ZWRdID0gbnVsbFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldKG51bGwsIG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2hvdWxkIG5vdCBlcnJvci5cbiAgICB0aGlzW2tEZXN0cm95XShlcnIpLnRoZW4oKCkgPT4ge1xuICAgICAgcXVldWVNaWNyb3Rhc2sob25EZXN0cm95ZWQpXG4gICAgfSlcbiAgfVxuXG4gIFtrSW50ZXJjZXB0ZWREaXNwYXRjaF0gKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXNba0ludGVyY2VwdG9yc10gfHwgdGhpc1trSW50ZXJjZXB0b3JzXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXNba0ludGVyY2VwdGVkRGlzcGF0Y2hdID0gdGhpc1trRGlzcGF0Y2hdXG4gICAgICByZXR1cm4gdGhpc1trRGlzcGF0Y2hdKG9wdHMsIGhhbmRsZXIpXG4gICAgfVxuXG4gICAgbGV0IGRpc3BhdGNoID0gdGhpc1trRGlzcGF0Y2hdLmJpbmQodGhpcylcbiAgICBmb3IgKGxldCBpID0gdGhpc1trSW50ZXJjZXB0b3JzXS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgZGlzcGF0Y2ggPSB0aGlzW2tJbnRlcmNlcHRvcnNdW2ldKGRpc3BhdGNoKVxuICAgIH1cbiAgICB0aGlzW2tJbnRlcmNlcHRlZERpc3BhdGNoXSA9IGRpc3BhdGNoXG4gICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlciB8fCB0eXBlb2YgaGFuZGxlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGFuZGxlciBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzIG11c3QgYmUgYW4gb2JqZWN0LicpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2tEZXN0cm95ZWRdIHx8IHRoaXNba09uRGVzdHJveWVkXSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1trQ2xvc2VkXSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2xpZW50Q2xvc2VkRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1trSW50ZXJjZXB0ZWREaXNwYXRjaF0ob3B0cywgaGFuZGxlcilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkVycm9yIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGhhbmRsZXIub25FcnJvcihlcnIpXG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXJCYXNlXG4iXSwibmFtZXMiOlsiRGlzcGF0Y2hlciIsInJlcXVpcmUiLCJDbGllbnREZXN0cm95ZWRFcnJvciIsIkNsaWVudENsb3NlZEVycm9yIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJrRGVzdHJveSIsImtDbG9zZSIsImtEaXNwYXRjaCIsImtJbnRlcmNlcHRvcnMiLCJrRGVzdHJveWVkIiwiU3ltYm9sIiwia0Nsb3NlZCIsImtPbkRlc3Ryb3llZCIsImtPbkNsb3NlZCIsImtJbnRlcmNlcHRlZERpc3BhdGNoIiwiRGlzcGF0Y2hlckJhc2UiLCJjb25zdHJ1Y3RvciIsImRlc3Ryb3llZCIsImNsb3NlZCIsImludGVyY2VwdG9ycyIsIm5ld0ludGVyY2VwdG9ycyIsImkiLCJsZW5ndGgiLCJpbnRlcmNlcHRvciIsImNsb3NlIiwiY2FsbGJhY2siLCJ1bmRlZmluZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVyciIsImRhdGEiLCJxdWV1ZU1pY3JvdGFzayIsInB1c2giLCJvbkNsb3NlZCIsImNhbGxiYWNrcyIsInRoZW4iLCJkZXN0cm95Iiwib25EZXN0cm95ZWQiLCJvcHRzIiwiaGFuZGxlciIsImRpc3BhdGNoIiwiYmluZCIsIm9uRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/dispatcher-base.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/dispatcher.js":
/*!***************************************************!*\
  !*** ../../node_modules/undici/lib/dispatcher.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nclass Dispatcher extends EventEmitter {\n    dispatch() {\n        throw new Error(\"not implemented\");\n    }\n    close() {\n        throw new Error(\"not implemented\");\n    }\n    destroy() {\n        throw new Error(\"not implemented\");\n    }\n}\nmodule.exports = Dispatcher;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGVBQWVDLG1CQUFPQSxDQUFDO0FBRTdCLE1BQU1DLG1CQUFtQkY7SUFDdkJHLFdBQVk7UUFDVixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQUMsUUFBUztRQUNQLE1BQU0sSUFBSUQsTUFBTTtJQUNsQjtJQUVBRSxVQUFXO1FBQ1QsTUFBTSxJQUFJRixNQUFNO0lBQ2xCO0FBQ0Y7QUFFQUcsT0FBT0MsT0FBTyxHQUFHTiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci5qcz83NmQ5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKVxuXG5jbGFzcyBEaXNwYXRjaGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgZGlzcGF0Y2ggKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaXNwYXRjaGVyXG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsIkRpc3BhdGNoZXIiLCJkaXNwYXRjaCIsIkVycm9yIiwiY2xvc2UiLCJkZXN0cm95IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/dispatcher.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/body.js":
/*!***************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/body.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Busboy = __webpack_require__(/*! @fastify/busboy */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/main.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { ReadableStreamFrom, isBlobLike, isReadableStreamLike, readableStreamClose, createDeferredPromise, fullyReadBody } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/fetch/util.js\");\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(rsc)/../../node_modules/undici/lib/fetch/formdata.js\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst { DOMException, structuredClone } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/undici/lib/fetch/constants.js\");\nconst { Blob, File: NativeFile } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { isErrored } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { isUint8Array, isArrayBuffer } = __webpack_require__(/*! util/types */ \"util/types\");\nconst { File: UndiciFile } = __webpack_require__(/*! ./file */ \"(rsc)/../../node_modules/undici/lib/fetch/file.js\");\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./dataURL */ \"(rsc)/../../node_modules/undici/lib/fetch/dataURL.js\");\nlet ReadableStream = globalThis.ReadableStream;\n/** @type {globalThis['File']} */ const File = NativeFile ?? UndiciFile;\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody(object, keepalive = false) {\n    if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    // 1. Let stream be null.\n    let stream = null;\n    // 2. If object is a ReadableStream object, then set stream to object.\n    if (object instanceof ReadableStream) {\n        stream = object;\n    } else if (isBlobLike(object)) {\n        // 3. Otherwise, if object is a Blob object, set stream to the\n        //    result of running objects get stream.\n        stream = object.stream();\n    } else {\n        // 4. Otherwise, set stream to a new ReadableStream object, and set\n        //    up stream.\n        stream = new ReadableStream({\n            async pull (controller) {\n                controller.enqueue(typeof source === \"string\" ? textEncoder.encode(source) : source);\n                queueMicrotask(()=>readableStreamClose(controller));\n            },\n            start () {},\n            type: undefined\n        });\n    }\n    // 5. Assert: stream is a ReadableStream object.\n    assert(isReadableStreamLike(stream));\n    // 6. Let action be null.\n    let action = null;\n    // 7. Let source be null.\n    let source = null;\n    // 8. Let length be null.\n    let length = null;\n    // 9. Let type be null.\n    let type = null;\n    // 10. Switch on object:\n    if (typeof object === \"string\") {\n        // Set source to the UTF-8 encoding of object.\n        // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n        source = object;\n        // Set type to `text/plain;charset=UTF-8`.\n        type = \"text/plain;charset=UTF-8\";\n    } else if (object instanceof URLSearchParams) {\n        // URLSearchParams\n        // spec says to run application/x-www-form-urlencoded on body.list\n        // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n        // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n        // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n        // Set source to the result of running the application/x-www-form-urlencoded serializer with objects list.\n        source = object.toString();\n        // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n        type = \"application/x-www-form-urlencoded;charset=UTF-8\";\n    } else if (isArrayBuffer(object)) {\n        // BufferSource/ArrayBuffer\n        // Set source to a copy of the bytes held by object.\n        source = new Uint8Array(object.slice());\n    } else if (ArrayBuffer.isView(object)) {\n        // BufferSource/ArrayBufferView\n        // Set source to a copy of the bytes held by object.\n        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n    } else if (util.isFormDataLike(object)) {\n        const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, \"0\")}`;\n        const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n        /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */ const escape = (str)=>str.replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\");\n        const normalizeLinefeeds = (value)=>value.replace(/\\r?\\n|\\r/g, \"\\r\\n\");\n        // Set action to this step: run the multipart/form-data\n        // encoding algorithm, with objects entry list and UTF-8.\n        // - This ensures that the body is immutable and can't be changed afterwords\n        // - That the content-length is calculated in advance.\n        // - And that all parts are pre-encoded and ready to be sent.\n        const blobParts = [];\n        const rn = new Uint8Array([\n            13,\n            10\n        ]) // '\\r\\n'\n        ;\n        length = 0;\n        let hasUnknownSizeValue = false;\n        for (const [name, value] of object){\n            if (typeof value === \"string\") {\n                const chunk = textEncoder.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n                blobParts.push(chunk);\n                length += chunk.byteLength;\n            } else {\n                const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : \"\") + \"\\r\\n\" + `Content-Type: ${value.type || \"application/octet-stream\"}\\r\\n\\r\\n`);\n                blobParts.push(chunk, value, rn);\n                if (typeof value.size === \"number\") {\n                    length += chunk.byteLength + value.size + rn.byteLength;\n                } else {\n                    hasUnknownSizeValue = true;\n                }\n            }\n        }\n        const chunk = textEncoder.encode(`--${boundary}--`);\n        blobParts.push(chunk);\n        length += chunk.byteLength;\n        if (hasUnknownSizeValue) {\n            length = null;\n        }\n        // Set source to object.\n        source = object;\n        action = async function*() {\n            for (const part of blobParts){\n                if (part.stream) {\n                    yield* part.stream();\n                } else {\n                    yield part;\n                }\n            }\n        };\n        // Set type to `multipart/form-data; boundary=`,\n        // followed by the multipart/form-data boundary string generated\n        // by the multipart/form-data encoding algorithm.\n        type = \"multipart/form-data; boundary=\" + boundary;\n    } else if (isBlobLike(object)) {\n        // Blob\n        // Set source to object.\n        source = object;\n        // Set length to objects size.\n        length = object.size;\n        // If objects type attribute is not the empty byte sequence, set\n        // type to its value.\n        if (object.type) {\n            type = object.type;\n        }\n    } else if (typeof object[Symbol.asyncIterator] === \"function\") {\n        // If keepalive is true, then throw a TypeError.\n        if (keepalive) {\n            throw new TypeError(\"keepalive\");\n        }\n        // If object is disturbed or locked, then throw a TypeError.\n        if (util.isDisturbed(object) || object.locked) {\n            throw new TypeError(\"Response body object should not be disturbed or locked\");\n        }\n        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n    }\n    // 11. If source is a byte sequence, then set action to a\n    // step that returns source and length to sources length.\n    if (typeof source === \"string\" || util.isBuffer(source)) {\n        length = Buffer.byteLength(source);\n    }\n    // 12. If action is non-null, then run these steps in in parallel:\n    if (action != null) {\n        // Run action.\n        let iterator;\n        stream = new ReadableStream({\n            async start () {\n                iterator = action(object)[Symbol.asyncIterator]();\n            },\n            async pull (controller) {\n                const { value, done } = await iterator.next();\n                if (done) {\n                    // When running action is done, close stream.\n                    queueMicrotask(()=>{\n                        controller.close();\n                    });\n                } else {\n                    // Whenever one or more bytes are available and stream is not errored,\n                    // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n                    // bytes into stream.\n                    if (!isErrored(stream)) {\n                        controller.enqueue(new Uint8Array(value));\n                    }\n                }\n                return controller.desiredSize > 0;\n            },\n            async cancel (reason) {\n                await iterator.return();\n            },\n            type: undefined\n        });\n    }\n    // 13. Let body be a body whose stream is stream, source is source,\n    // and length is length.\n    const body = {\n        stream,\n        source,\n        length\n    };\n    // 14. Return (body, type).\n    return [\n        body,\n        type\n    ];\n}\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody(object, keepalive = false) {\n    if (!ReadableStream) {\n        // istanbul ignore next\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    // To safely extract a body and a `Content-Type` value from\n    // a byte sequence or BodyInit object object, run these steps:\n    // 1. If object is a ReadableStream object, then:\n    if (object instanceof ReadableStream) {\n        // Assert: object is neither disturbed nor locked.\n        // istanbul ignore next\n        assert(!util.isDisturbed(object), \"The body has already been consumed.\");\n        // istanbul ignore next\n        assert(!object.locked, \"The stream is locked.\");\n    }\n    // 2. Return the results of extracting object.\n    return extractBody(object, keepalive);\n}\nfunction cloneBody(body) {\n    // To clone a body body, run these steps:\n    // https://fetch.spec.whatwg.org/#concept-body-clone\n    // 1. Let  out1, out2  be the result of teeing bodys stream.\n    const [out1, out2] = body.stream.tee();\n    const out2Clone = structuredClone(out2, {\n        transfer: [\n            out2\n        ]\n    });\n    // This, for whatever reasons, unrefs out2Clone which allows\n    // the process to exit by itself.\n    const [, finalClone] = out2Clone.tee();\n    // 2. Set bodys stream to out1.\n    body.stream = out1;\n    // 3. Return a body whose stream is out2 and other members are copied from body.\n    return {\n        stream: finalClone,\n        length: body.length,\n        source: body.source\n    };\n}\nasync function* consumeBody(body) {\n    if (body) {\n        if (isUint8Array(body)) {\n            yield body;\n        } else {\n            const stream = body.stream;\n            if (util.isDisturbed(stream)) {\n                throw new TypeError(\"The body has already been consumed.\");\n            }\n            if (stream.locked) {\n                throw new TypeError(\"The stream is locked.\");\n            }\n            // Compat.\n            stream[kBodyUsed] = true;\n            yield* stream;\n        }\n    }\n}\nfunction throwIfAborted(state) {\n    if (state.aborted) {\n        throw new DOMException(\"The operation was aborted.\", \"AbortError\");\n    }\n}\nfunction bodyMixinMethods(instance) {\n    const methods = {\n        blob () {\n            // The blob() method steps are to return the result of\n            // running consume body with this and the following step\n            // given a byte sequence bytes: return a Blob whose\n            // contents are bytes and whose type attribute is thiss\n            // MIME type.\n            return specConsumeBody(this, (bytes)=>{\n                let mimeType = bodyMimeType(this);\n                if (mimeType === \"failure\") {\n                    mimeType = \"\";\n                } else if (mimeType) {\n                    mimeType = serializeAMimeType(mimeType);\n                }\n                // Return a Blob whose contents are bytes and type attribute\n                // is mimeType.\n                return new Blob([\n                    bytes\n                ], {\n                    type: mimeType\n                });\n            }, instance);\n        },\n        arrayBuffer () {\n            // The arrayBuffer() method steps are to return the result\n            // of running consume body with this and the following step\n            // given a byte sequence bytes: return a new ArrayBuffer\n            // whose contents are bytes.\n            return specConsumeBody(this, (bytes)=>{\n                return new Uint8Array(bytes).buffer;\n            }, instance);\n        },\n        text () {\n            // The text() method steps are to return the result of running\n            // consume body with this and UTF-8 decode.\n            return specConsumeBody(this, utf8DecodeBytes, instance);\n        },\n        json () {\n            // The json() method steps are to return the result of running\n            // consume body with this and parse JSON from bytes.\n            return specConsumeBody(this, parseJSONFromBytes, instance);\n        },\n        async formData () {\n            webidl.brandCheck(this, instance);\n            throwIfAborted(this[kState]);\n            const contentType = this.headers.get(\"Content-Type\");\n            // If mimeTypes essence is \"multipart/form-data\", then:\n            if (/multipart\\/form-data/.test(contentType)) {\n                const headers = {};\n                for (const [key, value] of this.headers)headers[key.toLowerCase()] = value;\n                const responseFormData = new FormData();\n                let busboy;\n                try {\n                    busboy = new Busboy({\n                        headers,\n                        preservePath: true\n                    });\n                } catch (err) {\n                    throw new DOMException(`${err}`, \"AbortError\");\n                }\n                busboy.on(\"field\", (name, value)=>{\n                    responseFormData.append(name, value);\n                });\n                busboy.on(\"file\", (name, value, filename, encoding, mimeType)=>{\n                    const chunks = [];\n                    if (encoding === \"base64\" || encoding.toLowerCase() === \"base64\") {\n                        let base64chunk = \"\";\n                        value.on(\"data\", (chunk)=>{\n                            base64chunk += chunk.toString().replace(/[\\r\\n]/gm, \"\");\n                            const end = base64chunk.length - base64chunk.length % 4;\n                            chunks.push(Buffer.from(base64chunk.slice(0, end), \"base64\"));\n                            base64chunk = base64chunk.slice(end);\n                        });\n                        value.on(\"end\", ()=>{\n                            chunks.push(Buffer.from(base64chunk, \"base64\"));\n                            responseFormData.append(name, new File(chunks, filename, {\n                                type: mimeType\n                            }));\n                        });\n                    } else {\n                        value.on(\"data\", (chunk)=>{\n                            chunks.push(chunk);\n                        });\n                        value.on(\"end\", ()=>{\n                            responseFormData.append(name, new File(chunks, filename, {\n                                type: mimeType\n                            }));\n                        });\n                    }\n                });\n                const busboyResolve = new Promise((resolve, reject)=>{\n                    busboy.on(\"finish\", resolve);\n                    busboy.on(\"error\", (err)=>reject(new TypeError(err)));\n                });\n                if (this.body !== null) for await (const chunk of consumeBody(this[kState].body))busboy.write(chunk);\n                busboy.end();\n                await busboyResolve;\n                return responseFormData;\n            } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n                // Otherwise, if mimeTypes essence is \"application/x-www-form-urlencoded\", then:\n                // 1. Let entries be the result of parsing bytes.\n                let entries;\n                try {\n                    let text = \"\";\n                    // application/x-www-form-urlencoded parser will keep the BOM.\n                    // https://url.spec.whatwg.org/#concept-urlencoded-parser\n                    // Note that streaming decoder is stateful and cannot be reused\n                    const streamingDecoder = new TextDecoder(\"utf-8\", {\n                        ignoreBOM: true\n                    });\n                    for await (const chunk of consumeBody(this[kState].body)){\n                        if (!isUint8Array(chunk)) {\n                            throw new TypeError(\"Expected Uint8Array chunk\");\n                        }\n                        text += streamingDecoder.decode(chunk, {\n                            stream: true\n                        });\n                    }\n                    text += streamingDecoder.decode();\n                    entries = new URLSearchParams(text);\n                } catch (err) {\n                    // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n                    // 2. If entries is failure, then throw a TypeError.\n                    throw Object.assign(new TypeError(), {\n                        cause: err\n                    });\n                }\n                // 3. Return a new FormData object whose entries are entries.\n                const formData = new FormData();\n                for (const [name, value] of entries){\n                    formData.append(name, value);\n                }\n                return formData;\n            } else {\n                // Wait a tick before checking if the request has been aborted.\n                // Otherwise, a TypeError can be thrown when an AbortError should.\n                await Promise.resolve();\n                throwIfAborted(this[kState]);\n                // Otherwise, throw a TypeError.\n                throw webidl.errors.exception({\n                    header: `${instance.name}.formData`,\n                    message: \"Could not parse content as FormData.\"\n                });\n            }\n        }\n    };\n    return methods;\n}\nfunction mixinBody(prototype) {\n    Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */ async function specConsumeBody(object, convertBytesToJSValue, instance) {\n    webidl.brandCheck(object, instance);\n    throwIfAborted(object[kState]);\n    // 1. If object is unusable, then return a promise rejected\n    //    with a TypeError.\n    if (bodyUnusable(object[kState].body)) {\n        throw new TypeError(\"Body is unusable\");\n    }\n    // 2. Let promise be a new promise.\n    const promise = createDeferredPromise();\n    // 3. Let errorSteps given error be to reject promise with error.\n    const errorSteps = (error)=>promise.reject(error);\n    // 4. Let successSteps given a byte sequence data be to resolve\n    //    promise with the result of running convertBytesToJSValue\n    //    with data. If that threw an exception, then run errorSteps\n    //    with that exception.\n    const successSteps = (data)=>{\n        try {\n            promise.resolve(convertBytesToJSValue(data));\n        } catch (e) {\n            errorSteps(e);\n        }\n    };\n    // 5. If objects body is null, then run successSteps with an\n    //    empty byte sequence.\n    if (object[kState].body == null) {\n        successSteps(new Uint8Array());\n        return promise.promise;\n    }\n    // 6. Otherwise, fully read objects body given successSteps,\n    //    errorSteps, and objects relevant global object.\n    await fullyReadBody(object[kState].body, successSteps, errorSteps);\n    // 7. Return promise.\n    return promise.promise;\n}\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable(body) {\n    // An object including the Body interface mixin is\n    // said to be unusable if its body is non-null and\n    // its bodys stream is disturbed or locked.\n    return body != null && (body.stream.locked || util.isDisturbed(body.stream));\n}\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */ function utf8DecodeBytes(buffer) {\n    if (buffer.length === 0) {\n        return \"\";\n    }\n    // 1. Let buffer be the result of peeking three bytes from\n    //    ioQueue, converted to a byte sequence.\n    // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n    //    bytes from ioQueue. (Do nothing with those bytes.)\n    if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n        buffer = buffer.subarray(3);\n    }\n    // 3. Process a queue with an instance of UTF-8s\n    //    decoder, ioQueue, output, and \"replacement\".\n    const output = textDecoder.decode(buffer);\n    // 4. Return output.\n    return output;\n}\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */ function parseJSONFromBytes(bytes) {\n    return JSON.parse(utf8DecodeBytes(bytes));\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} object\n */ function bodyMimeType(object) {\n    const { headersList } = object[kState];\n    const contentType = headersList.get(\"content-type\");\n    if (contentType === null) {\n        return \"failure\";\n    }\n    return parseMIMEType(contentType);\n}\nmodule.exports = {\n    extractBody,\n    safelyExtractBody,\n    cloneBody,\n    mixinBody\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvYm9keS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFDSkUsa0JBQWtCLEVBQ2xCQyxVQUFVLEVBQ1ZDLG9CQUFvQixFQUNwQkMsbUJBQW1CLEVBQ25CQyxxQkFBcUIsRUFDckJDLGFBQWEsRUFDZCxHQUFHUCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRVEsUUFBUSxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU0sRUFBRVMsTUFBTSxFQUFFLEdBQUdULG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRVUsTUFBTSxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRVcsWUFBWSxFQUFFQyxlQUFlLEVBQUUsR0FBR1osbUJBQU9BLENBQUM7QUFDbEQsTUFBTSxFQUFFYSxJQUFJLEVBQUVDLE1BQU1DLFVBQVUsRUFBRSxHQUFHZixtQkFBT0EsQ0FBQztBQUMzQyxNQUFNLEVBQUVnQixTQUFTLEVBQUUsR0FBR2hCLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1pQixTQUFTakIsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFa0IsU0FBUyxFQUFFLEdBQUdsQixtQkFBT0EsQ0FBQztBQUM5QixNQUFNLEVBQUVtQixZQUFZLEVBQUVDLGFBQWEsRUFBRSxHQUFHcEIsbUJBQU9BLENBQUM7QUFDaEQsTUFBTSxFQUFFYyxNQUFNTyxVQUFVLEVBQUUsR0FBR3JCLG1CQUFPQSxDQUFDO0FBQ3JDLE1BQU0sRUFBRXNCLGFBQWEsRUFBRUMsa0JBQWtCLEVBQUUsR0FBR3ZCLG1CQUFPQSxDQUFDO0FBRXRELElBQUl3QixpQkFBaUJDLFdBQVdELGNBQWM7QUFFOUMsK0JBQStCLEdBQy9CLE1BQU1WLE9BQU9DLGNBQWNNO0FBQzNCLE1BQU1LLGNBQWMsSUFBSUM7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TTtJQUMzQixNQUFNLEVBQUVzSSxXQUFXLEVBQUUsR0FBR3RJLE1BQU0sQ0FBQ3RCLE9BQU87SUFDdEMsTUFBTTRHLGNBQWNnRCxZQUFZOUMsR0FBRyxDQUFDO0lBRXBDLElBQUlGLGdCQUFnQixNQUFNO1FBQ3hCLE9BQU87SUFDVDtJQUVBLE9BQU8vRixjQUFjK0Y7QUFDdkI7QUFFQWlELE9BQU9DLE9BQU8sR0FBRztJQUNmekk7SUFDQTREO0lBQ0FDO0lBQ0E0RDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9ib2R5LmpzP2UxOTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJ1c2JveSA9IHJlcXVpcmUoJ0BmYXN0aWZ5L2J1c2JveScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHtcbiAgUmVhZGFibGVTdHJlYW1Gcm9tLFxuICBpc0Jsb2JMaWtlLFxuICBpc1JlYWRhYmxlU3RyZWFtTGlrZSxcbiAgcmVhZGFibGVTdHJlYW1DbG9zZSxcbiAgY3JlYXRlRGVmZXJyZWRQcm9taXNlLFxuICBmdWxseVJlYWRCb2R5XG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgRm9ybURhdGEgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEnKVxuY29uc3QgeyBrU3RhdGUgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBET01FeGNlcHRpb24sIHN0cnVjdHVyZWRDbG9uZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBCbG9iLCBGaWxlOiBOYXRpdmVGaWxlIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyBrQm9keVVzZWQgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBpc0Vycm9yZWQgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGlzVWludDhBcnJheSwgaXNBcnJheUJ1ZmZlciB9ID0gcmVxdWlyZSgndXRpbC90eXBlcycpXG5jb25zdCB7IEZpbGU6IFVuZGljaUZpbGUgfSA9IHJlcXVpcmUoJy4vZmlsZScpXG5jb25zdCB7IHBhcnNlTUlNRVR5cGUsIHNlcmlhbGl6ZUFNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhVVJMJylcblxubGV0IFJlYWRhYmxlU3RyZWFtID0gZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbVxuXG4vKiogQHR5cGUge2dsb2JhbFRoaXNbJ0ZpbGUnXX0gKi9cbmNvbnN0IEZpbGUgPSBOYXRpdmVGaWxlID8/IFVuZGljaUZpbGVcbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuZnVuY3Rpb24gZXh0cmFjdEJvZHkgKG9iamVjdCwga2VlcGFsaXZlID0gZmFsc2UpIHtcbiAgaWYgKCFSZWFkYWJsZVN0cmVhbSkge1xuICAgIFJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtL3dlYicpLlJlYWRhYmxlU3RyZWFtXG4gIH1cblxuICAvLyAxLiBMZXQgc3RyZWFtIGJlIG51bGwuXG4gIGxldCBzdHJlYW0gPSBudWxsXG5cbiAgLy8gMi4gSWYgb2JqZWN0IGlzIGEgUmVhZGFibGVTdHJlYW0gb2JqZWN0LCB0aGVuIHNldCBzdHJlYW0gdG8gb2JqZWN0LlxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICBzdHJlYW0gPSBvYmplY3RcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKG9iamVjdCkpIHtcbiAgICAvLyAzLiBPdGhlcndpc2UsIGlmIG9iamVjdCBpcyBhIEJsb2Igb2JqZWN0LCBzZXQgc3RyZWFtIHRvIHRoZVxuICAgIC8vICAgIHJlc3VsdCBvZiBydW5uaW5nIG9iamVjdOKAmXMgZ2V0IHN0cmVhbS5cbiAgICBzdHJlYW0gPSBvYmplY3Quc3RyZWFtKClcbiAgfSBlbHNlIHtcbiAgICAvLyA0LiBPdGhlcndpc2UsIHNldCBzdHJlYW0gdG8gYSBuZXcgUmVhZGFibGVTdHJlYW0gb2JqZWN0LCBhbmQgc2V0XG4gICAgLy8gICAgdXAgc3RyZWFtLlxuICAgIHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBhc3luYyBwdWxsIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHRleHRFbmNvZGVyLmVuY29kZShzb3VyY2UpIDogc291cmNlXG4gICAgICAgIClcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcmVhZGFibGVTdHJlYW1DbG9zZShjb250cm9sbGVyKSlcbiAgICAgIH0sXG4gICAgICBzdGFydCAoKSB7fSxcbiAgICAgIHR5cGU6IHVuZGVmaW5lZFxuICAgIH0pXG4gIH1cblxuICAvLyA1LiBBc3NlcnQ6IHN0cmVhbSBpcyBhIFJlYWRhYmxlU3RyZWFtIG9iamVjdC5cbiAgYXNzZXJ0KGlzUmVhZGFibGVTdHJlYW1MaWtlKHN0cmVhbSkpXG5cbiAgLy8gNi4gTGV0IGFjdGlvbiBiZSBudWxsLlxuICBsZXQgYWN0aW9uID0gbnVsbFxuXG4gIC8vIDcuIExldCBzb3VyY2UgYmUgbnVsbC5cbiAgbGV0IHNvdXJjZSA9IG51bGxcblxuICAvLyA4LiBMZXQgbGVuZ3RoIGJlIG51bGwuXG4gIGxldCBsZW5ndGggPSBudWxsXG5cbiAgLy8gOS4gTGV0IHR5cGUgYmUgbnVsbC5cbiAgbGV0IHR5cGUgPSBudWxsXG5cbiAgLy8gMTAuIFN3aXRjaCBvbiBvYmplY3Q6XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIFNldCBzb3VyY2UgdG8gdGhlIFVURi04IGVuY29kaW5nIG9mIG9iamVjdC5cbiAgICAvLyBOb3RlOiBzZXR0aW5nIHNvdXJjZSB0byBhIFVpbnQ4QXJyYXkgaGVyZSBicmVha3Mgc29tZSBtb2NraW5nIGFzc3VtcHRpb25zLlxuICAgIHNvdXJjZSA9IG9iamVjdFxuXG4gICAgLy8gU2V0IHR5cGUgdG8gYHRleHQvcGxhaW47Y2hhcnNldD1VVEYtOGAuXG4gICAgdHlwZSA9ICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnXG4gIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgLy8gVVJMU2VhcmNoUGFyYW1zXG5cbiAgICAvLyBzcGVjIHNheXMgdG8gcnVuIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBvbiBib2R5Lmxpc3RcbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGluIE5vZGUuanMgYXMgYXBhcnQgb2YgYW4gVVJMU2VhcmNoUGFyYW1zIGluc3RhbmNlIHRvU3RyaW5nIG1ldGhvZFxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZTQ2YzY4MGJmMmIyMTFiYmQ1MmNmOTU5Y2ExN2VlOThjN2Y2NTdmNS9saWIvaW50ZXJuYWwvdXJsLmpzI0w0OTBcbiAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZTQ2YzY4MGJmMmIyMTFiYmQ1MmNmOTU5Y2ExN2VlOThjN2Y2NTdmNS9saWIvaW50ZXJuYWwvdXJsLmpzI0wxMTAwXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGUgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIHNlcmlhbGl6ZXIgd2l0aCBvYmplY3TigJlzIGxpc3QuXG4gICAgc291cmNlID0gb2JqZWN0LnRvU3RyaW5nKClcblxuICAgIC8vIFNldCB0eXBlIHRvIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOGAuXG4gICAgdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCdcbiAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKG9iamVjdCkpIHtcbiAgICAvLyBCdWZmZXJTb3VyY2UvQXJyYXlCdWZmZXJcblxuICAgIC8vIFNldCBzb3VyY2UgdG8gYSBjb3B5IG9mIHRoZSBieXRlcyBoZWxkIGJ5IG9iamVjdC5cbiAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShvYmplY3Quc2xpY2UoKSlcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqZWN0KSkge1xuICAgIC8vIEJ1ZmZlclNvdXJjZS9BcnJheUJ1ZmZlclZpZXdcblxuICAgIC8vIFNldCBzb3VyY2UgdG8gYSBjb3B5IG9mIHRoZSBieXRlcyBoZWxkIGJ5IG9iamVjdC5cbiAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShvYmplY3QuYnVmZmVyLnNsaWNlKG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QuYnl0ZU9mZnNldCArIG9iamVjdC5ieXRlTGVuZ3RoKSlcbiAgfSBlbHNlIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKG9iamVjdCkpIHtcbiAgICBjb25zdCBib3VuZGFyeSA9IGAtLS0tZm9ybWRhdGEtdW5kaWNpLTAke2Ake01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMTEpfWAucGFkU3RhcnQoMTEsICcwJyl9YFxuICAgIGNvbnN0IHByZWZpeCA9IGAtLSR7Ym91bmRhcnl9XFxyXFxuQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhYFxuXG4gICAgLyohIGZvcm1kYXRhLXBvbHlmaWxsLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL1xuICAgIGNvbnN0IGVzY2FwZSA9IChzdHIpID0+XG4gICAgICBzdHIucmVwbGFjZSgvXFxuL2csICclMEEnKS5yZXBsYWNlKC9cXHIvZywgJyUwRCcpLnJlcGxhY2UoL1wiL2csICclMjInKVxuICAgIGNvbnN0IG5vcm1hbGl6ZUxpbmVmZWVkcyA9ICh2YWx1ZSkgPT4gdmFsdWUucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgJ1xcclxcbicpXG5cbiAgICAvLyBTZXQgYWN0aW9uIHRvIHRoaXMgc3RlcDogcnVuIHRoZSBtdWx0aXBhcnQvZm9ybS1kYXRhXG4gICAgLy8gZW5jb2RpbmcgYWxnb3JpdGhtLCB3aXRoIG9iamVjdOKAmXMgZW50cnkgbGlzdCBhbmQgVVRGLTguXG4gICAgLy8gLSBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgYm9keSBpcyBpbW11dGFibGUgYW5kIGNhbid0IGJlIGNoYW5nZWQgYWZ0ZXJ3b3Jkc1xuICAgIC8vIC0gVGhhdCB0aGUgY29udGVudC1sZW5ndGggaXMgY2FsY3VsYXRlZCBpbiBhZHZhbmNlLlxuICAgIC8vIC0gQW5kIHRoYXQgYWxsIHBhcnRzIGFyZSBwcmUtZW5jb2RlZCBhbmQgcmVhZHkgdG8gYmUgc2VudC5cblxuICAgIGNvbnN0IGJsb2JQYXJ0cyA9IFtdXG4gICAgY29uc3Qgcm4gPSBuZXcgVWludDhBcnJheShbMTMsIDEwXSkgLy8gJ1xcclxcbidcbiAgICBsZW5ndGggPSAwXG4gICAgbGV0IGhhc1Vua25vd25TaXplVmFsdWUgPSBmYWxzZVxuXG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIG9iamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUocHJlZml4ICtcbiAgICAgICAgICBgOyBuYW1lPVwiJHtlc2NhcGUobm9ybWFsaXplTGluZWZlZWRzKG5hbWUpKX1cImAgK1xuICAgICAgICAgIGBcXHJcXG5cXHJcXG4ke25vcm1hbGl6ZUxpbmVmZWVkcyh2YWx1ZSl9XFxyXFxuYClcbiAgICAgICAgYmxvYlBhcnRzLnB1c2goY2h1bmspXG4gICAgICAgIGxlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaHVuayA9IHRleHRFbmNvZGVyLmVuY29kZShgJHtwcmVmaXh9OyBuYW1lPVwiJHtlc2NhcGUobm9ybWFsaXplTGluZWZlZWRzKG5hbWUpKX1cImAgK1xuICAgICAgICAgICh2YWx1ZS5uYW1lID8gYDsgZmlsZW5hbWU9XCIke2VzY2FwZSh2YWx1ZS5uYW1lKX1cImAgOiAnJykgKyAnXFxyXFxuJyArXG4gICAgICAgICAgYENvbnRlbnQtVHlwZTogJHtcbiAgICAgICAgICAgIHZhbHVlLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuYClcbiAgICAgICAgYmxvYlBhcnRzLnB1c2goY2h1bmssIHZhbHVlLCBybilcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGxlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoICsgdmFsdWUuc2l6ZSArIHJuLmJ5dGVMZW5ndGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNVbmtub3duU2l6ZVZhbHVlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYC0tJHtib3VuZGFyeX0tLWApXG4gICAgYmxvYlBhcnRzLnB1c2goY2h1bmspXG4gICAgbGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGhcbiAgICBpZiAoaGFzVW5rbm93blNpemVWYWx1ZSkge1xuICAgICAgbGVuZ3RoID0gbnVsbFxuICAgIH1cblxuICAgIC8vIFNldCBzb3VyY2UgdG8gb2JqZWN0LlxuICAgIHNvdXJjZSA9IG9iamVjdFxuXG4gICAgYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgYmxvYlBhcnRzKSB7XG4gICAgICAgIGlmIChwYXJ0LnN0cmVhbSkge1xuICAgICAgICAgIHlpZWxkICogcGFydC5zdHJlYW0oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHBhcnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB0eXBlIHRvIGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT1gLFxuICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSBtdWx0aXBhcnQvZm9ybS1kYXRhIGJvdW5kYXJ5IHN0cmluZyBnZW5lcmF0ZWRcbiAgICAvLyBieSB0aGUgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBlbmNvZGluZyBhbGdvcml0aG0uXG4gICAgdHlwZSA9ICdtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0nICsgYm91bmRhcnlcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKG9iamVjdCkpIHtcbiAgICAvLyBCbG9iXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIG9iamVjdC5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIC8vIFNldCBsZW5ndGggdG8gb2JqZWN04oCZcyBzaXplLlxuICAgIGxlbmd0aCA9IG9iamVjdC5zaXplXG5cbiAgICAvLyBJZiBvYmplY3TigJlzIHR5cGUgYXR0cmlidXRlIGlzIG5vdCB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSwgc2V0XG4gICAgLy8gdHlwZSB0byBpdHMgdmFsdWUuXG4gICAgaWYgKG9iamVjdC50eXBlKSB7XG4gICAgICB0eXBlID0gb2JqZWN0LnR5cGVcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiBrZWVwYWxpdmUgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoa2VlcGFsaXZlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZWVwYWxpdmUnKVxuICAgIH1cblxuICAgIC8vIElmIG9iamVjdCBpcyBkaXN0dXJiZWQgb3IgbG9ja2VkLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh1dGlsLmlzRGlzdHVyYmVkKG9iamVjdCkgfHwgb2JqZWN0LmxvY2tlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1Jlc3BvbnNlIGJvZHkgb2JqZWN0IHNob3VsZCBub3QgYmUgZGlzdHVyYmVkIG9yIGxvY2tlZCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBzdHJlYW0gPVxuICAgICAgb2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gPyBvYmplY3QgOiBSZWFkYWJsZVN0cmVhbUZyb20ob2JqZWN0KVxuICB9XG5cbiAgLy8gMTEuIElmIHNvdXJjZSBpcyBhIGJ5dGUgc2VxdWVuY2UsIHRoZW4gc2V0IGFjdGlvbiB0byBhXG4gIC8vIHN0ZXAgdGhhdCByZXR1cm5zIHNvdXJjZSBhbmQgbGVuZ3RoIHRvIHNvdXJjZeKAmXMgbGVuZ3RoLlxuICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgfHwgdXRpbC5pc0J1ZmZlcihzb3VyY2UpKSB7XG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc291cmNlKVxuICB9XG5cbiAgLy8gMTIuIElmIGFjdGlvbiBpcyBub24tbnVsbCwgdGhlbiBydW4gdGhlc2Ugc3RlcHMgaW4gaW4gcGFyYWxsZWw6XG4gIGlmIChhY3Rpb24gIT0gbnVsbCkge1xuICAgIC8vIFJ1biBhY3Rpb24uXG4gICAgbGV0IGl0ZXJhdG9yXG4gICAgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0ICgpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBhY3Rpb24ob2JqZWN0KVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKVxuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgLy8gV2hlbiBydW5uaW5nIGFjdGlvbiBpcyBkb25lLCBjbG9zZSBzdHJlYW0uXG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuZXZlciBvbmUgb3IgbW9yZSBieXRlcyBhcmUgYXZhaWxhYmxlIGFuZCBzdHJlYW0gaXMgbm90IGVycm9yZWQsXG4gICAgICAgICAgLy8gZW5xdWV1ZSBhIFVpbnQ4QXJyYXkgd3JhcHBpbmcgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyB0aGUgYXZhaWxhYmxlXG4gICAgICAgICAgLy8gYnl0ZXMgaW50byBzdHJlYW0uXG4gICAgICAgICAgaWYgKCFpc0Vycm9yZWQoc3RyZWFtKSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPiAwXG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsIChyZWFzb24pIHtcbiAgICAgICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuKClcbiAgICAgIH0sXG4gICAgICB0eXBlOiB1bmRlZmluZWRcbiAgICB9KVxuICB9XG5cbiAgLy8gMTMuIExldCBib2R5IGJlIGEgYm9keSB3aG9zZSBzdHJlYW0gaXMgc3RyZWFtLCBzb3VyY2UgaXMgc291cmNlLFxuICAvLyBhbmQgbGVuZ3RoIGlzIGxlbmd0aC5cbiAgY29uc3QgYm9keSA9IHsgc3RyZWFtLCBzb3VyY2UsIGxlbmd0aCB9XG5cbiAgLy8gMTQuIFJldHVybiAoYm9keSwgdHlwZSkuXG4gIHJldHVybiBbYm9keSwgdHlwZV1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHlpbml0LXNhZmVseS1leHRyYWN0XG5mdW5jdGlvbiBzYWZlbHlFeHRyYWN0Qm9keSAob2JqZWN0LCBrZWVwYWxpdmUgPSBmYWxzZSkge1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtKSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBSZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbS93ZWInKS5SZWFkYWJsZVN0cmVhbVxuICB9XG5cbiAgLy8gVG8gc2FmZWx5IGV4dHJhY3QgYSBib2R5IGFuZCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb21cbiAgLy8gYSBieXRlIHNlcXVlbmNlIG9yIEJvZHlJbml0IG9iamVjdCBvYmplY3QsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiBvYmplY3QgaXMgYSBSZWFkYWJsZVN0cmVhbSBvYmplY3QsIHRoZW46XG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIC8vIEFzc2VydDogb2JqZWN0IGlzIG5laXRoZXIgZGlzdHVyYmVkIG5vciBsb2NrZWQuXG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBhc3NlcnQoIXV0aWwuaXNEaXN0dXJiZWQob2JqZWN0KSwgJ1RoZSBib2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJylcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIGFzc2VydCghb2JqZWN0LmxvY2tlZCwgJ1RoZSBzdHJlYW0gaXMgbG9ja2VkLicpXG4gIH1cblxuICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgZXh0cmFjdGluZyBvYmplY3QuXG4gIHJldHVybiBleHRyYWN0Qm9keShvYmplY3QsIGtlZXBhbGl2ZSlcbn1cblxuZnVuY3Rpb24gY2xvbmVCb2R5IChib2R5KSB7XG4gIC8vIFRvIGNsb25lIGEgYm9keSBib2R5LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jbG9uZVxuXG4gIC8vIDEuIExldCDCqyBvdXQxLCBvdXQyIMK7IGJlIHRoZSByZXN1bHQgb2YgdGVlaW5nIGJvZHnigJlzIHN0cmVhbS5cbiAgY29uc3QgW291dDEsIG91dDJdID0gYm9keS5zdHJlYW0udGVlKClcbiAgY29uc3Qgb3V0MkNsb25lID0gc3RydWN0dXJlZENsb25lKG91dDIsIHsgdHJhbnNmZXI6IFtvdXQyXSB9KVxuICAvLyBUaGlzLCBmb3Igd2hhdGV2ZXIgcmVhc29ucywgdW5yZWZzIG91dDJDbG9uZSB3aGljaCBhbGxvd3NcbiAgLy8gdGhlIHByb2Nlc3MgdG8gZXhpdCBieSBpdHNlbGYuXG4gIGNvbnN0IFssIGZpbmFsQ2xvbmVdID0gb3V0MkNsb25lLnRlZSgpXG5cbiAgLy8gMi4gU2V0IGJvZHnigJlzIHN0cmVhbSB0byBvdXQxLlxuICBib2R5LnN0cmVhbSA9IG91dDFcblxuICAvLyAzLiBSZXR1cm4gYSBib2R5IHdob3NlIHN0cmVhbSBpcyBvdXQyIGFuZCBvdGhlciBtZW1iZXJzIGFyZSBjb3BpZWQgZnJvbSBib2R5LlxuICByZXR1cm4ge1xuICAgIHN0cmVhbTogZmluYWxDbG9uZSxcbiAgICBsZW5ndGg6IGJvZHkubGVuZ3RoLFxuICAgIHNvdXJjZTogYm9keS5zb3VyY2VcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiAqIGNvbnN1bWVCb2R5IChib2R5KSB7XG4gIGlmIChib2R5KSB7XG4gICAgaWYgKGlzVWludDhBcnJheShib2R5KSkge1xuICAgICAgeWllbGQgYm9keVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBib2R5LnN0cmVhbVxuXG4gICAgICBpZiAodXRpbC5pc0Rpc3R1cmJlZChzdHJlYW0pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBib2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJylcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5sb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBsb2NrZWQuJylcbiAgICAgIH1cblxuICAgICAgLy8gQ29tcGF0LlxuICAgICAgc3RyZWFtW2tCb2R5VXNlZF0gPSB0cnVlXG5cbiAgICAgIHlpZWxkICogc3RyZWFtXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93SWZBYm9ydGVkIChzdGF0ZSkge1xuICBpZiAoc3RhdGUuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvZHlNaXhpbk1ldGhvZHMgKGluc3RhbmNlKSB7XG4gIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgYmxvYiAoKSB7XG4gICAgICAvLyBUaGUgYmxvYigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2ZcbiAgICAgIC8vIHJ1bm5pbmcgY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgdGhlIGZvbGxvd2luZyBzdGVwXG4gICAgICAvLyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgYnl0ZXM6IHJldHVybiBhIEJsb2Igd2hvc2VcbiAgICAgIC8vIGNvbnRlbnRzIGFyZSBieXRlcyBhbmQgd2hvc2UgdHlwZSBhdHRyaWJ1dGUgaXMgdGhpc+KAmXNcbiAgICAgIC8vIE1JTUUgdHlwZS5cbiAgICAgIHJldHVybiBzcGVjQ29uc3VtZUJvZHkodGhpcywgKGJ5dGVzKSA9PiB7XG4gICAgICAgIGxldCBtaW1lVHlwZSA9IGJvZHlNaW1lVHlwZSh0aGlzKVxuXG4gICAgICAgIGlmIChtaW1lVHlwZSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgbWltZVR5cGUgPSAnJ1xuICAgICAgICB9IGVsc2UgaWYgKG1pbWVUeXBlKSB7XG4gICAgICAgICAgbWltZVR5cGUgPSBzZXJpYWxpemVBTWltZVR5cGUobWltZVR5cGUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gYSBCbG9iIHdob3NlIGNvbnRlbnRzIGFyZSBieXRlcyBhbmQgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgLy8gaXMgbWltZVR5cGUuXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbYnl0ZXNdLCB7IHR5cGU6IG1pbWVUeXBlIH0pXG4gICAgICB9LCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgYXJyYXlCdWZmZXIgKCkge1xuICAgICAgLy8gVGhlIGFycmF5QnVmZmVyKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdFxuICAgICAgLy8gb2YgcnVubmluZyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCB0aGUgZm9sbG93aW5nIHN0ZXBcbiAgICAgIC8vIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlczogcmV0dXJuIGEgbmV3IEFycmF5QnVmZmVyXG4gICAgICAvLyB3aG9zZSBjb250ZW50cyBhcmUgYnl0ZXMuXG4gICAgICByZXR1cm4gc3BlY0NvbnN1bWVCb2R5KHRoaXMsIChieXRlcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlclxuICAgICAgfSwgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIHRleHQgKCkge1xuICAgICAgLy8gVGhlIHRleHQoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgIC8vIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIFVURi04IGRlY29kZS5cbiAgICAgIHJldHVybiBzcGVjQ29uc3VtZUJvZHkodGhpcywgdXRmOERlY29kZUJ5dGVzLCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAganNvbiAoKSB7XG4gICAgICAvLyBUaGUganNvbigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAgICAgLy8gY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgcGFyc2UgSlNPTiBmcm9tIGJ5dGVzLlxuICAgICAgcmV0dXJuIHNwZWNDb25zdW1lQm9keSh0aGlzLCBwYXJzZUpTT05Gcm9tQnl0ZXMsIGluc3RhbmNlKVxuICAgIH0sXG5cbiAgICBhc3luYyBmb3JtRGF0YSAoKSB7XG4gICAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBpbnN0YW5jZSlcblxuICAgICAgdGhyb3dJZkFib3J0ZWQodGhpc1trU3RhdGVdKVxuXG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHRoaXMuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpXG5cbiAgICAgIC8vIElmIG1pbWVUeXBl4oCZcyBlc3NlbmNlIGlzIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCB0aGVuOlxuICAgICAgaWYgKC9tdWx0aXBhcnRcXC9mb3JtLWRhdGEvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmhlYWRlcnMpIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWVcblxuICAgICAgICBjb25zdCByZXNwb25zZUZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcblxuICAgICAgICBsZXQgYnVzYm95XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBidXNib3kgPSBuZXcgQnVzYm95KHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBwcmVzZXJ2ZVBhdGg6IHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGAke2Vycn1gLCAnQWJvcnRFcnJvcicpXG4gICAgICAgIH1cblxuICAgICAgICBidXNib3kub24oJ2ZpZWxkJywgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgcmVzcG9uc2VGb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICAgIH0pXG4gICAgICAgIGJ1c2JveS5vbignZmlsZScsIChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUsIGVuY29kaW5nLCBtaW1lVHlwZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNodW5rcyA9IFtdXG5cbiAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnIHx8IGVuY29kaW5nLnRvTG93ZXJDYXNlKCkgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICBsZXQgYmFzZTY0Y2h1bmsgPSAnJ1xuXG4gICAgICAgICAgICB2YWx1ZS5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICBiYXNlNjRjaHVuayArPSBjaHVuay50b1N0cmluZygpLnJlcGxhY2UoL1tcXHJcXG5dL2dtLCAnJylcblxuICAgICAgICAgICAgICBjb25zdCBlbmQgPSBiYXNlNjRjaHVuay5sZW5ndGggLSBiYXNlNjRjaHVuay5sZW5ndGggJSA0XG4gICAgICAgICAgICAgIGNodW5rcy5wdXNoKEJ1ZmZlci5mcm9tKGJhc2U2NGNodW5rLnNsaWNlKDAsIGVuZCksICdiYXNlNjQnKSlcblxuICAgICAgICAgICAgICBiYXNlNjRjaHVuayA9IGJhc2U2NGNodW5rLnNsaWNlKGVuZClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB2YWx1ZS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICBjaHVua3MucHVzaChCdWZmZXIuZnJvbShiYXNlNjRjaHVuaywgJ2Jhc2U2NCcpKVxuICAgICAgICAgICAgICByZXNwb25zZUZvcm1EYXRhLmFwcGVuZChuYW1lLCBuZXcgRmlsZShjaHVua3MsIGZpbGVuYW1lLCB7IHR5cGU6IG1pbWVUeXBlIH0pKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdmFsdWUub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgcmVzcG9uc2VGb3JtRGF0YS5hcHBlbmQobmFtZSwgbmV3IEZpbGUoY2h1bmtzLCBmaWxlbmFtZSwgeyB0eXBlOiBtaW1lVHlwZSB9KSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IGJ1c2JveVJlc29sdmUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgYnVzYm95Lm9uKCdmaW5pc2gnLCByZXNvbHZlKVxuICAgICAgICAgIGJ1c2JveS5vbignZXJyb3InLCAoZXJyKSA9PiByZWplY3QobmV3IFR5cGVFcnJvcihlcnIpKSlcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAodGhpcy5ib2R5ICE9PSBudWxsKSBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVCb2R5KHRoaXNba1N0YXRlXS5ib2R5KSkgYnVzYm95LndyaXRlKGNodW5rKVxuICAgICAgICBidXNib3kuZW5kKClcbiAgICAgICAgYXdhaXQgYnVzYm95UmVzb2x2ZVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZUZvcm1EYXRhXG4gICAgICB9IGVsc2UgaWYgKC9hcHBsaWNhdGlvblxcL3gtd3d3LWZvcm0tdXJsZW5jb2RlZC8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBtaW1lVHlwZeKAmXMgZXNzZW5jZSBpcyBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCB0aGVuOlxuXG4gICAgICAgIC8vIDEuIExldCBlbnRyaWVzIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyBieXRlcy5cbiAgICAgICAgbGV0IGVudHJpZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgdGV4dCA9ICcnXG4gICAgICAgICAgLy8gYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIHBhcnNlciB3aWxsIGtlZXAgdGhlIEJPTS5cbiAgICAgICAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdXJsZW5jb2RlZC1wYXJzZXJcbiAgICAgICAgICAvLyBOb3RlIHRoYXQgc3RyZWFtaW5nIGRlY29kZXIgaXMgc3RhdGVmdWwgYW5kIGNhbm5vdCBiZSByZXVzZWRcbiAgICAgICAgICBjb25zdCBzdHJlYW1pbmdEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgaWdub3JlQk9NOiB0cnVlIH0pXG5cbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVCb2R5KHRoaXNba1N0YXRlXS5ib2R5KSkge1xuICAgICAgICAgICAgaWYgKCFpc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXkgY2h1bmsnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCArPSBzdHJlYW1pbmdEZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dCArPSBzdHJlYW1pbmdEZWNvZGVyLmRlY29kZSgpXG4gICAgICAgICAgZW50cmllcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModGV4dClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IFVuY2xlYXIgd2hlbiBuZXcgVVJMU2VhcmNoUGFyYW1zIGNhbiBmYWlsIG9uIGEgc3RyaW5nLlxuICAgICAgICAgIC8vIDIuIElmIGVudHJpZXMgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBUeXBlRXJyb3IoKSwgeyBjYXVzZTogZXJyIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBSZXR1cm4gYSBuZXcgRm9ybURhdGEgb2JqZWN0IHdob3NlIGVudHJpZXMgYXJlIGVudHJpZXMuXG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1EYXRhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXYWl0IGEgdGljayBiZWZvcmUgY2hlY2tpbmcgaWYgdGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhIFR5cGVFcnJvciBjYW4gYmUgdGhyb3duIHdoZW4gYW4gQWJvcnRFcnJvciBzaG91bGQuXG4gICAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpXG5cbiAgICAgICAgdGhyb3dJZkFib3J0ZWQodGhpc1trU3RhdGVdKVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6IGAke2luc3RhbmNlLm5hbWV9LmZvcm1EYXRhYCxcbiAgICAgICAgICBtZXNzYWdlOiAnQ291bGQgbm90IHBhcnNlIGNvbnRlbnQgYXMgRm9ybURhdGEuJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXRob2RzXG59XG5cbmZ1bmN0aW9uIG1peGluQm9keSAocHJvdG90eXBlKSB7XG4gIE9iamVjdC5hc3NpZ24ocHJvdG90eXBlLnByb3RvdHlwZSwgYm9keU1peGluTWV0aG9kcyhwcm90b3R5cGUpKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jb25zdW1lLWJvZHlcbiAqIEBwYXJhbSB7UmVzcG9uc2V8UmVxdWVzdH0gb2JqZWN0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdW5rbm93bn0gY29udmVydEJ5dGVzVG9KU1ZhbHVlXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfFJlcXVlc3R9IGluc3RhbmNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNwZWNDb25zdW1lQm9keSAob2JqZWN0LCBjb252ZXJ0Qnl0ZXNUb0pTVmFsdWUsIGluc3RhbmNlKSB7XG4gIHdlYmlkbC5icmFuZENoZWNrKG9iamVjdCwgaW5zdGFuY2UpXG5cbiAgdGhyb3dJZkFib3J0ZWQob2JqZWN0W2tTdGF0ZV0pXG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIHVudXNhYmxlLCB0aGVuIHJldHVybiBhIHByb21pc2UgcmVqZWN0ZWRcbiAgLy8gICAgd2l0aCBhIFR5cGVFcnJvci5cbiAgaWYgKGJvZHlVbnVzYWJsZShvYmplY3Rba1N0YXRlXS5ib2R5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgaXMgdW51c2FibGUnKVxuICB9XG5cbiAgLy8gMi4gTGV0IHByb21pc2UgYmUgYSBuZXcgcHJvbWlzZS5cbiAgY29uc3QgcHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgLy8gMy4gTGV0IGVycm9yU3RlcHMgZ2l2ZW4gZXJyb3IgYmUgdG8gcmVqZWN0IHByb21pc2Ugd2l0aCBlcnJvci5cbiAgY29uc3QgZXJyb3JTdGVwcyA9IChlcnJvcikgPT4gcHJvbWlzZS5yZWplY3QoZXJyb3IpXG5cbiAgLy8gNC4gTGV0IHN1Y2Nlc3NTdGVwcyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgZGF0YSBiZSB0byByZXNvbHZlXG4gIC8vICAgIHByb21pc2Ugd2l0aCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgY29udmVydEJ5dGVzVG9KU1ZhbHVlXG4gIC8vICAgIHdpdGggZGF0YS4gSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIHRoZW4gcnVuIGVycm9yU3RlcHNcbiAgLy8gICAgd2l0aCB0aGF0IGV4Y2VwdGlvbi5cbiAgY29uc3Qgc3VjY2Vzc1N0ZXBzID0gKGRhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZS5yZXNvbHZlKGNvbnZlcnRCeXRlc1RvSlNWYWx1ZShkYXRhKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvclN0ZXBzKGUpXG4gICAgfVxuICB9XG5cbiAgLy8gNS4gSWYgb2JqZWN04oCZcyBib2R5IGlzIG51bGwsIHRoZW4gcnVuIHN1Y2Nlc3NTdGVwcyB3aXRoIGFuXG4gIC8vICAgIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gIGlmIChvYmplY3Rba1N0YXRlXS5ib2R5ID09IG51bGwpIHtcbiAgICBzdWNjZXNzU3RlcHMobmV3IFVpbnQ4QXJyYXkoKSlcbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvLyA2LiBPdGhlcndpc2UsIGZ1bGx5IHJlYWQgb2JqZWN04oCZcyBib2R5IGdpdmVuIHN1Y2Nlc3NTdGVwcyxcbiAgLy8gICAgZXJyb3JTdGVwcywgYW5kIG9iamVjdOKAmXMgcmVsZXZhbnQgZ2xvYmFsIG9iamVjdC5cbiAgYXdhaXQgZnVsbHlSZWFkQm9keShvYmplY3Rba1N0YXRlXS5ib2R5LCBzdWNjZXNzU3RlcHMsIGVycm9yU3RlcHMpXG5cbiAgLy8gNy4gUmV0dXJuIHByb21pc2UuXG4gIHJldHVybiBwcm9taXNlLnByb21pc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHktdW51c2FibGVcbmZ1bmN0aW9uIGJvZHlVbnVzYWJsZSAoYm9keSkge1xuICAvLyBBbiBvYmplY3QgaW5jbHVkaW5nIHRoZSBCb2R5IGludGVyZmFjZSBtaXhpbiBpc1xuICAvLyBzYWlkIHRvIGJlIHVudXNhYmxlIGlmIGl0cyBib2R5IGlzIG5vbi1udWxsIGFuZFxuICAvLyBpdHMgYm9keeKAmXMgc3RyZWFtIGlzIGRpc3R1cmJlZCBvciBsb2NrZWQuXG4gIHJldHVybiBib2R5ICE9IG51bGwgJiYgKGJvZHkuc3RyZWFtLmxvY2tlZCB8fCB1dGlsLmlzRGlzdHVyYmVkKGJvZHkuc3RyZWFtKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyN1dGYtOC1kZWNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcbiAqL1xuZnVuY3Rpb24gdXRmOERlY29kZUJ5dGVzIChidWZmZXIpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIDEuIExldCBidWZmZXIgYmUgdGhlIHJlc3VsdCBvZiBwZWVraW5nIHRocmVlIGJ5dGVzIGZyb21cbiAgLy8gICAgaW9RdWV1ZSwgY29udmVydGVkIHRvIGEgYnl0ZSBzZXF1ZW5jZS5cblxuICAvLyAyLiBJZiBidWZmZXIgaXMgMHhFRiAweEJCIDB4QkYsIHRoZW4gcmVhZCB0aHJlZVxuICAvLyAgICBieXRlcyBmcm9tIGlvUXVldWUuIChEbyBub3RoaW5nIHdpdGggdGhvc2UgYnl0ZXMuKVxuICBpZiAoYnVmZmVyWzBdID09PSAweEVGICYmIGJ1ZmZlclsxXSA9PT0gMHhCQiAmJiBidWZmZXJbMl0gPT09IDB4QkYpIHtcbiAgICBidWZmZXIgPSBidWZmZXIuc3ViYXJyYXkoMylcbiAgfVxuXG4gIC8vIDMuIFByb2Nlc3MgYSBxdWV1ZSB3aXRoIGFuIGluc3RhbmNlIG9mIFVURi044oCZc1xuICAvLyAgICBkZWNvZGVyLCBpb1F1ZXVlLCBvdXRwdXQsIGFuZCBcInJlcGxhY2VtZW50XCIuXG4gIGNvbnN0IG91dHB1dCA9IHRleHREZWNvZGVyLmRlY29kZShidWZmZXIpXG5cbiAgLy8gNC4gUmV0dXJuIG91dHB1dC5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3BhcnNlLWpzb24tYnl0ZXMtdG8tYS1qYXZhc2NyaXB0LXZhbHVlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSlNPTkZyb21CeXRlcyAoYnl0ZXMpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UodXRmOERlY29kZUJ5dGVzKGJ5dGVzKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktbWltZS10eXBlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9yZXNwb25zZScpLlJlc3BvbnNlfGltcG9ydCgnLi9yZXF1ZXN0JykuUmVxdWVzdH0gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGJvZHlNaW1lVHlwZSAob2JqZWN0KSB7XG4gIGNvbnN0IHsgaGVhZGVyc0xpc3QgfSA9IG9iamVjdFtrU3RhdGVdXG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVyc0xpc3QuZ2V0KCdjb250ZW50LXR5cGUnKVxuXG4gIGlmIChjb250ZW50VHlwZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIHJldHVybiBwYXJzZU1JTUVUeXBlKGNvbnRlbnRUeXBlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXh0cmFjdEJvZHksXG4gIHNhZmVseUV4dHJhY3RCb2R5LFxuICBjbG9uZUJvZHksXG4gIG1peGluQm9keVxufVxuIl0sIm5hbWVzIjpbIkJ1c2JveSIsInJlcXVpcmUiLCJ1dGlsIiwiUmVhZGFibGVTdHJlYW1Gcm9tIiwiaXNCbG9iTGlrZSIsImlzUmVhZGFibGVTdHJlYW1MaWtlIiwicmVhZGFibGVTdHJlYW1DbG9zZSIsImNyZWF0ZURlZmVycmVkUHJvbWlzZSIsImZ1bGx5UmVhZEJvZHkiLCJGb3JtRGF0YSIsImtTdGF0ZSIsIndlYmlkbCIsIkRPTUV4Y2VwdGlvbiIsInN0cnVjdHVyZWRDbG9uZSIsIkJsb2IiLCJGaWxlIiwiTmF0aXZlRmlsZSIsImtCb2R5VXNlZCIsImFzc2VydCIsImlzRXJyb3JlZCIsImlzVWludDhBcnJheSIsImlzQXJyYXlCdWZmZXIiLCJVbmRpY2lGaWxlIiwicGFyc2VNSU1FVHlwZSIsInNlcmlhbGl6ZUFNaW1lVHlwZSIsIlJlYWRhYmxlU3RyZWFtIiwiZ2xvYmFsVGhpcyIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJ0ZXh0RGVjb2RlciIsIlRleHREZWNvZGVyIiwiZXh0cmFjdEJvZHkiLCJvYmplY3QiLCJrZWVwYWxpdmUiLCJzdHJlYW0iLCJwdWxsIiwiY29udHJvbGxlciIsImVucXVldWUiLCJzb3VyY2UiLCJlbmNvZGUiLCJxdWV1ZU1pY3JvdGFzayIsInN0YXJ0IiwidHlwZSIsInVuZGVmaW5lZCIsImFjdGlvbiIsImxlbmd0aCIsIlVSTFNlYXJjaFBhcmFtcyIsInRvU3RyaW5nIiwiVWludDhBcnJheSIsInNsaWNlIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImlzRm9ybURhdGFMaWtlIiwiYm91bmRhcnkiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJwYWRTdGFydCIsInByZWZpeCIsImVzY2FwZSIsInN0ciIsInJlcGxhY2UiLCJub3JtYWxpemVMaW5lZmVlZHMiLCJ2YWx1ZSIsImJsb2JQYXJ0cyIsInJuIiwiaGFzVW5rbm93blNpemVWYWx1ZSIsIm5hbWUiLCJjaHVuayIsInB1c2giLCJzaXplIiwicGFydCIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJUeXBlRXJyb3IiLCJpc0Rpc3R1cmJlZCIsImxvY2tlZCIsImlzQnVmZmVyIiwiQnVmZmVyIiwiaXRlcmF0b3IiLCJkb25lIiwibmV4dCIsImNsb3NlIiwiZGVzaXJlZFNpemUiLCJjYW5jZWwiLCJyZWFzb24iLCJyZXR1cm4iLCJib2R5Iiwic2FmZWx5RXh0cmFjdEJvZHkiLCJjbG9uZUJvZHkiLCJvdXQxIiwib3V0MiIsInRlZSIsIm91dDJDbG9uZSIsInRyYW5zZmVyIiwiZmluYWxDbG9uZSIsImNvbnN1bWVCb2R5IiwidGhyb3dJZkFib3J0ZWQiLCJzdGF0ZSIsImFib3J0ZWQiLCJib2R5TWl4aW5NZXRob2RzIiwiaW5zdGFuY2UiLCJtZXRob2RzIiwiYmxvYiIsInNwZWNDb25zdW1lQm9keSIsImJ5dGVzIiwibWltZVR5cGUiLCJib2R5TWltZVR5cGUiLCJhcnJheUJ1ZmZlciIsInRleHQiLCJ1dGY4RGVjb2RlQnl0ZXMiLCJqc29uIiwicGFyc2VKU09ORnJvbUJ5dGVzIiwiZm9ybURhdGEiLCJicmFuZENoZWNrIiwiY29udGVudFR5cGUiLCJoZWFkZXJzIiwiZ2V0IiwidGVzdCIsImtleSIsInRvTG93ZXJDYXNlIiwicmVzcG9uc2VGb3JtRGF0YSIsImJ1c2JveSIsInByZXNlcnZlUGF0aCIsImVyciIsIm9uIiwiYXBwZW5kIiwiZmlsZW5hbWUiLCJlbmNvZGluZyIsImNodW5rcyIsImJhc2U2NGNodW5rIiwiZW5kIiwiZnJvbSIsImJ1c2JveVJlc29sdmUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIndyaXRlIiwiZW50cmllcyIsInN0cmVhbWluZ0RlY29kZXIiLCJpZ25vcmVCT00iLCJkZWNvZGUiLCJPYmplY3QiLCJhc3NpZ24iLCJjYXVzZSIsImVycm9ycyIsImV4Y2VwdGlvbiIsImhlYWRlciIsIm1lc3NhZ2UiLCJtaXhpbkJvZHkiLCJwcm90b3R5cGUiLCJjb252ZXJ0Qnl0ZXNUb0pTVmFsdWUiLCJib2R5VW51c2FibGUiLCJwcm9taXNlIiwiZXJyb3JTdGVwcyIsImVycm9yIiwic3VjY2Vzc1N0ZXBzIiwiZGF0YSIsImUiLCJzdWJhcnJheSIsIm91dHB1dCIsIkpTT04iLCJwYXJzZSIsImhlYWRlcnNMaXN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/body.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/constants.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/constants.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { MessageChannel, receiveMessageOnPort } = __webpack_require__(/*! worker_threads */ \"worker_threads\");\nconst corsSafeListedMethods = [\n    \"GET\",\n    \"HEAD\",\n    \"POST\"\n];\nconst corsSafeListedMethodsSet = new Set(corsSafeListedMethods);\nconst nullBodyStatus = [\n    101,\n    204,\n    205,\n    304\n];\nconst redirectStatus = [\n    301,\n    302,\n    303,\n    307,\n    308\n];\nconst redirectStatusSet = new Set(redirectStatus);\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = [\n    \"1\",\n    \"7\",\n    \"9\",\n    \"11\",\n    \"13\",\n    \"15\",\n    \"17\",\n    \"19\",\n    \"20\",\n    \"21\",\n    \"22\",\n    \"23\",\n    \"25\",\n    \"37\",\n    \"42\",\n    \"43\",\n    \"53\",\n    \"69\",\n    \"77\",\n    \"79\",\n    \"87\",\n    \"95\",\n    \"101\",\n    \"102\",\n    \"103\",\n    \"104\",\n    \"109\",\n    \"110\",\n    \"111\",\n    \"113\",\n    \"115\",\n    \"117\",\n    \"119\",\n    \"123\",\n    \"135\",\n    \"137\",\n    \"139\",\n    \"143\",\n    \"161\",\n    \"179\",\n    \"389\",\n    \"427\",\n    \"465\",\n    \"512\",\n    \"513\",\n    \"514\",\n    \"515\",\n    \"526\",\n    \"530\",\n    \"531\",\n    \"532\",\n    \"540\",\n    \"548\",\n    \"554\",\n    \"556\",\n    \"563\",\n    \"587\",\n    \"601\",\n    \"636\",\n    \"989\",\n    \"990\",\n    \"993\",\n    \"995\",\n    \"1719\",\n    \"1720\",\n    \"1723\",\n    \"2049\",\n    \"3659\",\n    \"4045\",\n    \"5060\",\n    \"5061\",\n    \"6000\",\n    \"6566\",\n    \"6665\",\n    \"6666\",\n    \"6667\",\n    \"6668\",\n    \"6669\",\n    \"6697\",\n    \"10080\"\n];\nconst badPortsSet = new Set(badPorts);\n// https://w3c.github.io/webappsec-referrer-policy/#referrer-policies\nconst referrerPolicy = [\n    \"\",\n    \"no-referrer\",\n    \"no-referrer-when-downgrade\",\n    \"same-origin\",\n    \"origin\",\n    \"strict-origin\",\n    \"origin-when-cross-origin\",\n    \"strict-origin-when-cross-origin\",\n    \"unsafe-url\"\n];\nconst referrerPolicySet = new Set(referrerPolicy);\nconst requestRedirect = [\n    \"follow\",\n    \"manual\",\n    \"error\"\n];\nconst safeMethods = [\n    \"GET\",\n    \"HEAD\",\n    \"OPTIONS\",\n    \"TRACE\"\n];\nconst safeMethodsSet = new Set(safeMethods);\nconst requestMode = [\n    \"navigate\",\n    \"same-origin\",\n    \"no-cors\",\n    \"cors\"\n];\nconst requestCredentials = [\n    \"omit\",\n    \"same-origin\",\n    \"include\"\n];\nconst requestCache = [\n    \"default\",\n    \"no-store\",\n    \"reload\",\n    \"no-cache\",\n    \"force-cache\",\n    \"only-if-cached\"\n];\n// https://fetch.spec.whatwg.org/#request-body-header-name\nconst requestBodyHeader = [\n    \"content-encoding\",\n    \"content-language\",\n    \"content-location\",\n    \"content-type\",\n    // See https://github.com/nodejs/undici/issues/2021\n    // 'Content-Length' is a forbidden header name, which is typically\n    // removed in the Headers implementation. However, undici doesn't\n    // filter out headers, so we add it here.\n    \"content-length\"\n];\n// https://fetch.spec.whatwg.org/#enumdef-requestduplex\nconst requestDuplex = [\n    \"half\"\n];\n// http://fetch.spec.whatwg.org/#forbidden-method\nconst forbiddenMethods = [\n    \"CONNECT\",\n    \"TRACE\",\n    \"TRACK\"\n];\nconst forbiddenMethodsSet = new Set(forbiddenMethods);\nconst subresource = [\n    \"audio\",\n    \"audioworklet\",\n    \"font\",\n    \"image\",\n    \"manifest\",\n    \"paintworklet\",\n    \"script\",\n    \"style\",\n    \"track\",\n    \"video\",\n    \"xslt\",\n    \"\"\n];\nconst subresourceSet = new Set(subresource);\n/** @type {globalThis['DOMException']} */ const DOMException = globalThis.DOMException ?? (()=>{\n    // DOMException was only made a global in Node v17.0.0,\n    // but fetch supports >= v16.8.\n    try {\n        atob(\"~\");\n    } catch (err) {\n        return Object.getPrototypeOf(err).constructor;\n    }\n})();\nlet channel;\n/** @type {globalThis['structuredClone']} */ const structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js\n// structuredClone was added in v17.0.0, but fetch supports v16.8\nfunction structuredClone(value, options = undefined) {\n    if (arguments.length === 0) {\n        throw new TypeError(\"missing argument\");\n    }\n    if (!channel) {\n        channel = new MessageChannel();\n    }\n    channel.port1.unref();\n    channel.port2.unref();\n    channel.port1.postMessage(value, options?.transfer);\n    return receiveMessageOnPort(channel.port2).message;\n};\nmodule.exports = {\n    DOMException,\n    structuredClone,\n    subresource,\n    forbiddenMethods,\n    requestBodyHeader,\n    referrerPolicy,\n    requestRedirect,\n    requestMode,\n    requestCredentials,\n    requestCache,\n    redirectStatus,\n    corsSafeListedMethods,\n    nullBodyStatus,\n    safeMethods,\n    badPorts,\n    requestDuplex,\n    subresourceSet,\n    badPortsSet,\n    redirectStatusSet,\n    corsSafeListedMethodsSet,\n    safeMethodsSet,\n    forbiddenMethodsSet,\n    referrerPolicySet\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxjQUFjLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRXpELE1BQU1DLHdCQUF3QjtJQUFDO0lBQU87SUFBUTtDQUFPO0FBQ3JELE1BQU1DLDJCQUEyQixJQUFJQyxJQUFJRjtBQUV6QyxNQUFNRyxpQkFBaUI7SUFBQztJQUFLO0lBQUs7SUFBSztDQUFJO0FBRTNDLE1BQU1DLGlCQUFpQjtJQUFDO0lBQUs7SUFBSztJQUFLO0lBQUs7Q0FBSTtBQUNoRCxNQUFNQyxvQkFBb0IsSUFBSUgsSUFBSUU7QUFFbEMsZ0RBQWdEO0FBQ2hELE1BQU1FLFdBQVc7SUFDZjtJQUFLO0lBQUs7SUFBSztJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQy9HO0lBQU07SUFBTTtJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQ3ZHO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUNsRztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFRO0lBQVE7SUFDcEc7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFDaEc7Q0FDRDtBQUVELE1BQU1DLGNBQWMsSUFBSUwsSUFBSUk7QUFFNUIscUVBQXFFO0FBQ3JFLE1BQU1FLGlCQUFpQjtJQUNyQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUNELE1BQU1DLG9CQUFvQixJQUFJUCxJQUFJTTtBQUVsQyxNQUFNRSxrQkFBa0I7SUFBQztJQUFVO0lBQVU7Q0FBUTtBQUVyRCxNQUFNQyxjQUFjO0lBQUM7SUFBTztJQUFRO0lBQVc7Q0FBUTtBQUN2RCxNQUFNQyxpQkFBaUIsSUFBSVYsSUFBSVM7QUFFL0IsTUFBTUUsY0FBYztJQUFDO0lBQVk7SUFBZTtJQUFXO0NBQU87QUFFbEUsTUFBTUMscUJBQXFCO0lBQUM7SUFBUTtJQUFlO0NBQVU7QUFFN0QsTUFBTUMsZUFBZTtJQUNuQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVELDBEQUEwRDtBQUMxRCxNQUFNQyxvQkFBb0I7SUFDeEI7SUFDQTtJQUNBO0lBQ0E7SUFDQSxtREFBbUQ7SUFDbkQsa0VBQWtFO0lBQ2xFLGlFQUFpRTtJQUNqRSx5Q0FBeUM7SUFDekM7Q0FDRDtBQUVELHVEQUF1RDtBQUN2RCxNQUFNQyxnQkFBZ0I7SUFDcEI7Q0FDRDtBQUVELGlEQUFpRDtBQUNqRCxNQUFNQyxtQkFBbUI7SUFBQztJQUFXO0lBQVM7Q0FBUTtBQUN0RCxNQUFNQyxzQkFBc0IsSUFBSWpCLElBQUlnQjtBQUVwQyxNQUFNRSxjQUFjO0lBQ2xCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBQ0QsTUFBTUMsaUJBQWlCLElBQUluQixJQUFJa0I7QUFFL0IsdUNBQXVDLEdBQ3ZDLE1BQU1FLGVBQWVDLFdBQVdELFlBQVksSUFBSSxDQUFDO0lBQy9DLHVEQUF1RDtJQUN2RCwrQkFBK0I7SUFDL0IsSUFBSTtRQUNGRSxLQUFLO0lBQ1AsRUFBRSxPQUFPQyxLQUFLO1FBQ1osT0FBT0MsT0FBT0MsY0FBYyxDQUFDRixLQUFLRyxXQUFXO0lBQy9DO0FBQ0Y7QUFFQSxJQUFJQztBQUVKLDBDQUEwQyxHQUMxQyxNQUFNQyxrQkFDSlAsV0FBV08sZUFBZSxJQUMxQixnSEFBZ0g7QUFDaEgsaUVBQWlFO0FBQ2pFLFNBQVNBLGdCQUFpQkMsS0FBSyxFQUFFQyxVQUFVQyxTQUFTO0lBQ2xELElBQUlDLFVBQVVDLE1BQU0sS0FBSyxHQUFHO1FBQzFCLE1BQU0sSUFBSUMsVUFBVTtJQUN0QjtJQUVBLElBQUksQ0FBQ1AsU0FBUztRQUNaQSxVQUFVLElBQUloQztJQUNoQjtJQUNBZ0MsUUFBUVEsS0FBSyxDQUFDQyxLQUFLO0lBQ25CVCxRQUFRVSxLQUFLLENBQUNELEtBQUs7SUFDbkJULFFBQVFRLEtBQUssQ0FBQ0csV0FBVyxDQUFDVCxPQUFPQyxTQUFTUztJQUMxQyxPQUFPM0MscUJBQXFCK0IsUUFBUVUsS0FBSyxFQUFFRyxPQUFPO0FBQ3BEO0FBRUZDLE9BQU9DLE9BQU8sR0FBRztJQUNmdEI7SUFDQVE7SUFDQVY7SUFDQUY7SUFDQUY7SUFDQVI7SUFDQUU7SUFDQUc7SUFDQUM7SUFDQUM7SUFDQVg7SUFDQUo7SUFDQUc7SUFDQVE7SUFDQUw7SUFDQVc7SUFDQUk7SUFDQWQ7SUFDQUY7SUFDQUo7SUFDQVc7SUFDQU87SUFDQVY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvY29uc3RhbnRzLmpzP2Y0NGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgTWVzc2FnZUNoYW5uZWwsIHJlY2VpdmVNZXNzYWdlT25Qb3J0IH0gPSByZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpXG5cbmNvbnN0IGNvcnNTYWZlTGlzdGVkTWV0aG9kcyA9IFsnR0VUJywgJ0hFQUQnLCAnUE9TVCddXG5jb25zdCBjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQgPSBuZXcgU2V0KGNvcnNTYWZlTGlzdGVkTWV0aG9kcylcblxuY29uc3QgbnVsbEJvZHlTdGF0dXMgPSBbMTAxLCAyMDQsIDIwNSwgMzA0XVxuXG5jb25zdCByZWRpcmVjdFN0YXR1cyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cbmNvbnN0IHJlZGlyZWN0U3RhdHVzU2V0ID0gbmV3IFNldChyZWRpcmVjdFN0YXR1cylcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2Jsb2NrLWJhZC1wb3J0XG5jb25zdCBiYWRQb3J0cyA9IFtcbiAgJzEnLCAnNycsICc5JywgJzExJywgJzEzJywgJzE1JywgJzE3JywgJzE5JywgJzIwJywgJzIxJywgJzIyJywgJzIzJywgJzI1JywgJzM3JywgJzQyJywgJzQzJywgJzUzJywgJzY5JywgJzc3JywgJzc5JyxcbiAgJzg3JywgJzk1JywgJzEwMScsICcxMDInLCAnMTAzJywgJzEwNCcsICcxMDknLCAnMTEwJywgJzExMScsICcxMTMnLCAnMTE1JywgJzExNycsICcxMTknLCAnMTIzJywgJzEzNScsICcxMzcnLFxuICAnMTM5JywgJzE0MycsICcxNjEnLCAnMTc5JywgJzM4OScsICc0MjcnLCAnNDY1JywgJzUxMicsICc1MTMnLCAnNTE0JywgJzUxNScsICc1MjYnLCAnNTMwJywgJzUzMScsICc1MzInLFxuICAnNTQwJywgJzU0OCcsICc1NTQnLCAnNTU2JywgJzU2MycsICc1ODcnLCAnNjAxJywgJzYzNicsICc5ODknLCAnOTkwJywgJzk5MycsICc5OTUnLCAnMTcxOScsICcxNzIwJywgJzE3MjMnLFxuICAnMjA0OScsICczNjU5JywgJzQwNDUnLCAnNTA2MCcsICc1MDYxJywgJzYwMDAnLCAnNjU2NicsICc2NjY1JywgJzY2NjYnLCAnNjY2NycsICc2NjY4JywgJzY2NjknLCAnNjY5NycsXG4gICcxMDA4MCdcbl1cblxuY29uc3QgYmFkUG9ydHNTZXQgPSBuZXcgU2V0KGJhZFBvcnRzKVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jcmVmZXJyZXItcG9saWNpZXNcbmNvbnN0IHJlZmVycmVyUG9saWN5ID0gW1xuICAnJyxcbiAgJ25vLXJlZmVycmVyJyxcbiAgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJyxcbiAgJ3NhbWUtb3JpZ2luJyxcbiAgJ29yaWdpbicsXG4gICdzdHJpY3Qtb3JpZ2luJyxcbiAgJ29yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicsXG4gICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcbiAgJ3Vuc2FmZS11cmwnXG5dXG5jb25zdCByZWZlcnJlclBvbGljeVNldCA9IG5ldyBTZXQocmVmZXJyZXJQb2xpY3kpXG5cbmNvbnN0IHJlcXVlc3RSZWRpcmVjdCA9IFsnZm9sbG93JywgJ21hbnVhbCcsICdlcnJvciddXG5cbmNvbnN0IHNhZmVNZXRob2RzID0gWydHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1RSQUNFJ11cbmNvbnN0IHNhZmVNZXRob2RzU2V0ID0gbmV3IFNldChzYWZlTWV0aG9kcylcblxuY29uc3QgcmVxdWVzdE1vZGUgPSBbJ25hdmlnYXRlJywgJ3NhbWUtb3JpZ2luJywgJ25vLWNvcnMnLCAnY29ycyddXG5cbmNvbnN0IHJlcXVlc3RDcmVkZW50aWFscyA9IFsnb21pdCcsICdzYW1lLW9yaWdpbicsICdpbmNsdWRlJ11cblxuY29uc3QgcmVxdWVzdENhY2hlID0gW1xuICAnZGVmYXVsdCcsXG4gICduby1zdG9yZScsXG4gICdyZWxvYWQnLFxuICAnbm8tY2FjaGUnLFxuICAnZm9yY2UtY2FjaGUnLFxuICAnb25seS1pZi1jYWNoZWQnXG5dXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWJvZHktaGVhZGVyLW5hbWVcbmNvbnN0IHJlcXVlc3RCb2R5SGVhZGVyID0gW1xuICAnY29udGVudC1lbmNvZGluZycsXG4gICdjb250ZW50LWxhbmd1YWdlJyxcbiAgJ2NvbnRlbnQtbG9jYXRpb24nLFxuICAnY29udGVudC10eXBlJyxcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDIxXG4gIC8vICdDb250ZW50LUxlbmd0aCcgaXMgYSBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHdoaWNoIGlzIHR5cGljYWxseVxuICAvLyByZW1vdmVkIGluIHRoZSBIZWFkZXJzIGltcGxlbWVudGF0aW9uLiBIb3dldmVyLCB1bmRpY2kgZG9lc24ndFxuICAvLyBmaWx0ZXIgb3V0IGhlYWRlcnMsIHNvIHdlIGFkZCBpdCBoZXJlLlxuICAnY29udGVudC1sZW5ndGgnXG5dXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNlbnVtZGVmLXJlcXVlc3RkdXBsZXhcbmNvbnN0IHJlcXVlc3REdXBsZXggPSBbXG4gICdoYWxmJ1xuXVxuXG4vLyBodHRwOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmb3JiaWRkZW4tbWV0aG9kXG5jb25zdCBmb3JiaWRkZW5NZXRob2RzID0gWydDT05ORUNUJywgJ1RSQUNFJywgJ1RSQUNLJ11cbmNvbnN0IGZvcmJpZGRlbk1ldGhvZHNTZXQgPSBuZXcgU2V0KGZvcmJpZGRlbk1ldGhvZHMpXG5cbmNvbnN0IHN1YnJlc291cmNlID0gW1xuICAnYXVkaW8nLFxuICAnYXVkaW93b3JrbGV0JyxcbiAgJ2ZvbnQnLFxuICAnaW1hZ2UnLFxuICAnbWFuaWZlc3QnLFxuICAncGFpbnR3b3JrbGV0JyxcbiAgJ3NjcmlwdCcsXG4gICdzdHlsZScsXG4gICd0cmFjaycsXG4gICd2aWRlbycsXG4gICd4c2x0JyxcbiAgJydcbl1cbmNvbnN0IHN1YnJlc291cmNlU2V0ID0gbmV3IFNldChzdWJyZXNvdXJjZSlcblxuLyoqIEB0eXBlIHtnbG9iYWxUaGlzWydET01FeGNlcHRpb24nXX0gKi9cbmNvbnN0IERPTUV4Y2VwdGlvbiA9IGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uID8/ICgoKSA9PiB7XG4gIC8vIERPTUV4Y2VwdGlvbiB3YXMgb25seSBtYWRlIGEgZ2xvYmFsIGluIE5vZGUgdjE3LjAuMCxcbiAgLy8gYnV0IGZldGNoIHN1cHBvcnRzID49IHYxNi44LlxuICB0cnkge1xuICAgIGF0b2IoJ34nKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKGVycikuY29uc3RydWN0b3JcbiAgfVxufSkoKVxuXG5sZXQgY2hhbm5lbFxuXG4vKiogQHR5cGUge2dsb2JhbFRoaXNbJ3N0cnVjdHVyZWRDbG9uZSddfSAqL1xuY29uc3Qgc3RydWN0dXJlZENsb25lID1cbiAgZ2xvYmFsVGhpcy5zdHJ1Y3R1cmVkQ2xvbmUgPz9cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYjI3YWUyNGRjYzQyNTFiYWQ3MjZkOWQ4NGJhZjY3OGQxZjcwN2ZlZC9saWIvaW50ZXJuYWwvc3RydWN0dXJlZF9jbG9uZS5qc1xuICAvLyBzdHJ1Y3R1cmVkQ2xvbmUgd2FzIGFkZGVkIGluIHYxNy4wLjAsIGJ1dCBmZXRjaCBzdXBwb3J0cyB2MTYuOFxuICBmdW5jdGlvbiBzdHJ1Y3R1cmVkQ2xvbmUgKHZhbHVlLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgYXJndW1lbnQnKVxuICAgIH1cblxuICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpXG4gICAgfVxuICAgIGNoYW5uZWwucG9ydDEudW5yZWYoKVxuICAgIGNoYW5uZWwucG9ydDIudW5yZWYoKVxuICAgIGNoYW5uZWwucG9ydDEucG9zdE1lc3NhZ2UodmFsdWUsIG9wdGlvbnM/LnRyYW5zZmVyKVxuICAgIHJldHVybiByZWNlaXZlTWVzc2FnZU9uUG9ydChjaGFubmVsLnBvcnQyKS5tZXNzYWdlXG4gIH1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIERPTUV4Y2VwdGlvbixcbiAgc3RydWN0dXJlZENsb25lLFxuICBzdWJyZXNvdXJjZSxcbiAgZm9yYmlkZGVuTWV0aG9kcyxcbiAgcmVxdWVzdEJvZHlIZWFkZXIsXG4gIHJlZmVycmVyUG9saWN5LFxuICByZXF1ZXN0UmVkaXJlY3QsXG4gIHJlcXVlc3RNb2RlLFxuICByZXF1ZXN0Q3JlZGVudGlhbHMsXG4gIHJlcXVlc3RDYWNoZSxcbiAgcmVkaXJlY3RTdGF0dXMsXG4gIGNvcnNTYWZlTGlzdGVkTWV0aG9kcyxcbiAgbnVsbEJvZHlTdGF0dXMsXG4gIHNhZmVNZXRob2RzLFxuICBiYWRQb3J0cyxcbiAgcmVxdWVzdER1cGxleCxcbiAgc3VicmVzb3VyY2VTZXQsXG4gIGJhZFBvcnRzU2V0LFxuICByZWRpcmVjdFN0YXR1c1NldCxcbiAgY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0LFxuICBzYWZlTWV0aG9kc1NldCxcbiAgZm9yYmlkZGVuTWV0aG9kc1NldCxcbiAgcmVmZXJyZXJQb2xpY3lTZXRcbn1cbiJdLCJuYW1lcyI6WyJNZXNzYWdlQ2hhbm5lbCIsInJlY2VpdmVNZXNzYWdlT25Qb3J0IiwicmVxdWlyZSIsImNvcnNTYWZlTGlzdGVkTWV0aG9kcyIsImNvcnNTYWZlTGlzdGVkTWV0aG9kc1NldCIsIlNldCIsIm51bGxCb2R5U3RhdHVzIiwicmVkaXJlY3RTdGF0dXMiLCJyZWRpcmVjdFN0YXR1c1NldCIsImJhZFBvcnRzIiwiYmFkUG9ydHNTZXQiLCJyZWZlcnJlclBvbGljeSIsInJlZmVycmVyUG9saWN5U2V0IiwicmVxdWVzdFJlZGlyZWN0Iiwic2FmZU1ldGhvZHMiLCJzYWZlTWV0aG9kc1NldCIsInJlcXVlc3RNb2RlIiwicmVxdWVzdENyZWRlbnRpYWxzIiwicmVxdWVzdENhY2hlIiwicmVxdWVzdEJvZHlIZWFkZXIiLCJyZXF1ZXN0RHVwbGV4IiwiZm9yYmlkZGVuTWV0aG9kcyIsImZvcmJpZGRlbk1ldGhvZHNTZXQiLCJzdWJyZXNvdXJjZSIsInN1YnJlc291cmNlU2V0IiwiRE9NRXhjZXB0aW9uIiwiZ2xvYmFsVGhpcyIsImF0b2IiLCJlcnIiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsImNvbnN0cnVjdG9yIiwiY2hhbm5lbCIsInN0cnVjdHVyZWRDbG9uZSIsInZhbHVlIiwib3B0aW9ucyIsInVuZGVmaW5lZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsIlR5cGVFcnJvciIsInBvcnQxIiwidW5yZWYiLCJwb3J0MiIsInBvc3RNZXNzYWdlIiwidHJhbnNmZXIiLCJtZXNzYWdlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/constants.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/dataURL.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/dataURL.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! assert */ \"assert\");\nconst { atob } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { isomorphicDecode } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/fetch/util.js\");\nconst encoder = new TextEncoder();\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */ const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;\nconst HTTP_WHITESPACE_REGEX = /(\\u000A|\\u000D|\\u0009|\\u0020)/ // eslint-disable-line\n;\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */ const HTTP_QUOTED_STRING_TOKENS = /[\\u0009|\\u0020-\\u007E|\\u0080-\\u00FF]/ // eslint-disable-line\n;\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */ function dataURLProcessor(dataURL) {\n    // 1. Assert: dataURLs scheme is \"data\".\n    assert(dataURL.protocol === \"data:\");\n    // 2. Let input be the result of running the URL\n    // serializer on dataURL with exclude fragment\n    // set to true.\n    let input = URLSerializer(dataURL, true);\n    // 3. Remove the leading \"data:\" string from input.\n    input = input.slice(5);\n    // 4. Let position point at the start of input.\n    const position = {\n        position: 0\n    };\n    // 5. Let mimeType be the result of collecting a\n    // sequence of code points that are not equal\n    // to U+002C (,), given position.\n    let mimeType = collectASequenceOfCodePointsFast(\",\", input, position);\n    // 6. Strip leading and trailing ASCII whitespace\n    // from mimeType.\n    // Undici implementation note: we need to store the\n    // length because if the mimetype has spaces removed,\n    // the wrong amount will be sliced from the input in\n    // step #9\n    const mimeTypeLength = mimeType.length;\n    mimeType = removeASCIIWhitespace(mimeType, true, true);\n    // 7. If position is past the end of input, then\n    // return failure\n    if (position.position >= input.length) {\n        return \"failure\";\n    }\n    // 8. Advance position by 1.\n    position.position++;\n    // 9. Let encodedBody be the remainder of input.\n    const encodedBody = input.slice(mimeTypeLength + 1);\n    // 10. Let body be the percent-decoding of encodedBody.\n    let body = stringPercentDecode(encodedBody);\n    // 11. If mimeType ends with U+003B (;), followed by\n    // zero or more U+0020 SPACE, followed by an ASCII\n    // case-insensitive match for \"base64\", then:\n    if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n        // 1. Let stringBody be the isomorphic decode of body.\n        const stringBody = isomorphicDecode(body);\n        // 2. Set body to the forgiving-base64 decode of\n        // stringBody.\n        body = forgivingBase64(stringBody);\n        // 3. If body is failure, then return failure.\n        if (body === \"failure\") {\n            return \"failure\";\n        }\n        // 4. Remove the last 6 code points from mimeType.\n        mimeType = mimeType.slice(0, -6);\n        // 5. Remove trailing U+0020 SPACE code points from mimeType,\n        // if any.\n        mimeType = mimeType.replace(/(\\u0020)+$/, \"\");\n        // 6. Remove the last U+003B (;) code point from mimeType.\n        mimeType = mimeType.slice(0, -1);\n    }\n    // 12. If mimeType starts with U+003B (;), then prepend\n    // \"text/plain\" to mimeType.\n    if (mimeType.startsWith(\";\")) {\n        mimeType = \"text/plain\" + mimeType;\n    }\n    // 13. Let mimeTypeRecord be the result of parsing\n    // mimeType.\n    let mimeTypeRecord = parseMIMEType(mimeType);\n    // 14. If mimeTypeRecord is failure, then set\n    // mimeTypeRecord to text/plain;charset=US-ASCII.\n    if (mimeTypeRecord === \"failure\") {\n        mimeTypeRecord = parseMIMEType(\"text/plain;charset=US-ASCII\");\n    }\n    // 15. Return a new data: URL struct whose MIME\n    // type is mimeTypeRecord and body is body.\n    // https://fetch.spec.whatwg.org/#data-url-struct\n    return {\n        mimeType: mimeTypeRecord,\n        body\n    };\n}\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */ function URLSerializer(url, excludeFragment = false) {\n    const href = url.href;\n    if (!excludeFragment) {\n        return href;\n    }\n    const hash = href.lastIndexOf(\"#\");\n    if (hash === -1) {\n        return href;\n    }\n    return href.slice(0, hash);\n}\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */ function collectASequenceOfCodePoints(condition, input, position) {\n    // 1. Let result be the empty string.\n    let result = \"\";\n    // 2. While position doesnt point past the end of input and the\n    // code point at position within input meets the condition condition:\n    while(position.position < input.length && condition(input[position.position])){\n        // 1. Append that code point to the end of result.\n        result += input[position.position];\n        // 2. Advance position by 1.\n        position.position++;\n    }\n    // 3. Return result.\n    return result;\n}\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */ function collectASequenceOfCodePointsFast(char, input, position) {\n    const idx = input.indexOf(char, position.position);\n    const start = position.position;\n    if (idx === -1) {\n        position.position = input.length;\n        return input.slice(start);\n    }\n    position.position = idx;\n    return input.slice(start, position.position);\n}\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */ function stringPercentDecode(input) {\n    // 1. Let bytes be the UTF-8 encoding of input.\n    const bytes = encoder.encode(input);\n    // 2. Return the percent-decoding of bytes.\n    return percentDecode(bytes);\n}\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */ function percentDecode(input) {\n    // 1. Let output be an empty byte sequence.\n    /** @type {number[]} */ const output = [];\n    // 2. For each byte byte in input:\n    for(let i = 0; i < input.length; i++){\n        const byte = input[i];\n        // 1. If byte is not 0x25 (%), then append byte to output.\n        if (byte !== 0x25) {\n            output.push(byte);\n        // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n        // after byte in input are not in the ranges\n        // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n        // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n        // to output.\n        } else if (byte === 0x25 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {\n            output.push(0x25);\n        // 3. Otherwise:\n        } else {\n            // 1. Let bytePoint be the two bytes after byte in input,\n            // decoded, and then interpreted as hexadecimal number.\n            const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);\n            const bytePoint = Number.parseInt(nextTwoBytes, 16);\n            // 2. Append a byte whose value is bytePoint to output.\n            output.push(bytePoint);\n            // 3. Skip the next two bytes in input.\n            i += 2;\n        }\n    }\n    // 3. Return output.\n    return Uint8Array.from(output);\n}\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */ function parseMIMEType(input) {\n    // 1. Remove any leading and trailing HTTP whitespace\n    // from input.\n    input = removeHTTPWhitespace(input, true, true);\n    // 2. Let position be a position variable for input,\n    // initially pointing at the start of input.\n    const position = {\n        position: 0\n    };\n    // 3. Let type be the result of collecting a sequence\n    // of code points that are not U+002F (/) from\n    // input, given position.\n    const type = collectASequenceOfCodePointsFast(\"/\", input, position);\n    // 4. If type is the empty string or does not solely\n    // contain HTTP token code points, then return failure.\n    // https://mimesniff.spec.whatwg.org/#http-token-code-point\n    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n        return \"failure\";\n    }\n    // 5. If position is past the end of input, then return\n    // failure\n    if (position.position > input.length) {\n        return \"failure\";\n    }\n    // 6. Advance position by 1. (This skips past U+002F (/).)\n    position.position++;\n    // 7. Let subtype be the result of collecting a sequence of\n    // code points that are not U+003B (;) from input, given\n    // position.\n    let subtype = collectASequenceOfCodePointsFast(\";\", input, position);\n    // 8. Remove any trailing HTTP whitespace from subtype.\n    subtype = removeHTTPWhitespace(subtype, false, true);\n    // 9. If subtype is the empty string or does not solely\n    // contain HTTP token code points, then return failure.\n    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n        return \"failure\";\n    }\n    const typeLowercase = type.toLowerCase();\n    const subtypeLowercase = subtype.toLowerCase();\n    // 10. Let mimeType be a new MIME type record whose type\n    // is type, in ASCII lowercase, and subtype is subtype,\n    // in ASCII lowercase.\n    // https://mimesniff.spec.whatwg.org/#mime-type\n    const mimeType = {\n        type: typeLowercase,\n        subtype: subtypeLowercase,\n        /** @type {Map<string, string>} */ parameters: new Map(),\n        // https://mimesniff.spec.whatwg.org/#mime-type-essence\n        essence: `${typeLowercase}/${subtypeLowercase}`\n    };\n    // 11. While position is not past the end of input:\n    while(position.position < input.length){\n        // 1. Advance position by 1. (This skips past U+003B (;).)\n        position.position++;\n        // 2. Collect a sequence of code points that are HTTP\n        // whitespace from input given position.\n        collectASequenceOfCodePoints(// https://fetch.spec.whatwg.org/#http-whitespace\n        (char)=>HTTP_WHITESPACE_REGEX.test(char), input, position);\n        // 3. Let parameterName be the result of collecting a\n        // sequence of code points that are not U+003B (;)\n        // or U+003D (=) from input, given position.\n        let parameterName = collectASequenceOfCodePoints((char)=>char !== \";\" && char !== \"=\", input, position);\n        // 4. Set parameterName to parameterName, in ASCII\n        // lowercase.\n        parameterName = parameterName.toLowerCase();\n        // 5. If position is not past the end of input, then:\n        if (position.position < input.length) {\n            // 1. If the code point at position within input is\n            // U+003B (;), then continue.\n            if (input[position.position] === \";\") {\n                continue;\n            }\n            // 2. Advance position by 1. (This skips past U+003D (=).)\n            position.position++;\n        }\n        // 6. If position is past the end of input, then break.\n        if (position.position > input.length) {\n            break;\n        }\n        // 7. Let parameterValue be null.\n        let parameterValue = null;\n        // 8. If the code point at position within input is\n        // U+0022 (\"), then:\n        if (input[position.position] === '\"') {\n            // 1. Set parameterValue to the result of collecting\n            // an HTTP quoted string from input, given position\n            // and the extract-value flag.\n            parameterValue = collectAnHTTPQuotedString(input, position, true);\n            // 2. Collect a sequence of code points that are not\n            // U+003B (;) from input, given position.\n            collectASequenceOfCodePointsFast(\";\", input, position);\n        // 9. Otherwise:\n        } else {\n            // 1. Set parameterValue to the result of collecting\n            // a sequence of code points that are not U+003B (;)\n            // from input, given position.\n            parameterValue = collectASequenceOfCodePointsFast(\";\", input, position);\n            // 2. Remove any trailing HTTP whitespace from parameterValue.\n            parameterValue = removeHTTPWhitespace(parameterValue, false, true);\n            // 3. If parameterValue is the empty string, then continue.\n            if (parameterValue.length === 0) {\n                continue;\n            }\n        }\n        // 10. If all of the following are true\n        // - parameterName is not the empty string\n        // - parameterName solely contains HTTP token code points\n        // - parameterValue solely contains HTTP quoted-string token code points\n        // - mimeTypes parameters[parameterName] does not exist\n        // then set mimeTypes parameters[parameterName] to parameterValue.\n        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {\n            mimeType.parameters.set(parameterName, parameterValue);\n        }\n    }\n    // 12. Return mimeType.\n    return mimeType;\n}\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */ function forgivingBase64(data) {\n    // 1. Remove all ASCII whitespace from data.\n    data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, \"\") // eslint-disable-line\n    ;\n    // 2. If datas code point length divides by 4 leaving\n    // no remainder, then:\n    if (data.length % 4 === 0) {\n        // 1. If data ends with one or two U+003D (=) code points,\n        // then remove them from data.\n        data = data.replace(/=?=$/, \"\");\n    }\n    // 3. If datas code point length divides by 4 leaving\n    // a remainder of 1, then return failure.\n    if (data.length % 4 === 1) {\n        return \"failure\";\n    }\n    // 4. If data contains a code point that is not one of\n    //  U+002B (+)\n    //  U+002F (/)\n    //  ASCII alphanumeric\n    // then return failure.\n    if (/[^+/0-9A-Za-z]/.test(data)) {\n        return \"failure\";\n    }\n    const binary = atob(data);\n    const bytes = new Uint8Array(binary.length);\n    for(let byte = 0; byte < binary.length; byte++){\n        bytes[byte] = binary.charCodeAt(byte);\n    }\n    return bytes;\n}\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */ function collectAnHTTPQuotedString(input, position, extractValue) {\n    // 1. Let positionStart be position.\n    const positionStart = position.position;\n    // 2. Let value be the empty string.\n    let value = \"\";\n    // 3. Assert: the code point at position within input\n    // is U+0022 (\").\n    assert(input[position.position] === '\"');\n    // 4. Advance position by 1.\n    position.position++;\n    // 5. While true:\n    while(true){\n        // 1. Append the result of collecting a sequence of code points\n        // that are not U+0022 (\") or U+005C (\\) from input, given\n        // position, to value.\n        value += collectASequenceOfCodePoints((char)=>char !== '\"' && char !== \"\\\\\", input, position);\n        // 2. If position is past the end of input, then break.\n        if (position.position >= input.length) {\n            break;\n        }\n        // 3. Let quoteOrBackslash be the code point at position within\n        // input.\n        const quoteOrBackslash = input[position.position];\n        // 4. Advance position by 1.\n        position.position++;\n        // 5. If quoteOrBackslash is U+005C (\\), then:\n        if (quoteOrBackslash === \"\\\\\") {\n            // 1. If position is past the end of input, then append\n            // U+005C (\\) to value and break.\n            if (position.position >= input.length) {\n                value += \"\\\\\";\n                break;\n            }\n            // 2. Append the code point at position within input to value.\n            value += input[position.position];\n            // 3. Advance position by 1.\n            position.position++;\n        // 6. Otherwise:\n        } else {\n            // 1. Assert: quoteOrBackslash is U+0022 (\").\n            assert(quoteOrBackslash === '\"');\n            break;\n        }\n    }\n    // 6. If the extract-value flag is set, then return value.\n    if (extractValue) {\n        return value;\n    }\n    // 7. Return the code points from positionStart to position,\n    // inclusive, within input.\n    return input.slice(positionStart, position.position);\n}\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */ function serializeAMimeType(mimeType) {\n    assert(mimeType !== \"failure\");\n    const { parameters, essence } = mimeType;\n    // 1. Let serialization be the concatenation of mimeTypes\n    //    type, U+002F (/), and mimeTypes subtype.\n    let serialization = essence;\n    // 2. For each name  value of mimeTypes parameters:\n    for (let [name, value] of parameters.entries()){\n        // 1. Append U+003B (;) to serialization.\n        serialization += \";\";\n        // 2. Append name to serialization.\n        serialization += name;\n        // 3. Append U+003D (=) to serialization.\n        serialization += \"=\";\n        // 4. If value does not solely contain HTTP token code\n        //    points or value is the empty string, then:\n        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n            // 1. Precede each occurence of U+0022 (\") or\n            //    U+005C (\\) in value with U+005C (\\).\n            value = value.replace(/(\\\\|\")/g, \"\\\\$1\");\n            // 2. Prepend U+0022 (\") to value.\n            value = '\"' + value;\n            // 3. Append U+0022 (\") to value.\n            value += '\"';\n        }\n        // 5. Append value to serialization.\n        serialization += value;\n    }\n    // 3. Return serialization.\n    return serialization;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} char\n */ function isHTTPWhiteSpace(char) {\n    return char === \"\\r\" || char === \"\\n\" || char === \"\t\" || char === \" \";\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n */ function removeHTTPWhitespace(str, leading = true, trailing = true) {\n    let lead = 0;\n    let trail = str.length - 1;\n    if (leading) {\n        for(; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);\n    }\n    if (trailing) {\n        for(; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);\n    }\n    return str.slice(lead, trail + 1);\n}\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {string} char\n */ function isASCIIWhitespace(char) {\n    return char === \"\\r\" || char === \"\\n\" || char === \"\t\" || char === \"\\f\" || char === \" \";\n}\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n */ function removeASCIIWhitespace(str, leading = true, trailing = true) {\n    let lead = 0;\n    let trail = str.length - 1;\n    if (leading) {\n        for(; lead < str.length && isASCIIWhitespace(str[lead]); lead++);\n    }\n    if (trailing) {\n        for(; trail > 0 && isASCIIWhitespace(str[trail]); trail--);\n    }\n    return str.slice(lead, trail + 1);\n}\nmodule.exports = {\n    dataURLProcessor,\n    URLSerializer,\n    collectASequenceOfCodePoints,\n    collectASequenceOfCodePointsFast,\n    stringPercentDecode,\n    parseMIMEType,\n    collectAnHTTPQuotedString,\n    serializeAMimeType\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZGF0YVVSTC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQUVFLGdCQUFnQixFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBRXJDLE1BQU1HLFVBQVUsSUFBSUM7QUFFcEI7O0NBRUMsR0FDRCxNQUFNQyx3QkFBd0I7QUFDOUIsTUFBTUMsd0JBQXdCLGdDQUFnQyxzQkFBc0I7O0FBQ3BGOztDQUVDLEdBQ0QsTUFBTUMsNEJBQTRCLHVDQUF1QyxzQkFBc0I7O0FBRS9GLG9EQUFvRDtBQUNwRCx5QkFBeUIsR0FDekIsU0FBU0MsaUJBQWtCQyxPQUFPO0lBQ2hDLHlDQUF5QztJQUN6Q1YsT0FBT1UsUUFBUUMsUUFBUSxLQUFLO0lBRTVCLGdEQUFnRDtJQUNoRCw4Q0FBOEM7SUFDOUMsZUFBZTtJQUNmLElBQUlDLFFBQVFDLGNBQWNILFNBQVM7SUFFbkMsbURBQW1EO0lBQ25ERSxRQUFRQSxNQUFNRSxLQUFLLENBQUM7SUFFcEIsK0NBQStDO0lBQy9DLE1BQU1DLFdBQVc7UUFBRUEsVUFBVTtJQUFFO0lBRS9CLGdEQUFnRDtJQUNoRCw2Q0FBNkM7SUFDN0MsaUNBQWlDO0lBQ2pDLElBQUlDLFdBQVdDLGlDQUNiLEtBQ0FMLE9BQ0FHO0lBR0YsaURBQWlEO0lBQ2pELGlCQUFpQjtJQUNqQixtREFBbUQ7SUFDbkQscURBQXFEO0lBQ3JELG9EQUFvRDtJQUNwRCxVQUFVO0lBQ1YsTUFBTUcsaUJBQWlCRixTQUFTRyxNQUFNO0lBQ3RDSCxXQUFXSSxzQkFBc0JKLFVBQVUsTUFBTTtJQUVqRCxnREFBZ0Q7SUFDaEQsaUJBQWlCO0lBQ2pCLElBQUlELFNBQVNBLFFBQVEsSUFBSUgsTUFBTU8sTUFBTSxFQUFFO1FBQ3JDLE9BQU87SUFDVDtJQUVBLDRCQUE0QjtJQUM1QkosU0FBU0EsUUFBUTtJQUVqQixnREFBZ0Q7SUFDaEQsTUFBTU0sY0FBY1QsTUFBTUUsS0FBSyxDQUFDSSxpQkFBaUI7SUFFakQsdURBQXVEO0lBQ3ZELElBQUlJLE9BQU9DLG9CQUFvQkY7SUFFL0Isb0RBQW9EO0lBQ3BELGtEQUFrRDtJQUNsRCw2Q0FBNkM7SUFDN0MsSUFBSSx3QkFBd0JHLElBQUksQ0FBQ1IsV0FBVztRQUMxQyxzREFBc0Q7UUFDdEQsTUFBTVMsYUFBYXRCLGlCQUFpQm1CO1FBRXBDLGdEQUFnRDtRQUNoRCxjQUFjO1FBQ2RBLE9BQU9JLGdCQUFnQkQ7UUFFdkIsOENBQThDO1FBQzlDLElBQUlILFNBQVMsV0FBVztZQUN0QixPQUFPO1FBQ1Q7UUFFQSxrREFBa0Q7UUFDbEROLFdBQVdBLFNBQVNGLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFFOUIsNkRBQTZEO1FBQzdELFVBQVU7UUFDVkUsV0FBV0EsU0FBU1csT0FBTyxDQUFDLGNBQWM7UUFFMUMsMERBQTBEO1FBQzFEWCxXQUFXQSxTQUFTRixLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ2hDO0lBRUEsdURBQXVEO0lBQ3ZELDRCQUE0QjtJQUM1QixJQUFJRSxTQUFTWSxVQUFVLENBQUMsTUFBTTtRQUM1QlosV0FBVyxlQUFlQTtJQUM1QjtJQUVBLGtEQUFrRDtJQUNsRCxZQUFZO0lBQ1osSUFBSWEsaUJBQWlCQyxjQUFjZDtJQUVuQyw2Q0FBNkM7SUFDN0MsaURBQWlEO0lBQ2pELElBQUlhLG1CQUFtQixXQUFXO1FBQ2hDQSxpQkFBaUJDLGNBQWM7SUFDakM7SUFFQSwrQ0FBK0M7SUFDL0MsMkNBQTJDO0lBQzNDLGlEQUFpRDtJQUNqRCxPQUFPO1FBQUVkLFVBQVVhO1FBQWdCUDtJQUFLO0FBQzFDO0FBRUEsc0RBQXNEO0FBQ3REOzs7Q0FHQyxHQUNELFNBQVNULGNBQWVrQixHQUFHLEVBQUVDLGtCQUFrQixLQUFLO0lBQ2xELE1BQU1DLE9BQU9GLElBQUlFLElBQUk7SUFFckIsSUFBSSxDQUFDRCxpQkFBaUI7UUFDcEIsT0FBT0M7SUFDVDtJQUVBLE1BQU1DLE9BQU9ELEtBQUtFLFdBQVcsQ0FBQztJQUM5QixJQUFJRCxTQUFTLENBQUMsR0FBRztRQUNmLE9BQU9EO0lBQ1Q7SUFDQSxPQUFPQSxLQUFLbkIsS0FBSyxDQUFDLEdBQUdvQjtBQUN2QjtBQUVBLG1FQUFtRTtBQUNuRTs7OztDQUlDLEdBQ0QsU0FBU0UsNkJBQThCQyxTQUFTLEVBQUV6QixLQUFLLEVBQUVHLFFBQVE7SUFDL0QscUNBQXFDO0lBQ3JDLElBQUl1QixTQUFTO0lBRWIsZ0VBQWdFO0lBQ2hFLHFFQUFxRTtJQUNyRSxNQUFPdkIsU0FBU0EsUUFBUSxHQUFHSCxNQUFNTyxNQUFNLElBQUlrQixVQUFVekIsS0FBSyxDQUFDRyxTQUFTQSxRQUFRLENBQUMsRUFBRztRQUM5RSxrREFBa0Q7UUFDbER1QixVQUFVMUIsS0FBSyxDQUFDRyxTQUFTQSxRQUFRLENBQUM7UUFFbEMsNEJBQTRCO1FBQzVCQSxTQUFTQSxRQUFRO0lBQ25CO0lBRUEsb0JBQW9CO0lBQ3BCLE9BQU91QjtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTckIsaUNBQWtDc0IsSUFBSSxFQUFFM0IsS0FBSyxFQUFFRyxRQUFRO0lBQzlELE1BQU15QixNQUFNNUIsTUFBTTZCLE9BQU8sQ0FBQ0YsTUFBTXhCLFNBQVNBLFFBQVE7SUFDakQsTUFBTTJCLFFBQVEzQixTQUFTQSxRQUFRO0lBRS9CLElBQUl5QixRQUFRLENBQUMsR0FBRztRQUNkekIsU0FBU0EsUUFBUSxHQUFHSCxNQUFNTyxNQUFNO1FBQ2hDLE9BQU9QLE1BQU1FLEtBQUssQ0FBQzRCO0lBQ3JCO0lBRUEzQixTQUFTQSxRQUFRLEdBQUd5QjtJQUNwQixPQUFPNUIsTUFBTUUsS0FBSyxDQUFDNEIsT0FBTzNCLFNBQVNBLFFBQVE7QUFDN0M7QUFFQSxxREFBcUQ7QUFDckQsMEJBQTBCLEdBQzFCLFNBQVNRLG9CQUFxQlgsS0FBSztJQUNqQywrQ0FBK0M7SUFDL0MsTUFBTStCLFFBQVF2QyxRQUFRd0MsTUFBTSxDQUFDaEM7SUFFN0IsMkNBQTJDO0lBQzNDLE9BQU9pQyxjQUFjRjtBQUN2QjtBQUVBLDhDQUE4QztBQUM5Qyw4QkFBOEIsR0FDOUIsU0FBU0UsY0FBZWpDLEtBQUs7SUFDM0IsMkNBQTJDO0lBQzNDLHFCQUFxQixHQUNyQixNQUFNa0MsU0FBUyxFQUFFO0lBRWpCLGtDQUFrQztJQUNsQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSW5DLE1BQU1PLE1BQU0sRUFBRTRCLElBQUs7UUFDckMsTUFBTUMsT0FBT3BDLEtBQUssQ0FBQ21DLEVBQUU7UUFFckIsMERBQTBEO1FBQzFELElBQUlDLFNBQVMsTUFBTTtZQUNqQkYsT0FBT0csSUFBSSxDQUFDRDtRQUVkLDJEQUEyRDtRQUMzRCw0Q0FBNEM7UUFDNUMsOENBQThDO1FBQzlDLHVEQUF1RDtRQUN2RCxhQUFhO1FBQ2IsT0FBTyxJQUNMQSxTQUFTLFFBQ1QsQ0FBQyxvQkFBb0J4QixJQUFJLENBQUMwQixPQUFPQyxZQUFZLENBQUN2QyxLQUFLLENBQUNtQyxJQUFJLEVBQUUsRUFBRW5DLEtBQUssQ0FBQ21DLElBQUksRUFBRSxJQUN4RTtZQUNBRCxPQUFPRyxJQUFJLENBQUM7UUFFZCxnQkFBZ0I7UUFDaEIsT0FBTztZQUNMLHlEQUF5RDtZQUN6RCx1REFBdUQ7WUFDdkQsTUFBTUcsZUFBZUYsT0FBT0MsWUFBWSxDQUFDdkMsS0FBSyxDQUFDbUMsSUFBSSxFQUFFLEVBQUVuQyxLQUFLLENBQUNtQyxJQUFJLEVBQUU7WUFDbkUsTUFBTU0sWUFBWUMsT0FBT0MsUUFBUSxDQUFDSCxjQUFjO1lBRWhELHVEQUF1RDtZQUN2RE4sT0FBT0csSUFBSSxDQUFDSTtZQUVaLHVDQUF1QztZQUN2Q04sS0FBSztRQUNQO0lBQ0Y7SUFFQSxvQkFBb0I7SUFDcEIsT0FBT1MsV0FBV0MsSUFBSSxDQUFDWDtBQUN6QjtBQUVBLHVEQUF1RDtBQUN2RCwwQkFBMEIsR0FDMUIsU0FBU2hCLGNBQWVsQixLQUFLO0lBQzNCLHFEQUFxRDtJQUNyRCxjQUFjO0lBQ2RBLFFBQVE4QyxxQkFBcUI5QyxPQUFPLE1BQU07SUFFMUMsb0RBQW9EO0lBQ3BELDRDQUE0QztJQUM1QyxNQUFNRyxXQUFXO1FBQUVBLFVBQVU7SUFBRTtJQUUvQixxREFBcUQ7SUFDckQsOENBQThDO0lBQzlDLHlCQUF5QjtJQUN6QixNQUFNNEMsT0FBTzFDLGlDQUNYLEtBQ0FMLE9BQ0FHO0lBR0Ysb0RBQW9EO0lBQ3BELHVEQUF1RDtJQUN2RCwyREFBMkQ7SUFDM0QsSUFBSTRDLEtBQUt4QyxNQUFNLEtBQUssS0FBSyxDQUFDYixzQkFBc0JrQixJQUFJLENBQUNtQyxPQUFPO1FBQzFELE9BQU87SUFDVDtJQUVBLHVEQUF1RDtJQUN2RCxVQUFVO0lBQ1YsSUFBSTVDLFNBQVNBLFFBQVEsR0FBR0gsTUFBTU8sTUFBTSxFQUFFO1FBQ3BDLE9BQU87SUFDVDtJQUVBLDBEQUEwRDtJQUMxREosU0FBU0EsUUFBUTtJQUVqQiwyREFBMkQ7SUFDM0Qsd0RBQXdEO0lBQ3hELFlBQVk7SUFDWixJQUFJNkMsVUFBVTNDLGlDQUNaLEtBQ0FMLE9BQ0FHO0lBR0YsdURBQXVEO0lBQ3ZENkMsVUFBVUYscUJBQXFCRSxTQUFTLE9BQU87SUFFL0MsdURBQXVEO0lBQ3ZELHVEQUF1RDtJQUN2RCxJQUFJQSxRQUFRekMsTUFBTSxLQUFLLEtBQUssQ0FBQ2Isc0JBQXNCa0IsSUFBSSxDQUFDb0MsVUFBVTtRQUNoRSxPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxnQkFBZ0JGLEtBQUtHLFdBQVc7SUFDdEMsTUFBTUMsbUJBQW1CSCxRQUFRRSxXQUFXO0lBRTVDLHdEQUF3RDtJQUN4RCx1REFBdUQ7SUFDdkQsc0JBQXNCO0lBQ3RCLCtDQUErQztJQUMvQyxNQUFNOUMsV0FBVztRQUNmMkMsTUFBTUU7UUFDTkQsU0FBU0c7UUFDVCxnQ0FBZ0MsR0FDaENDLFlBQVksSUFBSUM7UUFDaEIsdURBQXVEO1FBQ3ZEQyxTQUFTLENBQUMsRUFBRUwsY0FBYyxDQUFDLEVBQUVFLGlCQUFpQixDQUFDO0lBQ2pEO0lBRUEsbURBQW1EO0lBQ25ELE1BQU9oRCxTQUFTQSxRQUFRLEdBQUdILE1BQU1PLE1BQU0sQ0FBRTtRQUN2QywwREFBMEQ7UUFDMURKLFNBQVNBLFFBQVE7UUFFakIscURBQXFEO1FBQ3JELHdDQUF3QztRQUN4Q3FCLDZCQUNFLGlEQUFpRDtRQUNqREcsQ0FBQUEsT0FBUWhDLHNCQUFzQmlCLElBQUksQ0FBQ2UsT0FDbkMzQixPQUNBRztRQUdGLHFEQUFxRDtRQUNyRCxrREFBa0Q7UUFDbEQsNENBQTRDO1FBQzVDLElBQUlvRCxnQkFBZ0IvQiw2QkFDbEIsQ0FBQ0csT0FBU0EsU0FBUyxPQUFPQSxTQUFTLEtBQ25DM0IsT0FDQUc7UUFHRixrREFBa0Q7UUFDbEQsYUFBYTtRQUNib0QsZ0JBQWdCQSxjQUFjTCxXQUFXO1FBRXpDLHFEQUFxRDtRQUNyRCxJQUFJL0MsU0FBU0EsUUFBUSxHQUFHSCxNQUFNTyxNQUFNLEVBQUU7WUFDcEMsbURBQW1EO1lBQ25ELDZCQUE2QjtZQUM3QixJQUFJUCxLQUFLLENBQUNHLFNBQVNBLFFBQVEsQ0FBQyxLQUFLLEtBQUs7Z0JBQ3BDO1lBQ0Y7WUFFQSwwREFBMEQ7WUFDMURBLFNBQVNBLFFBQVE7UUFDbkI7UUFFQSx1REFBdUQ7UUFDdkQsSUFBSUEsU0FBU0EsUUFBUSxHQUFHSCxNQUFNTyxNQUFNLEVBQUU7WUFDcEM7UUFDRjtRQUVBLGlDQUFpQztRQUNqQyxJQUFJaUQsaUJBQWlCO1FBRXJCLG1EQUFtRDtRQUNuRCxvQkFBb0I7UUFDcEIsSUFBSXhELEtBQUssQ0FBQ0csU0FBU0EsUUFBUSxDQUFDLEtBQUssS0FBSztZQUNwQyxvREFBb0Q7WUFDcEQsbURBQW1EO1lBQ25ELDhCQUE4QjtZQUM5QnFELGlCQUFpQkMsMEJBQTBCekQsT0FBT0csVUFBVTtZQUU1RCxvREFBb0Q7WUFDcEQseUNBQXlDO1lBQ3pDRSxpQ0FDRSxLQUNBTCxPQUNBRztRQUdKLGdCQUFnQjtRQUNoQixPQUFPO1lBQ0wsb0RBQW9EO1lBQ3BELG9EQUFvRDtZQUNwRCw4QkFBOEI7WUFDOUJxRCxpQkFBaUJuRCxpQ0FDZixLQUNBTCxPQUNBRztZQUdGLDhEQUE4RDtZQUM5RHFELGlCQUFpQlYscUJBQXFCVSxnQkFBZ0IsT0FBTztZQUU3RCwyREFBMkQ7WUFDM0QsSUFBSUEsZUFBZWpELE1BQU0sS0FBSyxHQUFHO2dCQUMvQjtZQUNGO1FBQ0Y7UUFFQSx1Q0FBdUM7UUFDdkMsMENBQTBDO1FBQzFDLHlEQUF5RDtRQUN6RCx3RUFBd0U7UUFDeEUsd0RBQXdEO1FBQ3hELG1FQUFtRTtRQUNuRSxJQUNFZ0QsY0FBY2hELE1BQU0sS0FBSyxLQUN6QmIsc0JBQXNCa0IsSUFBSSxDQUFDMkMsa0JBQzFCQyxDQUFBQSxlQUFlakQsTUFBTSxLQUFLLEtBQUtYLDBCQUEwQmdCLElBQUksQ0FBQzRDLGVBQWMsS0FDN0UsQ0FBQ3BELFNBQVNnRCxVQUFVLENBQUNNLEdBQUcsQ0FBQ0gsZ0JBQ3pCO1lBQ0FuRCxTQUFTZ0QsVUFBVSxDQUFDTyxHQUFHLENBQUNKLGVBQWVDO1FBQ3pDO0lBQ0Y7SUFFQSx1QkFBdUI7SUFDdkIsT0FBT3BEO0FBQ1Q7QUFFQSx5REFBeUQ7QUFDekQseUJBQXlCLEdBQ3pCLFNBQVNVLGdCQUFpQjhDLElBQUk7SUFDNUIsNENBQTRDO0lBQzVDQSxPQUFPQSxLQUFLN0MsT0FBTyxDQUFDLHFDQUFxQyxJQUFLLHNCQUFzQjs7SUFFcEYsc0RBQXNEO0lBQ3RELHNCQUFzQjtJQUN0QixJQUFJNkMsS0FBS3JELE1BQU0sR0FBRyxNQUFNLEdBQUc7UUFDekIsMERBQTBEO1FBQzFELDhCQUE4QjtRQUM5QnFELE9BQU9BLEtBQUs3QyxPQUFPLENBQUMsUUFBUTtJQUM5QjtJQUVBLHNEQUFzRDtJQUN0RCx5Q0FBeUM7SUFDekMsSUFBSTZDLEtBQUtyRCxNQUFNLEdBQUcsTUFBTSxHQUFHO1FBQ3pCLE9BQU87SUFDVDtJQUVBLHNEQUFzRDtJQUN0RCxjQUFjO0lBQ2QsY0FBYztJQUNkLHNCQUFzQjtJQUN0Qix1QkFBdUI7SUFDdkIsSUFBSSxpQkFBaUJLLElBQUksQ0FBQ2dELE9BQU87UUFDL0IsT0FBTztJQUNUO0lBRUEsTUFBTUMsU0FBU3ZFLEtBQUtzRTtJQUNwQixNQUFNN0IsUUFBUSxJQUFJYSxXQUFXaUIsT0FBT3RELE1BQU07SUFFMUMsSUFBSyxJQUFJNkIsT0FBTyxHQUFHQSxPQUFPeUIsT0FBT3RELE1BQU0sRUFBRTZCLE9BQVE7UUFDL0NMLEtBQUssQ0FBQ0ssS0FBSyxHQUFHeUIsT0FBT0MsVUFBVSxDQUFDMUI7SUFDbEM7SUFFQSxPQUFPTDtBQUNUO0FBRUEsK0RBQStEO0FBQy9ELG1FQUFtRTtBQUNuRTs7OztDQUlDLEdBQ0QsU0FBUzBCLDBCQUEyQnpELEtBQUssRUFBRUcsUUFBUSxFQUFFNEQsWUFBWTtJQUMvRCxvQ0FBb0M7SUFDcEMsTUFBTUMsZ0JBQWdCN0QsU0FBU0EsUUFBUTtJQUV2QyxvQ0FBb0M7SUFDcEMsSUFBSThELFFBQVE7SUFFWixxREFBcUQ7SUFDckQsaUJBQWlCO0lBQ2pCN0UsT0FBT1ksS0FBSyxDQUFDRyxTQUFTQSxRQUFRLENBQUMsS0FBSztJQUVwQyw0QkFBNEI7SUFDNUJBLFNBQVNBLFFBQVE7SUFFakIsaUJBQWlCO0lBQ2pCLE1BQU8sS0FBTTtRQUNYLCtEQUErRDtRQUMvRCwwREFBMEQ7UUFDMUQsc0JBQXNCO1FBQ3RCOEQsU0FBU3pDLDZCQUNQLENBQUNHLE9BQVNBLFNBQVMsT0FBT0EsU0FBUyxNQUNuQzNCLE9BQ0FHO1FBR0YsdURBQXVEO1FBQ3ZELElBQUlBLFNBQVNBLFFBQVEsSUFBSUgsTUFBTU8sTUFBTSxFQUFFO1lBQ3JDO1FBQ0Y7UUFFQSwrREFBK0Q7UUFDL0QsU0FBUztRQUNULE1BQU0yRCxtQkFBbUJsRSxLQUFLLENBQUNHLFNBQVNBLFFBQVEsQ0FBQztRQUVqRCw0QkFBNEI7UUFDNUJBLFNBQVNBLFFBQVE7UUFFakIsOENBQThDO1FBQzlDLElBQUkrRCxxQkFBcUIsTUFBTTtZQUM3Qix1REFBdUQ7WUFDdkQsaUNBQWlDO1lBQ2pDLElBQUkvRCxTQUFTQSxRQUFRLElBQUlILE1BQU1PLE1BQU0sRUFBRTtnQkFDckMwRCxTQUFTO2dCQUNUO1lBQ0Y7WUFFQSw4REFBOEQ7WUFDOURBLFNBQVNqRSxLQUFLLENBQUNHLFNBQVNBLFFBQVEsQ0FBQztZQUVqQyw0QkFBNEI7WUFDNUJBLFNBQVNBLFFBQVE7UUFFbkIsZ0JBQWdCO1FBQ2hCLE9BQU87WUFDTCw2Q0FBNkM7WUFDN0NmLE9BQU84RSxxQkFBcUI7WUFHNUI7UUFDRjtJQUNGO0lBRUEsMERBQTBEO0lBQzFELElBQUlILGNBQWM7UUFDaEIsT0FBT0U7SUFDVDtJQUVBLDREQUE0RDtJQUM1RCwyQkFBMkI7SUFDM0IsT0FBT2pFLE1BQU1FLEtBQUssQ0FBQzhELGVBQWU3RCxTQUFTQSxRQUFRO0FBQ3JEO0FBRUE7O0NBRUMsR0FDRCxTQUFTZ0UsbUJBQW9CL0QsUUFBUTtJQUNuQ2hCLE9BQU9nQixhQUFhO0lBQ3BCLE1BQU0sRUFBRWdELFVBQVUsRUFBRUUsT0FBTyxFQUFFLEdBQUdsRDtJQUVoQywwREFBMEQ7SUFDMUQsK0NBQStDO0lBQy9DLElBQUlnRSxnQkFBZ0JkO0lBRXBCLHFEQUFxRDtJQUNyRCxLQUFLLElBQUksQ0FBQ2UsTUFBTUosTUFBTSxJQUFJYixXQUFXa0IsT0FBTyxHQUFJO1FBQzlDLHlDQUF5QztRQUN6Q0YsaUJBQWlCO1FBRWpCLG1DQUFtQztRQUNuQ0EsaUJBQWlCQztRQUVqQix5Q0FBeUM7UUFDekNELGlCQUFpQjtRQUVqQixzREFBc0Q7UUFDdEQsZ0RBQWdEO1FBQ2hELElBQUksQ0FBQzFFLHNCQUFzQmtCLElBQUksQ0FBQ3FELFFBQVE7WUFDdEMsNkNBQTZDO1lBQzdDLDBDQUEwQztZQUMxQ0EsUUFBUUEsTUFBTWxELE9BQU8sQ0FBQyxXQUFXO1lBRWpDLGtDQUFrQztZQUNsQ2tELFFBQVEsTUFBTUE7WUFFZCxpQ0FBaUM7WUFDakNBLFNBQVM7UUFDWDtRQUVBLG9DQUFvQztRQUNwQ0csaUJBQWlCSDtJQUNuQjtJQUVBLDJCQUEyQjtJQUMzQixPQUFPRztBQUNUO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0csaUJBQWtCNUMsSUFBSTtJQUM3QixPQUFPQSxTQUFTLFFBQVFBLFNBQVMsUUFBUUEsU0FBUyxPQUFRQSxTQUFTO0FBQ3JFO0FBRUE7OztDQUdDLEdBQ0QsU0FBU21CLHFCQUFzQjBCLEdBQUcsRUFBRUMsVUFBVSxJQUFJLEVBQUVDLFdBQVcsSUFBSTtJQUNqRSxJQUFJQyxPQUFPO0lBQ1gsSUFBSUMsUUFBUUosSUFBSWpFLE1BQU0sR0FBRztJQUV6QixJQUFJa0UsU0FBUztRQUNYLE1BQU9FLE9BQU9ILElBQUlqRSxNQUFNLElBQUlnRSxpQkFBaUJDLEdBQUcsQ0FBQ0csS0FBSyxHQUFHQTtJQUMzRDtJQUVBLElBQUlELFVBQVU7UUFDWixNQUFPRSxRQUFRLEtBQUtMLGlCQUFpQkMsR0FBRyxDQUFDSSxNQUFNLEdBQUdBO0lBQ3BEO0lBRUEsT0FBT0osSUFBSXRFLEtBQUssQ0FBQ3lFLE1BQU1DLFFBQVE7QUFDakM7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQyxrQkFBbUJsRCxJQUFJO0lBQzlCLE9BQU9BLFNBQVMsUUFBUUEsU0FBUyxRQUFRQSxTQUFTLE9BQVFBLFNBQVMsUUFBUUEsU0FBUztBQUN0RjtBQUVBOztDQUVDLEdBQ0QsU0FBU25CLHNCQUF1QmdFLEdBQUcsRUFBRUMsVUFBVSxJQUFJLEVBQUVDLFdBQVcsSUFBSTtJQUNsRSxJQUFJQyxPQUFPO0lBQ1gsSUFBSUMsUUFBUUosSUFBSWpFLE1BQU0sR0FBRztJQUV6QixJQUFJa0UsU0FBUztRQUNYLE1BQU9FLE9BQU9ILElBQUlqRSxNQUFNLElBQUlzRSxrQkFBa0JMLEdBQUcsQ0FBQ0csS0FBSyxHQUFHQTtJQUM1RDtJQUVBLElBQUlELFVBQVU7UUFDWixNQUFPRSxRQUFRLEtBQUtDLGtCQUFrQkwsR0FBRyxDQUFDSSxNQUFNLEdBQUdBO0lBQ3JEO0lBRUEsT0FBT0osSUFBSXRFLEtBQUssQ0FBQ3lFLE1BQU1DLFFBQVE7QUFDakM7QUFFQUUsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZsRjtJQUNBSTtJQUNBdUI7SUFDQW5CO0lBQ0FNO0lBQ0FPO0lBQ0F1QztJQUNBVTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9kYXRhVVJMLmpzPzQ5NTQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsgYXRvYiB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgaXNvbW9ycGhpY0RlY29kZSB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbi8qKlxuICogQHNlZSBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtdG9rZW4tY29kZS1wb2ludFxuICovXG5jb25zdCBIVFRQX1RPS0VOX0NPREVQT0lOVFMgPSAvXlshIyQlJicqKy0uXl98fkEtWmEtejAtOV0rJC9cbmNvbnN0IEhUVFBfV0hJVEVTUEFDRV9SRUdFWCA9IC8oXFx1MDAwQXxcXHUwMDBEfFxcdTAwMDl8XFx1MDAyMCkvIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbi8qKlxuICogQHNlZSBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtcXVvdGVkLXN0cmluZy10b2tlbi1jb2RlLXBvaW50XG4gKi9cbmNvbnN0IEhUVFBfUVVPVEVEX1NUUklOR19UT0tFTlMgPSAvW1xcdTAwMDl8XFx1MDAyMC1cXHUwMDdFfFxcdTAwODAtXFx1MDBGRl0vIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RhdGEtdXJsLXByb2Nlc3NvclxuLyoqIEBwYXJhbSB7VVJMfSBkYXRhVVJMICovXG5mdW5jdGlvbiBkYXRhVVJMUHJvY2Vzc29yIChkYXRhVVJMKSB7XG4gIC8vIDEuIEFzc2VydDogZGF0YVVSTOKAmXMgc2NoZW1lIGlzIFwiZGF0YVwiLlxuICBhc3NlcnQoZGF0YVVSTC5wcm90b2NvbCA9PT0gJ2RhdGE6JylcblxuICAvLyAyLiBMZXQgaW5wdXQgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHRoZSBVUkxcbiAgLy8gc2VyaWFsaXplciBvbiBkYXRhVVJMIHdpdGggZXhjbHVkZSBmcmFnbWVudFxuICAvLyBzZXQgdG8gdHJ1ZS5cbiAgbGV0IGlucHV0ID0gVVJMU2VyaWFsaXplcihkYXRhVVJMLCB0cnVlKVxuXG4gIC8vIDMuIFJlbW92ZSB0aGUgbGVhZGluZyBcImRhdGE6XCIgc3RyaW5nIGZyb20gaW5wdXQuXG4gIGlucHV0ID0gaW5wdXQuc2xpY2UoNSlcblxuICAvLyA0LiBMZXQgcG9zaXRpb24gcG9pbnQgYXQgdGhlIHN0YXJ0IG9mIGlucHV0LlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gIC8vIDUuIExldCBtaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYVxuICAvLyBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgZXF1YWxcbiAgLy8gdG8gVSswMDJDICgsKSwgZ2l2ZW4gcG9zaXRpb24uXG4gIGxldCBtaW1lVHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICcsJyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gNi4gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgQVNDSUkgd2hpdGVzcGFjZVxuICAvLyBmcm9tIG1pbWVUeXBlLlxuICAvLyBVbmRpY2kgaW1wbGVtZW50YXRpb24gbm90ZTogd2UgbmVlZCB0byBzdG9yZSB0aGVcbiAgLy8gbGVuZ3RoIGJlY2F1c2UgaWYgdGhlIG1pbWV0eXBlIGhhcyBzcGFjZXMgcmVtb3ZlZCxcbiAgLy8gdGhlIHdyb25nIGFtb3VudCB3aWxsIGJlIHNsaWNlZCBmcm9tIHRoZSBpbnB1dCBpblxuICAvLyBzdGVwICM5XG4gIGNvbnN0IG1pbWVUeXBlTGVuZ3RoID0gbWltZVR5cGUubGVuZ3RoXG4gIG1pbWVUeXBlID0gcmVtb3ZlQVNDSUlXaGl0ZXNwYWNlKG1pbWVUeXBlLCB0cnVlLCB0cnVlKVxuXG4gIC8vIDcuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlblxuICAvLyByZXR1cm4gZmFpbHVyZVxuICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gOC4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gOS4gTGV0IGVuY29kZWRCb2R5IGJlIHRoZSByZW1haW5kZXIgb2YgaW5wdXQuXG4gIGNvbnN0IGVuY29kZWRCb2R5ID0gaW5wdXQuc2xpY2UobWltZVR5cGVMZW5ndGggKyAxKVxuXG4gIC8vIDEwLiBMZXQgYm9keSBiZSB0aGUgcGVyY2VudC1kZWNvZGluZyBvZiBlbmNvZGVkQm9keS5cbiAgbGV0IGJvZHkgPSBzdHJpbmdQZXJjZW50RGVjb2RlKGVuY29kZWRCb2R5KVxuXG4gIC8vIDExLiBJZiBtaW1lVHlwZSBlbmRzIHdpdGggVSswMDNCICg7KSwgZm9sbG93ZWQgYnlcbiAgLy8gemVybyBvciBtb3JlIFUrMDAyMCBTUEFDRSwgZm9sbG93ZWQgYnkgYW4gQVNDSUlcbiAgLy8gY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgXCJiYXNlNjRcIiwgdGhlbjpcbiAgaWYgKC87KFxcdTAwMjApezAsfWJhc2U2NCQvaS50ZXN0KG1pbWVUeXBlKSkge1xuICAgIC8vIDEuIExldCBzdHJpbmdCb2R5IGJlIHRoZSBpc29tb3JwaGljIGRlY29kZSBvZiBib2R5LlxuICAgIGNvbnN0IHN0cmluZ0JvZHkgPSBpc29tb3JwaGljRGVjb2RlKGJvZHkpXG5cbiAgICAvLyAyLiBTZXQgYm9keSB0byB0aGUgZm9yZ2l2aW5nLWJhc2U2NCBkZWNvZGUgb2ZcbiAgICAvLyBzdHJpbmdCb2R5LlxuICAgIGJvZHkgPSBmb3JnaXZpbmdCYXNlNjQoc3RyaW5nQm9keSlcblxuICAgIC8vIDMuIElmIGJvZHkgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgICBpZiAoYm9keSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfVxuXG4gICAgLy8gNC4gUmVtb3ZlIHRoZSBsYXN0IDYgY29kZSBwb2ludHMgZnJvbSBtaW1lVHlwZS5cbiAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnNsaWNlKDAsIC02KVxuXG4gICAgLy8gNS4gUmVtb3ZlIHRyYWlsaW5nIFUrMDAyMCBTUEFDRSBjb2RlIHBvaW50cyBmcm9tIG1pbWVUeXBlLFxuICAgIC8vIGlmIGFueS5cbiAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnJlcGxhY2UoLyhcXHUwMDIwKSskLywgJycpXG5cbiAgICAvLyA2LiBSZW1vdmUgdGhlIGxhc3QgVSswMDNCICg7KSBjb2RlIHBvaW50IGZyb20gbWltZVR5cGUuXG4gICAgbWltZVR5cGUgPSBtaW1lVHlwZS5zbGljZSgwLCAtMSlcbiAgfVxuXG4gIC8vIDEyLiBJZiBtaW1lVHlwZSBzdGFydHMgd2l0aCBVKzAwM0IgKDspLCB0aGVuIHByZXBlbmRcbiAgLy8gXCJ0ZXh0L3BsYWluXCIgdG8gbWltZVR5cGUuXG4gIGlmIChtaW1lVHlwZS5zdGFydHNXaXRoKCc7JykpIHtcbiAgICBtaW1lVHlwZSA9ICd0ZXh0L3BsYWluJyArIG1pbWVUeXBlXG4gIH1cblxuICAvLyAxMy4gTGV0IG1pbWVUeXBlUmVjb3JkIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZ1xuICAvLyBtaW1lVHlwZS5cbiAgbGV0IG1pbWVUeXBlUmVjb3JkID0gcGFyc2VNSU1FVHlwZShtaW1lVHlwZSlcblxuICAvLyAxNC4gSWYgbWltZVR5cGVSZWNvcmQgaXMgZmFpbHVyZSwgdGhlbiBzZXRcbiAgLy8gbWltZVR5cGVSZWNvcmQgdG8gdGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJLlxuICBpZiAobWltZVR5cGVSZWNvcmQgPT09ICdmYWlsdXJlJykge1xuICAgIG1pbWVUeXBlUmVjb3JkID0gcGFyc2VNSU1FVHlwZSgndGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJJylcbiAgfVxuXG4gIC8vIDE1LiBSZXR1cm4gYSBuZXcgZGF0YTogVVJMIHN0cnVjdCB3aG9zZSBNSU1FXG4gIC8vIHR5cGUgaXMgbWltZVR5cGVSZWNvcmQgYW5kIGJvZHkgaXMgYm9keS5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RhdGEtdXJsLXN0cnVjdFxuICByZXR1cm4geyBtaW1lVHlwZTogbWltZVR5cGVSZWNvcmQsIGJvZHkgfVxufVxuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdXJsLXNlcmlhbGl6ZXJcbi8qKlxuICogQHBhcmFtIHtVUkx9IHVybFxuICogQHBhcmFtIHtib29sZWFufSBleGNsdWRlRnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gVVJMU2VyaWFsaXplciAodXJsLCBleGNsdWRlRnJhZ21lbnQgPSBmYWxzZSkge1xuICBjb25zdCBocmVmID0gdXJsLmhyZWZcblxuICBpZiAoIWV4Y2x1ZGVGcmFnbWVudCkge1xuICAgIHJldHVybiBocmVmXG4gIH1cblxuICBjb25zdCBoYXNoID0gaHJlZi5sYXN0SW5kZXhPZignIycpXG4gIGlmIChoYXNoID09PSAtMSkge1xuICAgIHJldHVybiBocmVmXG4gIH1cbiAgcmV0dXJuIGhyZWYuc2xpY2UoMCwgaGFzaClcbn1cblxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2NvbGxlY3QtYS1zZXF1ZW5jZS1vZi1jb2RlLXBvaW50c1xuLyoqXG4gKiBAcGFyYW0geyhjaGFyOiBzdHJpbmcpID0+IGJvb2xlYW59IGNvbmRpdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzIChjb25kaXRpb24sIGlucHV0LCBwb3NpdGlvbikge1xuICAvLyAxLiBMZXQgcmVzdWx0IGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGxldCByZXN1bHQgPSAnJ1xuXG4gIC8vIDIuIFdoaWxlIHBvc2l0aW9uIGRvZXNu4oCZdCBwb2ludCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQgYW5kIHRoZVxuICAvLyBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBtZWV0cyB0aGUgY29uZGl0aW9uIGNvbmRpdGlvbjpcbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoICYmIGNvbmRpdGlvbihpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0pKSB7XG4gICAgLy8gMS4gQXBwZW5kIHRoYXQgY29kZSBwb2ludCB0byB0aGUgZW5kIG9mIHJlc3VsdC5cbiAgICByZXN1bHQgKz0gaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dXG5cbiAgICAvLyAyLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHJlc3VsdC5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEEgZmFzdGVyIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMgdGhhdCBvbmx5IHdvcmtzIHdoZW4gY29tcGFyaW5nIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0IChjaGFyLCBpbnB1dCwgcG9zaXRpb24pIHtcbiAgY29uc3QgaWR4ID0gaW5wdXQuaW5kZXhPZihjaGFyLCBwb3NpdGlvbi5wb3NpdGlvbilcbiAgY29uc3Qgc3RhcnQgPSBwb3NpdGlvbi5wb3NpdGlvblxuXG4gIGlmIChpZHggPT09IC0xKSB7XG4gICAgcG9zaXRpb24ucG9zaXRpb24gPSBpbnB1dC5sZW5ndGhcbiAgICByZXR1cm4gaW5wdXQuc2xpY2Uoc3RhcnQpXG4gIH1cblxuICBwb3NpdGlvbi5wb3NpdGlvbiA9IGlkeFxuICByZXR1cm4gaW5wdXQuc2xpY2Uoc3RhcnQsIHBvc2l0aW9uLnBvc2l0aW9uKVxufVxuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3N0cmluZy1wZXJjZW50LWRlY29kZVxuLyoqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAqL1xuZnVuY3Rpb24gc3RyaW5nUGVyY2VudERlY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gTGV0IGJ5dGVzIGJlIHRoZSBVVEYtOCBlbmNvZGluZyBvZiBpbnB1dC5cbiAgY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZShpbnB1dClcblxuICAvLyAyLiBSZXR1cm4gdGhlIHBlcmNlbnQtZGVjb2Rpbmcgb2YgYnl0ZXMuXG4gIHJldHVybiBwZXJjZW50RGVjb2RlKGJ5dGVzKVxufVxuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3BlcmNlbnQtZGVjb2RlXG4vKiogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dCAqL1xuZnVuY3Rpb24gcGVyY2VudERlY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICAvKiogQHR5cGUge251bWJlcltdfSAqL1xuICBjb25zdCBvdXRwdXQgPSBbXVxuXG4gIC8vIDIuIEZvciBlYWNoIGJ5dGUgYnl0ZSBpbiBpbnB1dDpcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJ5dGUgPSBpbnB1dFtpXVxuXG4gICAgLy8gMS4gSWYgYnl0ZSBpcyBub3QgMHgyNSAoJSksIHRoZW4gYXBwZW5kIGJ5dGUgdG8gb3V0cHV0LlxuICAgIGlmIChieXRlICE9PSAweDI1KSB7XG4gICAgICBvdXRwdXQucHVzaChieXRlKVxuXG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiBieXRlIGlzIDB4MjUgKCUpIGFuZCB0aGUgbmV4dCB0d28gYnl0ZXNcbiAgICAvLyBhZnRlciBieXRlIGluIGlucHV0IGFyZSBub3QgaW4gdGhlIHJhbmdlc1xuICAgIC8vIDB4MzAgKDApIHRvIDB4MzkgKDkpLCAweDQxIChBKSB0byAweDQ2IChGKSxcbiAgICAvLyBhbmQgMHg2MSAoYSkgdG8gMHg2NiAoZiksIGFsbCBpbmNsdXNpdmUsIGFwcGVuZCBieXRlXG4gICAgLy8gdG8gb3V0cHV0LlxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBieXRlID09PSAweDI1ICYmXG4gICAgICAhL15bMC05QS1GYS1mXXsyfSQvaS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoaW5wdXRbaSArIDFdLCBpbnB1dFtpICsgMl0pKVxuICAgICkge1xuICAgICAgb3V0cHV0LnB1c2goMHgyNSlcblxuICAgIC8vIDMuIE90aGVyd2lzZTpcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMS4gTGV0IGJ5dGVQb2ludCBiZSB0aGUgdHdvIGJ5dGVzIGFmdGVyIGJ5dGUgaW4gaW5wdXQsXG4gICAgICAvLyBkZWNvZGVkLCBhbmQgdGhlbiBpbnRlcnByZXRlZCBhcyBoZXhhZGVjaW1hbCBudW1iZXIuXG4gICAgICBjb25zdCBuZXh0VHdvQnl0ZXMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0W2kgKyAxXSwgaW5wdXRbaSArIDJdKVxuICAgICAgY29uc3QgYnl0ZVBvaW50ID0gTnVtYmVyLnBhcnNlSW50KG5leHRUd29CeXRlcywgMTYpXG5cbiAgICAgIC8vIDIuIEFwcGVuZCBhIGJ5dGUgd2hvc2UgdmFsdWUgaXMgYnl0ZVBvaW50IHRvIG91dHB1dC5cbiAgICAgIG91dHB1dC5wdXNoKGJ5dGVQb2ludClcblxuICAgICAgLy8gMy4gU2tpcCB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gaW5wdXQuXG4gICAgICBpICs9IDJcbiAgICB9XG4gIH1cblxuICAvLyAzLiBSZXR1cm4gb3V0cHV0LlxuICByZXR1cm4gVWludDhBcnJheS5mcm9tKG91dHB1dClcbn1cblxuLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNwYXJzZS1hLW1pbWUtdHlwZVxuLyoqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAqL1xuZnVuY3Rpb24gcGFyc2VNSU1FVHlwZSAoaW5wdXQpIHtcbiAgLy8gMS4gUmVtb3ZlIGFueSBsZWFkaW5nIGFuZCB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2VcbiAgLy8gZnJvbSBpbnB1dC5cbiAgaW5wdXQgPSByZW1vdmVIVFRQV2hpdGVzcGFjZShpbnB1dCwgdHJ1ZSwgdHJ1ZSlcblxuICAvLyAyLiBMZXQgcG9zaXRpb24gYmUgYSBwb3NpdGlvbiB2YXJpYWJsZSBmb3IgaW5wdXQsXG4gIC8vIGluaXRpYWxseSBwb2ludGluZyBhdCB0aGUgc3RhcnQgb2YgaW5wdXQuXG4gIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgLy8gMy4gTGV0IHR5cGUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2VcbiAgLy8gb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAyRiAoLykgZnJvbVxuICAvLyBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24uXG4gIGNvbnN0IHR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAnLycsXG4gICAgaW5wdXQsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDQuIElmIHR5cGUgaXMgdGhlIGVtcHR5IHN0cmluZyBvciBkb2VzIG5vdCBzb2xlbHlcbiAgLy8gY29udGFpbiBIVFRQIHRva2VuIGNvZGUgcG9pbnRzLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICAvLyBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtdG9rZW4tY29kZS1wb2ludFxuICBpZiAodHlwZS5sZW5ndGggPT09IDAgfHwgIUhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KHR5cGUpKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNS4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIHJldHVyblxuICAvLyBmYWlsdXJlXG4gIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDYuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS4gKFRoaXMgc2tpcHMgcGFzdCBVKzAwMkYgKC8pLilcbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDcuIExldCBzdWJ0eXBlIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mXG4gIC8vIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwM0IgKDspIGZyb20gaW5wdXQsIGdpdmVuXG4gIC8vIHBvc2l0aW9uLlxuICBsZXQgc3VidHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICc7JyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gOC4gUmVtb3ZlIGFueSB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgZnJvbSBzdWJ0eXBlLlxuICBzdWJ0eXBlID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2Uoc3VidHlwZSwgZmFsc2UsIHRydWUpXG5cbiAgLy8gOS4gSWYgc3VidHlwZSBpcyB0aGUgZW1wdHkgc3RyaW5nIG9yIGRvZXMgbm90IHNvbGVseVxuICAvLyBjb250YWluIEhUVFAgdG9rZW4gY29kZSBwb2ludHMsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChzdWJ0eXBlLmxlbmd0aCA9PT0gMCB8fCAhSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3Qoc3VidHlwZSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICBjb25zdCB0eXBlTG93ZXJjYXNlID0gdHlwZS50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IHN1YnR5cGVMb3dlcmNhc2UgPSBzdWJ0eXBlLnRvTG93ZXJDYXNlKClcblxuICAvLyAxMC4gTGV0IG1pbWVUeXBlIGJlIGEgbmV3IE1JTUUgdHlwZSByZWNvcmQgd2hvc2UgdHlwZVxuICAvLyBpcyB0eXBlLCBpbiBBU0NJSSBsb3dlcmNhc2UsIGFuZCBzdWJ0eXBlIGlzIHN1YnR5cGUsXG4gIC8vIGluIEFTQ0lJIGxvd2VyY2FzZS5cbiAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNtaW1lLXR5cGVcbiAgY29uc3QgbWltZVR5cGUgPSB7XG4gICAgdHlwZTogdHlwZUxvd2VyY2FzZSxcbiAgICBzdWJ0eXBlOiBzdWJ0eXBlTG93ZXJjYXNlLFxuICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICBwYXJhbWV0ZXJzOiBuZXcgTWFwKCksXG4gICAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNtaW1lLXR5cGUtZXNzZW5jZVxuICAgIGVzc2VuY2U6IGAke3R5cGVMb3dlcmNhc2V9LyR7c3VidHlwZUxvd2VyY2FzZX1gXG4gIH1cblxuICAvLyAxMS4gV2hpbGUgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dDpcbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgLy8gMS4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLiAoVGhpcyBza2lwcyBwYXN0IFUrMDAzQiAoOykuKVxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDIuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQXG4gICAgLy8gd2hpdGVzcGFjZSBmcm9tIGlucHV0IGdpdmVuIHBvc2l0aW9uLlxuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC13aGl0ZXNwYWNlXG4gICAgICBjaGFyID0+IEhUVFBfV0hJVEVTUEFDRV9SRUdFWC50ZXN0KGNoYXIpLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDMuIExldCBwYXJhbWV0ZXJOYW1lIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhXG4gICAgLy8gc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAzQiAoOylcbiAgICAvLyBvciBVKzAwM0QgKD0pIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgIGxldCBwYXJhbWV0ZXJOYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAnOycgJiYgY2hhciAhPT0gJz0nLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDQuIFNldCBwYXJhbWV0ZXJOYW1lIHRvIHBhcmFtZXRlck5hbWUsIGluIEFTQ0lJXG4gICAgLy8gbG93ZXJjYXNlLlxuICAgIHBhcmFtZXRlck5hbWUgPSBwYXJhbWV0ZXJOYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIC8vIDUuIElmIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW46XG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAvLyAxLiBJZiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgaXNcbiAgICAgIC8vIFUrMDAzQiAoOyksIHRoZW4gY29udGludWUuXG4gICAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnOycpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLiAoVGhpcyBza2lwcyBwYXN0IFUrMDAzRCAoPSkuKVxuICAgICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICAgIH1cblxuICAgIC8vIDYuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBicmVhay5cbiAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gNy4gTGV0IHBhcmFtZXRlclZhbHVlIGJlIG51bGwuXG4gICAgbGV0IHBhcmFtZXRlclZhbHVlID0gbnVsbFxuXG4gICAgLy8gOC4gSWYgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IGlzXG4gICAgLy8gVSswMDIyIChcIiksIHRoZW46XG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gJ1wiJykge1xuICAgICAgLy8gMS4gU2V0IHBhcmFtZXRlclZhbHVlIHRvIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZ1xuICAgICAgLy8gYW4gSFRUUCBxdW90ZWQgc3RyaW5nIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uXG4gICAgICAvLyBhbmQgdGhlIGV4dHJhY3QtdmFsdWUgZmxhZy5cbiAgICAgIHBhcmFtZXRlclZhbHVlID0gY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZyhpbnB1dCwgcG9zaXRpb24sIHRydWUpXG5cbiAgICAgIC8vIDIuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3RcbiAgICAgIC8vIFUrMDAzQiAoOykgZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICAgJzsnLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIClcblxuICAgIC8vIDkuIE90aGVyd2lzZTpcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMS4gU2V0IHBhcmFtZXRlclZhbHVlIHRvIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZ1xuICAgICAgLy8gYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDNCICg7KVxuICAgICAgLy8gZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICBwYXJhbWV0ZXJWYWx1ZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgICAnOycsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBwb3NpdGlvblxuICAgICAgKVxuXG4gICAgICAvLyAyLiBSZW1vdmUgYW55IHRyYWlsaW5nIEhUVFAgd2hpdGVzcGFjZSBmcm9tIHBhcmFtZXRlclZhbHVlLlxuICAgICAgcGFyYW1ldGVyVmFsdWUgPSByZW1vdmVIVFRQV2hpdGVzcGFjZShwYXJhbWV0ZXJWYWx1ZSwgZmFsc2UsIHRydWUpXG5cbiAgICAgIC8vIDMuIElmIHBhcmFtZXRlclZhbHVlIGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gY29udGludWUuXG4gICAgICBpZiAocGFyYW1ldGVyVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMTAuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGFyZSB0cnVlXG4gICAgLy8gLSBwYXJhbWV0ZXJOYW1lIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nXG4gICAgLy8gLSBwYXJhbWV0ZXJOYW1lIHNvbGVseSBjb250YWlucyBIVFRQIHRva2VuIGNvZGUgcG9pbnRzXG4gICAgLy8gLSBwYXJhbWV0ZXJWYWx1ZSBzb2xlbHkgY29udGFpbnMgSFRUUCBxdW90ZWQtc3RyaW5nIHRva2VuIGNvZGUgcG9pbnRzXG4gICAgLy8gLSBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXSBkb2VzIG5vdCBleGlzdFxuICAgIC8vIHRoZW4gc2V0IG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW3BhcmFtZXRlck5hbWVdIHRvIHBhcmFtZXRlclZhbHVlLlxuICAgIGlmIChcbiAgICAgIHBhcmFtZXRlck5hbWUubGVuZ3RoICE9PSAwICYmXG4gICAgICBIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdChwYXJhbWV0ZXJOYW1lKSAmJlxuICAgICAgKHBhcmFtZXRlclZhbHVlLmxlbmd0aCA9PT0gMCB8fCBIVFRQX1FVT1RFRF9TVFJJTkdfVE9LRU5TLnRlc3QocGFyYW1ldGVyVmFsdWUpKSAmJlxuICAgICAgIW1pbWVUeXBlLnBhcmFtZXRlcnMuaGFzKHBhcmFtZXRlck5hbWUpXG4gICAgKSB7XG4gICAgICBtaW1lVHlwZS5wYXJhbWV0ZXJzLnNldChwYXJhbWV0ZXJOYW1lLCBwYXJhbWV0ZXJWYWx1ZSlcbiAgICB9XG4gIH1cblxuICAvLyAxMi4gUmV0dXJuIG1pbWVUeXBlLlxuICByZXR1cm4gbWltZVR5cGVcbn1cblxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2ZvcmdpdmluZy1iYXNlNjQtZGVjb2RlXG4vKiogQHBhcmFtIHtzdHJpbmd9IGRhdGEgKi9cbmZ1bmN0aW9uIGZvcmdpdmluZ0Jhc2U2NCAoZGF0YSkge1xuICAvLyAxLiBSZW1vdmUgYWxsIEFTQ0lJIHdoaXRlc3BhY2UgZnJvbSBkYXRhLlxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC9bXFx1MDAwOVxcdTAwMEFcXHUwMDBDXFx1MDAwRFxcdTAwMjBdL2csICcnKSAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIC8vIDIuIElmIGRhdGHigJlzIGNvZGUgcG9pbnQgbGVuZ3RoIGRpdmlkZXMgYnkgNCBsZWF2aW5nXG4gIC8vIG5vIHJlbWFpbmRlciwgdGhlbjpcbiAgaWYgKGRhdGEubGVuZ3RoICUgNCA9PT0gMCkge1xuICAgIC8vIDEuIElmIGRhdGEgZW5kcyB3aXRoIG9uZSBvciB0d28gVSswMDNEICg9KSBjb2RlIHBvaW50cyxcbiAgICAvLyB0aGVuIHJlbW92ZSB0aGVtIGZyb20gZGF0YS5cbiAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC89Pz0kLywgJycpXG4gIH1cblxuICAvLyAzLiBJZiBkYXRh4oCZcyBjb2RlIHBvaW50IGxlbmd0aCBkaXZpZGVzIGJ5IDQgbGVhdmluZ1xuICAvLyBhIHJlbWFpbmRlciBvZiAxLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoZGF0YS5sZW5ndGggJSA0ID09PSAxKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNC4gSWYgZGF0YSBjb250YWlucyBhIGNvZGUgcG9pbnQgdGhhdCBpcyBub3Qgb25lIG9mXG4gIC8vICBVKzAwMkIgKCspXG4gIC8vICBVKzAwMkYgKC8pXG4gIC8vICBBU0NJSSBhbHBoYW51bWVyaWNcbiAgLy8gdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKC9bXisvMC05QS1aYS16XS8udGVzdChkYXRhKSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIGNvbnN0IGJpbmFyeSA9IGF0b2IoZGF0YSlcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnkubGVuZ3RoKVxuXG4gIGZvciAobGV0IGJ5dGUgPSAwOyBieXRlIDwgYmluYXJ5Lmxlbmd0aDsgYnl0ZSsrKSB7XG4gICAgYnl0ZXNbYnl0ZV0gPSBiaW5hcnkuY2hhckNvZGVBdChieXRlKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb2xsZWN0LWFuLWh0dHAtcXVvdGVkLXN0cmluZ1xuLy8gdGVzdHM6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNleGFtcGxlLWh0dHAtcXVvdGVkLXN0cmluZ1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBleHRyYWN0VmFsdWVcbiAqL1xuZnVuY3Rpb24gY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZyAoaW5wdXQsIHBvc2l0aW9uLCBleHRyYWN0VmFsdWUpIHtcbiAgLy8gMS4gTGV0IHBvc2l0aW9uU3RhcnQgYmUgcG9zaXRpb24uXG4gIGNvbnN0IHBvc2l0aW9uU3RhcnQgPSBwb3NpdGlvbi5wb3NpdGlvblxuXG4gIC8vIDIuIExldCB2YWx1ZSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBsZXQgdmFsdWUgPSAnJ1xuXG4gIC8vIDMuIEFzc2VydDogdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0XG4gIC8vIGlzIFUrMDAyMiAoXCIpLlxuICBhc3NlcnQoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnXCInKVxuXG4gIC8vIDQuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDUuIFdoaWxlIHRydWU6XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gMS4gQXBwZW5kIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzXG4gICAgLy8gdGhhdCBhcmUgbm90IFUrMDAyMiAoXCIpIG9yIFUrMDA1QyAoXFwpIGZyb20gaW5wdXQsIGdpdmVuXG4gICAgLy8gcG9zaXRpb24sIHRvIHZhbHVlLlxuICAgIHZhbHVlICs9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciAhPT0gJ1wiJyAmJiBjaGFyICE9PSAnXFxcXCcsXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgLy8gMi4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIGJyZWFrLlxuICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IHF1b3RlT3JCYWNrc2xhc2ggYmUgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluXG4gICAgLy8gaW5wdXQuXG4gICAgY29uc3QgcXVvdGVPckJhY2tzbGFzaCA9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXVxuXG4gICAgLy8gNC4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDUuIElmIHF1b3RlT3JCYWNrc2xhc2ggaXMgVSswMDVDIChcXCksIHRoZW46XG4gICAgaWYgKHF1b3RlT3JCYWNrc2xhc2ggPT09ICdcXFxcJykge1xuICAgICAgLy8gMS4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIGFwcGVuZFxuICAgICAgLy8gVSswMDVDIChcXCkgdG8gdmFsdWUgYW5kIGJyZWFrLlxuICAgICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSArPSAnXFxcXCdcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQXBwZW5kIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCB0byB2YWx1ZS5cbiAgICAgIHZhbHVlICs9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXVxuXG4gICAgICAvLyAzLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgICAvLyA2LiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIEFzc2VydDogcXVvdGVPckJhY2tzbGFzaCBpcyBVKzAwMjIgKFwiKS5cbiAgICAgIGFzc2VydChxdW90ZU9yQmFja3NsYXNoID09PSAnXCInKVxuXG4gICAgICAvLyAyLiBCcmVhay5cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gNi4gSWYgdGhlIGV4dHJhY3QtdmFsdWUgZmxhZyBpcyBzZXQsIHRoZW4gcmV0dXJuIHZhbHVlLlxuICBpZiAoZXh0cmFjdFZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyA3LiBSZXR1cm4gdGhlIGNvZGUgcG9pbnRzIGZyb20gcG9zaXRpb25TdGFydCB0byBwb3NpdGlvbixcbiAgLy8gaW5jbHVzaXZlLCB3aXRoaW4gaW5wdXQuXG4gIHJldHVybiBpbnB1dC5zbGljZShwb3NpdGlvblN0YXJ0LCBwb3NpdGlvbi5wb3NpdGlvbilcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jc2VyaWFsaXplLWEtbWltZS10eXBlXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFNaW1lVHlwZSAobWltZVR5cGUpIHtcbiAgYXNzZXJ0KG1pbWVUeXBlICE9PSAnZmFpbHVyZScpXG4gIGNvbnN0IHsgcGFyYW1ldGVycywgZXNzZW5jZSB9ID0gbWltZVR5cGVcblxuICAvLyAxLiBMZXQgc2VyaWFsaXphdGlvbiBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBtaW1lVHlwZeKAmXNcbiAgLy8gICAgdHlwZSwgVSswMDJGICgvKSwgYW5kIG1pbWVUeXBl4oCZcyBzdWJ0eXBlLlxuICBsZXQgc2VyaWFsaXphdGlvbiA9IGVzc2VuY2VcblxuICAvLyAyLiBGb3IgZWFjaCBuYW1lIOKGkiB2YWx1ZSBvZiBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyczpcbiAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiBwYXJhbWV0ZXJzLmVudHJpZXMoKSkge1xuICAgIC8vIDEuIEFwcGVuZCBVKzAwM0IgKDspIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSAnOydcblxuICAgIC8vIDIuIEFwcGVuZCBuYW1lIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSBuYW1lXG5cbiAgICAvLyAzLiBBcHBlbmQgVSswMDNEICg9KSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gJz0nXG5cbiAgICAvLyA0LiBJZiB2YWx1ZSBkb2VzIG5vdCBzb2xlbHkgY29udGFpbiBIVFRQIHRva2VuIGNvZGVcbiAgICAvLyAgICBwb2ludHMgb3IgdmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbjpcbiAgICBpZiAoIUhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KHZhbHVlKSkge1xuICAgICAgLy8gMS4gUHJlY2VkZSBlYWNoIG9jY3VyZW5jZSBvZiBVKzAwMjIgKFwiKSBvclxuICAgICAgLy8gICAgVSswMDVDIChcXCkgaW4gdmFsdWUgd2l0aCBVKzAwNUMgKFxcKS5cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvKFxcXFx8XCIpL2csICdcXFxcJDEnKVxuXG4gICAgICAvLyAyLiBQcmVwZW5kIFUrMDAyMiAoXCIpIHRvIHZhbHVlLlxuICAgICAgdmFsdWUgPSAnXCInICsgdmFsdWVcblxuICAgICAgLy8gMy4gQXBwZW5kIFUrMDAyMiAoXCIpIHRvIHZhbHVlLlxuICAgICAgdmFsdWUgKz0gJ1wiJ1xuICAgIH1cblxuICAgIC8vIDUuIEFwcGVuZCB2YWx1ZSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gdmFsdWVcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBzZXJpYWxpemF0aW9uLlxuICByZXR1cm4gc2VyaWFsaXphdGlvblxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtd2hpdGVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNIVFRQV2hpdGVTcGFjZSAoY2hhcikge1xuICByZXR1cm4gY2hhciA9PT0gJ1xccicgfHwgY2hhciA9PT0gJ1xcbicgfHwgY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJyAnXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC13aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUhUVFBXaGl0ZXNwYWNlIChzdHIsIGxlYWRpbmcgPSB0cnVlLCB0cmFpbGluZyA9IHRydWUpIHtcbiAgbGV0IGxlYWQgPSAwXG4gIGxldCB0cmFpbCA9IHN0ci5sZW5ndGggLSAxXG5cbiAgaWYgKGxlYWRpbmcpIHtcbiAgICBmb3IgKDsgbGVhZCA8IHN0ci5sZW5ndGggJiYgaXNIVFRQV2hpdGVTcGFjZShzdHJbbGVhZF0pOyBsZWFkKyspO1xuICB9XG5cbiAgaWYgKHRyYWlsaW5nKSB7XG4gICAgZm9yICg7IHRyYWlsID4gMCAmJiBpc0hUVFBXaGl0ZVNwYWNlKHN0clt0cmFpbF0pOyB0cmFpbC0tKTtcbiAgfVxuXG4gIHJldHVybiBzdHIuc2xpY2UobGVhZCwgdHJhaWwgKyAxKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzQVNDSUlXaGl0ZXNwYWNlIChjaGFyKSB7XG4gIHJldHVybiBjaGFyID09PSAnXFxyJyB8fCBjaGFyID09PSAnXFxuJyB8fCBjaGFyID09PSAnXFx0JyB8fCBjaGFyID09PSAnXFxmJyB8fCBjaGFyID09PSAnICdcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1sZWFkaW5nLWFuZC10cmFpbGluZy1hc2NpaS13aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUFTQ0lJV2hpdGVzcGFjZSAoc3RyLCBsZWFkaW5nID0gdHJ1ZSwgdHJhaWxpbmcgPSB0cnVlKSB7XG4gIGxldCBsZWFkID0gMFxuICBsZXQgdHJhaWwgPSBzdHIubGVuZ3RoIC0gMVxuXG4gIGlmIChsZWFkaW5nKSB7XG4gICAgZm9yICg7IGxlYWQgPCBzdHIubGVuZ3RoICYmIGlzQVNDSUlXaGl0ZXNwYWNlKHN0cltsZWFkXSk7IGxlYWQrKyk7XG4gIH1cblxuICBpZiAodHJhaWxpbmcpIHtcbiAgICBmb3IgKDsgdHJhaWwgPiAwICYmIGlzQVNDSUlXaGl0ZXNwYWNlKHN0clt0cmFpbF0pOyB0cmFpbC0tKTtcbiAgfVxuXG4gIHJldHVybiBzdHIuc2xpY2UobGVhZCwgdHJhaWwgKyAxKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGF0YVVSTFByb2Nlc3NvcixcbiAgVVJMU2VyaWFsaXplcixcbiAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyxcbiAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QsXG4gIHN0cmluZ1BlcmNlbnREZWNvZGUsXG4gIHBhcnNlTUlNRVR5cGUsXG4gIGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcsXG4gIHNlcmlhbGl6ZUFNaW1lVHlwZVxufVxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJhdG9iIiwiaXNvbW9ycGhpY0RlY29kZSIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsIkhUVFBfVE9LRU5fQ09ERVBPSU5UUyIsIkhUVFBfV0hJVEVTUEFDRV9SRUdFWCIsIkhUVFBfUVVPVEVEX1NUUklOR19UT0tFTlMiLCJkYXRhVVJMUHJvY2Vzc29yIiwiZGF0YVVSTCIsInByb3RvY29sIiwiaW5wdXQiLCJVUkxTZXJpYWxpemVyIiwic2xpY2UiLCJwb3NpdGlvbiIsIm1pbWVUeXBlIiwiY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QiLCJtaW1lVHlwZUxlbmd0aCIsImxlbmd0aCIsInJlbW92ZUFTQ0lJV2hpdGVzcGFjZSIsImVuY29kZWRCb2R5IiwiYm9keSIsInN0cmluZ1BlcmNlbnREZWNvZGUiLCJ0ZXN0Iiwic3RyaW5nQm9keSIsImZvcmdpdmluZ0Jhc2U2NCIsInJlcGxhY2UiLCJzdGFydHNXaXRoIiwibWltZVR5cGVSZWNvcmQiLCJwYXJzZU1JTUVUeXBlIiwidXJsIiwiZXhjbHVkZUZyYWdtZW50IiwiaHJlZiIsImhhc2giLCJsYXN0SW5kZXhPZiIsImNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMiLCJjb25kaXRpb24iLCJyZXN1bHQiLCJjaGFyIiwiaWR4IiwiaW5kZXhPZiIsInN0YXJ0IiwiYnl0ZXMiLCJlbmNvZGUiLCJwZXJjZW50RGVjb2RlIiwib3V0cHV0IiwiaSIsImJ5dGUiLCJwdXNoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibmV4dFR3b0J5dGVzIiwiYnl0ZVBvaW50IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJVaW50OEFycmF5IiwiZnJvbSIsInJlbW92ZUhUVFBXaGl0ZXNwYWNlIiwidHlwZSIsInN1YnR5cGUiLCJ0eXBlTG93ZXJjYXNlIiwidG9Mb3dlckNhc2UiLCJzdWJ0eXBlTG93ZXJjYXNlIiwicGFyYW1ldGVycyIsIk1hcCIsImVzc2VuY2UiLCJwYXJhbWV0ZXJOYW1lIiwicGFyYW1ldGVyVmFsdWUiLCJjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nIiwiaGFzIiwic2V0IiwiZGF0YSIsImJpbmFyeSIsImNoYXJDb2RlQXQiLCJleHRyYWN0VmFsdWUiLCJwb3NpdGlvblN0YXJ0IiwidmFsdWUiLCJxdW90ZU9yQmFja3NsYXNoIiwic2VyaWFsaXplQU1pbWVUeXBlIiwic2VyaWFsaXphdGlvbiIsIm5hbWUiLCJlbnRyaWVzIiwiaXNIVFRQV2hpdGVTcGFjZSIsInN0ciIsImxlYWRpbmciLCJ0cmFpbGluZyIsImxlYWQiLCJ0cmFpbCIsImlzQVNDSUlXaGl0ZXNwYWNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/dataURL.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/file.js":
/*!***************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/file.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Blob, File: NativeFile } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { types } = __webpack_require__(/*! util */ \"util\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/fetch/symbols.js\");\nconst { isBlobLike } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/fetch/util.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./dataURL */ \"(rsc)/../../node_modules/undici/lib/fetch/dataURL.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst encoder = new TextEncoder();\nclass File extends Blob {\n    constructor(fileBits, fileName, options = {}){\n        // The File constructor is invoked with two or three parameters, depending\n        // on whether the optional dictionary parameter is used. When the File()\n        // constructor is invoked, user agents must run the following steps:\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"File constructor\"\n        });\n        fileBits = webidl.converters[\"sequence<BlobPart>\"](fileBits);\n        fileName = webidl.converters.USVString(fileName);\n        options = webidl.converters.FilePropertyBag(options);\n        // 1. Let bytes be the result of processing blob parts given fileBits and\n        // options.\n        // Note: Blob handles this for us\n        // 2. Let n be the fileName argument to the constructor.\n        const n = fileName;\n        // 3. Process FilePropertyBag dictionary argument by running the following\n        // substeps:\n        //    1. If the type member is provided and is not the empty string, let t\n        //    be set to the type dictionary member. If t contains any characters\n        //    outside the range U+0020 to U+007E, then set t to the empty string\n        //    and return from these substeps.\n        //    2. Convert every character in t to ASCII lowercase.\n        let t = options.type;\n        let d;\n        // eslint-disable-next-line no-labels\n        substep: {\n            if (t) {\n                t = parseMIMEType(t);\n                if (t === \"failure\") {\n                    t = \"\";\n                    break substep;\n                }\n                t = serializeAMimeType(t).toLowerCase();\n            }\n            //    3. If the lastModified member is provided, let d be set to the\n            //    lastModified dictionary member. If it is not provided, set d to the\n            //    current date and time represented as the number of milliseconds since\n            //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n            d = options.lastModified;\n        }\n        // 4. Return a new File object F such that:\n        // F refers to the bytes byte sequence.\n        // F.size is set to the number of total bytes in bytes.\n        // F.name is set to n.\n        // F.type is set to t.\n        // F.lastModified is set to d.\n        super(processBlobParts(fileBits, options), {\n            type: t\n        });\n        this[kState] = {\n            name: n,\n            lastModified: d,\n            type: t\n        };\n    }\n    get name() {\n        webidl.brandCheck(this, File);\n        return this[kState].name;\n    }\n    get lastModified() {\n        webidl.brandCheck(this, File);\n        return this[kState].lastModified;\n    }\n    get type() {\n        webidl.brandCheck(this, File);\n        return this[kState].type;\n    }\n}\nclass FileLike {\n    constructor(blobLike, fileName, options = {}){\n        // TODO: argument idl type check\n        // The File constructor is invoked with two or three parameters, depending\n        // on whether the optional dictionary parameter is used. When the File()\n        // constructor is invoked, user agents must run the following steps:\n        // 1. Let bytes be the result of processing blob parts given fileBits and\n        // options.\n        // 2. Let n be the fileName argument to the constructor.\n        const n = fileName;\n        // 3. Process FilePropertyBag dictionary argument by running the following\n        // substeps:\n        //    1. If the type member is provided and is not the empty string, let t\n        //    be set to the type dictionary member. If t contains any characters\n        //    outside the range U+0020 to U+007E, then set t to the empty string\n        //    and return from these substeps.\n        //    TODO\n        const t = options.type;\n        //    2. Convert every character in t to ASCII lowercase.\n        //    TODO\n        //    3. If the lastModified member is provided, let d be set to the\n        //    lastModified dictionary member. If it is not provided, set d to the\n        //    current date and time represented as the number of milliseconds since\n        //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n        const d = options.lastModified ?? Date.now();\n        // 4. Return a new File object F such that:\n        // F refers to the bytes byte sequence.\n        // F.size is set to the number of total bytes in bytes.\n        // F.name is set to n.\n        // F.type is set to t.\n        // F.lastModified is set to d.\n        this[kState] = {\n            blobLike,\n            name: n,\n            type: t,\n            lastModified: d\n        };\n    }\n    stream(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.stream(...args);\n    }\n    arrayBuffer(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.arrayBuffer(...args);\n    }\n    slice(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.slice(...args);\n    }\n    text(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.text(...args);\n    }\n    get size() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.size;\n    }\n    get type() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.type;\n    }\n    get name() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].name;\n    }\n    get lastModified() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].lastModified;\n    }\n    get [Symbol.toStringTag]() {\n        return \"File\";\n    }\n}\nObject.defineProperties(File.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"File\",\n        configurable: true\n    },\n    name: kEnumerableProperty,\n    lastModified: kEnumerableProperty\n});\nwebidl.converters.Blob = webidl.interfaceConverter(Blob);\nwebidl.converters.BlobPart = function(V, opts) {\n    if (webidl.util.Type(V) === \"Object\") {\n        if (isBlobLike(V)) {\n            return webidl.converters.Blob(V, {\n                strict: false\n            });\n        }\n        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n            return webidl.converters.BufferSource(V, opts);\n        }\n    }\n    return webidl.converters.USVString(V, opts);\n};\nwebidl.converters[\"sequence<BlobPart>\"] = webidl.sequenceConverter(webidl.converters.BlobPart);\n// https://www.w3.org/TR/FileAPI/#dfn-FilePropertyBag\nwebidl.converters.FilePropertyBag = webidl.dictionaryConverter([\n    {\n        key: \"lastModified\",\n        converter: webidl.converters[\"long long\"],\n        get defaultValue () {\n            return Date.now();\n        }\n    },\n    {\n        key: \"type\",\n        converter: webidl.converters.DOMString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"endings\",\n        converter: (value)=>{\n            value = webidl.converters.DOMString(value);\n            value = value.toLowerCase();\n            if (value !== \"native\") {\n                value = \"transparent\";\n            }\n            return value;\n        },\n        defaultValue: \"transparent\"\n    }\n]);\n/**\n * @see https://www.w3.org/TR/FileAPI/#process-blob-parts\n * @param {(NodeJS.TypedArray|Blob|string)[]} parts\n * @param {{ type: string, endings: string }} options\n */ function processBlobParts(parts, options) {\n    // 1. Let bytes be an empty sequence of bytes.\n    /** @type {NodeJS.TypedArray[]} */ const bytes = [];\n    // 2. For each element in parts:\n    for (const element of parts){\n        // 1. If element is a USVString, run the following substeps:\n        if (typeof element === \"string\") {\n            // 1. Let s be element.\n            let s = element;\n            // 2. If the endings member of options is \"native\", set s\n            //    to the result of converting line endings to native\n            //    of element.\n            if (options.endings === \"native\") {\n                s = convertLineEndingsNative(s);\n            }\n            // 3. Append the result of UTF-8 encoding s to bytes.\n            bytes.push(encoder.encode(s));\n        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {\n            // 2. If element is a BufferSource, get a copy of the\n            //    bytes held by the buffer source, and append those\n            //    bytes to bytes.\n            if (!element.buffer) {\n                bytes.push(new Uint8Array(element));\n            } else {\n                bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));\n            }\n        } else if (isBlobLike(element)) {\n            // 3. If element is a Blob, append the bytes it represents\n            //    to bytes.\n            bytes.push(element);\n        }\n    }\n    // 3. Return bytes.\n    return bytes;\n}\n/**\n * @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native\n * @param {string} s\n */ function convertLineEndingsNative(s) {\n    // 1. Let native line ending be be the code point U+000A LF.\n    let nativeLineEnding = \"\\n\";\n    // 2. If the underlying platforms conventions are to\n    //    represent newlines as a carriage return and line feed\n    //    sequence, set native line ending to the code point\n    //    U+000D CR followed by the code point U+000A LF.\n    if (process.platform === \"win32\") {\n        nativeLineEnding = \"\\r\\n\";\n    }\n    return s.replace(/\\r?\\n/g, nativeLineEnding);\n}\n// If this function is moved to ./util.js, some tools (such as\n// rollup) will warn about circular dependencies. See:\n// https://github.com/nodejs/undici/issues/1629\nfunction isFileLike(object) {\n    return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && object[Symbol.toStringTag] === \"File\";\n}\nmodule.exports = {\n    File,\n    FileLike,\n    isFileLike\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsSUFBSSxFQUFFQyxNQUFNQyxVQUFVLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDM0MsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDMUIsTUFBTSxFQUFFRSxNQUFNLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFRyxVQUFVLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFFSSxNQUFNLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFSyxhQUFhLEVBQUVDLGtCQUFrQixFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ3RELE1BQU0sRUFBRU8sbUJBQW1CLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDeEMsTUFBTVEsVUFBVSxJQUFJQztBQUVwQixNQUFNWCxhQUFhRDtJQUNqQmEsWUFBYUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDN0MsMEVBQTBFO1FBQzFFLHdFQUF3RTtRQUN4RSxvRUFBb0U7UUFDcEVULE9BQU9VLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7WUFBRUMsUUFBUTtRQUFtQjtRQUV0RUwsV0FBV1AsT0FBT2EsVUFBVSxDQUFDLHFCQUFxQixDQUFDTjtRQUNuREMsV0FBV1IsT0FBT2EsVUFBVSxDQUFDQyxTQUFTLENBQUNOO1FBQ3ZDQyxVQUFVVCxPQUFPYSxVQUFVLENBQUNFLGVBQWUsQ0FBQ047UUFFNUMseUVBQXlFO1FBQ3pFLFdBQVc7UUFDWCxpQ0FBaUM7UUFFakMsd0RBQXdEO1FBQ3hELE1BQU1PLElBQUlSO1FBRVYsMEVBQTBFO1FBQzFFLFlBQVk7UUFFWiwwRUFBMEU7UUFDMUUsd0VBQXdFO1FBQ3hFLHdFQUF3RTtRQUN4RSxxQ0FBcUM7UUFDckMseURBQXlEO1FBQ3pELElBQUlTLElBQUlSLFFBQVFTLElBQUk7UUFDcEIsSUFBSUM7UUFFSixxQ0FBcUM7UUFDckNDLFNBQVM7WUFDUCxJQUFJSCxHQUFHO2dCQUNMQSxJQUFJaEIsY0FBY2dCO2dCQUVsQixJQUFJQSxNQUFNLFdBQVc7b0JBQ25CQSxJQUFJO29CQUVKLE1BQU1HO2dCQUNSO2dCQUVBSCxJQUFJZixtQkFBbUJlLEdBQUdJLFdBQVc7WUFDdkM7WUFFQSxvRUFBb0U7WUFDcEUseUVBQXlFO1lBQ3pFLDJFQUEyRTtZQUMzRSx3RUFBd0U7WUFDeEVGLElBQUlWLFFBQVFhLFlBQVk7UUFDMUI7UUFFQSwyQ0FBMkM7UUFDM0MsdUNBQXVDO1FBQ3ZDLHVEQUF1RDtRQUN2RCxzQkFBc0I7UUFDdEIsc0JBQXNCO1FBQ3RCLDhCQUE4QjtRQUU5QixLQUFLLENBQUNDLGlCQUFpQmhCLFVBQVVFLFVBQVU7WUFBRVMsTUFBTUQ7UUFBRTtRQUNyRCxJQUFJLENBQUNuQixPQUFPLEdBQUc7WUFDYjBCLE1BQU1SO1lBQ05NLGNBQWNIO1lBQ2RELE1BQU1EO1FBQ1I7SUFDRjtJQUVBLElBQUlPLE9BQVE7UUFDVnhCLE9BQU95QixVQUFVLENBQUMsSUFBSSxFQUFFL0I7UUFFeEIsT0FBTyxJQUFJLENBQUNJLE9BQU8sQ0FBQzBCLElBQUk7SUFDMUI7SUFFQSxJQUFJRixlQUFnQjtRQUNsQnRCLE9BQU95QixVQUFVLENBQUMsSUFBSSxFQUFFL0I7UUFFeEIsT0FBTyxJQUFJLENBQUNJLE9BQU8sQ0FBQ3dCLFlBQVk7SUFDbEM7SUFFQSxJQUFJSixPQUFRO1FBQ1ZsQixPQUFPeUIsVUFBVSxDQUFDLElBQUksRUFBRS9CO1FBRXhCLE9BQU8sSUFBSSxDQUFDSSxPQUFPLENBQUNvQixJQUFJO0lBQzFCO0FBQ0Y7QUFFQSxNQUFNUTtJQUNKcEIsWUFBYXFCLFFBQVEsRUFBRW5CLFFBQVEsRUFBRUMsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUM3QyxnQ0FBZ0M7UUFFaEMsMEVBQTBFO1FBQzFFLHdFQUF3RTtRQUN4RSxvRUFBb0U7UUFFcEUseUVBQXlFO1FBQ3pFLFdBQVc7UUFFWCx3REFBd0Q7UUFDeEQsTUFBTU8sSUFBSVI7UUFFViwwRUFBMEU7UUFDMUUsWUFBWTtRQUVaLDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUsd0VBQXdFO1FBQ3hFLHFDQUFxQztRQUNyQyxVQUFVO1FBQ1YsTUFBTVMsSUFBSVIsUUFBUVMsSUFBSTtRQUV0Qix5REFBeUQ7UUFDekQsVUFBVTtRQUVWLG9FQUFvRTtRQUNwRSx5RUFBeUU7UUFDekUsMkVBQTJFO1FBQzNFLHdFQUF3RTtRQUN4RSxNQUFNQyxJQUFJVixRQUFRYSxZQUFZLElBQUlNLEtBQUtDLEdBQUc7UUFFMUMsMkNBQTJDO1FBQzNDLHVDQUF1QztRQUN2Qyx1REFBdUQ7UUFDdkQsc0JBQXNCO1FBQ3RCLHNCQUFzQjtRQUN0Qiw4QkFBOEI7UUFFOUIsSUFBSSxDQUFDL0IsT0FBTyxHQUFHO1lBQ2I2QjtZQUNBSCxNQUFNUjtZQUNORSxNQUFNRDtZQUNOSyxjQUFjSDtRQUNoQjtJQUNGO0lBRUFXLE9BQVEsR0FBR0MsSUFBSSxFQUFFO1FBQ2YvQixPQUFPeUIsVUFBVSxDQUFDLElBQUksRUFBRUM7UUFFeEIsT0FBTyxJQUFJLENBQUM1QixPQUFPLENBQUM2QixRQUFRLENBQUNHLE1BQU0sSUFBSUM7SUFDekM7SUFFQUMsWUFBYSxHQUFHRCxJQUFJLEVBQUU7UUFDcEIvQixPQUFPeUIsVUFBVSxDQUFDLElBQUksRUFBRUM7UUFFeEIsT0FBTyxJQUFJLENBQUM1QixPQUFPLENBQUM2QixRQUFRLENBQUNLLFdBQVcsSUFBSUQ7SUFDOUM7SUFFQUUsTUFBTyxHQUFHRixJQUFJLEVBQUU7UUFDZC9CLE9BQU95QixVQUFVLENBQUMsSUFBSSxFQUFFQztRQUV4QixPQUFPLElBQUksQ0FBQzVCLE9BQU8sQ0FBQzZCLFFBQVEsQ0FBQ00sS0FBSyxJQUFJRjtJQUN4QztJQUVBRyxLQUFNLEdBQUdILElBQUksRUFBRTtRQUNiL0IsT0FBT3lCLFVBQVUsQ0FBQyxJQUFJLEVBQUVDO1FBRXhCLE9BQU8sSUFBSSxDQUFDNUIsT0FBTyxDQUFDNkIsUUFBUSxDQUFDTyxJQUFJLElBQUlIO0lBQ3ZDO0lBRUEsSUFBSUksT0FBUTtRQUNWbkMsT0FBT3lCLFVBQVUsQ0FBQyxJQUFJLEVBQUVDO1FBRXhCLE9BQU8sSUFBSSxDQUFDNUIsT0FBTyxDQUFDNkIsUUFBUSxDQUFDUSxJQUFJO0lBQ25DO0lBRUEsSUFBSWpCLE9BQVE7UUFDVmxCLE9BQU95QixVQUFVLENBQUMsSUFBSSxFQUFFQztRQUV4QixPQUFPLElBQUksQ0FBQzVCLE9BQU8sQ0FBQzZCLFFBQVEsQ0FBQ1QsSUFBSTtJQUNuQztJQUVBLElBQUlNLE9BQVE7UUFDVnhCLE9BQU95QixVQUFVLENBQUMsSUFBSSxFQUFFQztRQUV4QixPQUFPLElBQUksQ0FBQzVCLE9BQU8sQ0FBQzBCLElBQUk7SUFDMUI7SUFFQSxJQUFJRixlQUFnQjtRQUNsQnRCLE9BQU95QixVQUFVLENBQUMsSUFBSSxFQUFFQztRQUV4QixPQUFPLElBQUksQ0FBQzVCLE9BQU8sQ0FBQ3dCLFlBQVk7SUFDbEM7SUFFQSxJQUFJLENBQUNjLE9BQU9DLFdBQVcsQ0FBQyxHQUFJO1FBQzFCLE9BQU87SUFDVDtBQUNGO0FBRUFDLE9BQU9DLGdCQUFnQixDQUFDN0MsS0FBSzhDLFNBQVMsRUFBRTtJQUN0QyxDQUFDSixPQUFPQyxXQUFXLENBQUMsRUFBRTtRQUNwQkksT0FBTztRQUNQQyxjQUFjO0lBQ2hCO0lBQ0FsQixNQUFNckI7SUFDTm1CLGNBQWNuQjtBQUNoQjtBQUVBSCxPQUFPYSxVQUFVLENBQUNwQixJQUFJLEdBQUdPLE9BQU8yQyxrQkFBa0IsQ0FBQ2xEO0FBRW5ETyxPQUFPYSxVQUFVLENBQUMrQixRQUFRLEdBQUcsU0FBVUMsQ0FBQyxFQUFFQyxJQUFJO0lBQzVDLElBQUk5QyxPQUFPK0MsSUFBSSxDQUFDQyxJQUFJLENBQUNILE9BQU8sVUFBVTtRQUNwQyxJQUFJOUMsV0FBVzhDLElBQUk7WUFDakIsT0FBTzdDLE9BQU9hLFVBQVUsQ0FBQ3BCLElBQUksQ0FBQ29ELEdBQUc7Z0JBQUVJLFFBQVE7WUFBTTtRQUNuRDtRQUVBLElBQ0VDLFlBQVlDLE1BQU0sQ0FBQ04sTUFDbkJoRCxNQUFNdUQsZ0JBQWdCLENBQUNQLElBQ3ZCO1lBQ0EsT0FBTzdDLE9BQU9hLFVBQVUsQ0FBQ3dDLFlBQVksQ0FBQ1IsR0FBR0M7UUFDM0M7SUFDRjtJQUVBLE9BQU85QyxPQUFPYSxVQUFVLENBQUNDLFNBQVMsQ0FBQytCLEdBQUdDO0FBQ3hDO0FBRUE5QyxPQUFPYSxVQUFVLENBQUMscUJBQXFCLEdBQUdiLE9BQU9zRCxpQkFBaUIsQ0FDaEV0RCxPQUFPYSxVQUFVLENBQUMrQixRQUFRO0FBRzVCLHFEQUFxRDtBQUNyRDVDLE9BQU9hLFVBQVUsQ0FBQ0UsZUFBZSxHQUFHZixPQUFPdUQsbUJBQW1CLENBQUM7SUFDN0Q7UUFDRUMsS0FBSztRQUNMQyxXQUFXekQsT0FBT2EsVUFBVSxDQUFDLFlBQVk7UUFDekMsSUFBSTZDLGdCQUFnQjtZQUNsQixPQUFPOUIsS0FBS0MsR0FBRztRQUNqQjtJQUNGO0lBQ0E7UUFDRTJCLEtBQUs7UUFDTEMsV0FBV3pELE9BQU9hLFVBQVUsQ0FBQzhDLFNBQVM7UUFDdENELGNBQWM7SUFDaEI7SUFDQTtRQUNFRixLQUFLO1FBQ0xDLFdBQVcsQ0FBQ2hCO1lBQ1ZBLFFBQVF6QyxPQUFPYSxVQUFVLENBQUM4QyxTQUFTLENBQUNsQjtZQUNwQ0EsUUFBUUEsTUFBTXBCLFdBQVc7WUFFekIsSUFBSW9CLFVBQVUsVUFBVTtnQkFDdEJBLFFBQVE7WUFDVjtZQUVBLE9BQU9BO1FBQ1Q7UUFDQWlCLGNBQWM7SUFDaEI7Q0FDRDtBQUVEOzs7O0NBSUMsR0FDRCxTQUFTbkMsaUJBQWtCcUMsS0FBSyxFQUFFbkQsT0FBTztJQUN2Qyw4Q0FBOEM7SUFDOUMsZ0NBQWdDLEdBQ2hDLE1BQU1vRCxRQUFRLEVBQUU7SUFFaEIsZ0NBQWdDO0lBQ2hDLEtBQUssTUFBTUMsV0FBV0YsTUFBTztRQUMzQiw0REFBNEQ7UUFDNUQsSUFBSSxPQUFPRSxZQUFZLFVBQVU7WUFDL0IsdUJBQXVCO1lBQ3ZCLElBQUlDLElBQUlEO1lBRVIseURBQXlEO1lBQ3pELHdEQUF3RDtZQUN4RCxpQkFBaUI7WUFDakIsSUFBSXJELFFBQVF1RCxPQUFPLEtBQUssVUFBVTtnQkFDaENELElBQUlFLHlCQUF5QkY7WUFDL0I7WUFFQSxxREFBcUQ7WUFDckRGLE1BQU1LLElBQUksQ0FBQzlELFFBQVErRCxNQUFNLENBQUNKO1FBQzVCLE9BQU8sSUFDTGxFLE1BQU11RCxnQkFBZ0IsQ0FBQ1UsWUFDdkJqRSxNQUFNdUUsWUFBWSxDQUFDTixVQUNuQjtZQUNBLHFEQUFxRDtZQUNyRCx1REFBdUQ7WUFDdkQscUJBQXFCO1lBQ3JCLElBQUksQ0FBQ0EsUUFBUU8sTUFBTSxFQUFFO2dCQUNuQlIsTUFBTUssSUFBSSxDQUFDLElBQUlJLFdBQVdSO1lBQzVCLE9BQU87Z0JBQ0xELE1BQU1LLElBQUksQ0FDUixJQUFJSSxXQUFXUixRQUFRTyxNQUFNLEVBQUVQLFFBQVFTLFVBQVUsRUFBRVQsUUFBUVUsVUFBVTtZQUV6RTtRQUNGLE9BQU8sSUFBSXpFLFdBQVcrRCxVQUFVO1lBQzlCLDBEQUEwRDtZQUMxRCxlQUFlO1lBQ2ZELE1BQU1LLElBQUksQ0FBQ0o7UUFDYjtJQUNGO0lBRUEsbUJBQW1CO0lBQ25CLE9BQU9EO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxTQUFTSSx5QkFBMEJGLENBQUM7SUFDbEMsNERBQTREO0lBQzVELElBQUlVLG1CQUFtQjtJQUV2QixxREFBcUQ7SUFDckQsMkRBQTJEO0lBQzNELHdEQUF3RDtJQUN4RCxxREFBcUQ7SUFDckQsSUFBSUMsUUFBUUMsUUFBUSxLQUFLLFNBQVM7UUFDaENGLG1CQUFtQjtJQUNyQjtJQUVBLE9BQU9WLEVBQUVhLE9BQU8sQ0FBQyxVQUFVSDtBQUM3QjtBQUVBLDhEQUE4RDtBQUM5RCxzREFBc0Q7QUFDdEQsK0NBQStDO0FBQy9DLFNBQVNJLFdBQVlDLE1BQU07SUFDekIsT0FDRSxjQUFlQSxrQkFBa0JuRixjQUNqQ21GLGtCQUFrQnBGLFFBQ2hCb0YsVUFDQyxRQUFPQSxPQUFPaEQsTUFBTSxLQUFLLGNBQzFCLE9BQU9nRCxPQUFPOUMsV0FBVyxLQUFLLFVBQVMsS0FDdkM4QyxNQUFNLENBQUMxQyxPQUFPQyxXQUFXLENBQUMsS0FBSztBQUdyQztBQUVBMEMsT0FBT0MsT0FBTyxHQUFHO0lBQUV0RjtJQUFNZ0M7SUFBVW1EO0FBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2ZpbGUuanM/OTJjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCbG9iLCBGaWxlOiBOYXRpdmVGaWxlIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyB0eXBlcyB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCB7IGtTdGF0ZSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgaXNCbG9iTGlrZSB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IHBhcnNlTUlNRVR5cGUsIHNlcmlhbGl6ZUFNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhVVJMJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuXG5jbGFzcyBGaWxlIGV4dGVuZHMgQmxvYiB7XG4gIGNvbnN0cnVjdG9yIChmaWxlQml0cywgZmlsZU5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIFRoZSBGaWxlIGNvbnN0cnVjdG9yIGlzIGludm9rZWQgd2l0aCB0d28gb3IgdGhyZWUgcGFyYW1ldGVycywgZGVwZW5kaW5nXG4gICAgLy8gb24gd2hldGhlciB0aGUgb3B0aW9uYWwgZGljdGlvbmFyeSBwYXJhbWV0ZXIgaXMgdXNlZC4gV2hlbiB0aGUgRmlsZSgpXG4gICAgLy8gY29uc3RydWN0b3IgaXMgaW52b2tlZCwgdXNlciBhZ2VudHMgbXVzdCBydW4gdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnRmlsZSBjb25zdHJ1Y3RvcicgfSlcblxuICAgIGZpbGVCaXRzID0gd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPEJsb2JQYXJ0PiddKGZpbGVCaXRzKVxuICAgIGZpbGVOYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKGZpbGVOYW1lKVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5GaWxlUHJvcGVydHlCYWcob3B0aW9ucylcblxuICAgIC8vIDEuIExldCBieXRlcyBiZSB0aGUgcmVzdWx0IG9mIHByb2Nlc3NpbmcgYmxvYiBwYXJ0cyBnaXZlbiBmaWxlQml0cyBhbmRcbiAgICAvLyBvcHRpb25zLlxuICAgIC8vIE5vdGU6IEJsb2IgaGFuZGxlcyB0aGlzIGZvciB1c1xuXG4gICAgLy8gMi4gTGV0IG4gYmUgdGhlIGZpbGVOYW1lIGFyZ3VtZW50IHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICBjb25zdCBuID0gZmlsZU5hbWVcblxuICAgIC8vIDMuIFByb2Nlc3MgRmlsZVByb3BlcnR5QmFnIGRpY3Rpb25hcnkgYXJndW1lbnQgYnkgcnVubmluZyB0aGUgZm9sbG93aW5nXG4gICAgLy8gc3Vic3RlcHM6XG5cbiAgICAvLyAgICAxLiBJZiB0aGUgdHlwZSBtZW1iZXIgaXMgcHJvdmlkZWQgYW5kIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgdFxuICAgIC8vICAgIGJlIHNldCB0byB0aGUgdHlwZSBkaWN0aW9uYXJ5IG1lbWJlci4gSWYgdCBjb250YWlucyBhbnkgY2hhcmFjdGVyc1xuICAgIC8vICAgIG91dHNpZGUgdGhlIHJhbmdlIFUrMDAyMCB0byBVKzAwN0UsIHRoZW4gc2V0IHQgdG8gdGhlIGVtcHR5IHN0cmluZ1xuICAgIC8vICAgIGFuZCByZXR1cm4gZnJvbSB0aGVzZSBzdWJzdGVwcy5cbiAgICAvLyAgICAyLiBDb252ZXJ0IGV2ZXJ5IGNoYXJhY3RlciBpbiB0IHRvIEFTQ0lJIGxvd2VyY2FzZS5cbiAgICBsZXQgdCA9IG9wdGlvbnMudHlwZVxuICAgIGxldCBkXG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gICAgc3Vic3RlcDoge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdCA9IHBhcnNlTUlNRVR5cGUodClcblxuICAgICAgICBpZiAodCA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgdCA9ICcnXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgIGJyZWFrIHN1YnN0ZXBcbiAgICAgICAgfVxuXG4gICAgICAgIHQgPSBzZXJpYWxpemVBTWltZVR5cGUodCkudG9Mb3dlckNhc2UoKVxuICAgICAgfVxuXG4gICAgICAvLyAgICAzLiBJZiB0aGUgbGFzdE1vZGlmaWVkIG1lbWJlciBpcyBwcm92aWRlZCwgbGV0IGQgYmUgc2V0IHRvIHRoZVxuICAgICAgLy8gICAgbGFzdE1vZGlmaWVkIGRpY3Rpb25hcnkgbWVtYmVyLiBJZiBpdCBpcyBub3QgcHJvdmlkZWQsIHNldCBkIHRvIHRoZVxuICAgICAgLy8gICAgY3VycmVudCBkYXRlIGFuZCB0aW1lIHJlcHJlc2VudGVkIGFzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlXG4gICAgICAvLyAgICB0aGUgVW5peCBFcG9jaCAod2hpY2ggaXMgdGhlIGVxdWl2YWxlbnQgb2YgRGF0ZS5ub3coKSBbRUNNQS0yNjJdKS5cbiAgICAgIGQgPSBvcHRpb25zLmxhc3RNb2RpZmllZFxuICAgIH1cblxuICAgIC8vIDQuIFJldHVybiBhIG5ldyBGaWxlIG9iamVjdCBGIHN1Y2ggdGhhdDpcbiAgICAvLyBGIHJlZmVycyB0byB0aGUgYnl0ZXMgYnl0ZSBzZXF1ZW5jZS5cbiAgICAvLyBGLnNpemUgaXMgc2V0IHRvIHRoZSBudW1iZXIgb2YgdG90YWwgYnl0ZXMgaW4gYnl0ZXMuXG4gICAgLy8gRi5uYW1lIGlzIHNldCB0byBuLlxuICAgIC8vIEYudHlwZSBpcyBzZXQgdG8gdC5cbiAgICAvLyBGLmxhc3RNb2RpZmllZCBpcyBzZXQgdG8gZC5cblxuICAgIHN1cGVyKHByb2Nlc3NCbG9iUGFydHMoZmlsZUJpdHMsIG9wdGlvbnMpLCB7IHR5cGU6IHQgfSlcbiAgICB0aGlzW2tTdGF0ZV0gPSB7XG4gICAgICBuYW1lOiBuLFxuICAgICAgbGFzdE1vZGlmaWVkOiBkLFxuICAgICAgdHlwZTogdFxuICAgIH1cbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5uYW1lXG4gIH1cblxuICBnZXQgbGFzdE1vZGlmaWVkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5sYXN0TW9kaWZpZWRcbiAgfVxuXG4gIGdldCB0eXBlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS50eXBlXG4gIH1cbn1cblxuY2xhc3MgRmlsZUxpa2Uge1xuICBjb25zdHJ1Y3RvciAoYmxvYkxpa2UsIGZpbGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBUT0RPOiBhcmd1bWVudCBpZGwgdHlwZSBjaGVja1xuXG4gICAgLy8gVGhlIEZpbGUgY29uc3RydWN0b3IgaXMgaW52b2tlZCB3aXRoIHR3byBvciB0aHJlZSBwYXJhbWV0ZXJzLCBkZXBlbmRpbmdcbiAgICAvLyBvbiB3aGV0aGVyIHRoZSBvcHRpb25hbCBkaWN0aW9uYXJ5IHBhcmFtZXRlciBpcyB1c2VkLiBXaGVuIHRoZSBGaWxlKClcbiAgICAvLyBjb25zdHJ1Y3RvciBpcyBpbnZva2VkLCB1c2VyIGFnZW50cyBtdXN0IHJ1biB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuXG4gICAgLy8gMS4gTGV0IGJ5dGVzIGJlIHRoZSByZXN1bHQgb2YgcHJvY2Vzc2luZyBibG9iIHBhcnRzIGdpdmVuIGZpbGVCaXRzIGFuZFxuICAgIC8vIG9wdGlvbnMuXG5cbiAgICAvLyAyLiBMZXQgbiBiZSB0aGUgZmlsZU5hbWUgYXJndW1lbnQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgIGNvbnN0IG4gPSBmaWxlTmFtZVxuXG4gICAgLy8gMy4gUHJvY2VzcyBGaWxlUHJvcGVydHlCYWcgZGljdGlvbmFyeSBhcmd1bWVudCBieSBydW5uaW5nIHRoZSBmb2xsb3dpbmdcbiAgICAvLyBzdWJzdGVwczpcblxuICAgIC8vICAgIDEuIElmIHRoZSB0eXBlIG1lbWJlciBpcyBwcm92aWRlZCBhbmQgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCB0XG4gICAgLy8gICAgYmUgc2V0IHRvIHRoZSB0eXBlIGRpY3Rpb25hcnkgbWVtYmVyLiBJZiB0IGNvbnRhaW5zIGFueSBjaGFyYWN0ZXJzXG4gICAgLy8gICAgb3V0c2lkZSB0aGUgcmFuZ2UgVSswMDIwIHRvIFUrMDA3RSwgdGhlbiBzZXQgdCB0byB0aGUgZW1wdHkgc3RyaW5nXG4gICAgLy8gICAgYW5kIHJldHVybiBmcm9tIHRoZXNlIHN1YnN0ZXBzLlxuICAgIC8vICAgIFRPRE9cbiAgICBjb25zdCB0ID0gb3B0aW9ucy50eXBlXG5cbiAgICAvLyAgICAyLiBDb252ZXJ0IGV2ZXJ5IGNoYXJhY3RlciBpbiB0IHRvIEFTQ0lJIGxvd2VyY2FzZS5cbiAgICAvLyAgICBUT0RPXG5cbiAgICAvLyAgICAzLiBJZiB0aGUgbGFzdE1vZGlmaWVkIG1lbWJlciBpcyBwcm92aWRlZCwgbGV0IGQgYmUgc2V0IHRvIHRoZVxuICAgIC8vICAgIGxhc3RNb2RpZmllZCBkaWN0aW9uYXJ5IG1lbWJlci4gSWYgaXQgaXMgbm90IHByb3ZpZGVkLCBzZXQgZCB0byB0aGVcbiAgICAvLyAgICBjdXJyZW50IGRhdGUgYW5kIHRpbWUgcmVwcmVzZW50ZWQgYXMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2VcbiAgICAvLyAgICB0aGUgVW5peCBFcG9jaCAod2hpY2ggaXMgdGhlIGVxdWl2YWxlbnQgb2YgRGF0ZS5ub3coKSBbRUNNQS0yNjJdKS5cbiAgICBjb25zdCBkID0gb3B0aW9ucy5sYXN0TW9kaWZpZWQgPz8gRGF0ZS5ub3coKVxuXG4gICAgLy8gNC4gUmV0dXJuIGEgbmV3IEZpbGUgb2JqZWN0IEYgc3VjaCB0aGF0OlxuICAgIC8vIEYgcmVmZXJzIHRvIHRoZSBieXRlcyBieXRlIHNlcXVlbmNlLlxuICAgIC8vIEYuc2l6ZSBpcyBzZXQgdG8gdGhlIG51bWJlciBvZiB0b3RhbCBieXRlcyBpbiBieXRlcy5cbiAgICAvLyBGLm5hbWUgaXMgc2V0IHRvIG4uXG4gICAgLy8gRi50eXBlIGlzIHNldCB0byB0LlxuICAgIC8vIEYubGFzdE1vZGlmaWVkIGlzIHNldCB0byBkLlxuXG4gICAgdGhpc1trU3RhdGVdID0ge1xuICAgICAgYmxvYkxpa2UsXG4gICAgICBuYW1lOiBuLFxuICAgICAgdHlwZTogdCxcbiAgICAgIGxhc3RNb2RpZmllZDogZFxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbSAoLi4uYXJncykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5zdHJlYW0oLi4uYXJncylcbiAgfVxuXG4gIGFycmF5QnVmZmVyICguLi5hcmdzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLmFycmF5QnVmZmVyKC4uLmFyZ3MpXG4gIH1cblxuICBzbGljZSAoLi4uYXJncykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5zbGljZSguLi5hcmdzKVxuICB9XG5cbiAgdGV4dCAoLi4uYXJncykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS50ZXh0KC4uLmFyZ3MpXG4gIH1cblxuICBnZXQgc2l6ZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnNpemVcbiAgfVxuXG4gIGdldCB0eXBlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2UudHlwZVxuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5uYW1lXG4gIH1cblxuICBnZXQgbGFzdE1vZGlmaWVkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubGFzdE1vZGlmaWVkXG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10gKCkge1xuICAgIHJldHVybiAnRmlsZSdcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhGaWxlLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnRmlsZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIG5hbWU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGxhc3RNb2RpZmllZDoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuQmxvYiA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoQmxvYilcblxud2ViaWRsLmNvbnZlcnRlcnMuQmxvYlBhcnQgPSBmdW5jdGlvbiAoViwgb3B0cykge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcpIHtcbiAgICBpZiAoaXNCbG9iTGlrZShWKSkge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoViwgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3KFYpIHx8XG4gICAgICB0eXBlcy5pc0FueUFycmF5QnVmZmVyKFYpXG4gICAgKSB7XG4gICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQnVmZmVyU291cmNlKFYsIG9wdHMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWLCBvcHRzKVxufVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8QmxvYlBhcnQ+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2JQYXJ0XG4pXG5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9GaWxlQVBJLyNkZm4tRmlsZVByb3BlcnR5QmFnXG53ZWJpZGwuY29udmVydGVycy5GaWxlUHJvcGVydHlCYWcgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdsYXN0TW9kaWZpZWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ2xvbmcgbG9uZyddLFxuICAgIGdldCBkZWZhdWx0VmFsdWUgKCkge1xuICAgICAgcmV0dXJuIERhdGUubm93KClcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBrZXk6ICd0eXBlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdlbmRpbmdzJyxcbiAgICBjb252ZXJ0ZXI6ICh2YWx1ZSkgPT4ge1xuICAgICAgdmFsdWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodmFsdWUpXG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKClcblxuICAgICAgaWYgKHZhbHVlICE9PSAnbmF0aXZlJykge1xuICAgICAgICB2YWx1ZSA9ICd0cmFuc3BhcmVudCdcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWU6ICd0cmFuc3BhcmVudCdcbiAgfVxuXSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9GaWxlQVBJLyNwcm9jZXNzLWJsb2ItcGFydHNcbiAqIEBwYXJhbSB7KE5vZGVKUy5UeXBlZEFycmF5fEJsb2J8c3RyaW5nKVtdfSBwYXJ0c1xuICogQHBhcmFtIHt7IHR5cGU6IHN0cmluZywgZW5kaW5nczogc3RyaW5nIH19IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0Jsb2JQYXJ0cyAocGFydHMsIG9wdGlvbnMpIHtcbiAgLy8gMS4gTGV0IGJ5dGVzIGJlIGFuIGVtcHR5IHNlcXVlbmNlIG9mIGJ5dGVzLlxuICAvKiogQHR5cGUge05vZGVKUy5UeXBlZEFycmF5W119ICovXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICAvLyAyLiBGb3IgZWFjaCBlbGVtZW50IGluIHBhcnRzOlxuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgcGFydHMpIHtcbiAgICAvLyAxLiBJZiBlbGVtZW50IGlzIGEgVVNWU3RyaW5nLCBydW4gdGhlIGZvbGxvd2luZyBzdWJzdGVwczpcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAxLiBMZXQgcyBiZSBlbGVtZW50LlxuICAgICAgbGV0IHMgPSBlbGVtZW50XG5cbiAgICAgIC8vIDIuIElmIHRoZSBlbmRpbmdzIG1lbWJlciBvZiBvcHRpb25zIGlzIFwibmF0aXZlXCIsIHNldCBzXG4gICAgICAvLyAgICB0byB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgbGluZSBlbmRpbmdzIHRvIG5hdGl2ZVxuICAgICAgLy8gICAgb2YgZWxlbWVudC5cbiAgICAgIGlmIChvcHRpb25zLmVuZGluZ3MgPT09ICduYXRpdmUnKSB7XG4gICAgICAgIHMgPSBjb252ZXJ0TGluZUVuZGluZ3NOYXRpdmUocylcbiAgICAgIH1cblxuICAgICAgLy8gMy4gQXBwZW5kIHRoZSByZXN1bHQgb2YgVVRGLTggZW5jb2RpbmcgcyB0byBieXRlcy5cbiAgICAgIGJ5dGVzLnB1c2goZW5jb2Rlci5lbmNvZGUocykpXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoZWxlbWVudCkgfHxcbiAgICAgIHR5cGVzLmlzVHlwZWRBcnJheShlbGVtZW50KVxuICAgICkge1xuICAgICAgLy8gMi4gSWYgZWxlbWVudCBpcyBhIEJ1ZmZlclNvdXJjZSwgZ2V0IGEgY29weSBvZiB0aGVcbiAgICAgIC8vICAgIGJ5dGVzIGhlbGQgYnkgdGhlIGJ1ZmZlciBzb3VyY2UsIGFuZCBhcHBlbmQgdGhvc2VcbiAgICAgIC8vICAgIGJ5dGVzIHRvIGJ5dGVzLlxuICAgICAgaWYgKCFlbGVtZW50LmJ1ZmZlcikgeyAvLyBBcnJheUJ1ZmZlclxuICAgICAgICBieXRlcy5wdXNoKG5ldyBVaW50OEFycmF5KGVsZW1lbnQpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgICBuZXcgVWludDhBcnJheShlbGVtZW50LmJ1ZmZlciwgZWxlbWVudC5ieXRlT2Zmc2V0LCBlbGVtZW50LmJ5dGVMZW5ndGgpXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQmxvYkxpa2UoZWxlbWVudCkpIHtcbiAgICAgIC8vIDMuIElmIGVsZW1lbnQgaXMgYSBCbG9iLCBhcHBlbmQgdGhlIGJ5dGVzIGl0IHJlcHJlc2VudHNcbiAgICAgIC8vICAgIHRvIGJ5dGVzLlxuICAgICAgYnl0ZXMucHVzaChlbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIFJldHVybiBieXRlcy5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvRmlsZUFQSS8jY29udmVydC1saW5lLWVuZGluZ3MtdG8tbmF0aXZlXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICovXG5mdW5jdGlvbiBjb252ZXJ0TGluZUVuZGluZ3NOYXRpdmUgKHMpIHtcbiAgLy8gMS4gTGV0IG5hdGl2ZSBsaW5lIGVuZGluZyBiZSBiZSB0aGUgY29kZSBwb2ludCBVKzAwMEEgTEYuXG4gIGxldCBuYXRpdmVMaW5lRW5kaW5nID0gJ1xcbidcblxuICAvLyAyLiBJZiB0aGUgdW5kZXJseWluZyBwbGF0Zm9ybeKAmXMgY29udmVudGlvbnMgYXJlIHRvXG4gIC8vICAgIHJlcHJlc2VudCBuZXdsaW5lcyBhcyBhIGNhcnJpYWdlIHJldHVybiBhbmQgbGluZSBmZWVkXG4gIC8vICAgIHNlcXVlbmNlLCBzZXQgbmF0aXZlIGxpbmUgZW5kaW5nIHRvIHRoZSBjb2RlIHBvaW50XG4gIC8vICAgIFUrMDAwRCBDUiBmb2xsb3dlZCBieSB0aGUgY29kZSBwb2ludCBVKzAwMEEgTEYuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgbmF0aXZlTGluZUVuZGluZyA9ICdcXHJcXG4nXG4gIH1cblxuICByZXR1cm4gcy5yZXBsYWNlKC9cXHI/XFxuL2csIG5hdGl2ZUxpbmVFbmRpbmcpXG59XG5cbi8vIElmIHRoaXMgZnVuY3Rpb24gaXMgbW92ZWQgdG8gLi91dGlsLmpzLCBzb21lIHRvb2xzIChzdWNoIGFzXG4vLyByb2xsdXApIHdpbGwgd2FybiBhYm91dCBjaXJjdWxhciBkZXBlbmRlbmNpZXMuIFNlZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNjI5XG5mdW5jdGlvbiBpc0ZpbGVMaWtlIChvYmplY3QpIHtcbiAgcmV0dXJuIChcbiAgICAoTmF0aXZlRmlsZSAmJiBvYmplY3QgaW5zdGFuY2VvZiBOYXRpdmVGaWxlKSB8fFxuICAgIG9iamVjdCBpbnN0YW5jZW9mIEZpbGUgfHwgKFxuICAgICAgb2JqZWN0ICYmXG4gICAgICAodHlwZW9mIG9iamVjdC5zdHJlYW0gPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicpICYmXG4gICAgICBvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0ZpbGUnXG4gICAgKVxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBGaWxlLCBGaWxlTGlrZSwgaXNGaWxlTGlrZSB9XG4iXSwibmFtZXMiOlsiQmxvYiIsIkZpbGUiLCJOYXRpdmVGaWxlIiwicmVxdWlyZSIsInR5cGVzIiwia1N0YXRlIiwiaXNCbG9iTGlrZSIsIndlYmlkbCIsInBhcnNlTUlNRVR5cGUiLCJzZXJpYWxpemVBTWltZVR5cGUiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiY29uc3RydWN0b3IiLCJmaWxlQml0cyIsImZpbGVOYW1lIiwib3B0aW9ucyIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJoZWFkZXIiLCJjb252ZXJ0ZXJzIiwiVVNWU3RyaW5nIiwiRmlsZVByb3BlcnR5QmFnIiwibiIsInQiLCJ0eXBlIiwiZCIsInN1YnN0ZXAiLCJ0b0xvd2VyQ2FzZSIsImxhc3RNb2RpZmllZCIsInByb2Nlc3NCbG9iUGFydHMiLCJuYW1lIiwiYnJhbmRDaGVjayIsIkZpbGVMaWtlIiwiYmxvYkxpa2UiLCJEYXRlIiwibm93Iiwic3RyZWFtIiwiYXJncyIsImFycmF5QnVmZmVyIiwic2xpY2UiLCJ0ZXh0Iiwic2l6ZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiaW50ZXJmYWNlQ29udmVydGVyIiwiQmxvYlBhcnQiLCJWIiwib3B0cyIsInV0aWwiLCJUeXBlIiwic3RyaWN0IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJpc0FueUFycmF5QnVmZmVyIiwiQnVmZmVyU291cmNlIiwic2VxdWVuY2VDb252ZXJ0ZXIiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwia2V5IiwiY29udmVydGVyIiwiZGVmYXVsdFZhbHVlIiwiRE9NU3RyaW5nIiwicGFydHMiLCJieXRlcyIsImVsZW1lbnQiLCJzIiwiZW5kaW5ncyIsImNvbnZlcnRMaW5lRW5kaW5nc05hdGl2ZSIsInB1c2giLCJlbmNvZGUiLCJpc1R5cGVkQXJyYXkiLCJidWZmZXIiLCJVaW50OEFycmF5IiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJuYXRpdmVMaW5lRW5kaW5nIiwicHJvY2VzcyIsInBsYXRmb3JtIiwicmVwbGFjZSIsImlzRmlsZUxpa2UiLCJvYmplY3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/file.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/formdata.js":
/*!*******************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/formdata.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { isBlobLike, toUSVString, makeIterator } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/fetch/util.js\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/fetch/symbols.js\");\nconst { File: UndiciFile, FileLike, isFileLike } = __webpack_require__(/*! ./file */ \"(rsc)/../../node_modules/undici/lib/fetch/file.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst { Blob, File: NativeFile } = __webpack_require__(/*! buffer */ \"buffer\");\n/** @type {globalThis['File']} */ const File = NativeFile ?? UndiciFile;\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n    constructor(form){\n        if (form !== undefined) {\n            throw webidl.errors.conversionFailed({\n                prefix: \"FormData constructor\",\n                argument: \"Argument 1\",\n                types: [\n                    \"undefined\"\n                ]\n            });\n        }\n        this[kState] = [];\n    }\n    append(name, value, filename = undefined) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"FormData.append\"\n        });\n        if (arguments.length === 3 && !isBlobLike(value)) {\n            throw new TypeError(\"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\");\n        }\n        // 1. Let value be value if given; otherwise blobValue.\n        name = webidl.converters.USVString(name);\n        value = isBlobLike(value) ? webidl.converters.Blob(value, {\n            strict: false\n        }) : webidl.converters.USVString(value);\n        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : undefined;\n        // 2. Let entry be the result of creating an entry with\n        // name, value, and filename if given.\n        const entry = makeEntry(name, value, filename);\n        // 3. Append entry to thiss entry list.\n        this[kState].push(entry);\n    }\n    delete(name) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.delete\"\n        });\n        name = webidl.converters.USVString(name);\n        // The delete(name) method steps are to remove all entries whose name\n        // is name from thiss entry list.\n        this[kState] = this[kState].filter((entry)=>entry.name !== name);\n    }\n    get(name) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.get\"\n        });\n        name = webidl.converters.USVString(name);\n        // 1. If there is no entry whose name is name in thiss entry list,\n        // then return null.\n        const idx = this[kState].findIndex((entry)=>entry.name === name);\n        if (idx === -1) {\n            return null;\n        }\n        // 2. Return the value of the first entry whose name is name from\n        // thiss entry list.\n        return this[kState][idx].value;\n    }\n    getAll(name) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.getAll\"\n        });\n        name = webidl.converters.USVString(name);\n        // 1. If there is no entry whose name is name in thiss entry list,\n        // then return the empty list.\n        // 2. Return the values of all entries whose name is name, in order,\n        // from thiss entry list.\n        return this[kState].filter((entry)=>entry.name === name).map((entry)=>entry.value);\n    }\n    has(name) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.has\"\n        });\n        name = webidl.converters.USVString(name);\n        // The has(name) method steps are to return true if there is an entry\n        // whose name is name in thiss entry list; otherwise false.\n        return this[kState].findIndex((entry)=>entry.name === name) !== -1;\n    }\n    set(name, value, filename = undefined) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"FormData.set\"\n        });\n        if (arguments.length === 3 && !isBlobLike(value)) {\n            throw new TypeError(\"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\");\n        }\n        // The set(name, value) and set(name, blobValue, filename) method steps\n        // are:\n        // 1. Let value be value if given; otherwise blobValue.\n        name = webidl.converters.USVString(name);\n        value = isBlobLike(value) ? webidl.converters.Blob(value, {\n            strict: false\n        }) : webidl.converters.USVString(value);\n        filename = arguments.length === 3 ? toUSVString(filename) : undefined;\n        // 2. Let entry be the result of creating an entry with name, value, and\n        // filename if given.\n        const entry = makeEntry(name, value, filename);\n        // 3. If there are entries in thiss entry list whose name is name, then\n        // replace the first such entry with entry and remove the others.\n        const idx = this[kState].findIndex((entry)=>entry.name === name);\n        if (idx !== -1) {\n            this[kState] = [\n                ...this[kState].slice(0, idx),\n                entry,\n                ...this[kState].slice(idx + 1).filter((entry)=>entry.name !== name)\n            ];\n        } else {\n            // 4. Otherwise, append entry to thiss entry list.\n            this[kState].push(entry);\n        }\n    }\n    entries() {\n        webidl.brandCheck(this, FormData);\n        return makeIterator(()=>this[kState].map((pair)=>[\n                    pair.name,\n                    pair.value\n                ]), \"FormData\", \"key+value\");\n    }\n    keys() {\n        webidl.brandCheck(this, FormData);\n        return makeIterator(()=>this[kState].map((pair)=>[\n                    pair.name,\n                    pair.value\n                ]), \"FormData\", \"key\");\n    }\n    values() {\n        webidl.brandCheck(this, FormData);\n        return makeIterator(()=>this[kState].map((pair)=>[\n                    pair.name,\n                    pair.value\n                ]), \"FormData\", \"value\");\n    }\n    /**\n   * @param {(value: string, key: string, self: FormData) => void} callbackFn\n   * @param {unknown} thisArg\n   */ forEach(callbackFn, thisArg = globalThis) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.forEach\"\n        });\n        if (typeof callbackFn !== \"function\") {\n            throw new TypeError(\"Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.\");\n        }\n        for (const [key, value] of this){\n            callbackFn.apply(thisArg, [\n                value,\n                key,\n                this\n            ]);\n        }\n    }\n}\nFormData.prototype[Symbol.iterator] = FormData.prototype.entries;\nObject.defineProperties(FormData.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"FormData\",\n        configurable: true\n    }\n});\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */ function makeEntry(name, value, filename) {\n    // 1. Set name to the result of converting name into a scalar value string.\n    // \"To convert a string into a scalar value string, replace any surrogates\n    //  with U+FFFD.\"\n    // see: https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html#buftostringencoding-start-end\n    name = Buffer.from(name).toString(\"utf8\");\n    // 2. If value is a string, then set value to the result of converting\n    //    value into a scalar value string.\n    if (typeof value === \"string\") {\n        value = Buffer.from(value).toString(\"utf8\");\n    } else {\n        // 3. Otherwise:\n        // 1. If value is not a File object, then set value to a new File object,\n        //    representing the same bytes, whose name attribute value is \"blob\"\n        if (!isFileLike(value)) {\n            value = value instanceof Blob ? new File([\n                value\n            ], \"blob\", {\n                type: value.type\n            }) : new FileLike(value, \"blob\", {\n                type: value.type\n            });\n        }\n        // 2. If filename is given, then set value to a new File object,\n        //    representing the same bytes, whose name attribute is filename.\n        if (filename !== undefined) {\n            /** @type {FilePropertyBag} */ const options = {\n                type: value.type,\n                lastModified: value.lastModified\n            };\n            value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([\n                value\n            ], filename, options) : new FileLike(value, filename, options);\n        }\n    }\n    // 4. Return an entry whose name is name and whose value is value.\n    return {\n        name,\n        value\n    };\n}\nmodule.exports = {\n    FormData\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZm9ybWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDMUQsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFRSxNQUFNQyxVQUFVLEVBQUVDLFFBQVEsRUFBRUMsVUFBVSxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQzNELE1BQU0sRUFBRU0sTUFBTSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRU8sSUFBSSxFQUFFTCxNQUFNTSxVQUFVLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFFM0MsK0JBQStCLEdBQy9CLE1BQU1FLE9BQU9NLGNBQWNMO0FBRTNCLHdDQUF3QztBQUN4QyxNQUFNTTtJQUNKQyxZQUFhQyxJQUFJLENBQUU7UUFDakIsSUFBSUEsU0FBU0MsV0FBVztZQUN0QixNQUFNTixPQUFPTyxNQUFNLENBQUNDLGdCQUFnQixDQUFDO2dCQUNuQ0MsUUFBUTtnQkFDUkMsVUFBVTtnQkFDVkMsT0FBTztvQkFBQztpQkFBWTtZQUN0QjtRQUNGO1FBRUEsSUFBSSxDQUFDaEIsT0FBTyxHQUFHLEVBQUU7SUFDbkI7SUFFQWlCLE9BQVFDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxXQUFXVCxTQUFTLEVBQUU7UUFDekNOLE9BQU9nQixVQUFVLENBQUMsSUFBSSxFQUFFYjtRQUV4QkgsT0FBT2lCLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7WUFBRUMsUUFBUTtRQUFrQjtRQUVyRSxJQUFJRCxVQUFVRSxNQUFNLEtBQUssS0FBSyxDQUFDN0IsV0FBV3VCLFFBQVE7WUFDaEQsTUFBTSxJQUFJTyxVQUNSO1FBRUo7UUFFQSx1REFBdUQ7UUFFdkRSLE9BQU9iLE9BQU9zQixVQUFVLENBQUNDLFNBQVMsQ0FB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QUMxRSxpQkFBaUI7SUFDakIsK0ZBQStGO0lBQy9GRixPQUFPMEMsT0FBT0MsSUFBSSxDQUFDM0MsTUFBTTRDLFFBQVEsQ0FBQztJQUVsQyxzRUFBc0U7SUFDdEUsdUNBQXVDO0lBQ3ZDLElBQUksT0FBTzNDLFVBQVUsVUFBVTtRQUM3QkEsUUFBUXlDLE9BQU9DLElBQUksQ0FBQzFDLE9BQU8yQyxRQUFRLENBQUM7SUFDdEMsT0FBTztRQUNMLGdCQUFnQjtRQUVoQix5RUFBeUU7UUFDekUsdUVBQXVFO1FBQ3ZFLElBQUksQ0FBQzFELFdBQVdlLFFBQVE7WUFDdEJBLFFBQVFBLGlCQUFpQmIsT0FDckIsSUFBSUwsS0FBSztnQkFBQ2tCO2FBQU0sRUFBRSxRQUFRO2dCQUFFNEMsTUFBTTVDLE1BQU00QyxJQUFJO1lBQUMsS0FDN0MsSUFBSTVELFNBQVNnQixPQUFPLFFBQVE7Z0JBQUU0QyxNQUFNNUMsTUFBTTRDLElBQUk7WUFBQztRQUNyRDtRQUVBLGdFQUFnRTtRQUNoRSxvRUFBb0U7UUFDcEUsSUFBSTNDLGFBQWFULFdBQVc7WUFDMUIsNEJBQTRCLEdBQzVCLE1BQU1xRCxVQUFVO2dCQUNkRCxNQUFNNUMsTUFBTTRDLElBQUk7Z0JBQ2hCRSxjQUFjOUMsTUFBTThDLFlBQVk7WUFDbEM7WUFFQTlDLFFBQVEsY0FBZUEsaUJBQWlCWixjQUFlWSxpQkFBaUJqQixhQUNwRSxJQUFJRCxLQUFLO2dCQUFDa0I7YUFBTSxFQUFFQyxVQUFVNEMsV0FDNUIsSUFBSTdELFNBQVNnQixPQUFPQyxVQUFVNEM7UUFDcEM7SUFDRjtJQUVBLGtFQUFrRTtJQUNsRSxPQUFPO1FBQUU5QztRQUFNQztJQUFNO0FBQ3ZCO0FBRUErQyxPQUFPQyxPQUFPLEdBQUc7SUFBRTNEO0FBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL2Zvcm1kYXRhLmpzPzZmMmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgaXNCbG9iTGlrZSwgdG9VU1ZTdHJpbmcsIG1ha2VJdGVyYXRvciB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsga1N0YXRlIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBGaWxlOiBVbmRpY2lGaWxlLCBGaWxlTGlrZSwgaXNGaWxlTGlrZSB9ID0gcmVxdWlyZSgnLi9maWxlJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IEJsb2IsIEZpbGU6IE5hdGl2ZUZpbGUgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5cbi8qKiBAdHlwZSB7Z2xvYmFsVGhpc1snRmlsZSddfSAqL1xuY29uc3QgRmlsZSA9IE5hdGl2ZUZpbGUgPz8gVW5kaWNpRmlsZVxuXG4vLyBodHRwczovL3hoci5zcGVjLndoYXR3Zy5vcmcvI2Zvcm1kYXRhXG5jbGFzcyBGb3JtRGF0YSB7XG4gIGNvbnN0cnVjdG9yIChmb3JtKSB7XG4gICAgaWYgKGZvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgICAgcHJlZml4OiAnRm9ybURhdGEgY29uc3RydWN0b3InLFxuICAgICAgICBhcmd1bWVudDogJ0FyZ3VtZW50IDEnLFxuICAgICAgICB0eXBlczogWyd1bmRlZmluZWQnXVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzW2tTdGF0ZV0gPSBbXVxuICB9XG5cbiAgYXBwZW5kIChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgeyBoZWFkZXI6ICdGb3JtRGF0YS5hcHBlbmQnIH0pXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiAhaXNCbG9iTGlrZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2FwcGVuZCcgb24gJ0Zvcm1EYXRhJzogcGFyYW1ldGVyIDIgaXMgbm90IG9mIHR5cGUgJ0Jsb2InXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyAxLiBMZXQgdmFsdWUgYmUgdmFsdWUgaWYgZ2l2ZW47IG90aGVyd2lzZSBibG9iVmFsdWUuXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG4gICAgdmFsdWUgPSBpc0Jsb2JMaWtlKHZhbHVlKVxuICAgICAgPyB3ZWJpZGwuY29udmVydGVycy5CbG9iKHZhbHVlLCB7IHN0cmljdDogZmFsc2UgfSlcbiAgICAgIDogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHZhbHVlKVxuICAgIGZpbGVuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gM1xuICAgICAgPyB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoZmlsZW5hbWUpXG4gICAgICA6IHVuZGVmaW5lZFxuXG4gICAgLy8gMi4gTGV0IGVudHJ5IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gZW50cnkgd2l0aFxuICAgIC8vIG5hbWUsIHZhbHVlLCBhbmQgZmlsZW5hbWUgaWYgZ2l2ZW4uXG4gICAgY29uc3QgZW50cnkgPSBtYWtlRW50cnkobmFtZSwgdmFsdWUsIGZpbGVuYW1lKVxuXG4gICAgLy8gMy4gQXBwZW5kIGVudHJ5IHRvIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgdGhpc1trU3RhdGVdLnB1c2goZW50cnkpXG4gIH1cblxuICBkZWxldGUgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGb3JtRGF0YS5kZWxldGUnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG5cbiAgICAvLyBUaGUgZGVsZXRlKG5hbWUpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmVtb3ZlIGFsbCBlbnRyaWVzIHdob3NlIG5hbWVcbiAgICAvLyBpcyBuYW1lIGZyb20gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICB0aGlzW2tTdGF0ZV0gPSB0aGlzW2tTdGF0ZV0uZmlsdGVyKGVudHJ5ID0+IGVudHJ5Lm5hbWUgIT09IG5hbWUpXG4gIH1cblxuICBnZXQgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGb3JtRGF0YS5nZXQnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG5cbiAgICAvLyAxLiBJZiB0aGVyZSBpcyBubyBlbnRyeSB3aG9zZSBuYW1lIGlzIG5hbWUgaW4gdGhpc+KAmXMgZW50cnkgbGlzdCxcbiAgICAvLyB0aGVuIHJldHVybiBudWxsLlxuICAgIGNvbnN0IGlkeCA9IHRoaXNba1N0YXRlXS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKVxuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVudHJ5IHdob3NlIG5hbWUgaXMgbmFtZSBmcm9tXG4gICAgLy8gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdW2lkeF0udmFsdWVcbiAgfVxuXG4gIGdldEFsbCAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0Zvcm1EYXRhLmdldEFsbCcgfSlcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSlcblxuICAgIC8vIDEuIElmIHRoZXJlIGlzIG5vIGVudHJ5IHdob3NlIG5hbWUgaXMgbmFtZSBpbiB0aGlz4oCZcyBlbnRyeSBsaXN0LFxuICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBlbXB0eSBsaXN0LlxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWVzIG9mIGFsbCBlbnRyaWVzIHdob3NlIG5hbWUgaXMgbmFtZSwgaW4gb3JkZXIsXG4gICAgLy8gZnJvbSB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV1cbiAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKVxuICAgICAgLm1hcCgoZW50cnkpID0+IGVudHJ5LnZhbHVlKVxuICB9XG5cbiAgaGFzIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRm9ybURhdGEuaGFzJyB9KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuXG4gICAgLy8gVGhlIGhhcyhuYW1lKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGFuIGVudHJ5XG4gICAgLy8gd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3Q7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpICE9PSAtMVxuICB9XG5cbiAgc2V0IChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgeyBoZWFkZXI6ICdGb3JtRGF0YS5zZXQnIH0pXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiAhaXNCbG9iTGlrZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ3NldCcgb24gJ0Zvcm1EYXRhJzogcGFyYW1ldGVyIDIgaXMgbm90IG9mIHR5cGUgJ0Jsb2InXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUaGUgc2V0KG5hbWUsIHZhbHVlKSBhbmQgc2V0KG5hbWUsIGJsb2JWYWx1ZSwgZmlsZW5hbWUpIG1ldGhvZCBzdGVwc1xuICAgIC8vIGFyZTpcblxuICAgIC8vIDEuIExldCB2YWx1ZSBiZSB2YWx1ZSBpZiBnaXZlbjsgb3RoZXJ3aXNlIGJsb2JWYWx1ZS5cblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSlcbiAgICB2YWx1ZSA9IGlzQmxvYkxpa2UodmFsdWUpXG4gICAgICA/IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IodmFsdWUsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICAgICAgOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodmFsdWUpXG4gICAgZmlsZW5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID09PSAzXG4gICAgICA/IHRvVVNWU3RyaW5nKGZpbGVuYW1lKVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIC8vIDIuIExldCBlbnRyeSBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIGVudHJ5IHdpdGggbmFtZSwgdmFsdWUsIGFuZFxuICAgIC8vIGZpbGVuYW1lIGlmIGdpdmVuLlxuICAgIGNvbnN0IGVudHJ5ID0gbWFrZUVudHJ5KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSlcblxuICAgIC8vIDMuIElmIHRoZXJlIGFyZSBlbnRyaWVzIGluIHRoaXPigJlzIGVudHJ5IGxpc3Qgd2hvc2UgbmFtZSBpcyBuYW1lLCB0aGVuXG4gICAgLy8gcmVwbGFjZSB0aGUgZmlyc3Qgc3VjaCBlbnRyeSB3aXRoIGVudHJ5IGFuZCByZW1vdmUgdGhlIG90aGVycy5cbiAgICBjb25zdCBpZHggPSB0aGlzW2tTdGF0ZV0uZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSlcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgdGhpc1trU3RhdGVdID0gW1xuICAgICAgICAuLi50aGlzW2tTdGF0ZV0uc2xpY2UoMCwgaWR4KSxcbiAgICAgICAgZW50cnksXG4gICAgICAgIC4uLnRoaXNba1N0YXRlXS5zbGljZShpZHggKyAxKS5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS5uYW1lICE9PSBuYW1lKVxuICAgICAgXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyA0LiBPdGhlcndpc2UsIGFwcGVuZCBlbnRyeSB0byB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgICAgdGhpc1trU3RhdGVdLnB1c2goZW50cnkpXG4gICAgfVxuICB9XG5cbiAgZW50cmllcyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKFxuICAgICAgKCkgPT4gdGhpc1trU3RhdGVdLm1hcChwYWlyID0+IFtwYWlyLm5hbWUsIHBhaXIudmFsdWVdKSxcbiAgICAgICdGb3JtRGF0YScsXG4gICAgICAna2V5K3ZhbHVlJ1xuICAgIClcbiAgfVxuXG4gIGtleXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgcmV0dXJuIG1ha2VJdGVyYXRvcihcbiAgICAgICgpID0+IHRoaXNba1N0YXRlXS5tYXAocGFpciA9PiBbcGFpci5uYW1lLCBwYWlyLnZhbHVlXSksXG4gICAgICAnRm9ybURhdGEnLFxuICAgICAgJ2tleSdcbiAgICApXG4gIH1cblxuICB2YWx1ZXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgcmV0dXJuIG1ha2VJdGVyYXRvcihcbiAgICAgICgpID0+IHRoaXNba1N0YXRlXS5tYXAocGFpciA9PiBbcGFpci5uYW1lLCBwYWlyLnZhbHVlXSksXG4gICAgICAnRm9ybURhdGEnLFxuICAgICAgJ3ZhbHVlJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyh2YWx1ZTogc3RyaW5nLCBrZXk6IHN0cmluZywgc2VsZjogRm9ybURhdGEpID0+IHZvaWR9IGNhbGxiYWNrRm5cbiAgICogQHBhcmFtIHt1bmtub3dufSB0aGlzQXJnXG4gICAqL1xuICBmb3JFYWNoIChjYWxsYmFja0ZuLCB0aGlzQXJnID0gZ2xvYmFsVGhpcykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0Zvcm1EYXRhLmZvckVhY2gnIH0pXG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2ZvckVhY2gnIG9uICdGb3JtRGF0YSc6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdGdW5jdGlvbicuXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzKSB7XG4gICAgICBjYWxsYmFja0ZuLmFwcGx5KHRoaXNBcmcsIFt2YWx1ZSwga2V5LCB0aGlzXSlcbiAgICB9XG4gIH1cbn1cblxuRm9ybURhdGEucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBGb3JtRGF0YS5wcm90b3R5cGUuZW50cmllc1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhGb3JtRGF0YS5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0Zvcm1EYXRhJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI2NyZWF0ZS1hbi1lbnRyeVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfEJsb2J9IHZhbHVlXG4gKiBAcGFyYW0gez9zdHJpbmd9IGZpbGVuYW1lXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBtYWtlRW50cnkgKG5hbWUsIHZhbHVlLCBmaWxlbmFtZSkge1xuICAvLyAxLiBTZXQgbmFtZSB0byB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgbmFtZSBpbnRvIGEgc2NhbGFyIHZhbHVlIHN0cmluZy5cbiAgLy8gXCJUbyBjb252ZXJ0IGEgc3RyaW5nIGludG8gYSBzY2FsYXIgdmFsdWUgc3RyaW5nLCByZXBsYWNlIGFueSBzdXJyb2dhdGVzXG4gIC8vICB3aXRoIFUrRkZGRC5cIlxuICAvLyBzZWU6IGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12MTgueC9kb2NzL2FwaS9idWZmZXIuaHRtbCNidWZ0b3N0cmluZ2VuY29kaW5nLXN0YXJ0LWVuZFxuICBuYW1lID0gQnVmZmVyLmZyb20obmFtZSkudG9TdHJpbmcoJ3V0ZjgnKVxuXG4gIC8vIDIuIElmIHZhbHVlIGlzIGEgc3RyaW5nLCB0aGVuIHNldCB2YWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmdcbiAgLy8gICAgdmFsdWUgaW50byBhIHNjYWxhciB2YWx1ZSBzdHJpbmcuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoJ3V0ZjgnKVxuICB9IGVsc2Uge1xuICAgIC8vIDMuIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIElmIHZhbHVlIGlzIG5vdCBhIEZpbGUgb2JqZWN0LCB0aGVuIHNldCB2YWx1ZSB0byBhIG5ldyBGaWxlIG9iamVjdCxcbiAgICAvLyAgICByZXByZXNlbnRpbmcgdGhlIHNhbWUgYnl0ZXMsIHdob3NlIG5hbWUgYXR0cmlidXRlIHZhbHVlIGlzIFwiYmxvYlwiXG4gICAgaWYgKCFpc0ZpbGVMaWtlKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2JcbiAgICAgICAgPyBuZXcgRmlsZShbdmFsdWVdLCAnYmxvYicsIHsgdHlwZTogdmFsdWUudHlwZSB9KVxuICAgICAgICA6IG5ldyBGaWxlTGlrZSh2YWx1ZSwgJ2Jsb2InLCB7IHR5cGU6IHZhbHVlLnR5cGUgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBJZiBmaWxlbmFtZSBpcyBnaXZlbiwgdGhlbiBzZXQgdmFsdWUgdG8gYSBuZXcgRmlsZSBvYmplY3QsXG4gICAgLy8gICAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIGJ5dGVzLCB3aG9zZSBuYW1lIGF0dHJpYnV0ZSBpcyBmaWxlbmFtZS5cbiAgICBpZiAoZmlsZW5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLyoqIEB0eXBlIHtGaWxlUHJvcGVydHlCYWd9ICovXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuICAgICAgICBsYXN0TW9kaWZpZWQ6IHZhbHVlLmxhc3RNb2RpZmllZFxuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IChOYXRpdmVGaWxlICYmIHZhbHVlIGluc3RhbmNlb2YgTmF0aXZlRmlsZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBVbmRpY2lGaWxlXG4gICAgICAgID8gbmV3IEZpbGUoW3ZhbHVlXSwgZmlsZW5hbWUsIG9wdGlvbnMpXG4gICAgICAgIDogbmV3IEZpbGVMaWtlKHZhbHVlLCBmaWxlbmFtZSwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICAvLyA0LiBSZXR1cm4gYW4gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGFuZCB3aG9zZSB2YWx1ZSBpcyB2YWx1ZS5cbiAgcmV0dXJuIHsgbmFtZSwgdmFsdWUgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgRm9ybURhdGEgfVxuIl0sIm5hbWVzIjpbImlzQmxvYkxpa2UiLCJ0b1VTVlN0cmluZyIsIm1ha2VJdGVyYXRvciIsInJlcXVpcmUiLCJrU3RhdGUiLCJGaWxlIiwiVW5kaWNpRmlsZSIsIkZpbGVMaWtlIiwiaXNGaWxlTGlrZSIsIndlYmlkbCIsIkJsb2IiLCJOYXRpdmVGaWxlIiwiRm9ybURhdGEiLCJjb25zdHJ1Y3RvciIsImZvcm0iLCJ1bmRlZmluZWQiLCJlcnJvcnMiLCJjb252ZXJzaW9uRmFpbGVkIiwicHJlZml4IiwiYXJndW1lbnQiLCJ0eXBlcyIsImFwcGVuZCIsIm5hbWUiLCJ2YWx1ZSIsImZpbGVuYW1lIiwiYnJhbmRDaGVjayIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJoZWFkZXIiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJjb252ZXJ0ZXJzIiwiVVNWU3RyaW5nIiwic3RyaWN0IiwiZW50cnkiLCJtYWtlRW50cnkiLCJwdXNoIiwiZGVsZXRlIiwiZmlsdGVyIiwiZ2V0IiwiaWR4IiwiZmluZEluZGV4IiwiZ2V0QWxsIiwibWFwIiwiaGFzIiwic2V0Iiwic2xpY2UiLCJlbnRyaWVzIiwicGFpciIsImtleXMiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwiY2FsbGJhY2tGbiIsInRoaXNBcmciLCJnbG9iYWxUaGlzIiwia2V5IiwiYXBwbHkiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJpdGVyYXRvciIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJ0b1N0cmluZ1RhZyIsImNvbmZpZ3VyYWJsZSIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsInR5cGUiLCJvcHRpb25zIiwibGFzdE1vZGlmaWVkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/formdata.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/global.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/global.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n// In case of breaking changes, increase the version\n// number to avoid conflicts.\nconst globalOrigin = Symbol.for(\"undici.globalOrigin.1\");\nfunction getGlobalOrigin() {\n    return globalThis[globalOrigin];\n}\nfunction setGlobalOrigin(newOrigin) {\n    if (newOrigin === undefined) {\n        Object.defineProperty(globalThis, globalOrigin, {\n            value: undefined,\n            writable: true,\n            enumerable: false,\n            configurable: false\n        });\n        return;\n    }\n    const parsedURL = new URL(newOrigin);\n    if (parsedURL.protocol !== \"http:\" && parsedURL.protocol !== \"https:\") {\n        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);\n    }\n    Object.defineProperty(globalThis, globalOrigin, {\n        value: parsedURL,\n        writable: true,\n        enumerable: false,\n        configurable: false\n    });\n}\nmodule.exports = {\n    getGlobalOrigin,\n    setGlobalOrigin\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZ2xvYmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsb0RBQW9EO0FBQ3BELDZCQUE2QjtBQUM3QixNQUFNQSxlQUFlQyxPQUFPQyxHQUFHLENBQUM7QUFFaEMsU0FBU0M7SUFDUCxPQUFPQyxVQUFVLENBQUNKLGFBQWE7QUFDakM7QUFFQSxTQUFTSyxnQkFBaUJDLFNBQVM7SUFDakMsSUFBSUEsY0FBY0MsV0FBVztRQUMzQkMsT0FBT0MsY0FBYyxDQUFDTCxZQUFZSixjQUFjO1lBQzlDVSxPQUFPSDtZQUNQSSxVQUFVO1lBQ1ZDLFlBQVk7WUFDWkMsY0FBYztRQUNoQjtRQUVBO0lBQ0Y7SUFFQSxNQUFNQyxZQUFZLElBQUlDLElBQUlUO0lBRTFCLElBQUlRLFVBQVVFLFFBQVEsS0FBSyxXQUFXRixVQUFVRSxRQUFRLEtBQUssVUFBVTtRQUNyRSxNQUFNLElBQUlDLFVBQVUsQ0FBQyw2Q0FBNkMsRUFBRUgsVUFBVUUsUUFBUSxDQUFDLENBQUM7SUFDMUY7SUFFQVIsT0FBT0MsY0FBYyxDQUFDTCxZQUFZSixjQUFjO1FBQzlDVSxPQUFPSTtRQUNQSCxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsY0FBYztJQUNoQjtBQUNGO0FBRUFLLE9BQU9DLE9BQU8sR0FBRztJQUNmaEI7SUFDQUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZ2xvYmFsLmpzPzdkYzkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIEluIGNhc2Ugb2YgYnJlYWtpbmcgY2hhbmdlcywgaW5jcmVhc2UgdGhlIHZlcnNpb25cbi8vIG51bWJlciB0byBhdm9pZCBjb25mbGljdHMuXG5jb25zdCBnbG9iYWxPcmlnaW4gPSBTeW1ib2wuZm9yKCd1bmRpY2kuZ2xvYmFsT3JpZ2luLjEnKVxuXG5mdW5jdGlvbiBnZXRHbG9iYWxPcmlnaW4gKCkge1xuICByZXR1cm4gZ2xvYmFsVGhpc1tnbG9iYWxPcmlnaW5dXG59XG5cbmZ1bmN0aW9uIHNldEdsb2JhbE9yaWdpbiAobmV3T3JpZ2luKSB7XG4gIGlmIChuZXdPcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBnbG9iYWxPcmlnaW4sIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0pXG5cbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHBhcnNlZFVSTCA9IG5ldyBVUkwobmV3T3JpZ2luKVxuXG4gIGlmIChwYXJzZWRVUkwucHJvdG9jb2wgIT09ICdodHRwOicgJiYgcGFyc2VkVVJMLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE9ubHkgaHR0cCAmIGh0dHBzIHVybHMgYXJlIGFsbG93ZWQsIHJlY2VpdmVkICR7cGFyc2VkVVJMLnByb3RvY29sfWApXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgZ2xvYmFsT3JpZ2luLCB7XG4gICAgdmFsdWU6IHBhcnNlZFVSTCxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRHbG9iYWxPcmlnaW4sXG4gIHNldEdsb2JhbE9yaWdpblxufVxuIl0sIm5hbWVzIjpbImdsb2JhbE9yaWdpbiIsIlN5bWJvbCIsImZvciIsImdldEdsb2JhbE9yaWdpbiIsImdsb2JhbFRoaXMiLCJzZXRHbG9iYWxPcmlnaW4iLCJuZXdPcmlnaW4iLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwicGFyc2VkVVJMIiwiVVJMIiwicHJvdG9jb2wiLCJUeXBlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/global.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/headers.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/headers.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst { kGuard } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/fetch/symbols.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { makeIterator, isValidHeaderName, isValidHeaderValue } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/fetch/util.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst kHeadersMap = Symbol(\"headers map\");\nconst kHeadersSortedMap = Symbol(\"headers map sorted\");\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */ function headerValueNormalize(potentialValue) {\n    //  To normalize a byte sequence potentialValue, remove\n    //  any leading and trailing HTTP whitespace bytes from\n    //  potentialValue.\n    // Trimming the end with `.replace()` and a RegExp is typically subject to\n    // ReDoS. This is safer and faster.\n    let i = potentialValue.length;\n    while(/[\\r\\n\\t ]/.test(potentialValue.charAt(--i)));\n    return potentialValue.slice(0, i + 1).replace(/^[\\r\\n\\t ]+/, \"\");\n}\nfunction fill(headers, object) {\n    // To fill a Headers object headers with a given object object, run these steps:\n    // 1. If object is a sequence, then for each header in object:\n    // Note: webidl conversion to array has already been done.\n    if (Array.isArray(object)) {\n        for (const header of object){\n            // 1. If header does not contain exactly two items, then throw a TypeError.\n            if (header.length !== 2) {\n                throw webidl.errors.exception({\n                    header: \"Headers constructor\",\n                    message: `expected name/value pair to be length 2, found ${header.length}.`\n                });\n            }\n            // 2. Append (headers first item, headers second item) to headers.\n            headers.append(header[0], header[1]);\n        }\n    } else if (typeof object === \"object\" && object !== null) {\n        // Note: null should throw\n        // 2. Otherwise, object is a record, then for each key  value in object,\n        //    append (key, value) to headers\n        for (const [key, value] of Object.entries(object)){\n            headers.append(key, value);\n        }\n    } else {\n        throw webidl.errors.conversionFailed({\n            prefix: \"Headers constructor\",\n            argument: \"Argument 1\",\n            types: [\n                \"sequence<sequence<ByteString>>\",\n                \"record<ByteString, ByteString>\"\n            ]\n        });\n    }\n}\nclass HeadersList {\n    constructor(init){\n        /** @type {[string, string][]|null} */ this.cookies = null;\n        if (init instanceof HeadersList) {\n            this[kHeadersMap] = new Map(init[kHeadersMap]);\n            this[kHeadersSortedMap] = init[kHeadersSortedMap];\n            this.cookies = init.cookies;\n        } else {\n            this[kHeadersMap] = new Map(init);\n            this[kHeadersSortedMap] = null;\n        }\n    }\n    // https://fetch.spec.whatwg.org/#header-list-contains\n    contains(name) {\n        // A header list list contains a header name name if list\n        // contains a header whose name is a byte-case-insensitive\n        // match for name.\n        name = name.toLowerCase();\n        return this[kHeadersMap].has(name);\n    }\n    clear() {\n        this[kHeadersMap].clear();\n        this[kHeadersSortedMap] = null;\n        this.cookies = null;\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-append\n    append(name, value) {\n        this[kHeadersSortedMap] = null;\n        // 1. If list contains name, then set name to the first such\n        //    headers name.\n        const lowercaseName = name.toLowerCase();\n        const exists = this[kHeadersMap].get(lowercaseName);\n        // 2. Append (name, value) to list.\n        if (exists) {\n            const delimiter = lowercaseName === \"cookie\" ? \"; \" : \", \";\n            this[kHeadersMap].set(lowercaseName, {\n                name: exists.name,\n                value: `${exists.value}${delimiter}${value}`\n            });\n        } else {\n            this[kHeadersMap].set(lowercaseName, {\n                name,\n                value\n            });\n        }\n        if (lowercaseName === \"set-cookie\") {\n            this.cookies ??= [];\n            this.cookies.push(value);\n        }\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-set\n    set(name, value) {\n        this[kHeadersSortedMap] = null;\n        const lowercaseName = name.toLowerCase();\n        if (lowercaseName === \"set-cookie\") {\n            this.cookies = [\n                value\n            ];\n        }\n        // 1. If list contains name, then set the value of\n        //    the first such header to value and remove the\n        //    others.\n        // 2. Otherwise, append header (name, value) to list.\n        return this[kHeadersMap].set(lowercaseName, {\n            name,\n            value\n        });\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-delete\n    delete(name) {\n        this[kHeadersSortedMap] = null;\n        name = name.toLowerCase();\n        if (name === \"set-cookie\") {\n            this.cookies = null;\n        }\n        return this[kHeadersMap].delete(name);\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-get\n    get(name) {\n        // 1. If list does not contain name, then return null.\n        if (!this.contains(name)) {\n            return null;\n        }\n        // 2. Return the values of all headers in list whose name\n        //    is a byte-case-insensitive match for name,\n        //    separated from each other by 0x2C 0x20, in order.\n        return this[kHeadersMap].get(name.toLowerCase())?.value ?? null;\n    }\n    *[Symbol.iterator]() {\n        // use the lowercased name\n        for (const [name, { value }] of this[kHeadersMap]){\n            yield [\n                name,\n                value\n            ];\n        }\n    }\n    get entries() {\n        const headers = {};\n        if (this[kHeadersMap].size) {\n            for (const { name, value } of this[kHeadersMap].values()){\n                headers[name] = value;\n            }\n        }\n        return headers;\n    }\n}\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n    constructor(init = undefined){\n        this[kHeadersList] = new HeadersList();\n        // The new Headers(init) constructor steps are:\n        // 1. Set thiss guard to \"none\".\n        this[kGuard] = \"none\";\n        // 2. If init is given, then fill this with init.\n        if (init !== undefined) {\n            init = webidl.converters.HeadersInit(init);\n            fill(this, init);\n        }\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-append\n    append(name, value) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"Headers.append\"\n        });\n        name = webidl.converters.ByteString(name);\n        value = webidl.converters.ByteString(value);\n        // 1. Normalize value.\n        value = headerValueNormalize(value);\n        // 2. If name is not a header name or value is not a\n        //    header value, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.append\",\n                value: name,\n                type: \"header name\"\n            });\n        } else if (!isValidHeaderValue(value)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.append\",\n                value,\n                type: \"header value\"\n            });\n        }\n        // 3. If headerss guard is \"immutable\", then throw a TypeError.\n        // 4. Otherwise, if headerss guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this[kGuard] === \"immutable\") {\n            throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        // 5. Otherwise, if headerss guard is \"request-no-cors\":\n        // TODO\n        }\n        // 6. Otherwise, if headerss guard is \"response\" and name is a\n        //    forbidden response-header name, return.\n        // 7. Append (name, value) to headerss header list.\n        // 8. If headerss guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from headers\n        return this[kHeadersList].append(name, value);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-delete\n    delete(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Headers.delete\"\n        });\n        name = webidl.converters.ByteString(name);\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.delete\",\n                value: name,\n                type: \"header name\"\n            });\n        }\n        // 2. If thiss guard is \"immutable\", then throw a TypeError.\n        // 3. Otherwise, if thiss guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // 4. Otherwise, if thiss guard is \"request-no-cors\", name\n        //    is not a no-CORS-safelisted request-header name, and\n        //    name is not a privileged no-CORS request-header name,\n        //    return.\n        // 5. Otherwise, if thiss guard is \"response\" and name is\n        //    a forbidden response-header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this[kGuard] === \"immutable\") {\n            throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        // TODO\n        }\n        // 6. If thiss header list does not contain name, then\n        //    return.\n        if (!this[kHeadersList].contains(name)) {\n            return;\n        }\n        // 7. Delete name from thiss header list.\n        // 8. If thiss guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from this.\n        return this[kHeadersList].delete(name);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-get\n    get(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Headers.get\"\n        });\n        name = webidl.converters.ByteString(name);\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.get\",\n                value: name,\n                type: \"header name\"\n            });\n        }\n        // 2. Return the result of getting name from thiss header\n        //    list.\n        return this[kHeadersList].get(name);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-has\n    has(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Headers.has\"\n        });\n        name = webidl.converters.ByteString(name);\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.has\",\n                value: name,\n                type: \"header name\"\n            });\n        }\n        // 2. Return true if thiss header list contains name;\n        //    otherwise false.\n        return this[kHeadersList].contains(name);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-set\n    set(name, value) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"Headers.set\"\n        });\n        name = webidl.converters.ByteString(name);\n        value = webidl.converters.ByteString(value);\n        // 1. Normalize value.\n        value = headerValueNormalize(value);\n        // 2. If name is not a header name or value is not a\n        //    header value, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.set\",\n                value: name,\n                type: \"header name\"\n            });\n        } else if (!isValidHeaderValue(value)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.set\",\n                value,\n                type: \"header value\"\n            });\n        }\n        // 3. If thiss guard is \"immutable\", then throw a TypeError.\n        // 4. Otherwise, if thiss guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // 5. Otherwise, if thiss guard is \"request-no-cors\" and\n        //    name/value is not a no-CORS-safelisted request-header,\n        //    return.\n        // 6. Otherwise, if thiss guard is \"response\" and name is a\n        //    forbidden response-header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this[kGuard] === \"immutable\") {\n            throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        // TODO\n        }\n        // 7. Set (name, value) in thiss header list.\n        // 8. If thiss guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from this\n        return this[kHeadersList].set(name, value);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n    getSetCookie() {\n        webidl.brandCheck(this, Headers);\n        // 1. If thiss header list does not contain `Set-Cookie`, then return  .\n        // 2. Return the values of all headers in thiss header list whose name is\n        //    a byte-case-insensitive match for `Set-Cookie`, in order.\n        const list = this[kHeadersList].cookies;\n        if (list) {\n            return [\n                ...list\n            ];\n        }\n        return [];\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n    get [kHeadersSortedMap]() {\n        if (this[kHeadersList][kHeadersSortedMap]) {\n            return this[kHeadersList][kHeadersSortedMap];\n        }\n        // 1. Let headers be an empty list of headers with the key being the name\n        //    and value the value.\n        const headers = [];\n        // 2. Let names be the result of convert header names to a sorted-lowercase\n        //    set with all the names of the headers in list.\n        const names = [\n            ...this[kHeadersList]\n        ].sort((a, b)=>a[0] < b[0] ? -1 : 1);\n        const cookies = this[kHeadersList].cookies;\n        // 3. For each name of names:\n        for (const [name, value] of names){\n            // 1. If name is `set-cookie`, then:\n            if (name === \"set-cookie\") {\n                // 1. Let values be a list of all values of headers in list whose name\n                //    is a byte-case-insensitive match for name, in order.\n                // 2. For each value of values:\n                // 1. Append (name, value) to headers.\n                for (const value of cookies){\n                    headers.push([\n                        name,\n                        value\n                    ]);\n                }\n            } else {\n                // 2. Otherwise:\n                // 1. Let value be the result of getting name from list.\n                // 2. Assert: value is non-null.\n                assert(value !== null);\n                // 3. Append (name, value) to headers.\n                headers.push([\n                    name,\n                    value\n                ]);\n            }\n        }\n        this[kHeadersList][kHeadersSortedMap] = headers;\n        // 4. Return headers.\n        return headers;\n    }\n    keys() {\n        webidl.brandCheck(this, Headers);\n        return makeIterator(()=>[\n                ...this[kHeadersSortedMap].values()\n            ], \"Headers\", \"key\");\n    }\n    values() {\n        webidl.brandCheck(this, Headers);\n        return makeIterator(()=>[\n                ...this[kHeadersSortedMap].values()\n            ], \"Headers\", \"value\");\n    }\n    entries() {\n        webidl.brandCheck(this, Headers);\n        return makeIterator(()=>[\n                ...this[kHeadersSortedMap].values()\n            ], \"Headers\", \"key+value\");\n    }\n    /**\n   * @param {(value: string, key: string, self: Headers) => void} callbackFn\n   * @param {unknown} thisArg\n   */ forEach(callbackFn, thisArg = globalThis) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Headers.forEach\"\n        });\n        if (typeof callbackFn !== \"function\") {\n            throw new TypeError(\"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\");\n        }\n        for (const [key, value] of this){\n            callbackFn.apply(thisArg, [\n                value,\n                key,\n                this\n            ]);\n        }\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        webidl.brandCheck(this, Headers);\n        return this[kHeadersList];\n    }\n}\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries;\nObject.defineProperties(Headers.prototype, {\n    append: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    get: kEnumerableProperty,\n    has: kEnumerableProperty,\n    set: kEnumerableProperty,\n    getSetCookie: kEnumerableProperty,\n    keys: kEnumerableProperty,\n    values: kEnumerableProperty,\n    entries: kEnumerableProperty,\n    forEach: kEnumerableProperty,\n    [Symbol.iterator]: {\n        enumerable: false\n    },\n    [Symbol.toStringTag]: {\n        value: \"Headers\",\n        configurable: true\n    }\n});\nwebidl.converters.HeadersInit = function(V) {\n    if (webidl.util.Type(V) === \"Object\") {\n        if (V[Symbol.iterator]) {\n            return webidl.converters[\"sequence<sequence<ByteString>>\"](V);\n        }\n        return webidl.converters[\"record<ByteString, ByteString>\"](V);\n    }\n    throw webidl.errors.conversionFailed({\n        prefix: \"Headers constructor\",\n        argument: \"Argument 1\",\n        types: [\n            \"sequence<sequence<ByteString>>\",\n            \"record<ByteString, ByteString>\"\n        ]\n    });\n};\nmodule.exports = {\n    fill,\n    Headers,\n    HeadersList\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvaGVhZGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpREFBaUQ7QUFFakQ7QUFFQSxNQUFNLEVBQUVBLFlBQVksRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUNqQyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVFLG1CQUFtQixFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ3hDLE1BQU0sRUFDSkcsWUFBWSxFQUNaQyxpQkFBaUIsRUFDakJDLGtCQUFrQixFQUNuQixHQUFHTCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRU0sTUFBTSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1PLFNBQVNQLG1CQUFPQSxDQUFDO0FBRXZCLE1BQU1RLGNBQWNDLE9BQU87QUFDM0IsTUFBTUMsb0JBQW9CRCxPQUFPO0FBRWpDOzs7Q0FHQyxHQUNELFNBQVNFLHFCQUFzQkMsY0FBYztJQUMzQyx1REFBdUQ7SUFDdkQsdURBQXVEO0lBQ3ZELG1CQUFtQjtJQUVuQiwwRUFBMEU7SUFDMUUsbUNBQW1DO0lBQ25DLElBQUlDLElBQUlELGVBQWVFLE1BQU07SUFDN0IsTUFBTyxZQUFZQyxJQUFJLENBQUNILGVBQWVJLE1BQU0sQ0FBQyxFQUFFSDtJQUNoRCxPQUFPRCxlQUFlSyxLQUFLLENBQUMsR0FBR0osSUFBSSxHQUFHSyxPQUFPLENBQUMsZUFBZTtBQUMvRDtBQUVBLFNBQVNDLEtBQU1DLE9BQU8sRUFBRUMsTUFBTTtJQUM1QixnRkFBZ0Y7SUFFaEYsOERBQThEO0lBQzlELDBEQUEwRDtJQUMxRCxJQUFJQyxNQUFNQyxPQUFPLENBQUNGLFNBQVM7UUFDekIsS0FBSyxNQUFNRyxVQUFVSCxPQUFRO1lBQzNCLDJFQUEyRTtZQUMzRSxJQUFJRyxPQUFPVixNQUFNLEtBQUssR0FBRztnQkFDdkIsTUFBTVIsT0FBT21CLE1BQU0sQ0FBQ0MsU0FBUyxD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UUFBUXdCLFNBQVMsQ0FBQ2pELE9BQU87QUFFOURELE9BQU9tRCxnQkFBZ0IsQ0FBQ3pCLFFBQVF3QixTQUFTLEVBQUU7SUFDekNyRCxRQUFRMUI7SUFDUm1ELFFBQVFuRDtJQUNSK0MsS0FBSy9DO0lBQ0wyQyxLQUFLM0M7SUFDTGlELEtBQUtqRDtJQUNMa0UsY0FBY2xFO0lBQ2R3RSxNQUFNeEU7SUFDTnNELFFBQVF0RDtJQUNSOEIsU0FBUzlCO0lBQ1R5RSxTQUFTekU7SUFDVCxDQUFDTyxPQUFPNkMsUUFBUSxDQUFDLEVBQUU7UUFBRTZCLFlBQVk7SUFBTTtJQUN2QyxDQUFDMUUsT0FBTzJFLFdBQVcsQ0FBQyxFQUFFO1FBQ3BCdEQsT0FBTztRQUNQdUQsY0FBYztJQUNoQjtBQUNGO0FBRUEvRSxPQUFPcUQsVUFBVSxDQUFDQyxXQUFXLEdBQUcsU0FBVTBCLENBQUM7SUFDekMsSUFBSWhGLE9BQU9pRixJQUFJLENBQUNDLElBQUksQ0FBQ0YsT0FBTyxVQUFVO1FBQ3BDLElBQUlBLENBQUMsQ0FBQzdFLE9BQU82QyxRQUFRLENBQUMsRUFBRTtZQUN0QixPQUFPaEQsT0FBT3FELFVBQVUsQ0FBQyxpQ0FBaUMsQ0FBQzJCO1FBQzdEO1FBRUEsT0FBT2hGLE9BQU9xRCxVQUFVLENBQUMsaUNBQWlDLENBQUMyQjtJQUM3RDtJQUVBLE1BQU1oRixPQUFPbUIsTUFBTSxDQUFDUSxnQkFBZ0IsQ0FBQztRQUNuQ0MsUUFBUTtRQUNSQyxVQUFVO1FBQ1ZDLE9BQU87WUFBQztZQUFrQztTQUFpQztJQUM3RTtBQUNGO0FBRUFxRCxPQUFPQyxPQUFPLEdBQUc7SUFDZnZFO0lBQ0FzQztJQUNBcEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvaGVhZGVycy5qcz9lZTFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9FdGhhbi1BcnJvd29vZC91bmRpY2ktZmV0Y2hcblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga0hlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBrR3VhcmQgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7XG4gIG1ha2VJdGVyYXRvcixcbiAgaXNWYWxpZEhlYWRlck5hbWUsXG4gIGlzVmFsaWRIZWFkZXJWYWx1ZVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxuY29uc3Qga0hlYWRlcnNNYXAgPSBTeW1ib2woJ2hlYWRlcnMgbWFwJylcbmNvbnN0IGtIZWFkZXJzU29ydGVkTWFwID0gU3ltYm9sKCdoZWFkZXJzIG1hcCBzb3J0ZWQnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLXZhbHVlLW5vcm1hbGl6ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGhlYWRlclZhbHVlTm9ybWFsaXplIChwb3RlbnRpYWxWYWx1ZSkge1xuICAvLyAgVG8gbm9ybWFsaXplIGEgYnl0ZSBzZXF1ZW5jZSBwb3RlbnRpYWxWYWx1ZSwgcmVtb3ZlXG4gIC8vICBhbnkgbGVhZGluZyBhbmQgdHJhaWxpbmcgSFRUUCB3aGl0ZXNwYWNlIGJ5dGVzIGZyb21cbiAgLy8gIHBvdGVudGlhbFZhbHVlLlxuXG4gIC8vIFRyaW1taW5nIHRoZSBlbmQgd2l0aCBgLnJlcGxhY2UoKWAgYW5kIGEgUmVnRXhwIGlzIHR5cGljYWxseSBzdWJqZWN0IHRvXG4gIC8vIFJlRG9TLiBUaGlzIGlzIHNhZmVyIGFuZCBmYXN0ZXIuXG4gIGxldCBpID0gcG90ZW50aWFsVmFsdWUubGVuZ3RoXG4gIHdoaWxlICgvW1xcclxcblxcdCBdLy50ZXN0KHBvdGVudGlhbFZhbHVlLmNoYXJBdCgtLWkpKSk7XG4gIHJldHVybiBwb3RlbnRpYWxWYWx1ZS5zbGljZSgwLCBpICsgMSkucmVwbGFjZSgvXltcXHJcXG5cXHQgXSsvLCAnJylcbn1cblxuZnVuY3Rpb24gZmlsbCAoaGVhZGVycywgb2JqZWN0KSB7XG4gIC8vIFRvIGZpbGwgYSBIZWFkZXJzIG9iamVjdCBoZWFkZXJzIHdpdGggYSBnaXZlbiBvYmplY3Qgb2JqZWN0LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIGEgc2VxdWVuY2UsIHRoZW4gZm9yIGVhY2ggaGVhZGVyIGluIG9iamVjdDpcbiAgLy8gTm90ZTogd2ViaWRsIGNvbnZlcnNpb24gdG8gYXJyYXkgaGFzIGFscmVhZHkgYmVlbiBkb25lLlxuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgZm9yIChjb25zdCBoZWFkZXIgb2Ygb2JqZWN0KSB7XG4gICAgICAvLyAxLiBJZiBoZWFkZXIgZG9lcyBub3QgY29udGFpbiBleGFjdGx5IHR3byBpdGVtcywgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChoZWFkZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgICBtZXNzYWdlOiBgZXhwZWN0ZWQgbmFtZS92YWx1ZSBwYWlyIHRvIGJlIGxlbmd0aCAyLCBmb3VuZCAke2hlYWRlci5sZW5ndGh9LmBcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQXBwZW5kIChoZWFkZXLigJlzIGZpcnN0IGl0ZW0sIGhlYWRlcuKAmXMgc2Vjb25kIGl0ZW0pIHRvIGhlYWRlcnMuXG4gICAgICBoZWFkZXJzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgLy8gTm90ZTogbnVsbCBzaG91bGQgdGhyb3dcblxuICAgIC8vIDIuIE90aGVyd2lzZSwgb2JqZWN0IGlzIGEgcmVjb3JkLCB0aGVuIGZvciBlYWNoIGtleSDihpIgdmFsdWUgaW4gb2JqZWN0LFxuICAgIC8vICAgIGFwcGVuZCAoa2V5LCB2YWx1ZSkgdG8gaGVhZGVyc1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICBwcmVmaXg6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICAgIGFyZ3VtZW50OiAnQXJndW1lbnQgMScsXG4gICAgICB0eXBlczogWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nLCAncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J11cbiAgICB9KVxuICB9XG59XG5cbmNsYXNzIEhlYWRlcnNMaXN0IHtcbiAgLyoqIEB0eXBlIHtbc3RyaW5nLCBzdHJpbmddW118bnVsbH0gKi9cbiAgY29va2llcyA9IG51bGxcblxuICBjb25zdHJ1Y3RvciAoaW5pdCkge1xuICAgIGlmIChpbml0IGluc3RhbmNlb2YgSGVhZGVyc0xpc3QpIHtcbiAgICAgIHRoaXNba0hlYWRlcnNNYXBdID0gbmV3IE1hcChpbml0W2tIZWFkZXJzTWFwXSlcbiAgICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gaW5pdFtrSGVhZGVyc1NvcnRlZE1hcF1cbiAgICAgIHRoaXMuY29va2llcyA9IGluaXQuY29va2llc1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tIZWFkZXJzTWFwXSA9IG5ldyBNYXAoaW5pdClcbiAgICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItbGlzdC1jb250YWluc1xuICBjb250YWlucyAobmFtZSkge1xuICAgIC8vIEEgaGVhZGVyIGxpc3QgbGlzdCBjb250YWlucyBhIGhlYWRlciBuYW1lIG5hbWUgaWYgbGlzdFxuICAgIC8vIGNvbnRhaW5zIGEgaGVhZGVyIHdob3NlIG5hbWUgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmVcbiAgICAvLyBtYXRjaCBmb3IgbmFtZS5cbiAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uaGFzKG5hbWUpXG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpc1trSGVhZGVyc01hcF0uY2xlYXIoKVxuICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuICAgIHRoaXMuY29va2llcyA9IG51bGxcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWFwcGVuZFxuICBhcHBlbmQgKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG5cbiAgICAvLyAxLiBJZiBsaXN0IGNvbnRhaW5zIG5hbWUsIHRoZW4gc2V0IG5hbWUgdG8gdGhlIGZpcnN0IHN1Y2hcbiAgICAvLyAgICBoZWFkZXLigJlzIG5hbWUuXG4gICAgY29uc3QgbG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuICAgIGNvbnN0IGV4aXN0cyA9IHRoaXNba0hlYWRlcnNNYXBdLmdldChsb3dlcmNhc2VOYW1lKVxuXG4gICAgLy8gMi4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gbGlzdC5cbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICBjb25zdCBkZWxpbWl0ZXIgPSBsb3dlcmNhc2VOYW1lID09PSAnY29va2llJyA/ICc7ICcgOiAnLCAnXG4gICAgICB0aGlzW2tIZWFkZXJzTWFwXS5zZXQobG93ZXJjYXNlTmFtZSwge1xuICAgICAgICBuYW1lOiBleGlzdHMubmFtZSxcbiAgICAgICAgdmFsdWU6IGAke2V4aXN0cy52YWx1ZX0ke2RlbGltaXRlcn0ke3ZhbHVlfWBcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0hlYWRlcnNNYXBdLnNldChsb3dlcmNhc2VOYW1lLCB7IG5hbWUsIHZhbHVlIH0pXG4gICAgfVxuXG4gICAgaWYgKGxvd2VyY2FzZU5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgdGhpcy5jb29raWVzID8/PSBbXVxuICAgICAgdGhpcy5jb29raWVzLnB1c2godmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3Qtc2V0XG4gIHNldCAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcbiAgICBjb25zdCBsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICBpZiAobG93ZXJjYXNlTmFtZSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICB0aGlzLmNvb2tpZXMgPSBbdmFsdWVdXG4gICAgfVxuXG4gICAgLy8gMS4gSWYgbGlzdCBjb250YWlucyBuYW1lLCB0aGVuIHNldCB0aGUgdmFsdWUgb2ZcbiAgICAvLyAgICB0aGUgZmlyc3Qgc3VjaCBoZWFkZXIgdG8gdmFsdWUgYW5kIHJlbW92ZSB0aGVcbiAgICAvLyAgICBvdGhlcnMuXG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBhcHBlbmQgaGVhZGVyIChuYW1lLCB2YWx1ZSkgdG8gbGlzdC5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uc2V0KGxvd2VyY2FzZU5hbWUsIHsgbmFtZSwgdmFsdWUgfSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWRlbGV0ZVxuICBkZWxldGUgKG5hbWUpIHtcbiAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcblxuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIGlmIChuYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIHRoaXMuY29va2llcyA9IG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uZGVsZXRlKG5hbWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1nZXRcbiAgZ2V0IChuYW1lKSB7XG4gICAgLy8gMS4gSWYgbGlzdCBkb2VzIG5vdCBjb250YWluIG5hbWUsIHRoZW4gcmV0dXJuIG51bGwuXG4gICAgaWYgKCF0aGlzLmNvbnRhaW5zKG5hbWUpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWVzIG9mIGFsbCBoZWFkZXJzIGluIGxpc3Qgd2hvc2UgbmFtZVxuICAgIC8vICAgIGlzIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBuYW1lLFxuICAgIC8vICAgIHNlcGFyYXRlZCBmcm9tIGVhY2ggb3RoZXIgYnkgMHgyQyAweDIwLCBpbiBvcmRlci5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uZ2V0KG5hbWUudG9Mb3dlckNhc2UoKSk/LnZhbHVlID8/IG51bGxcbiAgfVxuXG4gICogW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIC8vIHVzZSB0aGUgbG93ZXJjYXNlZCBuYW1lXG4gICAgZm9yIChjb25zdCBbbmFtZSwgeyB2YWx1ZSB9XSBvZiB0aGlzW2tIZWFkZXJzTWFwXSkge1xuICAgICAgeWllbGQgW25hbWUsIHZhbHVlXVxuICAgIH1cbiAgfVxuXG4gIGdldCBlbnRyaWVzICgpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge31cblxuICAgIGlmICh0aGlzW2tIZWFkZXJzTWFwXS5zaXplKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdmFsdWUgfSBvZiB0aGlzW2tIZWFkZXJzTWFwXS52YWx1ZXMoKSkge1xuICAgICAgICBoZWFkZXJzW25hbWVdID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXJzLWNsYXNzXG5jbGFzcyBIZWFkZXJzIHtcbiAgY29uc3RydWN0b3IgKGluaXQgPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzW2tIZWFkZXJzTGlzdF0gPSBuZXcgSGVhZGVyc0xpc3QoKVxuXG4gICAgLy8gVGhlIG5ldyBIZWFkZXJzKGluaXQpIGNvbnN0cnVjdG9yIHN0ZXBzIGFyZTpcblxuICAgIC8vIDEuIFNldCB0aGlz4oCZcyBndWFyZCB0byBcIm5vbmVcIi5cbiAgICB0aGlzW2tHdWFyZF0gPSAnbm9uZSdcblxuICAgIC8vIDIuIElmIGluaXQgaXMgZ2l2ZW4sIHRoZW4gZmlsbCB0aGlzIHdpdGggaW5pdC5cbiAgICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQoaW5pdClcbiAgICAgIGZpbGwodGhpcywgaW5pdClcbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtYXBwZW5kXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCB7IGhlYWRlcjogJ0hlYWRlcnMuYXBwZW5kJyB9KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSlcbiAgICB2YWx1ZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcodmFsdWUpXG5cbiAgICAvLyAxLiBOb3JtYWxpemUgdmFsdWUuXG4gICAgdmFsdWUgPSBoZWFkZXJWYWx1ZU5vcm1hbGl6ZSh2YWx1ZSlcblxuICAgIC8vIDIuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUgb3IgdmFsdWUgaXMgbm90IGFcbiAgICAvLyAgICBoZWFkZXIgdmFsdWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXg6ICdIZWFkZXJzLmFwcGVuZCcsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4OiAnSGVhZGVycy5hcHBlbmQnLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciB2YWx1ZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJpbW11dGFibGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyA0LiBPdGhlcndpc2UsIGlmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVxdWVzdFwiIGFuZCBuYW1lIGlzIGFcbiAgICAvLyAgICBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IGZvcmJpZGRlbiBoZWFkZXIgbmFtZXNcbiAgICBpZiAodGhpc1trR3VhcmRdID09PSAnaW1tdXRhYmxlJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW1tdXRhYmxlJylcbiAgICB9IGVsc2UgaWYgKHRoaXNba0d1YXJkXSA9PT0gJ3JlcXVlc3Qtbm8tY29ycycpIHtcbiAgICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIjpcbiAgICAgIC8vIFRPRE9cbiAgICB9XG5cbiAgICAvLyA2LiBPdGhlcndpc2UsIGlmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG5cbiAgICAvLyA3LiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBoZWFkZXJz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAvLyA4LiBJZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSBoZWFkZXJzXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNMaXN0XS5hcHBlbmQobmFtZSwgdmFsdWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZGVsZXRlXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnSGVhZGVycy5kZWxldGUnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKVxuXG4gICAgLy8gMS4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuZGVsZXRlJyxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJpbW11dGFibGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyAzLiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdFwiIGFuZCBuYW1lIGlzIGFcbiAgICAvLyAgICBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgICAvLyA0LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIG5hbWVcbiAgICAvLyAgICBpcyBub3QgYSBuby1DT1JTLXNhZmVsaXN0ZWQgcmVxdWVzdC1oZWFkZXIgbmFtZSwgYW5kXG4gICAgLy8gICAgbmFtZSBpcyBub3QgYSBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdC1oZWFkZXIgbmFtZSxcbiAgICAvLyAgICByZXR1cm4uXG4gICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlc3BvbnNlXCIgYW5kIG5hbWUgaXNcbiAgICAvLyAgICBhIGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIGhlYWRlciBuYW1lc1xuICAgIGlmICh0aGlzW2tHdWFyZF0gPT09ICdpbW11dGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbW11dGFibGUnKVxuICAgIH0gZWxzZSBpZiAodGhpc1trR3VhcmRdID09PSAncmVxdWVzdC1uby1jb3JzJykge1xuICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIC8vIDYuIElmIHRoaXPigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gbmFtZSwgdGhlblxuICAgIC8vICAgIHJldHVybi5cbiAgICBpZiAoIXRoaXNba0hlYWRlcnNMaXN0XS5jb250YWlucyhuYW1lKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gNy4gRGVsZXRlIG5hbWUgZnJvbSB0aGlz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAvLyA4LiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSB0aGlzLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF0uZGVsZXRlKG5hbWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZ2V0XG4gIGdldCAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnSGVhZGVycy5nZXQnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKVxuXG4gICAgLy8gMS4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuZ2V0JyxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBuYW1lIGZyb20gdGhpc+KAmXMgaGVhZGVyXG4gICAgLy8gICAgbGlzdC5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdLmdldChuYW1lKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLWhhc1xuICBoYXMgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0hlYWRlcnMuaGFzJyB9KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSlcblxuICAgIC8vIDEuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXg6ICdIZWFkZXJzLmhhcycsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFJldHVybiB0cnVlIGlmIHRoaXPigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIG5hbWU7XG4gICAgLy8gICAgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF0uY29udGFpbnMobmFtZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1zZXRcbiAgc2V0IChuYW1lLCB2YWx1ZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnSGVhZGVycy5zZXQnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKVxuICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyh2YWx1ZSlcblxuICAgIC8vIDEuIE5vcm1hbGl6ZSB2YWx1ZS5cbiAgICB2YWx1ZSA9IGhlYWRlclZhbHVlTm9ybWFsaXplKHZhbHVlKVxuXG4gICAgLy8gMi4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSBvciB2YWx1ZSBpcyBub3QgYVxuICAgIC8vICAgIGhlYWRlciB2YWx1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuc2V0JyxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXg6ICdIZWFkZXJzLnNldCcsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIHZhbHVlJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAzLiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcImltbXV0YWJsZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIC8vIDQuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0XCIgYW5kIG5hbWUgaXMgYVxuICAgIC8vICAgIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiBhbmRcbiAgICAvLyAgICBuYW1lL3ZhbHVlIGlzIG5vdCBhIG5vLUNPUlMtc2FmZWxpc3RlZCByZXF1ZXN0LWhlYWRlcixcbiAgICAvLyAgICByZXR1cm4uXG4gICAgLy8gNi4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlc3BvbnNlXCIgYW5kIG5hbWUgaXMgYVxuICAgIC8vICAgIGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIGhlYWRlciBuYW1lc1xuICAgIGlmICh0aGlzW2tHdWFyZF0gPT09ICdpbW11dGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbW11dGFibGUnKVxuICAgIH0gZWxzZSBpZiAodGhpc1trR3VhcmRdID09PSAncmVxdWVzdC1uby1jb3JzJykge1xuICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIC8vIDcuIFNldCAobmFtZSwgdmFsdWUpIGluIHRoaXPigJlzIGhlYWRlciBsaXN0LlxuICAgIC8vIDguIElmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIHRoZW4gcmVtb3ZlXG4gICAgLy8gICAgcHJpdmlsZWdlZCBuby1DT1JTIHJlcXVlc3QgaGVhZGVycyBmcm9tIHRoaXNcbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdLnNldChuYW1lLCB2YWx1ZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1nZXRzZXRjb29raWVcbiAgZ2V0U2V0Q29va2llICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgLy8gMS4gSWYgdGhpc+KAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgU2V0LUNvb2tpZWAsIHRoZW4gcmV0dXJuIMKrIMK7LlxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWVzIG9mIGFsbCBoZWFkZXJzIGluIHRoaXPigJlzIGhlYWRlciBsaXN0IHdob3NlIG5hbWUgaXNcbiAgICAvLyAgICBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgYFNldC1Db29raWVgLCBpbiBvcmRlci5cblxuICAgIGNvbnN0IGxpc3QgPSB0aGlzW2tIZWFkZXJzTGlzdF0uY29va2llc1xuXG4gICAgaWYgKGxpc3QpIHtcbiAgICAgIHJldHVybiBbLi4ubGlzdF1cbiAgICB9XG5cbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LXNvcnQtYW5kLWNvbWJpbmVcbiAgZ2V0IFtrSGVhZGVyc1NvcnRlZE1hcF0gKCkge1xuICAgIGlmICh0aGlzW2tIZWFkZXJzTGlzdF1ba0hlYWRlcnNTb3J0ZWRNYXBdKSB7XG4gICAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdW2tIZWFkZXJzU29ydGVkTWFwXVxuICAgIH1cblxuICAgIC8vIDEuIExldCBoZWFkZXJzIGJlIGFuIGVtcHR5IGxpc3Qgb2YgaGVhZGVycyB3aXRoIHRoZSBrZXkgYmVpbmcgdGhlIG5hbWVcbiAgICAvLyAgICBhbmQgdmFsdWUgdGhlIHZhbHVlLlxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXVxuXG4gICAgLy8gMi4gTGV0IG5hbWVzIGJlIHRoZSByZXN1bHQgb2YgY29udmVydCBoZWFkZXIgbmFtZXMgdG8gYSBzb3J0ZWQtbG93ZXJjYXNlXG4gICAgLy8gICAgc2V0IHdpdGggYWxsIHRoZSBuYW1lcyBvZiB0aGUgaGVhZGVycyBpbiBsaXN0LlxuICAgIGNvbnN0IG5hbWVzID0gWy4uLnRoaXNba0hlYWRlcnNMaXN0XV0uc29ydCgoYSwgYikgPT4gYVswXSA8IGJbMF0gPyAtMSA6IDEpXG4gICAgY29uc3QgY29va2llcyA9IHRoaXNba0hlYWRlcnNMaXN0XS5jb29raWVzXG5cbiAgICAvLyAzLiBGb3IgZWFjaCBuYW1lIG9mIG5hbWVzOlxuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBuYW1lcykge1xuICAgICAgLy8gMS4gSWYgbmFtZSBpcyBgc2V0LWNvb2tpZWAsIHRoZW46XG4gICAgICBpZiAobmFtZSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIC8vIDEuIExldCB2YWx1ZXMgYmUgYSBsaXN0IG9mIGFsbCB2YWx1ZXMgb2YgaGVhZGVycyBpbiBsaXN0IHdob3NlIG5hbWVcbiAgICAgICAgLy8gICAgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIG5hbWUsIGluIG9yZGVyLlxuXG4gICAgICAgIC8vIDIuIEZvciBlYWNoIHZhbHVlIG9mIHZhbHVlczpcbiAgICAgICAgLy8gMS4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gaGVhZGVycy5cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBjb29raWVzKSB7XG4gICAgICAgICAgaGVhZGVycy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDIuIE90aGVyd2lzZTpcblxuICAgICAgICAvLyAxLiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIG5hbWUgZnJvbSBsaXN0LlxuXG4gICAgICAgIC8vIDIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICAgIGFzc2VydCh2YWx1ZSAhPT0gbnVsbClcblxuICAgICAgICAvLyAzLiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBoZWFkZXJzLlxuICAgICAgICBoZWFkZXJzLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW2tIZWFkZXJzTGlzdF1ba0hlYWRlcnNTb3J0ZWRNYXBdID0gaGVhZGVyc1xuXG4gICAgLy8gNC4gUmV0dXJuIGhlYWRlcnMuXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIGtleXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKFxuICAgICAgKCkgPT4gWy4uLnRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdLnZhbHVlcygpXSxcbiAgICAgICdIZWFkZXJzJyxcbiAgICAgICdrZXknXG4gICAgKVxuICB9XG5cbiAgdmFsdWVzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgcmV0dXJuIG1ha2VJdGVyYXRvcihcbiAgICAgICgpID0+IFsuLi50aGlzW2tIZWFkZXJzU29ydGVkTWFwXS52YWx1ZXMoKV0sXG4gICAgICAnSGVhZGVycycsXG4gICAgICAndmFsdWUnXG4gICAgKVxuICB9XG5cbiAgZW50cmllcyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHJldHVybiBtYWtlSXRlcmF0b3IoXG4gICAgICAoKSA9PiBbLi4udGhpc1trSGVhZGVyc1NvcnRlZE1hcF0udmFsdWVzKCldLFxuICAgICAgJ0hlYWRlcnMnLFxuICAgICAgJ2tleSt2YWx1ZSdcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsodmFsdWU6IHN0cmluZywga2V5OiBzdHJpbmcsIHNlbGY6IEhlYWRlcnMpID0+IHZvaWR9IGNhbGxiYWNrRm5cbiAgICogQHBhcmFtIHt1bmtub3dufSB0aGlzQXJnXG4gICAqL1xuICBmb3JFYWNoIChjYWxsYmFja0ZuLCB0aGlzQXJnID0gZ2xvYmFsVGhpcykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnSGVhZGVycy5mb3JFYWNoJyB9KVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFja0ZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdmb3JFYWNoJyBvbiAnSGVhZGVycyc6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdGdW5jdGlvbicuXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzKSB7XG4gICAgICBjYWxsYmFja0ZuLmFwcGx5KHRoaXNBcmcsIFt2YWx1ZSwga2V5LCB0aGlzXSlcbiAgICB9XG4gIH1cblxuICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdXG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXNcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSGVhZGVycy5wcm90b3R5cGUsIHtcbiAgYXBwZW5kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGdldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGFzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzZXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGdldFNldENvb2tpZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAga2V5czoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdmFsdWVzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlbnRyaWVzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBmb3JFYWNoOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLml0ZXJhdG9yXTogeyBlbnVtZXJhYmxlOiBmYWxzZSB9LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnSGVhZGVycycsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0ID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09ICdPYmplY3QnKSB7XG4gICAgaWYgKFZbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nXShWKVxuICAgIH1cblxuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1sncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J10oVilcbiAgfVxuXG4gIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgcHJlZml4OiAnSGVhZGVycyBjb25zdHJ1Y3RvcicsXG4gICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICB0eXBlczogWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nLCAncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J11cbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZpbGwsXG4gIEhlYWRlcnMsXG4gIEhlYWRlcnNMaXN0XG59XG4iXSwibmFtZXMiOlsia0hlYWRlcnNMaXN0IiwicmVxdWlyZSIsImtHdWFyZCIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJtYWtlSXRlcmF0b3IiLCJpc1ZhbGlkSGVhZGVyTmFtZSIsImlzVmFsaWRIZWFkZXJWYWx1ZSIsIndlYmlkbCIsImFzc2VydCIsImtIZWFkZXJzTWFwIiwiU3ltYm9sIiwia0hlYWRlcnNTb3J0ZWRNYXAiLCJoZWFkZXJWYWx1ZU5vcm1hbGl6ZSIsInBvdGVudGlhbFZhbHVlIiwiaSIsImxlbmd0aCIsInRlc3QiLCJjaGFyQXQiLCJzbGljZSIsInJlcGxhY2UiLCJmaWxsIiwiaGVhZGVycyIsIm9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsImhlYWRlciIsImVycm9ycyIsImV4Y2VwdGlvbiIsIm1lc3NhZ2UiLCJhcHBlbmQiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJjb252ZXJzaW9uRmFpbGVkIiwicHJlZml4IiwiYXJndW1lbnQiLCJ0eXBlcyIsIkhlYWRlcnNMaXN0IiwiY29uc3RydWN0b3IiLCJpbml0IiwiY29va2llcyIsIk1hcCIsImNvbnRhaW5zIiwibmFtZSIsInRvTG93ZXJDYXNlIiwiaGFzIiwiY2xlYXIiLCJsb3dlcmNhc2VOYW1lIiwiZXhpc3RzIiwiZ2V0IiwiZGVsaW1pdGVyIiwic2V0IiwicHVzaCIsImRlbGV0ZSIsIml0ZXJhdG9yIiwic2l6ZSIsInZhbHVlcyIsIkhlYWRlcnMiLCJ1bmRlZmluZWQiLCJjb252ZXJ0ZXJzIiwiSGVhZGVyc0luaXQiLCJicmFuZENoZWNrIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsIkJ5dGVTdHJpbmciLCJpbnZhbGlkQXJndW1lbnQiLCJ0eXBlIiwiVHlwZUVycm9yIiwiZ2V0U2V0Q29va2llIiwibGlzdCIsIm5hbWVzIiwic29ydCIsImEiLCJiIiwia2V5cyIsImZvckVhY2giLCJjYWxsYmFja0ZuIiwidGhpc0FyZyIsImdsb2JhbFRoaXMiLCJhcHBseSIsImZvciIsInByb3RvdHlwZSIsImRlZmluZVByb3BlcnRpZXMiLCJlbnVtZXJhYmxlIiwidG9TdHJpbmdUYWciLCJjb25maWd1cmFibGUiLCJWIiwidXRpbCIsIlR5cGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/headers.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\nconst { Response, makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse } = __webpack_require__(/*! ./response */ \"(rsc)/../../node_modules/undici/lib/fetch/response.js\");\nconst { Headers } = __webpack_require__(/*! ./headers */ \"(rsc)/../../node_modules/undici/lib/fetch/headers.js\");\nconst { Request, makeRequest } = __webpack_require__(/*! ./request */ \"(rsc)/../../node_modules/undici/lib/fetch/request.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer, coarsenedSharedCurrentTime, createDeferredPromise, isBlobLike, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme, urlHasHttpsScheme } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/fetch/util.js\");\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/fetch/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { safelyExtractBody } = __webpack_require__(/*! ./body */ \"(rsc)/../../node_modules/undici/lib/fetch/body.js\");\nconst { redirectStatusSet, nullBodyStatus, safeMethodsSet, requestBodyHeader, subresourceSet, DOMException } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/undici/lib/fetch/constants.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst EE = __webpack_require__(/*! events */ \"events\");\nconst { Readable, pipeline } = __webpack_require__(/*! stream */ \"stream\");\nconst { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { dataURLProcessor, serializeAMimeType } = __webpack_require__(/*! ./dataURL */ \"(rsc)/../../node_modules/undici/lib/fetch/dataURL.js\");\nconst { TransformStream } = __webpack_require__(/*! stream/web */ \"stream/web\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(rsc)/../../node_modules/undici/lib/global.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst { STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\nconst GET_OR_HEAD = [\n    \"GET\",\n    \"HEAD\"\n];\n/** @type {import('buffer').resolveObjectURL} */ let resolveObjectURL;\nlet ReadableStream = globalThis.ReadableStream;\nclass Fetch extends EE {\n    constructor(dispatcher){\n        super();\n        this.dispatcher = dispatcher;\n        this.connection = null;\n        this.dump = false;\n        this.state = \"ongoing\";\n        // 2 terminated listeners get added per request,\n        // but only 1 gets removed. If there are 20 redirects,\n        // 21 listeners will be added.\n        // See https://github.com/nodejs/undici/issues/1711\n        // TODO (fix): Find and fix root cause for leaked listener.\n        this.setMaxListeners(21);\n    }\n    terminate(reason) {\n        if (this.state !== \"ongoing\") {\n            return;\n        }\n        this.state = \"terminated\";\n        this.connection?.destroy(reason);\n        this.emit(\"terminated\", reason);\n    }\n    // https://fetch.spec.whatwg.org/#fetch-controller-abort\n    abort(error) {\n        if (this.state !== \"ongoing\") {\n            return;\n        }\n        // 1. Set controllers state to \"aborted\".\n        this.state = \"aborted\";\n        // 2. Let fallbackError be an \"AbortError\" DOMException.\n        // 3. Set error to fallbackError if it is not given.\n        if (!error) {\n            error = new DOMException(\"The operation was aborted.\", \"AbortError\");\n        }\n        // 4. Let serializedError be StructuredSerialize(error).\n        //    If that threw an exception, catch it, and let\n        //    serializedError be StructuredSerialize(fallbackError).\n        // 5. Set controllers serialized abort reason to serializedError.\n        this.serializedAbortReason = error;\n        this.connection?.destroy(error);\n        this.emit(\"terminated\", error);\n    }\n}\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch(input, init = {}) {\n    webidl.argumentLengthCheck(arguments, 1, {\n        header: \"globalThis.fetch\"\n    });\n    // 1. Let p be a new promise.\n    const p = createDeferredPromise();\n    // 2. Let requestObject be the result of invoking the initial value of\n    // Request as constructor with input and init as arguments. If this throws\n    // an exception, reject p with it and return p.\n    let requestObject;\n    try {\n        requestObject = new Request(input, init);\n    } catch (e) {\n        p.reject(e);\n        return p.promise;\n    }\n    // 3. Let request be requestObjects request.\n    const request = requestObject[kState];\n    // 4. If requestObjects signals aborted flag is set, then:\n    if (requestObject.signal.aborted) {\n        // 1. Abort the fetch() call with p, request, null, and\n        //    requestObjects signals abort reason.\n        abortFetch(p, request, null, requestObject.signal.reason);\n        // 2. Return p.\n        return p.promise;\n    }\n    // 5. Let globalObject be requests clients global object.\n    const globalObject = request.client.globalObject;\n    // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n    // requests service-workers mode to \"none\".\n    if (globalObject?.constructor?.name === \"ServiceWorkerGlobalScope\") {\n        request.serviceWorkers = \"none\";\n    }\n    // 7. Let responseObject be null.\n    let responseObject = null;\n    // 8. Let relevantRealm be thiss relevant Realm.\n    const relevantRealm = null;\n    // 9. Let locallyAborted be false.\n    let locallyAborted = false;\n    // 10. Let controller be null.\n    let controller = null;\n    // 11. Add the following abort steps to requestObjects signal:\n    addAbortListener(requestObject.signal, ()=>{\n        // 1. Set locallyAborted to true.\n        locallyAborted = true;\n        // 2. Assert: controller is non-null.\n        assert(controller != null);\n        // 3. Abort controller with requestObjects signals abort reason.\n        controller.abort(requestObject.signal.reason);\n        // 4. Abort the fetch() call with p, request, responseObject,\n        //    and requestObjects signals abort reason.\n        abortFetch(p, request, responseObject, requestObject.signal.reason);\n    });\n    // 12. Let handleFetchDone given response response be to finalize and\n    // report timing with response, globalObject, and \"fetch\".\n    const handleFetchDone = (response)=>finalizeAndReportTiming(response, \"fetch\");\n    // 13. Set controller to the result of calling fetch given request,\n    // with processResponseEndOfBody set to handleFetchDone, and processResponse\n    // given response being these substeps:\n    const processResponse = (response)=>{\n        // 1. If locallyAborted is true, terminate these substeps.\n        if (locallyAborted) {\n            return Promise.resolve();\n        }\n        // 2. If responses aborted flag is set, then:\n        if (response.aborted) {\n            // 1. Let deserializedError be the result of deserialize a serialized\n            //    abort reason given controllers serialized abort reason and\n            //    relevantRealm.\n            // 2. Abort the fetch() call with p, request, responseObject, and\n            //    deserializedError.\n            abortFetch(p, request, responseObject, controller.serializedAbortReason);\n            return Promise.resolve();\n        }\n        // 3. If response is a network error, then reject p with a TypeError\n        // and terminate these substeps.\n        if (response.type === \"error\") {\n            p.reject(Object.assign(new TypeError(\"fetch failed\"), {\n                cause: response.error\n            }));\n            return Promise.resolve();\n        }\n        // 4. Set responseObject to the result of creating a Response object,\n        // given response, \"immutable\", and relevantRealm.\n        responseObject = new Response();\n        responseObject[kState] = response;\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kHeadersList] = response.headersList;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        // 5. Resolve p with responseObject.\n        p.resolve(responseObject);\n    };\n    controller = fetching({\n        request,\n        processResponseEndOfBody: handleFetchDone,\n        processResponse,\n        dispatcher: init.dispatcher ?? getGlobalDispatcher() // undici\n    });\n    // 14. Return p.\n    return p.promise;\n}\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming(response, initiatorType = \"other\") {\n    // 1. If response is an aborted network error, then return.\n    if (response.type === \"error\" && response.aborted) {\n        return;\n    }\n    // 2. If responses URL list is null or empty, then return.\n    if (!response.urlList?.length) {\n        return;\n    }\n    // 3. Let originalURL be responses URL list[0].\n    const originalURL = response.urlList[0];\n    // 4. Let timingInfo be responses timing info.\n    let timingInfo = response.timingInfo;\n    // 5. Let cacheState be responses cache state.\n    let cacheState = response.cacheState;\n    // 6. If originalURLs scheme is not an HTTP(S) scheme, then return.\n    if (!urlIsHttpHttpsScheme(originalURL)) {\n        return;\n    }\n    // 7. If timingInfo is null, then return.\n    if (timingInfo === null) {\n        return;\n    }\n    // 8. If responses timing allow passed flag is not set, then:\n    if (!timingInfo.timingAllowPassed) {\n        //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n        timingInfo = createOpaqueTimingInfo({\n            startTime: timingInfo.startTime\n        });\n        //  2. Set cacheState to the empty string.\n        cacheState = \"\";\n    }\n    // 9. Set timingInfos end time to the coarsened shared current time\n    // given globals relevant settings objects cross-origin isolated\n    // capability.\n    // TODO: given globals relevant settings objects cross-origin isolated\n    // capability?\n    timingInfo.endTime = coarsenedSharedCurrentTime();\n    // 10. Set responses timing info to timingInfo.\n    response.timingInfo = timingInfo;\n    // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n    // global, and cacheState.\n    markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);\n}\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nfunction markResourceTiming(timingInfo, originalURL, initiatorType, globalThis1, cacheState) {\n    if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {\n        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis1, cacheState);\n    }\n}\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch(p, request, responseObject, error) {\n    // Note: AbortSignal.reason was added in node v17.2.0\n    // which would give us an undefined error to reject with.\n    // Remove this once node v16 is no longer supported.\n    if (!error) {\n        error = new DOMException(\"The operation was aborted.\", \"AbortError\");\n    }\n    // 1. Reject promise with error.\n    p.reject(error);\n    // 2. If requests body is not null and is readable, then cancel requests\n    // body with error.\n    if (request.body != null && isReadable(request.body?.stream)) {\n        request.body.stream.cancel(error).catch((err)=>{\n            if (err.code === \"ERR_INVALID_STATE\") {\n                // Node bug?\n                return;\n            }\n            throw err;\n        });\n    }\n    // 3. If responseObject is null, then return.\n    if (responseObject == null) {\n        return;\n    }\n    // 4. Let response be responseObjects response.\n    const response = responseObject[kState];\n    // 5. If responses body is not null and is readable, then error responses\n    // body with error.\n    if (response.body != null && isReadable(response.body?.stream)) {\n        response.body.stream.cancel(error).catch((err)=>{\n            if (err.code === \"ERR_INVALID_STATE\") {\n                // Node bug?\n                return;\n            }\n            throw err;\n        });\n    }\n}\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching({ request, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher// undici\n }) {\n    // 1. Let taskDestination be null.\n    let taskDestination = null;\n    // 2. Let crossOriginIsolatedCapability be false.\n    let crossOriginIsolatedCapability = false;\n    // 3. If requests client is non-null, then:\n    if (request.client != null) {\n        // 1. Set taskDestination to requests clients global object.\n        taskDestination = request.client.globalObject;\n        // 2. Set crossOriginIsolatedCapability to requests clients cross-origin\n        // isolated capability.\n        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;\n    }\n    // 4. If useParallelQueue is true, then set taskDestination to the result of\n    // starting a new parallel queue.\n    // TODO\n    // 5. Let timingInfo be a new fetch timing info whose start time and\n    // post-redirect start time are the coarsened shared current time given\n    // crossOriginIsolatedCapability.\n    const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);\n    const timingInfo = createOpaqueTimingInfo({\n        startTime: currenTime\n    });\n    // 6. Let fetchParams be a new fetch params whose\n    // request is request,\n    // timing info is timingInfo,\n    // process request body chunk length is processRequestBodyChunkLength,\n    // process request end-of-body is processRequestEndOfBody,\n    // process response is processResponse,\n    // process response consume body is processResponseConsumeBody,\n    // process response end-of-body is processResponseEndOfBody,\n    // task destination is taskDestination,\n    // and cross-origin isolated capability is crossOriginIsolatedCapability.\n    const fetchParams = {\n        controller: new Fetch(dispatcher),\n        request,\n        timingInfo,\n        processRequestBodyChunkLength,\n        processRequestEndOfBody,\n        processResponse,\n        processResponseConsumeBody,\n        processResponseEndOfBody,\n        taskDestination,\n        crossOriginIsolatedCapability\n    };\n    // 7. If requests body is a byte sequence, then set requests body to\n    //    requests body as a body.\n    // NOTE: Since fetching is only called from fetch, body should already be\n    // extracted.\n    assert(!request.body || request.body.stream);\n    // 8. If requests window is \"client\", then set requests window to requests\n    // client, if requests clients global object is a Window object; otherwise\n    // \"no-window\".\n    if (request.window === \"client\") {\n        // TODO: What if request.client is null?\n        request.window = request.client?.globalObject?.constructor?.name === \"Window\" ? request.client : \"no-window\";\n    }\n    // 9. If requests origin is \"client\", then set requests origin to requests\n    // clients origin.\n    if (request.origin === \"client\") {\n        // TODO: What if request.client is null?\n        request.origin = request.client?.origin;\n    }\n    // 10. If all of the following conditions are true:\n    // TODO\n    // 11. If requests policy container is \"client\", then:\n    if (request.policyContainer === \"client\") {\n        // 1. If requests client is non-null, then set requests policy\n        // container to a clone of requests clients policy container. [HTML]\n        if (request.client != null) {\n            request.policyContainer = clonePolicyContainer(request.client.policyContainer);\n        } else {\n            // 2. Otherwise, set requests policy container to a new policy\n            // container.\n            request.policyContainer = makePolicyContainer();\n        }\n    }\n    // 12. If requests header list does not contain `Accept`, then:\n    if (!request.headersList.contains(\"accept\")) {\n        // 1. Let value be `*/*`.\n        const value = \"*/*\";\n        // 2. A user agent should set value to the first matching statement, if\n        // any, switching on requests destination:\n        // \"document\"\n        // \"frame\"\n        // \"iframe\"\n        // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n        // \"image\"\n        // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n        // \"style\"\n        // `text/css,*/*;q=0.1`\n        // TODO\n        // 3. Append `Accept`/value to requests header list.\n        request.headersList.append(\"accept\", value);\n    }\n    // 13. If requests header list does not contain `Accept-Language`, then\n    // user agents should append `Accept-Language`/an appropriate value to\n    // requests header list.\n    if (!request.headersList.contains(\"accept-language\")) {\n        request.headersList.append(\"accept-language\", \"*\");\n    }\n    // 14. If requests priority is null, then use requests initiator and\n    // destination appropriately in setting requests priority to a\n    // user-agent-defined object.\n    if (request.priority === null) {\n    // TODO\n    }\n    // 15. If request is a subresource request, then:\n    if (subresourceSet.has(request.destination)) {\n    // TODO\n    }\n    // 16. Run main fetch given fetchParams.\n    mainFetch(fetchParams).catch((err)=>{\n        fetchParams.controller.terminate(err);\n    });\n    // 17. Return fetchParam's controller\n    return fetchParams.controller;\n}\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch(fetchParams, recursive = false) {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. If requests local-URLs-only flag is set and requests current URL is\n    // not local, then set response to a network error.\n    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n        response = makeNetworkError(\"local URLs only\");\n    }\n    // 4. Run report Content Security Policy violations for request.\n    // TODO\n    // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n    tryUpgradeRequestToAPotentiallyTrustworthyURL(request);\n    // 6. If should request be blocked due to a bad port, should fetching request\n    // be blocked as mixed content, or should request be blocked by Content\n    // Security Policy returns blocked, then set response to a network error.\n    if (requestBadPort(request) === \"blocked\") {\n        response = makeNetworkError(\"bad port\");\n    }\n    // TODO: should fetching request be blocked as mixed content?\n    // TODO: should request be blocked by Content Security Policy?\n    // 7. If requests referrer policy is the empty string, then set requests\n    // referrer policy to requests policy containers referrer policy.\n    if (request.referrerPolicy === \"\") {\n        request.referrerPolicy = request.policyContainer.referrerPolicy;\n    }\n    // 8. If requests referrer is not \"no-referrer\", then set requests\n    // referrer to the result of invoking determine requests referrer.\n    if (request.referrer !== \"no-referrer\") {\n        request.referrer = determineRequestsReferrer(request);\n    }\n    // 9. Set requests current URLs scheme to \"https\" if all of the following\n    // conditions are true:\n    // - requests current URLs scheme is \"http\"\n    // - requests current URLs host is a domain\n    // - Matching requests current URLs host per Known HSTS Host Domain Name\n    //   Matching results in either a superdomain match with an asserted\n    //   includeSubDomains directive or a congruent match (with or without an\n    //   asserted includeSubDomains directive). [HSTS]\n    // TODO\n    // 10. If recursive is false, then run the remaining steps in parallel.\n    // TODO\n    // 11. If response is null, then set response to the result of running\n    // the steps corresponding to the first matching statement:\n    if (response === null) {\n        response = await (async ()=>{\n            const currentURL = requestCurrentURL(request);\n            if (// - requests current URLs origin is same origin with requests origin,\n            //   and requests response tainting is \"basic\"\n            sameOrigin(currentURL, request.url) && request.responseTainting === \"basic\" || // requests current URLs scheme is \"data\"\n            currentURL.protocol === \"data:\" || // - requests mode is \"navigate\" or \"websocket\"\n            request.mode === \"navigate\" || request.mode === \"websocket\") {\n                // 1. Set requests response tainting to \"basic\".\n                request.responseTainting = \"basic\";\n                // 2. Return the result of running scheme fetch given fetchParams.\n                return await schemeFetch(fetchParams);\n            }\n            // requests mode is \"same-origin\"\n            if (request.mode === \"same-origin\") {\n                // 1. Return a network error.\n                return makeNetworkError('request mode cannot be \"same-origin\"');\n            }\n            // requests mode is \"no-cors\"\n            if (request.mode === \"no-cors\") {\n                // 1. If requests redirect mode is not \"follow\", then return a network\n                // error.\n                if (request.redirect !== \"follow\") {\n                    return makeNetworkError('redirect mode cannot be \"follow\" for \"no-cors\" request');\n                }\n                // 2. Set requests response tainting to \"opaque\".\n                request.responseTainting = \"opaque\";\n                // 3. Return the result of running scheme fetch given fetchParams.\n                return await schemeFetch(fetchParams);\n            }\n            // requests current URLs scheme is not an HTTP(S) scheme\n            if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n                // Return a network error.\n                return makeNetworkError(\"URL scheme must be a HTTP(S) scheme\");\n            }\n            // - requests use-CORS-preflight flag is set\n            // - requests unsafe-request flag is set and either requests method is\n            //   not a CORS-safelisted method or CORS-unsafe request-header names with\n            //   requests header list is not empty\n            //    1. Set requests response tainting to \"cors\".\n            //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n            //    given fetchParams and true.\n            //    3. If corsWithPreflightResponse is a network error, then clear cache\n            //    entries using request.\n            //    4. Return corsWithPreflightResponse.\n            // TODO\n            // Otherwise\n            //    1. Set requests response tainting to \"cors\".\n            request.responseTainting = \"cors\";\n            //    2. Return the result of running HTTP fetch given fetchParams.\n            return await httpFetch(fetchParams);\n        })();\n    }\n    // 12. If recursive is true, then return response.\n    if (recursive) {\n        return response;\n    }\n    // 13. If response is not a network error and response is not a filtered\n    // response, then:\n    if (response.status !== 0 && !response.internalResponse) {\n        // If requests response tainting is \"cors\", then:\n        if (request.responseTainting === \"cors\") {\n        // 1. Let headerNames be the result of extracting header list values\n        // given `Access-Control-Expose-Headers` and responses header list.\n        // TODO\n        // 2. If requests credentials mode is not \"include\" and headerNames\n        // contains `*`, then set responses CORS-exposed header-name list to\n        // all unique header names in responses header list.\n        // TODO\n        // 3. Otherwise, if headerNames is not null or failure, then set\n        // responses CORS-exposed header-name list to headerNames.\n        // TODO\n        }\n        // Set response to the following filtered response with response as its\n        // internal response, depending on requests response tainting:\n        if (request.responseTainting === \"basic\") {\n            response = filterResponse(response, \"basic\");\n        } else if (request.responseTainting === \"cors\") {\n            response = filterResponse(response, \"cors\");\n        } else if (request.responseTainting === \"opaque\") {\n            response = filterResponse(response, \"opaque\");\n        } else {\n            assert(false);\n        }\n    }\n    // 14. Let internalResponse be response, if response is a network error,\n    // and responses internal response otherwise.\n    let internalResponse = response.status === 0 ? response : response.internalResponse;\n    // 15. If internalResponses URL list is empty, then set it to a clone of\n    // requests URL list.\n    if (internalResponse.urlList.length === 0) {\n        internalResponse.urlList.push(...request.urlList);\n    }\n    // 16. If requests timing allow failed flag is unset, then set\n    // internalResponses timing allow passed flag.\n    if (!request.timingAllowFailed) {\n        response.timingAllowPassed = true;\n    }\n    // 17. If response is not a network error and any of the following returns\n    // blocked\n    // - should internalResponse to request be blocked as mixed content\n    // - should internalResponse to request be blocked by Content Security Policy\n    // - should internalResponse to request be blocked due to its MIME type\n    // - should internalResponse to request be blocked due to nosniff\n    // TODO\n    // 18. If responses type is \"opaque\", internalResponses status is 206,\n    // internalResponses range-requested flag is set, and requests header\n    // list does not contain `Range`, then set response and internalResponse\n    // to a network error.\n    if (response.type === \"opaque\" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains(\"range\")) {\n        response = internalResponse = makeNetworkError();\n    }\n    // 19. If response is not a network error and either requests method is\n    // `HEAD` or `CONNECT`, or internalResponses status is a null body status,\n    // set internalResponses body to null and disregard any enqueuing toward\n    // it (if any).\n    if (response.status !== 0 && (request.method === \"HEAD\" || request.method === \"CONNECT\" || nullBodyStatus.includes(internalResponse.status))) {\n        internalResponse.body = null;\n        fetchParams.controller.dump = true;\n    }\n    // 20. If requests integrity metadata is not the empty string, then:\n    if (request.integrity) {\n        // 1. Let processBodyError be this step: run fetch finale given fetchParams\n        // and a network error.\n        const processBodyError = (reason)=>fetchFinale(fetchParams, makeNetworkError(reason));\n        // 2. If requests response tainting is \"opaque\", or responses body is null,\n        // then run processBodyError and abort these steps.\n        if (request.responseTainting === \"opaque\" || response.body == null) {\n            processBodyError(response.error);\n            return;\n        }\n        // 3. Let processBody given bytes be these steps:\n        const processBody = (bytes)=>{\n            // 1. If bytes do not match requests integrity metadata,\n            // then run processBodyError and abort these steps. [SRI]\n            if (!bytesMatch(bytes, request.integrity)) {\n                processBodyError(\"integrity mismatch\");\n                return;\n            }\n            // 2. Set responses body to bytes as a body.\n            response.body = safelyExtractBody(bytes)[0];\n            // 3. Run fetch finale given fetchParams and response.\n            fetchFinale(fetchParams, response);\n        };\n        // 4. Fully read responses body given processBody and processBodyError.\n        await fullyReadBody(response.body, processBody, processBodyError);\n    } else {\n        // 21. Otherwise, run fetch finale given fetchParams and response.\n        fetchFinale(fetchParams, response);\n    }\n}\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch(fetchParams) {\n    // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n    // cancelled state, we do not want this condition to trigger *unless* there have been\n    // no redirects. See https://github.com/nodejs/undici/issues/1776\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n        return Promise.resolve(makeAppropriateNetworkError(fetchParams));\n    }\n    // 2. Let request be fetchParamss request.\n    const { request } = fetchParams;\n    const { protocol: scheme } = requestCurrentURL(request);\n    // 3. Switch on requests current URLs scheme and run the associated steps:\n    switch(scheme){\n        case \"about:\":\n            {\n                // If requests current URLs path is the string \"blank\", then return a new response\n                // whose status message is `OK`, header list is  (`Content-Type`, `text/html;charset=utf-8`) ,\n                // and body is the empty byte sequence as a body.\n                // Otherwise, return a network error.\n                return Promise.resolve(makeNetworkError(\"about scheme is not supported\"));\n            }\n        case \"blob:\":\n            {\n                if (!resolveObjectURL) {\n                    resolveObjectURL = (__webpack_require__(/*! buffer */ \"buffer\").resolveObjectURL);\n                }\n                // 1. Let blobURLEntry be requests current URLs blob URL entry.\n                const blobURLEntry = requestCurrentURL(request);\n                // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n                // Buffer.resolveObjectURL does not ignore URL queries.\n                if (blobURLEntry.search.length !== 0) {\n                    return Promise.resolve(makeNetworkError(\"NetworkError when attempting to fetch resource.\"));\n                }\n                const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());\n                // 2. If requests method is not `GET`, blobURLEntry is null, or blobURLEntrys\n                //    object is not a Blob object, then return a network error.\n                if (request.method !== \"GET\" || !isBlobLike(blobURLEntryObject)) {\n                    return Promise.resolve(makeNetworkError(\"invalid method\"));\n                }\n                // 3. Let bodyWithType be the result of safely extracting blobURLEntrys object.\n                const bodyWithType = safelyExtractBody(blobURLEntryObject);\n                // 4. Let body be bodyWithTypes body.\n                const body = bodyWithType[0];\n                // 5. Let length be bodys length, serialized and isomorphic encoded.\n                const length = isomorphicEncode(`${body.length}`);\n                // 6. Let type be bodyWithTypes type if it is non-null; otherwise the empty byte sequence.\n                const type = bodyWithType[1] ?? \"\";\n                // 7. Return a new response whose status message is `OK`, header list is\n                //     (`Content-Length`, length), (`Content-Type`, type) , and body is body.\n                const response = makeResponse({\n                    statusText: \"OK\",\n                    headersList: [\n                        [\n                            \"content-length\",\n                            {\n                                name: \"Content-Length\",\n                                value: length\n                            }\n                        ],\n                        [\n                            \"content-type\",\n                            {\n                                name: \"Content-Type\",\n                                value: type\n                            }\n                        ]\n                    ]\n                });\n                response.body = body;\n                return Promise.resolve(response);\n            }\n        case \"data:\":\n            {\n                // 1. Let dataURLStruct be the result of running the\n                //    data: URL processor on requests current URL.\n                const currentURL = requestCurrentURL(request);\n                const dataURLStruct = dataURLProcessor(currentURL);\n                // 2. If dataURLStruct is failure, then return a\n                //    network error.\n                if (dataURLStruct === \"failure\") {\n                    return Promise.resolve(makeNetworkError(\"failed to fetch the data URL\"));\n                }\n                // 3. Let mimeType be dataURLStructs MIME type, serialized.\n                const mimeType = serializeAMimeType(dataURLStruct.mimeType);\n                // 4. Return a response whose status message is `OK`,\n                //    header list is  (`Content-Type`, mimeType) ,\n                //    and body is dataURLStructs body as a body.\n                return Promise.resolve(makeResponse({\n                    statusText: \"OK\",\n                    headersList: [\n                        [\n                            \"content-type\",\n                            {\n                                name: \"Content-Type\",\n                                value: mimeType\n                            }\n                        ]\n                    ],\n                    body: safelyExtractBody(dataURLStruct.body)[0]\n                }));\n            }\n        case \"file:\":\n            {\n                // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n                // When in doubt, return a network error.\n                return Promise.resolve(makeNetworkError(\"not implemented... yet...\"));\n            }\n        case \"http:\":\n        case \"https:\":\n            {\n                // Return the result of running HTTP fetch given fetchParams.\n                return httpFetch(fetchParams).catch((err)=>makeNetworkError(err));\n            }\n        default:\n            {\n                return Promise.resolve(makeNetworkError(\"unknown scheme\"));\n            }\n    }\n}\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse(fetchParams, response) {\n    // 1. Set fetchParamss requests done flag.\n    fetchParams.request.done = true;\n    // 2, If fetchParamss process response done is not null, then queue a fetch\n    // task to run fetchParamss process response done given response, with\n    // fetchParamss task destination.\n    if (fetchParams.processResponseDone != null) {\n        queueMicrotask(()=>fetchParams.processResponseDone(response));\n    }\n}\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale(fetchParams, response) {\n    // 1. If response is a network error, then:\n    if (response.type === \"error\") {\n        // 1. Set responses URL list to  fetchParamss requests URL list[0] .\n        response.urlList = [\n            fetchParams.request.urlList[0]\n        ];\n        // 2. Set responses timing info to the result of creating an opaque timing\n        // info for fetchParamss timing info.\n        response.timingInfo = createOpaqueTimingInfo({\n            startTime: fetchParams.timingInfo.startTime\n        });\n    }\n    // 2. Let processResponseEndOfBody be the following steps:\n    const processResponseEndOfBody = ()=>{\n        // 1. Set fetchParamss requests done flag.\n        fetchParams.request.done = true;\n        // If fetchParamss process response end-of-body is not null,\n        // then queue a fetch task to run fetchParamss process response\n        // end-of-body given response with fetchParamss task destination.\n        if (fetchParams.processResponseEndOfBody != null) {\n            queueMicrotask(()=>fetchParams.processResponseEndOfBody(response));\n        }\n    };\n    // 3. If fetchParamss process response is non-null, then queue a fetch task\n    // to run fetchParamss process response given response, with fetchParamss\n    // task destination.\n    if (fetchParams.processResponse != null) {\n        queueMicrotask(()=>fetchParams.processResponse(response));\n    }\n    // 4. If responses body is null, then run processResponseEndOfBody.\n    if (response.body == null) {\n        processResponseEndOfBody();\n    } else {\n        // 5. Otherwise:\n        // 1. Let transformStream be a new a TransformStream.\n        // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,\n        // enqueues chunk in transformStream.\n        const identityTransformAlgorithm = (chunk, controller)=>{\n            controller.enqueue(chunk);\n        };\n        // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm\n        // and flushAlgorithm set to processResponseEndOfBody.\n        const transformStream = new TransformStream({\n            start () {},\n            transform: identityTransformAlgorithm,\n            flush: processResponseEndOfBody\n        }, {\n            size () {\n                return 1;\n            }\n        }, {\n            size () {\n                return 1;\n            }\n        });\n        // 4. Set responses body to the result of piping responses body through transformStream.\n        response.body = {\n            stream: response.body.stream.pipeThrough(transformStream)\n        };\n    }\n    // 6. If fetchParamss process response consume body is non-null, then:\n    if (fetchParams.processResponseConsumeBody != null) {\n        // 1. Let processBody given nullOrBytes be this step: run fetchParamss\n        // process response consume body given response and nullOrBytes.\n        const processBody = (nullOrBytes)=>fetchParams.processResponseConsumeBody(response, nullOrBytes);\n        // 2. Let processBodyError be this step: run fetchParamss process\n        // response consume body given response and failure.\n        const processBodyError = (failure)=>fetchParams.processResponseConsumeBody(response, failure);\n        // 3. If responses body is null, then queue a fetch task to run processBody\n        // given null, with fetchParamss task destination.\n        if (response.body == null) {\n            queueMicrotask(()=>processBody(null));\n        } else {\n            // 4. Otherwise, fully read responses body given processBody, processBodyError,\n            // and fetchParamss task destination.\n            return fullyReadBody(response.body, processBody, processBodyError);\n        }\n        return Promise.resolve();\n    }\n}\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch(fetchParams) {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. Let actualResponse be null.\n    let actualResponse = null;\n    // 4. Let timingInfo be fetchParamss timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 5. If requests service-workers mode is \"all\", then:\n    if (request.serviceWorkers === \"all\") {\n    // TODO\n    }\n    // 6. If response is null, then:\n    if (response === null) {\n        // 1. If makeCORSPreflight is true and one of these conditions is true:\n        // TODO\n        // 2. If requests redirect mode is \"follow\", then set requests\n        // service-workers mode to \"none\".\n        if (request.redirect === \"follow\") {\n            request.serviceWorkers = \"none\";\n        }\n        // 3. Set response and actualResponse to the result of running\n        // HTTP-network-or-cache fetch given fetchParams.\n        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);\n        // 4. If requests response tainting is \"cors\" and a CORS check\n        // for request and response returns failure, then return a network error.\n        if (request.responseTainting === \"cors\" && corsCheck(request, response) === \"failure\") {\n            return makeNetworkError(\"cors failure\");\n        }\n        // 5. If the TAO check for request and response returns failure, then set\n        // requests timing allow failed flag.\n        if (TAOCheck(request, response) === \"failure\") {\n            request.timingAllowFailed = true;\n        }\n    }\n    // 7. If either requests response tainting or responses type\n    // is \"opaque\", and the cross-origin resource policy check with\n    // requests origin, requests client, requests destination,\n    // and actualResponse returns blocked, then return a network error.\n    if ((request.responseTainting === \"opaque\" || response.type === \"opaque\") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === \"blocked\") {\n        return makeNetworkError(\"blocked\");\n    }\n    // 8. If actualResponses status is a redirect status, then:\n    if (redirectStatusSet.has(actualResponse.status)) {\n        // 1. If actualResponses status is not 303, requests body is not null,\n        // and the connection uses HTTP/2, then user agents may, and are even\n        // encouraged to, transmit an RST_STREAM frame.\n        // See, https://github.com/whatwg/fetch/issues/1288\n        if (request.redirect !== \"manual\") {\n            fetchParams.controller.connection.destroy();\n        }\n        // 2. Switch on requests redirect mode:\n        if (request.redirect === \"error\") {\n            // Set response to a network error.\n            response = makeNetworkError(\"unexpected redirect\");\n        } else if (request.redirect === \"manual\") {\n            // Set response to an opaque-redirect filtered response whose internal\n            // response is actualResponse.\n            // NOTE(spec): On the web this would return an `opaqueredirect` response,\n            // but that doesn't make sense server side.\n            // See https://github.com/nodejs/undici/issues/1193.\n            response = actualResponse;\n        } else if (request.redirect === \"follow\") {\n            // Set response to the result of running HTTP-redirect fetch given\n            // fetchParams and response.\n            response = await httpRedirectFetch(fetchParams, response);\n        } else {\n            assert(false);\n        }\n    }\n    // 9. Set responses timing info to timingInfo.\n    response.timingInfo = timingInfo;\n    // 10. Return response.\n    return response;\n}\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch(fetchParams, response) {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let actualResponse be response, if response is not a filtered response,\n    // and responses internal response otherwise.\n    const actualResponse = response.internalResponse ? response.internalResponse : response;\n    // 3. Let locationURL be actualResponses location URL given requests current\n    // URLs fragment.\n    let locationURL;\n    try {\n        locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);\n        // 4. If locationURL is null, then return response.\n        if (locationURL == null) {\n            return response;\n        }\n    } catch (err) {\n        // 5. If locationURL is failure, then return a network error.\n        return Promise.resolve(makeNetworkError(err));\n    }\n    // 6. If locationURLs scheme is not an HTTP(S) scheme, then return a network\n    // error.\n    if (!urlIsHttpHttpsScheme(locationURL)) {\n        return Promise.resolve(makeNetworkError(\"URL scheme must be a HTTP(S) scheme\"));\n    }\n    // 7. If requests redirect count is 20, then return a network error.\n    if (request.redirectCount === 20) {\n        return Promise.resolve(makeNetworkError(\"redirect count exceeded\"));\n    }\n    // 8. Increase requests redirect count by 1.\n    request.redirectCount += 1;\n    // 9. If requests mode is \"cors\", locationURL includes credentials, and\n    // requests origin is not same origin with locationURLs origin, then return\n    //  a network error.\n    if (request.mode === \"cors\" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {\n        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'));\n    }\n    // 10. If requests response tainting is \"cors\" and locationURL includes\n    // credentials, then return a network error.\n    if (request.responseTainting === \"cors\" && (locationURL.username || locationURL.password)) {\n        return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode \"cors\"'));\n    }\n    // 11. If actualResponses status is not 303, requests body is non-null,\n    // and requests bodys source is null, then return a network error.\n    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {\n        return Promise.resolve(makeNetworkError());\n    }\n    // 12. If one of the following is true\n    // - actualResponses status is 301 or 302 and requests method is `POST`\n    // - actualResponses status is 303 and requests method is not `GET` or `HEAD`\n    if ([\n        301,\n        302\n    ].includes(actualResponse.status) && request.method === \"POST\" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {\n        // then:\n        // 1. Set requests method to `GET` and requests body to null.\n        request.method = \"GET\";\n        request.body = null;\n        // 2. For each headerName of request-body-header name, delete headerName from\n        // requests header list.\n        for (const headerName of requestBodyHeader){\n            request.headersList.delete(headerName);\n        }\n    }\n    // 13. If requests current URLs origin is not same origin with locationURLs\n    //     origin, then for each headerName of CORS non-wildcard request-header name,\n    //     delete headerName from requests header list.\n    if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n        // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n        request.headersList.delete(\"authorization\");\n        // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n        request.headersList.delete(\"cookie\");\n        request.headersList.delete(\"host\");\n    }\n    // 14. If requests body is non-null, then set requests body to the first return\n    // value of safely extracting requests bodys source.\n    if (request.body != null) {\n        assert(request.body.source != null);\n        request.body = safelyExtractBody(request.body.source)[0];\n    }\n    // 15. Let timingInfo be fetchParamss timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 16. Set timingInfos redirect end time and post-redirect start time to the\n    // coarsened shared current time given fetchParamss cross-origin isolated\n    // capability.\n    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n    // 17. If timingInfos redirect start time is 0, then set timingInfos\n    //  redirect start time to timingInfos start time.\n    if (timingInfo.redirectStartTime === 0) {\n        timingInfo.redirectStartTime = timingInfo.startTime;\n    }\n    // 18. Append locationURL to requests URL list.\n    request.urlList.push(locationURL);\n    // 19. Invoke set requests referrer policy on redirect on request and\n    // actualResponse.\n    setRequestReferrerPolicyOnRedirect(request, actualResponse);\n    // 20. Return the result of running main fetch given fetchParams and true.\n    return mainFetch(fetchParams, true);\n}\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let httpFetchParams be null.\n    let httpFetchParams = null;\n    // 3. Let httpRequest be null.\n    let httpRequest = null;\n    // 4. Let response be null.\n    let response = null;\n    // 5. Let storedResponse be null.\n    // TODO: cache\n    // 6. Let httpCache be null.\n    const httpCache = null;\n    // 7. Let the revalidatingFlag be unset.\n    const revalidatingFlag = false;\n    // 8. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. If requests window is \"no-window\" and requests redirect mode is\n    //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n    //    request.\n    if (request.window === \"no-window\" && request.redirect === \"error\") {\n        httpFetchParams = fetchParams;\n        httpRequest = request;\n    } else {\n        // Otherwise:\n        // 1. Set httpRequest to a clone of request.\n        httpRequest = makeRequest(request);\n        // 2. Set httpFetchParams to a copy of fetchParams.\n        httpFetchParams = {\n            ...fetchParams\n        };\n        // 3. Set httpFetchParamss request to httpRequest.\n        httpFetchParams.request = httpRequest;\n    }\n    //    3. Let includeCredentials be true if one of\n    const includeCredentials = request.credentials === \"include\" || request.credentials === \"same-origin\" && request.responseTainting === \"basic\";\n    //    4. Let contentLength be httpRequests bodys length, if httpRequests\n    //    body is non-null; otherwise null.\n    const contentLength = httpRequest.body ? httpRequest.body.length : null;\n    //    5. Let contentLengthHeaderValue be null.\n    let contentLengthHeaderValue = null;\n    //    6. If httpRequests body is null and httpRequests method is `POST` or\n    //    `PUT`, then set contentLengthHeaderValue to `0`.\n    if (httpRequest.body == null && [\n        \"POST\",\n        \"PUT\"\n    ].includes(httpRequest.method)) {\n        contentLengthHeaderValue = \"0\";\n    }\n    //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n    //    contentLength, serialized and isomorphic encoded.\n    if (contentLength != null) {\n        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);\n    }\n    //    8. If contentLengthHeaderValue is non-null, then append\n    //    `Content-Length`/contentLengthHeaderValue to httpRequests header\n    //    list.\n    if (contentLengthHeaderValue != null) {\n        httpRequest.headersList.append(\"content-length\", contentLengthHeaderValue);\n    }\n    //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n    //    contentLengthHeaderValue) to httpRequests header list.\n    //    10. If contentLength is non-null and httpRequests keepalive is true,\n    //    then:\n    if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n    }\n    //    11. If httpRequests referrer is a URL, then append\n    //    `Referer`/httpRequests referrer, serialized and isomorphic encoded,\n    //     to httpRequests header list.\n    if (httpRequest.referrer instanceof URL) {\n        httpRequest.headersList.append(\"referer\", isomorphicEncode(httpRequest.referrer.href));\n    }\n    //    12. Append a request `Origin` header for httpRequest.\n    appendRequestOriginHeader(httpRequest);\n    //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n    appendFetchMetadata(httpRequest);\n    //    14. If httpRequests header list does not contain `User-Agent`, then\n    //    user agents should append `User-Agent`/default `User-Agent` value to\n    //    httpRequests header list.\n    if (!httpRequest.headersList.contains(\"user-agent\")) {\n        httpRequest.headersList.append(\"user-agent\", typeof esbuildDetection === \"undefined\" ? \"undici\" : \"node\");\n    }\n    //    15. If httpRequests cache mode is \"default\" and httpRequests header\n    //    list contains `If-Modified-Since`, `If-None-Match`,\n    //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n    //    httpRequests cache mode to \"no-store\".\n    if (httpRequest.cache === \"default\" && (httpRequest.headersList.contains(\"if-modified-since\") || httpRequest.headersList.contains(\"if-none-match\") || httpRequest.headersList.contains(\"if-unmodified-since\") || httpRequest.headersList.contains(\"if-match\") || httpRequest.headersList.contains(\"if-range\"))) {\n        httpRequest.cache = \"no-store\";\n    }\n    //    16. If httpRequests cache mode is \"no-cache\", httpRequests prevent\n    //    no-cache cache-control header modification flag is unset, and\n    //    httpRequests header list does not contain `Cache-Control`, then append\n    //    `Cache-Control`/`max-age=0` to httpRequests header list.\n    if (httpRequest.cache === \"no-cache\" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains(\"cache-control\")) {\n        httpRequest.headersList.append(\"cache-control\", \"max-age=0\");\n    }\n    //    17. If httpRequests cache mode is \"no-store\" or \"reload\", then:\n    if (httpRequest.cache === \"no-store\" || httpRequest.cache === \"reload\") {\n        // 1. If httpRequests header list does not contain `Pragma`, then append\n        // `Pragma`/`no-cache` to httpRequests header list.\n        if (!httpRequest.headersList.contains(\"pragma\")) {\n            httpRequest.headersList.append(\"pragma\", \"no-cache\");\n        }\n        // 2. If httpRequests header list does not contain `Cache-Control`,\n        // then append `Cache-Control`/`no-cache` to httpRequests header list.\n        if (!httpRequest.headersList.contains(\"cache-control\")) {\n            httpRequest.headersList.append(\"cache-control\", \"no-cache\");\n        }\n    }\n    //    18. If httpRequests header list contains `Range`, then append\n    //    `Accept-Encoding`/`identity` to httpRequests header list.\n    if (httpRequest.headersList.contains(\"range\")) {\n        httpRequest.headersList.append(\"accept-encoding\", \"identity\");\n    }\n    //    19. Modify httpRequests header list per HTTP. Do not append a given\n    //    header if httpRequests header list contains that headers name.\n    //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n    if (!httpRequest.headersList.contains(\"accept-encoding\")) {\n        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n            httpRequest.headersList.append(\"accept-encoding\", \"br, gzip, deflate\");\n        } else {\n            httpRequest.headersList.append(\"accept-encoding\", \"gzip, deflate\");\n        }\n    }\n    httpRequest.headersList.delete(\"host\");\n    //    20. If includeCredentials is true, then:\n    if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequests header list does not contain `Authorization`, then:\n    // TODO: credentials\n    }\n    //    21. If theres a proxy-authentication entry, use it as appropriate.\n    //    TODO: proxy-authentication\n    //    22. Set httpCache to the result of determining the HTTP cache\n    //    partition, given httpRequest.\n    //    TODO: cache\n    //    23. If httpCache is null, then set httpRequests cache mode to\n    //    \"no-store\".\n    if (httpCache == null) {\n        httpRequest.cache = \"no-store\";\n    }\n    //    24. If httpRequests cache mode is neither \"no-store\" nor \"reload\",\n    //    then:\n    if (httpRequest.mode !== \"no-store\" && httpRequest.mode !== \"reload\") {\n    // TODO: cache\n    }\n    // 9. If aborted, then return the appropriate network error for fetchParams.\n    // TODO\n    // 10. If response is null, then:\n    if (response == null) {\n        // 1. If httpRequests cache mode is \"only-if-cached\", then return a\n        // network error.\n        if (httpRequest.mode === \"only-if-cached\") {\n            return makeNetworkError(\"only if cached\");\n        }\n        // 2. Let forwardResponse be the result of running HTTP-network fetch\n        // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n        const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);\n        // 3. If httpRequests method is unsafe and forwardResponses status is\n        // in the range 200 to 399, inclusive, invalidate appropriate stored\n        // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n        // Caching, and set storedResponse to null. [HTTP-CACHING]\n        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {\n        // TODO: cache\n        }\n        // 4. If the revalidatingFlag is set and forwardResponses status is 304,\n        // then:\n        if (revalidatingFlag && forwardResponse.status === 304) {\n        // TODO: cache\n        }\n        // 5. If response is null, then:\n        if (response == null) {\n            // 1. Set response to forwardResponse.\n            response = forwardResponse;\n        // 2. Store httpRequest and forwardResponse in httpCache, as per the\n        // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n        // TODO: cache\n        }\n    }\n    // 11. Set responses URL list to a clone of httpRequests URL list.\n    response.urlList = [\n        ...httpRequest.urlList\n    ];\n    // 12. If httpRequests header list contains `Range`, then set responses\n    // range-requested flag.\n    if (httpRequest.headersList.contains(\"range\")) {\n        response.rangeRequested = true;\n    }\n    // 13. Set responses request-includes-credentials to includeCredentials.\n    response.requestIncludesCredentials = includeCredentials;\n    // 14. If responses status is 401, httpRequests response tainting is not\n    // \"cors\", includeCredentials is true, and requests window is an environment\n    // settings object, then:\n    // TODO\n    // 15. If responses status is 407, then:\n    if (response.status === 407) {\n        // 1. If requests window is \"no-window\", then return a network error.\n        if (request.window === \"no-window\") {\n            return makeNetworkError();\n        }\n        // 2. ???\n        // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n        if (isCancelled(fetchParams)) {\n            return makeAppropriateNetworkError(fetchParams);\n        }\n        // 4. Prompt the end user as appropriate in requests window and store\n        // the result as a proxy-authentication entry. [HTTP-AUTH]\n        // TODO: Invoke some kind of callback?\n        // 5. Set response to the result of running HTTP-network-or-cache fetch given\n        // fetchParams.\n        // TODO\n        return makeNetworkError(\"proxy authentication required\");\n    }\n    // 16. If all of the following are true\n    if (// responses status is 421\n    response.status === 421 && // isNewConnectionFetch is false\n    !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null\n    (request.body == null || request.body.source != null)) {\n        // then:\n        // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n        if (isCancelled(fetchParams)) {\n            return makeAppropriateNetworkError(fetchParams);\n        }\n        // 2. Set response to the result of running HTTP-network-or-cache\n        // fetch given fetchParams, isAuthenticationFetch, and true.\n        // TODO (spec): The spec doesn't specify this but we need to cancel\n        // the active response before we can start a new one.\n        // https://github.com/whatwg/fetch/issues/1293\n        fetchParams.controller.connection.destroy();\n        response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);\n    }\n    // 17. If isAuthenticationFetch is true, then create an authentication entry\n    if (isAuthenticationFetch) {\n    // TODO\n    }\n    // 18. Return response.\n    return response;\n}\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {\n    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);\n    fetchParams.controller.connection = {\n        abort: null,\n        destroyed: false,\n        destroy (err) {\n            if (!this.destroyed) {\n                this.destroyed = true;\n                this.abort?.(err ?? new DOMException(\"The operation was aborted.\", \"AbortError\"));\n            }\n        }\n    };\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. Let timingInfo be fetchParamss timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 4. Let httpCache be the result of determining the HTTP cache partition,\n    // given request.\n    // TODO: cache\n    const httpCache = null;\n    // 5. If httpCache is null, then set requests cache mode to \"no-store\".\n    if (httpCache == null) {\n        request.cache = \"no-store\";\n    }\n    // 6. Let networkPartitionKey be the result of determining the network\n    // partition key given request.\n    // TODO\n    // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n    // \"no\".\n    const newConnection = forceNewConnection ? \"yes\" : \"no\" // eslint-disable-line no-unused-vars\n    ;\n    // 8. Switch on requests mode:\n    if (request.mode === \"websocket\") {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given requests current URL.\n    // TODO\n    } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, requests current URLs origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n    }\n    // 9. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. If connection is failure, then return a network error.\n    //    2. Set timingInfos final connection timing info to the result of\n    //    calling clamp and coarsen connection timing info with connections\n    //    timing info, timingInfos post-redirect start time, and fetchParamss\n    //    cross-origin isolated capability.\n    //    3. If connection is not an HTTP/2 connection, requests body is non-null,\n    //    and requests bodys source is null, then append (`Transfer-Encoding`,\n    //    `chunked`) to requests header list.\n    //    4. Set timingInfos final network-request start time to the coarsened\n    //    shared current time given fetchParamss cross-origin isolated\n    //    capability.\n    //    5. Set response to the result of making an HTTP request over connection\n    //    using request with the following caveats:\n    //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n    //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n    //        - If requests body is non-null, and requests bodys source is null,\n    //        then the user agent may have a buffer of up to 64 kibibytes and store\n    //        a part of requests body in that buffer. If the user agent reads from\n    //        requests body beyond that buffers size and the user agent needs to\n    //        resend request, then instead return a network error.\n    //        - Set timingInfos final network-response start time to the coarsened\n    //        shared current time given fetchParamss cross-origin isolated capability,\n    //        immediately after the user agents HTTP parser receives the first byte\n    //        of the response (e.g., frame header bytes for HTTP/2 or response status\n    //        line for HTTP/1.x).\n    //        - Wait until all the headers are transmitted.\n    //        - Any responses whose status is in the range 100 to 199, inclusive,\n    //        and is not 101, are to be ignored, except for the purposes of setting\n    //        timingInfos final network-response start time above.\n    //    - If requests header list contains `Transfer-Encoding`/`chunked` and\n    //    response is transferred via HTTP/1.0 or older, then return a network\n    //    error.\n    //    - If the HTTP request results in a TLS client certificate dialog, then:\n    //        1. If requests window is an environment settings object, make the\n    //        dialog available in requests window.\n    //        2. Otherwise, return a network error.\n    // To transmit requests body body, run these steps:\n    let requestBody = null;\n    // 1. If body is null and fetchParamss process request end-of-body is\n    // non-null, then queue a fetch task given fetchParamss process request\n    // end-of-body and fetchParamss task destination.\n    if (request.body == null && fetchParams.processRequestEndOfBody) {\n        queueMicrotask(()=>fetchParams.processRequestEndOfBody());\n    } else if (request.body != null) {\n        // 2. Otherwise, if body is non-null:\n        //    1. Let processBodyChunk given bytes be these steps:\n        const processBodyChunk = async function*(bytes) {\n            // 1. If the ongoing fetch is terminated, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. Run this step in parallel: transmit bytes.\n            yield bytes;\n            // 3. If fetchParamss process request body is non-null, then run\n            // fetchParamss process request body given bytess length.\n            fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);\n        };\n        // 2. Let processEndOfBody be these steps:\n        const processEndOfBody = ()=>{\n            // 1. If fetchParams is canceled, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. If fetchParamss process request end-of-body is non-null,\n            // then run fetchParamss process request end-of-body.\n            if (fetchParams.processRequestEndOfBody) {\n                fetchParams.processRequestEndOfBody();\n            }\n        };\n        // 3. Let processBodyError given e be these steps:\n        const processBodyError = (e)=>{\n            // 1. If fetchParams is canceled, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. If e is an \"AbortError\" DOMException, then abort fetchParamss controller.\n            if (e.name === \"AbortError\") {\n                fetchParams.controller.abort();\n            } else {\n                fetchParams.controller.terminate(e);\n            }\n        };\n        // 4. Incrementally read requests body given processBodyChunk, processEndOfBody,\n        // processBodyError, and fetchParamss task destination.\n        requestBody = async function*() {\n            try {\n                for await (const bytes of request.body.stream){\n                    yield* processBodyChunk(bytes);\n                }\n                processEndOfBody();\n            } catch (err) {\n                processBodyError(err);\n            }\n        }();\n    }\n    try {\n        // socket is only provided for websockets\n        const { body, status, statusText, headersList, socket } = await dispatch({\n            body: requestBody\n        });\n        if (socket) {\n            response = makeResponse({\n                status,\n                statusText,\n                headersList,\n                socket\n            });\n        } else {\n            const iterator = body[Symbol.asyncIterator]();\n            fetchParams.controller.next = ()=>iterator.next();\n            response = makeResponse({\n                status,\n                statusText,\n                headersList\n            });\n        }\n    } catch (err) {\n        // 10. If aborted, then:\n        if (err.name === \"AbortError\") {\n            // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n            fetchParams.controller.connection.destroy();\n            // 2. Return the appropriate network error for fetchParams.\n            return makeAppropriateNetworkError(fetchParams, err);\n        }\n        return makeNetworkError(err);\n    }\n    // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n    // if it is suspended.\n    const pullAlgorithm = ()=>{\n        fetchParams.controller.resume();\n    };\n    // 12. Let cancelAlgorithm be an algorithm that aborts fetchParamss\n    // controller with reason, given reason.\n    const cancelAlgorithm = (reason)=>{\n        fetchParams.controller.abort(reason);\n    };\n    // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n    // the user agent.\n    // TODO\n    // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n    // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n    // TODO\n    // 15. Let stream be a new ReadableStream.\n    // 16. Set up stream with pullAlgorithm set to pullAlgorithm,\n    // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to\n    // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.\n    if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    const stream = new ReadableStream({\n        async start (controller) {\n            fetchParams.controller.controller = controller;\n        },\n        async pull (controller) {\n            await pullAlgorithm(controller);\n        },\n        async cancel (reason) {\n            await cancelAlgorithm(reason);\n        }\n    }, {\n        highWaterMark: 0,\n        size () {\n            return 1;\n        }\n    });\n    // 17. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. Set responses body to a new body whose stream is stream.\n    response.body = {\n        stream\n    };\n    //    2. If response is not a network error and requests cache mode is\n    //    not \"no-store\", then update response in httpCache for request.\n    //    TODO\n    //    3. If includeCredentials is true and the user agent is not configured\n    //    to block cookies for request (see section 7 of [COOKIES]), then run the\n    //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n    //    the value of each header whose name is a byte-case-insensitive match for\n    //    `Set-Cookie` in responses header list, if any, and requests current URL.\n    //    TODO\n    // 18. If aborted, then:\n    // TODO\n    // 19. Run these steps in parallel:\n    //    1. Run these steps, but abort when fetchParams is canceled:\n    fetchParams.controller.on(\"terminated\", onAborted);\n    fetchParams.controller.resume = async ()=>{\n        // 1. While true\n        while(true){\n            // 1-3. See onData...\n            // 4. Set bytes to the result of handling content codings given\n            // codings and bytes.\n            let bytes;\n            let isFailure;\n            try {\n                const { done, value } = await fetchParams.controller.next();\n                if (isAborted(fetchParams)) {\n                    break;\n                }\n                bytes = done ? undefined : value;\n            } catch (err) {\n                if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n                    // zlib doesn't like empty streams.\n                    bytes = undefined;\n                } else {\n                    bytes = err;\n                    // err may be propagated from the result of calling readablestream.cancel,\n                    // which might not be an error. https://github.com/nodejs/undici/issues/2009\n                    isFailure = true;\n                }\n            }\n            if (bytes === undefined) {\n                // 2. Otherwise, if the bytes transmission for responses message\n                // body is done normally and stream is readable, then close\n                // stream, finalize response for fetchParams and response, and\n                // abort these in-parallel steps.\n                readableStreamClose(fetchParams.controller.controller);\n                finalizeResponse(fetchParams, response);\n                return;\n            }\n            // 5. Increase timingInfos decoded body size by bytess length.\n            timingInfo.decodedBodySize += bytes?.byteLength ?? 0;\n            // 6. If bytes is failure, then terminate fetchParamss controller.\n            if (isFailure) {\n                fetchParams.controller.terminate(bytes);\n                return;\n            }\n            // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n            // into stream.\n            fetchParams.controller.controller.enqueue(new Uint8Array(bytes));\n            // 8. If stream is errored, then terminate the ongoing fetch.\n            if (isErrored(stream)) {\n                fetchParams.controller.terminate();\n                return;\n            }\n            // 9. If stream doesnt need more data ask the user agent to suspend\n            // the ongoing fetch.\n            if (!fetchParams.controller.controller.desiredSize) {\n                return;\n            }\n        }\n    };\n    //    2. If aborted, then:\n    function onAborted(reason) {\n        // 2. If fetchParams is aborted, then:\n        if (isAborted(fetchParams)) {\n            // 1. Set responses aborted flag.\n            response.aborted = true;\n            // 2. If stream is readable, then error stream with the result of\n            //    deserialize a serialized abort reason given fetchParamss\n            //    controllers serialized abort reason and an\n            //    implementation-defined realm.\n            if (isReadable(stream)) {\n                fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);\n            }\n        } else {\n            // 3. Otherwise, if stream is readable, error stream with a TypeError.\n            if (isReadable(stream)) {\n                fetchParams.controller.controller.error(new TypeError(\"terminated\", {\n                    cause: isErrorLike(reason) ? reason : undefined\n                }));\n            }\n        }\n        // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n        // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n        fetchParams.controller.connection.destroy();\n    }\n    // 20. Return response.\n    return response;\n    async function dispatch({ body }) {\n        const url = requestCurrentURL(request);\n        /** @type {import('../..').Agent} */ const agent = fetchParams.controller.dispatcher;\n        return new Promise((resolve, reject)=>agent.dispatch({\n                path: url.pathname + url.search,\n                origin: url.origin,\n                method: request.method,\n                body: fetchParams.controller.dispatcher.isMockActive ? request.body && request.body.source : body,\n                headers: request.headersList.entries,\n                maxRedirections: 0,\n                upgrade: request.mode === \"websocket\" ? \"websocket\" : undefined\n            }, {\n                body: null,\n                abort: null,\n                onConnect (abort) {\n                    // TODO (fix): Do we need connection here?\n                    const { connection } = fetchParams.controller;\n                    if (connection.destroyed) {\n                        abort(new DOMException(\"The operation was aborted.\", \"AbortError\"));\n                    } else {\n                        fetchParams.controller.on(\"terminated\", abort);\n                        this.abort = connection.abort = abort;\n                    }\n                },\n                onHeaders (status, headersList, resume, statusText) {\n                    if (status < 200) {\n                        return;\n                    }\n                    let codings = [];\n                    let location = \"\";\n                    const headers = new Headers();\n                    // For H2, the headers are a plain JS object\n                    // We distinguish between them and iterate accordingly\n                    if (Array.isArray(headersList)) {\n                        for(let n = 0; n < headersList.length; n += 2){\n                            const key = headersList[n + 0].toString(\"latin1\");\n                            const val = headersList[n + 1].toString(\"latin1\");\n                            if (key.toLowerCase() === \"content-encoding\") {\n                                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                                // \"All content-coding values are case-insensitive...\"\n                                codings = val.toLowerCase().split(\",\").map((x)=>x.trim());\n                            } else if (key.toLowerCase() === \"location\") {\n                                location = val;\n                            }\n                            headers.append(key, val);\n                        }\n                    } else {\n                        const keys = Object.keys(headersList);\n                        for (const key of keys){\n                            const val = headersList[key];\n                            if (key.toLowerCase() === \"content-encoding\") {\n                                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                                // \"All content-coding values are case-insensitive...\"\n                                codings = val.toLowerCase().split(\",\").map((x)=>x.trim()).reverse();\n                            } else if (key.toLowerCase() === \"location\") {\n                                location = val;\n                            }\n                            headers.append(key, val);\n                        }\n                    }\n                    this.body = new Readable({\n                        read: resume\n                    });\n                    const decoders = [];\n                    const willFollow = request.redirect === \"follow\" && location && redirectStatusSet.has(status);\n                    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n                    if (request.method !== \"HEAD\" && request.method !== \"CONNECT\" && !nullBodyStatus.includes(status) && !willFollow) {\n                        for (const coding of codings){\n                            // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n                            if (coding === \"x-gzip\" || coding === \"gzip\") {\n                                decoders.push(zlib.createGunzip({\n                                    // Be less strict when decoding compressed responses, since sometimes\n                                    // servers send slightly invalid responses that are still accepted\n                                    // by common browsers.\n                                    // Always using Z_SYNC_FLUSH is what cURL does.\n                                    flush: zlib.constants.Z_SYNC_FLUSH,\n                                    finishFlush: zlib.constants.Z_SYNC_FLUSH\n                                }));\n                            } else if (coding === \"deflate\") {\n                                decoders.push(zlib.createInflate());\n                            } else if (coding === \"br\") {\n                                decoders.push(zlib.createBrotliDecompress());\n                            } else {\n                                decoders.length = 0;\n                                break;\n                            }\n                        }\n                    }\n                    resolve({\n                        status,\n                        statusText,\n                        headersList: headers[kHeadersList],\n                        body: decoders.length ? pipeline(this.body, ...decoders, ()=>{}) : this.body.on(\"error\", ()=>{})\n                    });\n                    return true;\n                },\n                onData (chunk) {\n                    if (fetchParams.controller.dump) {\n                        return;\n                    }\n                    // 1. If one or more bytes have been transmitted from responses\n                    // message body, then:\n                    //  1. Let bytes be the transmitted bytes.\n                    const bytes = chunk;\n                    //  2. Let codings be the result of extracting header list values\n                    //  given `Content-Encoding` and responses header list.\n                    //  See pullAlgorithm.\n                    //  3. Increase timingInfos encoded body size by bytess length.\n                    timingInfo.encodedBodySize += bytes.byteLength;\n                    //  4. See pullAlgorithm...\n                    return this.body.push(bytes);\n                },\n                onComplete () {\n                    if (this.abort) {\n                        fetchParams.controller.off(\"terminated\", this.abort);\n                    }\n                    fetchParams.controller.ended = true;\n                    this.body.push(null);\n                },\n                onError (error) {\n                    if (this.abort) {\n                        fetchParams.controller.off(\"terminated\", this.abort);\n                    }\n                    this.body?.destroy(error);\n                    fetchParams.controller.terminate(error);\n                    reject(error);\n                },\n                onUpgrade (status, headersList, socket) {\n                    if (status !== 101) {\n                        return;\n                    }\n                    const headers = new Headers();\n                    for(let n = 0; n < headersList.length; n += 2){\n                        const key = headersList[n + 0].toString(\"latin1\");\n                        const val = headersList[n + 1].toString(\"latin1\");\n                        headers.append(key, val);\n                    }\n                    resolve({\n                        status,\n                        statusText: STATUS_CODES[status],\n                        headersList: headers[kHeadersList],\n                        socket\n                    });\n                    return true;\n                }\n            }));\n    }\n}\nmodule.exports = {\n    fetch,\n    Fetch,\n    fetching,\n    finalizeAndReportTiming\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsaURBQWlEO0FBRWpEO0FBRUEsTUFBTSxFQUNKQSxRQUFRLEVBQ1JDLGdCQUFnQixFQUNoQkMsMkJBQTJCLEVBQzNCQyxjQUFjLEVBQ2RDLFlBQVksRUFDYixHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRUMsT0FBTyxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQzVCLE1BQU0sRUFBRUUsT0FBTyxFQUFFQyxXQUFXLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFDekMsTUFBTUksT0FBT0osbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUNKSyxVQUFVLEVBQ1ZDLG1CQUFtQixFQUNuQkMsb0JBQW9CLEVBQ3BCQyxjQUFjLEVBQ2RDLFFBQVEsRUFDUkMseUJBQXlCLEVBQ3pCQyxtQkFBbUIsRUFDbkJDLGlCQUFpQixFQUNqQkMsa0NBQWtDLEVBQ2xDQyw2Q0FBNkMsRUFDN0NDLHNCQUFzQixFQUN0QkMsbUJBQW1CLEVBQ25CQyxTQUFTLEVBQ1RDLDhCQUE4QixFQUM5QkMseUJBQXlCLEVBQ3pCQywwQkFBMEIsRUFDMUJDLHFCQUFxQixFQUNyQkMsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsU0FBUyxFQUNUQyxXQUFXLEVBQ1hDLGFBQWEsRUFDYkMsbUJBQW1CLEVBQ25CQyxnQkFBZ0IsRUFDaEJDLFVBQVUsRUFDVkMsb0JBQW9CLEVBQ3BCQyxpQkFBaUIsRUFDbEIsR0FBR2hDLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFaUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdwQyxtQkFBT0EsQ0FBQztBQUNyRCxNQUFNcUMsU0FBU3JDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRXNDLGlCQUFpQixFQUFFLEdBQUd0QyxtQkFBT0EsQ0FBQztBQUN0QyxNQUFNLEVBQ0p1Qyxp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QUNvRCxJQUFJLEVBQUV0RCxRQUFRRztvQkFFbkJnRSxZQUFZeEMsVUFBVSxDQUFDN0IsU0FBUyxDQUFDSztvQkFFakNXLE9BQU9YO2dCQUNUO2dCQUVBNE4sV0FBV3JJLE1BQU0sRUFBRW5ELFdBQVcsRUFBRStILE1BQU07b0JBQ3BDLElBQUk1RSxXQUFXLEtBQUs7d0JBQ2xCO29CQUNGO29CQUVBLE1BQU1LLFVBQVUsSUFBSXZLO29CQUVwQixJQUFLLElBQUkrUSxJQUFJLEdBQUdBLElBQUloSyxZQUFZSyxNQUFNLEVBQUUySixLQUFLLEVBQUc7d0JBQzlDLE1BQU1DLE1BQU1qSyxXQUFXLENBQUNnSyxJQUFJLEVBQUUsQ0FBQzNGLFFBQVEsQ0FBQzt3QkFDeEMsTUFBTTZGLE1BQU1sSyxXQUFXLENBQUNnSyxJQUFJLEVBQUUsQ0FBQzNGLFFBQVEsQ0FBQzt3QkFFeENiLFFBQVF0QixNQUFNLENBQUMrSCxLQUFLQztvQkFDdEI7b0JBRUF4SyxRQUFRO3dCQUNOeUQ7d0JBQ0FvQixZQUFZNUgsWUFBWSxDQUFDd0csT0FBTzt3QkFDaENuRCxhQUFhd0QsT0FBTyxDQUFDM0gsYUFBYTt3QkFDbENrTTtvQkFDRjtvQkFFQSxPQUFPO2dCQUNUO1lBQ0Y7SUFFSjtBQUNGO0FBRUEwRCxPQUFPQyxPQUFPLEdBQUc7SUFDZjVOO0lBQ0FkO0lBQ0FpRDtJQUNBVjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9pbmRleC5qcz84ZWFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9FdGhhbi1BcnJvd29vZC91bmRpY2ktZmV0Y2hcblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgUmVzcG9uc2UsXG4gIG1ha2VOZXR3b3JrRXJyb3IsXG4gIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcixcbiAgZmlsdGVyUmVzcG9uc2UsXG4gIG1ha2VSZXNwb25zZVxufSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKVxuY29uc3QgeyBIZWFkZXJzIH0gPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuY29uc3QgeyBSZXF1ZXN0LCBtYWtlUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi9yZXF1ZXN0JylcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJylcbmNvbnN0IHtcbiAgYnl0ZXNNYXRjaCxcbiAgbWFrZVBvbGljeUNvbnRhaW5lcixcbiAgY2xvbmVQb2xpY3lDb250YWluZXIsXG4gIHJlcXVlc3RCYWRQb3J0LFxuICBUQU9DaGVjayxcbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcixcbiAgcmVzcG9uc2VMb2NhdGlvblVSTCxcbiAgcmVxdWVzdEN1cnJlbnRVUkwsXG4gIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QsXG4gIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCxcbiAgY3JlYXRlT3BhcXVlVGltaW5nSW5mbyxcbiAgYXBwZW5kRmV0Y2hNZXRhZGF0YSxcbiAgY29yc0NoZWNrLFxuICBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2ssXG4gIGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIsXG4gIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lLFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gIGlzQmxvYkxpa2UsXG4gIHNhbWVPcmlnaW4sXG4gIGlzQ2FuY2VsbGVkLFxuICBpc0Fib3J0ZWQsXG4gIGlzRXJyb3JMaWtlLFxuICBmdWxseVJlYWRCb2R5LFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBpc29tb3JwaGljRW5jb2RlLFxuICB1cmxJc0xvY2FsLFxuICB1cmxJc0h0dHBIdHRwc1NjaGVtZSxcbiAgdXJsSGFzSHR0cHNTY2hlbWVcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrU3RhdGUsIGtIZWFkZXJzLCBrR3VhcmQsIGtSZWFsbSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IHNhZmVseUV4dHJhY3RCb2R5IH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3Qge1xuICByZWRpcmVjdFN0YXR1c1NldCxcbiAgbnVsbEJvZHlTdGF0dXMsXG4gIHNhZmVNZXRob2RzU2V0LFxuICByZXF1ZXN0Qm9keUhlYWRlcixcbiAgc3VicmVzb3VyY2VTZXQsXG4gIERPTUV4Y2VwdGlvblxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsga0hlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgeyBSZWFkYWJsZSwgcGlwZWxpbmUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCB7IGFkZEFib3J0TGlzdGVuZXIsIGlzRXJyb3JlZCwgaXNSZWFkYWJsZSwgbm9kZU1ham9yLCBub2RlTWlub3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGRhdGFVUkxQcm9jZXNzb3IsIHNlcmlhbGl6ZUFNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhVVJMJylcbmNvbnN0IHsgVHJhbnNmb3JtU3RyZWFtIH0gPSByZXF1aXJlKCdzdHJlYW0vd2ViJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi4vZ2xvYmFsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnaHR0cCcpXG5jb25zdCBHRVRfT1JfSEVBRCA9IFsnR0VUJywgJ0hFQUQnXVxuXG4vKiogQHR5cGUge2ltcG9ydCgnYnVmZmVyJykucmVzb2x2ZU9iamVjdFVSTH0gKi9cbmxldCByZXNvbHZlT2JqZWN0VVJMXG5sZXQgUmVhZGFibGVTdHJlYW0gPSBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtXG5cbmNsYXNzIEZldGNoIGV4dGVuZHMgRUUge1xuICBjb25zdHJ1Y3RvciAoZGlzcGF0Y2hlcikge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXJcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsXG4gICAgdGhpcy5kdW1wID0gZmFsc2VcbiAgICB0aGlzLnN0YXRlID0gJ29uZ29pbmcnXG4gICAgLy8gMiB0ZXJtaW5hdGVkIGxpc3RlbmVycyBnZXQgYWRkZWQgcGVyIHJlcXVlc3QsXG4gICAgLy8gYnV0IG9ubHkgMSBnZXRzIHJlbW92ZWQuIElmIHRoZXJlIGFyZSAyMCByZWRpcmVjdHMsXG4gICAgLy8gMjEgbGlzdGVuZXJzIHdpbGwgYmUgYWRkZWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNzExXG4gICAgLy8gVE9ETyAoZml4KTogRmluZCBhbmQgZml4IHJvb3QgY2F1c2UgZm9yIGxlYWtlZCBsaXN0ZW5lci5cbiAgICB0aGlzLnNldE1heExpc3RlbmVycygyMSlcbiAgfVxuXG4gIHRlcm1pbmF0ZSAocmVhc29uKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09ICdvbmdvaW5nJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9ICd0ZXJtaW5hdGVkJ1xuICAgIHRoaXMuY29ubmVjdGlvbj8uZGVzdHJveShyZWFzb24pXG4gICAgdGhpcy5lbWl0KCd0ZXJtaW5hdGVkJywgcmVhc29uKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoLWNvbnRyb2xsZXItYWJvcnRcbiAgYWJvcnQgKGVycm9yKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09ICdvbmdvaW5nJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMS4gU2V0IGNvbnRyb2xsZXLigJlzIHN0YXRlIHRvIFwiYWJvcnRlZFwiLlxuICAgIHRoaXMuc3RhdGUgPSAnYWJvcnRlZCdcblxuICAgIC8vIDIuIExldCBmYWxsYmFja0Vycm9yIGJlIGFuIFwiQWJvcnRFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICAvLyAzLiBTZXQgZXJyb3IgdG8gZmFsbGJhY2tFcnJvciBpZiBpdCBpcyBub3QgZ2l2ZW4uXG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgZXJyb3IgPSBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJylcbiAgICB9XG5cbiAgICAvLyA0LiBMZXQgc2VyaWFsaXplZEVycm9yIGJlIFN0cnVjdHVyZWRTZXJpYWxpemUoZXJyb3IpLlxuICAgIC8vICAgIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCBjYXRjaCBpdCwgYW5kIGxldFxuICAgIC8vICAgIHNlcmlhbGl6ZWRFcnJvciBiZSBTdHJ1Y3R1cmVkU2VyaWFsaXplKGZhbGxiYWNrRXJyb3IpLlxuXG4gICAgLy8gNS4gU2V0IGNvbnRyb2xsZXLigJlzIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIHRvIHNlcmlhbGl6ZWRFcnJvci5cbiAgICB0aGlzLnNlcmlhbGl6ZWRBYm9ydFJlYXNvbiA9IGVycm9yXG5cbiAgICB0aGlzLmNvbm5lY3Rpb24/LmRlc3Ryb3koZXJyb3IpXG4gICAgdGhpcy5lbWl0KCd0ZXJtaW5hdGVkJywgZXJyb3IpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoLW1ldGhvZFxuZnVuY3Rpb24gZmV0Y2ggKGlucHV0LCBpbml0ID0ge30pIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ2dsb2JhbFRoaXMuZmV0Y2gnIH0pXG5cbiAgLy8gMS4gTGV0IHAgYmUgYSBuZXcgcHJvbWlzZS5cbiAgY29uc3QgcCA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgLy8gMi4gTGV0IHJlcXVlc3RPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgaW5pdGlhbCB2YWx1ZSBvZlxuICAvLyBSZXF1ZXN0IGFzIGNvbnN0cnVjdG9yIHdpdGggaW5wdXQgYW5kIGluaXQgYXMgYXJndW1lbnRzLiBJZiB0aGlzIHRocm93c1xuICAvLyBhbiBleGNlcHRpb24sIHJlamVjdCBwIHdpdGggaXQgYW5kIHJldHVybiBwLlxuICBsZXQgcmVxdWVzdE9iamVjdFxuXG4gIHRyeSB7XG4gICAgcmVxdWVzdE9iamVjdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICB9IGNhdGNoIChlKSB7XG4gICAgcC5yZWplY3QoZSlcbiAgICByZXR1cm4gcC5wcm9taXNlXG4gIH1cblxuICAvLyAzLiBMZXQgcmVxdWVzdCBiZSByZXF1ZXN0T2JqZWN04oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdE9iamVjdFtrU3RhdGVdXG5cbiAgLy8gNC4gSWYgcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydGVkIGZsYWcgaXMgc2V0LCB0aGVuOlxuICBpZiAocmVxdWVzdE9iamVjdC5zaWduYWwuYWJvcnRlZCkge1xuICAgIC8vIDEuIEFib3J0IHRoZSBmZXRjaCgpIGNhbGwgd2l0aCBwLCByZXF1ZXN0LCBudWxsLCBhbmRcbiAgICAvLyAgICByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0IHJlYXNvbi5cbiAgICBhYm9ydEZldGNoKHAsIHJlcXVlc3QsIG51bGwsIHJlcXVlc3RPYmplY3Quc2lnbmFsLnJlYXNvbilcblxuICAgIC8vIDIuIFJldHVybiBwLlxuICAgIHJldHVybiBwLnByb21pc2VcbiAgfVxuXG4gIC8vIDUuIExldCBnbG9iYWxPYmplY3QgYmUgcmVxdWVzdOKAmXMgY2xpZW504oCZcyBnbG9iYWwgb2JqZWN0LlxuICBjb25zdCBnbG9iYWxPYmplY3QgPSByZXF1ZXN0LmNsaWVudC5nbG9iYWxPYmplY3RcblxuICAvLyA2LiBJZiBnbG9iYWxPYmplY3QgaXMgYSBTZXJ2aWNlV29ya2VyR2xvYmFsU2NvcGUgb2JqZWN0LCB0aGVuIHNldFxuICAvLyByZXF1ZXN04oCZcyBzZXJ2aWNlLXdvcmtlcnMgbW9kZSB0byBcIm5vbmVcIi5cbiAgaWYgKGdsb2JhbE9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdTZXJ2aWNlV29ya2VyR2xvYmFsU2NvcGUnKSB7XG4gICAgcmVxdWVzdC5zZXJ2aWNlV29ya2VycyA9ICdub25lJ1xuICB9XG5cbiAgLy8gNy4gTGV0IHJlc3BvbnNlT2JqZWN0IGJlIG51bGwuXG4gIGxldCByZXNwb25zZU9iamVjdCA9IG51bGxcblxuICAvLyA4LiBMZXQgcmVsZXZhbnRSZWFsbSBiZSB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgY29uc3QgcmVsZXZhbnRSZWFsbSA9IG51bGxcblxuICAvLyA5LiBMZXQgbG9jYWxseUFib3J0ZWQgYmUgZmFsc2UuXG4gIGxldCBsb2NhbGx5QWJvcnRlZCA9IGZhbHNlXG5cbiAgLy8gMTAuIExldCBjb250cm9sbGVyIGJlIG51bGwuXG4gIGxldCBjb250cm9sbGVyID0gbnVsbFxuXG4gIC8vIDExLiBBZGQgdGhlIGZvbGxvd2luZyBhYm9ydCBzdGVwcyB0byByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWw6XG4gIGFkZEFib3J0TGlzdGVuZXIoXG4gICAgcmVxdWVzdE9iamVjdC5zaWduYWwsXG4gICAgKCkgPT4ge1xuICAgICAgLy8gMS4gU2V0IGxvY2FsbHlBYm9ydGVkIHRvIHRydWUuXG4gICAgICBsb2NhbGx5QWJvcnRlZCA9IHRydWVcblxuICAgICAgLy8gMi4gQXNzZXJ0OiBjb250cm9sbGVyIGlzIG5vbi1udWxsLlxuICAgICAgYXNzZXJ0KGNvbnRyb2xsZXIgIT0gbnVsbClcblxuICAgICAgLy8gMy4gQWJvcnQgY29udHJvbGxlciB3aXRoIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnQgcmVhc29uLlxuICAgICAgY29udHJvbGxlci5hYm9ydChyZXF1ZXN0T2JqZWN0LnNpZ25hbC5yZWFzb24pXG5cbiAgICAgIC8vIDQuIEFib3J0IHRoZSBmZXRjaCgpIGNhbGwgd2l0aCBwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCxcbiAgICAgIC8vICAgIGFuZCByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0IHJlYXNvbi5cbiAgICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIHJlcXVlc3RPYmplY3Quc2lnbmFsLnJlYXNvbilcbiAgICB9XG4gIClcblxuICAvLyAxMi4gTGV0IGhhbmRsZUZldGNoRG9uZSBnaXZlbiByZXNwb25zZSByZXNwb25zZSBiZSB0byBmaW5hbGl6ZSBhbmRcbiAgLy8gcmVwb3J0IHRpbWluZyB3aXRoIHJlc3BvbnNlLCBnbG9iYWxPYmplY3QsIGFuZCBcImZldGNoXCIuXG4gIGNvbnN0IGhhbmRsZUZldGNoRG9uZSA9IChyZXNwb25zZSkgPT5cbiAgICBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZyhyZXNwb25zZSwgJ2ZldGNoJylcblxuICAvLyAxMy4gU2V0IGNvbnRyb2xsZXIgdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGZldGNoIGdpdmVuIHJlcXVlc3QsXG4gIC8vIHdpdGggcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IHNldCB0byBoYW5kbGVGZXRjaERvbmUsIGFuZCBwcm9jZXNzUmVzcG9uc2VcbiAgLy8gZ2l2ZW4gcmVzcG9uc2UgYmVpbmcgdGhlc2Ugc3Vic3RlcHM6XG5cbiAgY29uc3QgcHJvY2Vzc1Jlc3BvbnNlID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgLy8gMS4gSWYgbG9jYWxseUFib3J0ZWQgaXMgdHJ1ZSwgdGVybWluYXRlIHRoZXNlIHN1YnN0ZXBzLlxuICAgIGlmIChsb2NhbGx5QWJvcnRlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgcmVzcG9uc2XigJlzIGFib3J0ZWQgZmxhZyBpcyBzZXQsIHRoZW46XG4gICAgaWYgKHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICAgIC8vIDEuIExldCBkZXNlcmlhbGl6ZWRFcnJvciBiZSB0aGUgcmVzdWx0IG9mIGRlc2VyaWFsaXplIGEgc2VyaWFsaXplZFxuICAgICAgLy8gICAgYWJvcnQgcmVhc29uIGdpdmVuIGNvbnRyb2xsZXLigJlzIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIGFuZFxuICAgICAgLy8gICAgcmVsZXZhbnRSZWFsbS5cblxuICAgICAgLy8gMi4gQWJvcnQgdGhlIGZldGNoKCkgY2FsbCB3aXRoIHAsIHJlcXVlc3QsIHJlc3BvbnNlT2JqZWN0LCBhbmRcbiAgICAgIC8vICAgIGRlc2VyaWFsaXplZEVycm9yLlxuXG4gICAgICBhYm9ydEZldGNoKHAsIHJlcXVlc3QsIHJlc3BvbnNlT2JqZWN0LCBjb250cm9sbGVyLnNlcmlhbGl6ZWRBYm9ydFJlYXNvbilcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIC8vIDMuIElmIHJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvciwgdGhlbiByZWplY3QgcCB3aXRoIGEgVHlwZUVycm9yXG4gICAgLy8gYW5kIHRlcm1pbmF0ZSB0aGVzZSBzdWJzdGVwcy5cbiAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgcC5yZWplY3QoXG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV3IFR5cGVFcnJvcignZmV0Y2ggZmFpbGVkJyksIHsgY2F1c2U6IHJlc3BvbnNlLmVycm9yIH0pXG4gICAgICApXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICAvLyA0LiBTZXQgcmVzcG9uc2VPYmplY3QgdG8gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCxcbiAgICAvLyBnaXZlbiByZXNwb25zZSwgXCJpbW11dGFibGVcIiwgYW5kIHJlbGV2YW50UmVhbG0uXG4gICAgcmVzcG9uc2VPYmplY3QgPSBuZXcgUmVzcG9uc2UoKVxuICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0gPSByZXNwb25zZVxuICAgIHJlc3BvbnNlT2JqZWN0W2tSZWFsbV0gPSByZWxldmFudFJlYWxtXG4gICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSByZXNwb25zZS5oZWFkZXJzTGlzdFxuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gJ2ltbXV0YWJsZSdcbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cblxuICAgIC8vIDUuIFJlc29sdmUgcCB3aXRoIHJlc3BvbnNlT2JqZWN0LlxuICAgIHAucmVzb2x2ZShyZXNwb25zZU9iamVjdClcbiAgfVxuXG4gIGNvbnRyb2xsZXIgPSBmZXRjaGluZyh7XG4gICAgcmVxdWVzdCxcbiAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHk6IGhhbmRsZUZldGNoRG9uZSxcbiAgICBwcm9jZXNzUmVzcG9uc2UsXG4gICAgZGlzcGF0Y2hlcjogaW5pdC5kaXNwYXRjaGVyID8/IGdldEdsb2JhbERpc3BhdGNoZXIoKSAvLyB1bmRpY2lcbiAgfSlcblxuICAvLyAxNC4gUmV0dXJuIHAuXG4gIHJldHVybiBwLnByb21pc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZpbmFsaXplLWFuZC1yZXBvcnQtdGltaW5nXG5mdW5jdGlvbiBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZyAocmVzcG9uc2UsIGluaXRpYXRvclR5cGUgPSAnb3RoZXInKSB7XG4gIC8vIDEuIElmIHJlc3BvbnNlIGlzIGFuIGFib3J0ZWQgbmV0d29yayBlcnJvciwgdGhlbiByZXR1cm4uXG4gIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InICYmIHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDIuIElmIHJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBudWxsIG9yIGVtcHR5LCB0aGVuIHJldHVybi5cbiAgaWYgKCFyZXNwb25zZS51cmxMaXN0Py5sZW5ndGgpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDMuIExldCBvcmlnaW5hbFVSTCBiZSByZXNwb25zZeKAmXMgVVJMIGxpc3RbMF0uXG4gIGNvbnN0IG9yaWdpbmFsVVJMID0gcmVzcG9uc2UudXJsTGlzdFswXVxuXG4gIC8vIDQuIExldCB0aW1pbmdJbmZvIGJlIHJlc3BvbnNl4oCZcyB0aW1pbmcgaW5mby5cbiAgbGV0IHRpbWluZ0luZm8gPSByZXNwb25zZS50aW1pbmdJbmZvXG5cbiAgLy8gNS4gTGV0IGNhY2hlU3RhdGUgYmUgcmVzcG9uc2XigJlzIGNhY2hlIHN0YXRlLlxuICBsZXQgY2FjaGVTdGF0ZSA9IHJlc3BvbnNlLmNhY2hlU3RhdGVcblxuICAvLyA2LiBJZiBvcmlnaW5hbFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBhbiBIVFRQKFMpIHNjaGVtZSwgdGhlbiByZXR1cm4uXG4gIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUob3JpZ2luYWxVUkwpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA3LiBJZiB0aW1pbmdJbmZvIGlzIG51bGwsIHRoZW4gcmV0dXJuLlxuICBpZiAodGltaW5nSW5mbyA9PT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gOC4gSWYgcmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZyBpcyBub3Qgc2V0LCB0aGVuOlxuICBpZiAoIXRpbWluZ0luZm8udGltaW5nQWxsb3dQYXNzZWQpIHtcbiAgICAvLyAgMS4gU2V0IHRpbWluZ0luZm8gdG8gYSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIG9wYXF1ZSB0aW1pbmcgaW5mbyBmb3IgdGltaW5nSW5mby5cbiAgICB0aW1pbmdJbmZvID0gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh7XG4gICAgICBzdGFydFRpbWU6IHRpbWluZ0luZm8uc3RhcnRUaW1lXG4gICAgfSlcblxuICAgIC8vICAyLiBTZXQgY2FjaGVTdGF0ZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIGNhY2hlU3RhdGUgPSAnJ1xuICB9XG5cbiAgLy8gOS4gU2V0IHRpbWluZ0luZm/igJlzIGVuZCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZVxuICAvLyBnaXZlbiBnbG9iYWzigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vIGNhcGFiaWxpdHkuXG4gIC8vIFRPRE86IGdpdmVuIGdsb2JhbOKAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gY2FwYWJpbGl0eT9cbiAgdGltaW5nSW5mby5lbmRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoKVxuXG4gIC8vIDEwLiBTZXQgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvIHRvIHRpbWluZ0luZm8uXG4gIHJlc3BvbnNlLnRpbWluZ0luZm8gPSB0aW1pbmdJbmZvXG5cbiAgLy8gMTEuIE1hcmsgcmVzb3VyY2UgdGltaW5nIGZvciB0aW1pbmdJbmZvLCBvcmlnaW5hbFVSTCwgaW5pdGlhdG9yVHlwZSxcbiAgLy8gZ2xvYmFsLCBhbmQgY2FjaGVTdGF0ZS5cbiAgbWFya1Jlc291cmNlVGltaW5nKFxuICAgIHRpbWluZ0luZm8sXG4gICAgb3JpZ2luYWxVUkwsXG4gICAgaW5pdGlhdG9yVHlwZSxcbiAgICBnbG9iYWxUaGlzLFxuICAgIGNhY2hlU3RhdGVcbiAgKVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vcmVzb3VyY2UtdGltaW5nLyNkZm4tbWFyay1yZXNvdXJjZS10aW1pbmdcbmZ1bmN0aW9uIG1hcmtSZXNvdXJjZVRpbWluZyAodGltaW5nSW5mbywgb3JpZ2luYWxVUkwsIGluaXRpYXRvclR5cGUsIGdsb2JhbFRoaXMsIGNhY2hlU3RhdGUpIHtcbiAgaWYgKG5vZGVNYWpvciA+IDE4IHx8IChub2RlTWFqb3IgPT09IDE4ICYmIG5vZGVNaW5vciA+PSAyKSkge1xuICAgIHBlcmZvcm1hbmNlLm1hcmtSZXNvdXJjZVRpbWluZyh0aW1pbmdJbmZvLCBvcmlnaW5hbFVSTC5ocmVmLCBpbml0aWF0b3JUeXBlLCBnbG9iYWxUaGlzLCBjYWNoZVN0YXRlKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNhYm9ydC1mZXRjaFxuZnVuY3Rpb24gYWJvcnRGZXRjaCAocCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGVycm9yKSB7XG4gIC8vIE5vdGU6IEFib3J0U2lnbmFsLnJlYXNvbiB3YXMgYWRkZWQgaW4gbm9kZSB2MTcuMi4wXG4gIC8vIHdoaWNoIHdvdWxkIGdpdmUgdXMgYW4gdW5kZWZpbmVkIGVycm9yIHRvIHJlamVjdCB3aXRoLlxuICAvLyBSZW1vdmUgdGhpcyBvbmNlIG5vZGUgdjE2IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuXG4gIGlmICghZXJyb3IpIHtcbiAgICBlcnJvciA9IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKVxuICB9XG5cbiAgLy8gMS4gUmVqZWN0IHByb21pc2Ugd2l0aCBlcnJvci5cbiAgcC5yZWplY3QoZXJyb3IpXG5cbiAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub3QgbnVsbCBhbmQgaXMgcmVhZGFibGUsIHRoZW4gY2FuY2VsIHJlcXVlc3TigJlzXG4gIC8vIGJvZHkgd2l0aCBlcnJvci5cbiAgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsICYmIGlzUmVhZGFibGUocmVxdWVzdC5ib2R5Py5zdHJlYW0pKSB7XG4gICAgcmVxdWVzdC5ib2R5LnN0cmVhbS5jYW5jZWwoZXJyb3IpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1NUQVRFJykge1xuICAgICAgICAvLyBOb2RlIGJ1Zz9cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgcmVzcG9uc2VPYmplY3QgaXMgbnVsbCwgdGhlbiByZXR1cm4uXG4gIGlmIChyZXNwb25zZU9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA0LiBMZXQgcmVzcG9uc2UgYmUgcmVzcG9uc2VPYmplY3TigJlzIHJlc3BvbnNlLlxuICBjb25zdCByZXNwb25zZSA9IHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV1cblxuICAvLyA1LiBJZiByZXNwb25zZeKAmXMgYm9keSBpcyBub3QgbnVsbCBhbmQgaXMgcmVhZGFibGUsIHRoZW4gZXJyb3IgcmVzcG9uc2XigJlzXG4gIC8vIGJvZHkgd2l0aCBlcnJvci5cbiAgaWYgKHJlc3BvbnNlLmJvZHkgIT0gbnVsbCAmJiBpc1JlYWRhYmxlKHJlc3BvbnNlLmJvZHk/LnN0cmVhbSkpIHtcbiAgICByZXNwb25zZS5ib2R5LnN0cmVhbS5jYW5jZWwoZXJyb3IpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1NUQVRFJykge1xuICAgICAgICAvLyBOb2RlIGJ1Zz9cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmZXRjaGluZ1xuZnVuY3Rpb24gZmV0Y2hpbmcgKHtcbiAgcmVxdWVzdCxcbiAgcHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgsXG4gIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICBwcm9jZXNzUmVzcG9uc2UsXG4gIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSxcbiAgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gIHVzZVBhcmFsbGVsUXVldWUgPSBmYWxzZSxcbiAgZGlzcGF0Y2hlciAvLyB1bmRpY2lcbn0pIHtcbiAgLy8gMS4gTGV0IHRhc2tEZXN0aW5hdGlvbiBiZSBudWxsLlxuICBsZXQgdGFza0Rlc3RpbmF0aW9uID0gbnVsbFxuXG4gIC8vIDIuIExldCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSBiZSBmYWxzZS5cbiAgbGV0IGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID0gZmFsc2VcblxuICAvLyAzLiBJZiByZXF1ZXN04oCZcyBjbGllbnQgaXMgbm9uLW51bGwsIHRoZW46XG4gIGlmIChyZXF1ZXN0LmNsaWVudCAhPSBudWxsKSB7XG4gICAgLy8gMS4gU2V0IHRhc2tEZXN0aW5hdGlvbiB0byByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QuXG4gICAgdGFza0Rlc3RpbmF0aW9uID0gcmVxdWVzdC5jbGllbnQuZ2xvYmFsT2JqZWN0XG5cbiAgICAvLyAyLiBTZXQgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgdG8gcmVxdWVzdOKAmXMgY2xpZW504oCZcyBjcm9zcy1vcmlnaW5cbiAgICAvLyBpc29sYXRlZCBjYXBhYmlsaXR5LlxuICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID1cbiAgICAgIHJlcXVlc3QuY2xpZW50LmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5XG4gIH1cblxuICAvLyA0LiBJZiB1c2VQYXJhbGxlbFF1ZXVlIGlzIHRydWUsIHRoZW4gc2V0IHRhc2tEZXN0aW5hdGlvbiB0byB0aGUgcmVzdWx0IG9mXG4gIC8vIHN0YXJ0aW5nIGEgbmV3IHBhcmFsbGVsIHF1ZXVlLlxuICAvLyBUT0RPXG5cbiAgLy8gNS4gTGV0IHRpbWluZ0luZm8gYmUgYSBuZXcgZmV0Y2ggdGltaW5nIGluZm8gd2hvc2Ugc3RhcnQgdGltZSBhbmRcbiAgLy8gcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lIGFyZSB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW5cbiAgLy8gY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkuXG4gIGNvbnN0IGN1cnJlblRpbWUgPSBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZShjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcbiAgY29uc3QgdGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8oe1xuICAgIHN0YXJ0VGltZTogY3VycmVuVGltZVxuICB9KVxuXG4gIC8vIDYuIExldCBmZXRjaFBhcmFtcyBiZSBhIG5ldyBmZXRjaCBwYXJhbXMgd2hvc2VcbiAgLy8gcmVxdWVzdCBpcyByZXF1ZXN0LFxuICAvLyB0aW1pbmcgaW5mbyBpcyB0aW1pbmdJbmZvLFxuICAvLyBwcm9jZXNzIHJlcXVlc3QgYm9keSBjaHVuayBsZW5ndGggaXMgcHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgsXG4gIC8vIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpcyBwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSxcbiAgLy8gcHJvY2VzcyByZXNwb25zZSBpcyBwcm9jZXNzUmVzcG9uc2UsXG4gIC8vIHByb2Nlc3MgcmVzcG9uc2UgY29uc3VtZSBib2R5IGlzIHByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5LFxuICAvLyBwcm9jZXNzIHJlc3BvbnNlIGVuZC1vZi1ib2R5IGlzIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSxcbiAgLy8gdGFzayBkZXN0aW5hdGlvbiBpcyB0YXNrRGVzdGluYXRpb24sXG4gIC8vIGFuZCBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eSBpcyBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eS5cbiAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgY29udHJvbGxlcjogbmV3IEZldGNoKGRpc3BhdGNoZXIpLFxuICAgIHJlcXVlc3QsXG4gICAgdGltaW5nSW5mbyxcbiAgICBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgICBwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSxcbiAgICBwcm9jZXNzUmVzcG9uc2UsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICAgIHRhc2tEZXN0aW5hdGlvbixcbiAgICBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eVxuICB9XG5cbiAgLy8gNy4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBhIGJ5dGUgc2VxdWVuY2UsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGJvZHkgdG9cbiAgLy8gICAgcmVxdWVzdOKAmXMgYm9keSBhcyBhIGJvZHkuXG4gIC8vIE5PVEU6IFNpbmNlIGZldGNoaW5nIGlzIG9ubHkgY2FsbGVkIGZyb20gZmV0Y2gsIGJvZHkgc2hvdWxkIGFscmVhZHkgYmVcbiAgLy8gZXh0cmFjdGVkLlxuICBhc3NlcnQoIXJlcXVlc3QuYm9keSB8fCByZXF1ZXN0LmJvZHkuc3RyZWFtKVxuXG4gIC8vIDguIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBcImNsaWVudFwiLCB0aGVuIHNldCByZXF1ZXN04oCZcyB3aW5kb3cgdG8gcmVxdWVzdOKAmXNcbiAgLy8gY2xpZW50LCBpZiByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QgaXMgYSBXaW5kb3cgb2JqZWN0OyBvdGhlcndpc2VcbiAgLy8gXCJuby13aW5kb3dcIi5cbiAgaWYgKHJlcXVlc3Qud2luZG93ID09PSAnY2xpZW50Jykge1xuICAgIC8vIFRPRE86IFdoYXQgaWYgcmVxdWVzdC5jbGllbnQgaXMgbnVsbD9cbiAgICByZXF1ZXN0LndpbmRvdyA9XG4gICAgICByZXF1ZXN0LmNsaWVudD8uZ2xvYmFsT2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ1dpbmRvdydcbiAgICAgICAgPyByZXF1ZXN0LmNsaWVudFxuICAgICAgICA6ICduby13aW5kb3cnXG4gIH1cblxuICAvLyA5LiBJZiByZXF1ZXN04oCZcyBvcmlnaW4gaXMgXCJjbGllbnRcIiwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgb3JpZ2luIHRvIHJlcXVlc3TigJlzXG4gIC8vIGNsaWVudOKAmXMgb3JpZ2luLlxuICBpZiAocmVxdWVzdC5vcmlnaW4gPT09ICdjbGllbnQnKSB7XG4gICAgLy8gVE9ETzogV2hhdCBpZiByZXF1ZXN0LmNsaWVudCBpcyBudWxsP1xuICAgIHJlcXVlc3Qub3JpZ2luID0gcmVxdWVzdC5jbGllbnQ/Lm9yaWdpblxuICB9XG5cbiAgLy8gMTAuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gIC8vIFRPRE9cblxuICAvLyAxMS4gSWYgcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lciBpcyBcImNsaWVudFwiLCB0aGVuOlxuICBpZiAocmVxdWVzdC5wb2xpY3lDb250YWluZXIgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgY2xpZW50IGlzIG5vbi1udWxsLCB0aGVuIHNldCByZXF1ZXN04oCZcyBwb2xpY3lcbiAgICAvLyBjb250YWluZXIgdG8gYSBjbG9uZSBvZiByZXF1ZXN04oCZcyBjbGllbnTigJlzIHBvbGljeSBjb250YWluZXIuIFtIVE1MXVxuICAgIGlmIChyZXF1ZXN0LmNsaWVudCAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0LnBvbGljeUNvbnRhaW5lciA9IGNsb25lUG9saWN5Q29udGFpbmVyKFxuICAgICAgICByZXF1ZXN0LmNsaWVudC5wb2xpY3lDb250YWluZXJcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBzZXQgcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lciB0byBhIG5ldyBwb2xpY3lcbiAgICAgIC8vIGNvbnRhaW5lci5cbiAgICAgIHJlcXVlc3QucG9saWN5Q29udGFpbmVyID0gbWFrZVBvbGljeUNvbnRhaW5lcigpXG4gICAgfVxuICB9XG5cbiAgLy8gMTIuIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEFjY2VwdGAsIHRoZW46XG4gIGlmICghcmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnYWNjZXB0JykpIHtcbiAgICAvLyAxLiBMZXQgdmFsdWUgYmUgYCovKmAuXG4gICAgY29uc3QgdmFsdWUgPSAnKi8qJ1xuXG4gICAgLy8gMi4gQSB1c2VyIGFnZW50IHNob3VsZCBzZXQgdmFsdWUgdG8gdGhlIGZpcnN0IG1hdGNoaW5nIHN0YXRlbWVudCwgaWZcbiAgICAvLyBhbnksIHN3aXRjaGluZyBvbiByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbjpcbiAgICAvLyBcImRvY3VtZW50XCJcbiAgICAvLyBcImZyYW1lXCJcbiAgICAvLyBcImlmcmFtZVwiXG4gICAgLy8gYHRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LCovKjtxPTAuOGBcbiAgICAvLyBcImltYWdlXCJcbiAgICAvLyBgaW1hZ2UvcG5nLGltYWdlL3N2Zyt4bWwsaW1hZ2UvKjtxPTAuOCwqLyo7cT0wLjVgXG4gICAgLy8gXCJzdHlsZVwiXG4gICAgLy8gYHRleHQvY3NzLCovKjtxPTAuMWBcbiAgICAvLyBUT0RPXG5cbiAgICAvLyAzLiBBcHBlbmQgYEFjY2VwdGAvdmFsdWUgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdCcsIHZhbHVlKVxuICB9XG5cbiAgLy8gMTMuIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEFjY2VwdC1MYW5ndWFnZWAsIHRoZW5cbiAgLy8gdXNlciBhZ2VudHMgc2hvdWxkIGFwcGVuZCBgQWNjZXB0LUxhbmd1YWdlYC9hbiBhcHByb3ByaWF0ZSB2YWx1ZSB0b1xuICAvLyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhY2NlcHQtbGFuZ3VhZ2UnKSkge1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtbGFuZ3VhZ2UnLCAnKicpXG4gIH1cblxuICAvLyAxNC4gSWYgcmVxdWVzdOKAmXMgcHJpb3JpdHkgaXMgbnVsbCwgdGhlbiB1c2UgcmVxdWVzdOKAmXMgaW5pdGlhdG9yIGFuZFxuICAvLyBkZXN0aW5hdGlvbiBhcHByb3ByaWF0ZWx5IGluIHNldHRpbmcgcmVxdWVzdOKAmXMgcHJpb3JpdHkgdG8gYVxuICAvLyB1c2VyLWFnZW50LWRlZmluZWQgb2JqZWN0LlxuICBpZiAocmVxdWVzdC5wcmlvcml0eSA9PT0gbnVsbCkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE1LiBJZiByZXF1ZXN0IGlzIGEgc3VicmVzb3VyY2UgcmVxdWVzdCwgdGhlbjpcbiAgaWYgKHN1YnJlc291cmNlU2V0LmhhcyhyZXF1ZXN0LmRlc3RpbmF0aW9uKSkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE2LiBSdW4gbWFpbiBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgbWFpbkZldGNoKGZldGNoUGFyYW1zKVxuICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZXJyKVxuICAgIH0pXG5cbiAgLy8gMTcuIFJldHVybiBmZXRjaFBhcmFtJ3MgY29udHJvbGxlclxuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlclxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tYWluLWZldGNoXG5hc3luYyBmdW5jdGlvbiBtYWluRmV0Y2ggKGZldGNoUGFyYW1zLCByZWN1cnNpdmUgPSBmYWxzZSkge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIElmIHJlcXVlc3TigJlzIGxvY2FsLVVSTHMtb25seSBmbGFnIGlzIHNldCBhbmQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXNcbiAgLy8gbm90IGxvY2FsLCB0aGVuIHNldCByZXNwb25zZSB0byBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChyZXF1ZXN0LmxvY2FsVVJMc09ubHkgJiYgIXVybElzTG9jYWwocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgcmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKCdsb2NhbCBVUkxzIG9ubHknKVxuICB9XG5cbiAgLy8gNC4gUnVuIHJlcG9ydCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB2aW9sYXRpb25zIGZvciByZXF1ZXN0LlxuICAvLyBUT0RPXG5cbiAgLy8gNS4gVXBncmFkZSByZXF1ZXN0IHRvIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCBpZiBhcHByb3ByaWF0ZS5cbiAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMKHJlcXVlc3QpXG5cbiAgLy8gNi4gSWYgc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBkdWUgdG8gYSBiYWQgcG9ydCwgc2hvdWxkIGZldGNoaW5nIHJlcXVlc3RcbiAgLy8gYmUgYmxvY2tlZCBhcyBtaXhlZCBjb250ZW50LCBvciBzaG91bGQgcmVxdWVzdCBiZSBibG9ja2VkIGJ5IENvbnRlbnRcbiAgLy8gU2VjdXJpdHkgUG9saWN5IHJldHVybnMgYmxvY2tlZCwgdGhlbiBzZXQgcmVzcG9uc2UgdG8gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAocmVxdWVzdEJhZFBvcnQocmVxdWVzdCkgPT09ICdibG9ja2VkJykge1xuICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcignYmFkIHBvcnQnKVxuICB9XG4gIC8vIFRPRE86IHNob3VsZCBmZXRjaGluZyByZXF1ZXN0IGJlIGJsb2NrZWQgYXMgbWl4ZWQgY29udGVudD9cbiAgLy8gVE9ETzogc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBieSBDb250ZW50IFNlY3VyaXR5IFBvbGljeT9cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXNcbiAgLy8gcmVmZXJyZXIgcG9saWN5IHRvIHJlcXVlc3TigJlzIHBvbGljeSBjb250YWluZXLigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgaWYgKHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPT09ICcnKSB7XG4gICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IHJlcXVlc3QucG9saWN5Q29udGFpbmVyLnJlZmVycmVyUG9saWN5XG4gIH1cblxuICAvLyA4LiBJZiByZXF1ZXN04oCZcyByZWZlcnJlciBpcyBub3QgXCJuby1yZWZlcnJlclwiLCB0aGVuIHNldCByZXF1ZXN04oCZc1xuICAvLyByZWZlcnJlciB0byB0aGUgcmVzdWx0IG9mIGludm9raW5nIGRldGVybWluZSByZXF1ZXN04oCZcyByZWZlcnJlci5cbiAgaWYgKHJlcXVlc3QucmVmZXJyZXIgIT09ICduby1yZWZlcnJlcicpIHtcbiAgICByZXF1ZXN0LnJlZmVycmVyID0gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihyZXF1ZXN0KVxuICB9XG5cbiAgLy8gOS4gU2V0IHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgdG8gXCJodHRwc1wiIGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gIC8vIC0gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBcImh0dHBcIlxuICAvLyAtIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBob3N0IGlzIGEgZG9tYWluXG4gIC8vIC0gTWF0Y2hpbmcgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIGhvc3QgcGVyIEtub3duIEhTVFMgSG9zdCBEb21haW4gTmFtZVxuICAvLyAgIE1hdGNoaW5nIHJlc3VsdHMgaW4gZWl0aGVyIGEgc3VwZXJkb21haW4gbWF0Y2ggd2l0aCBhbiBhc3NlcnRlZFxuICAvLyAgIGluY2x1ZGVTdWJEb21haW5zIGRpcmVjdGl2ZSBvciBhIGNvbmdydWVudCBtYXRjaCAod2l0aCBvciB3aXRob3V0IGFuXG4gIC8vICAgYXNzZXJ0ZWQgaW5jbHVkZVN1YkRvbWFpbnMgZGlyZWN0aXZlKS4gW0hTVFNdXG4gIC8vIFRPRE9cblxuICAvLyAxMC4gSWYgcmVjdXJzaXZlIGlzIGZhbHNlLCB0aGVuIHJ1biB0aGUgcmVtYWluaW5nIHN0ZXBzIGluIHBhcmFsbGVsLlxuICAvLyBUT0RPXG5cbiAgLy8gMTEuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW4gc2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAvLyB0aGUgc3RlcHMgY29ycmVzcG9uZGluZyB0byB0aGUgZmlyc3QgbWF0Y2hpbmcgc3RhdGVtZW50OlxuICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICByZXNwb25zZSA9IGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAgICAgaWYgKFxuICAgICAgICAvLyAtIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBvcmlnaW4gaXMgc2FtZSBvcmlnaW4gd2l0aCByZXF1ZXN04oCZcyBvcmlnaW4sXG4gICAgICAgIC8vICAgYW5kIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiYmFzaWNcIlxuICAgICAgICAoc2FtZU9yaWdpbihjdXJyZW50VVJMLCByZXF1ZXN0LnVybCkgJiYgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKSB8fFxuICAgICAgICAvLyByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIFwiZGF0YVwiXG4gICAgICAgIChjdXJyZW50VVJMLnByb3RvY29sID09PSAnZGF0YTonKSB8fFxuICAgICAgICAvLyAtIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuYXZpZ2F0ZVwiIG9yIFwid2Vic29ja2V0XCJcbiAgICAgICAgKHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJyB8fCByZXF1ZXN0Lm1vZGUgPT09ICd3ZWJzb2NrZXQnKVxuICAgICAgKSB7XG4gICAgICAgIC8vIDEuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcImJhc2ljXCIuXG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9ICdiYXNpYydcblxuICAgICAgICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIHNjaGVtZSBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHNjaGVtZUZldGNoKGZldGNoUGFyYW1zKVxuICAgICAgfVxuXG4gICAgICAvLyByZXF1ZXN04oCZcyBtb2RlIGlzIFwic2FtZS1vcmlnaW5cIlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ3NhbWUtb3JpZ2luJykge1xuICAgICAgICAvLyAxLiBSZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigncmVxdWVzdCBtb2RlIGNhbm5vdCBiZSBcInNhbWUtb3JpZ2luXCInKVxuICAgICAgfVxuXG4gICAgICAvLyByZXF1ZXN04oCZcyBtb2RlIGlzIFwibm8tY29yc1wiXG4gICAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnbm8tY29ycycpIHtcbiAgICAgICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSBpcyBub3QgXCJmb2xsb3dcIiwgdGhlbiByZXR1cm4gYSBuZXR3b3JrXG4gICAgICAgIC8vIGVycm9yLlxuICAgICAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ2ZvbGxvdycpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcbiAgICAgICAgICAgICdyZWRpcmVjdCBtb2RlIGNhbm5vdCBiZSBcImZvbGxvd1wiIGZvciBcIm5vLWNvcnNcIiByZXF1ZXN0J1xuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcIm9wYXF1ZVwiLlxuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPSAnb3BhcXVlJ1xuXG4gICAgICAgIC8vIDMuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgc2NoZW1lIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICAgICAgICByZXR1cm4gYXdhaXQgc2NoZW1lRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgICB9XG5cbiAgICAgIC8vIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgaXMgbm90IGFuIEhUVFAoUykgc2NoZW1lXG4gICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgICAvLyBSZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignVVJMIHNjaGVtZSBtdXN0IGJlIGEgSFRUUChTKSBzY2hlbWUnKVxuICAgICAgfVxuXG4gICAgICAvLyAtIHJlcXVlc3TigJlzIHVzZS1DT1JTLXByZWZsaWdodCBmbGFnIGlzIHNldFxuICAgICAgLy8gLSByZXF1ZXN04oCZcyB1bnNhZmUtcmVxdWVzdCBmbGFnIGlzIHNldCBhbmQgZWl0aGVyIHJlcXVlc3TigJlzIG1ldGhvZCBpc1xuICAgICAgLy8gICBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgbWV0aG9kIG9yIENPUlMtdW5zYWZlIHJlcXVlc3QtaGVhZGVyIG5hbWVzIHdpdGhcbiAgICAgIC8vICAgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgaXMgbm90IGVtcHR5XG4gICAgICAvLyAgICAxLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJjb3JzXCIuXG4gICAgICAvLyAgICAyLiBMZXQgY29yc1dpdGhQcmVmbGlnaHRSZXNwb25zZSBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaFxuICAgICAgLy8gICAgZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHRydWUuXG4gICAgICAvLyAgICAzLiBJZiBjb3JzV2l0aFByZWZsaWdodFJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvciwgdGhlbiBjbGVhciBjYWNoZVxuICAgICAgLy8gICAgZW50cmllcyB1c2luZyByZXF1ZXN0LlxuICAgICAgLy8gICAgNC4gUmV0dXJuIGNvcnNXaXRoUHJlZmxpZ2h0UmVzcG9uc2UuXG4gICAgICAvLyBUT0RPXG5cbiAgICAgIC8vIE90aGVyd2lzZVxuICAgICAgLy8gICAgMS4gU2V0IHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIHRvIFwiY29yc1wiLlxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID0gJ2NvcnMnXG5cbiAgICAgIC8vICAgIDIuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgIHJldHVybiBhd2FpdCBodHRwRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgfSkoKVxuICB9XG5cbiAgLy8gMTIuIElmIHJlY3Vyc2l2ZSBpcyB0cnVlLCB0aGVuIHJldHVybiByZXNwb25zZS5cbiAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLy8gMTMuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIHJlc3BvbnNlIGlzIG5vdCBhIGZpbHRlcmVkXG4gIC8vIHJlc3BvbnNlLCB0aGVuOlxuICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAwICYmICFyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSB7XG4gICAgLy8gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIsIHRoZW46XG4gICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnKSB7XG4gICAgICAvLyAxLiBMZXQgaGVhZGVyTmFtZXMgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlc1xuICAgICAgLy8gZ2l2ZW4gYEFjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gVE9ET1xuICAgICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgY3JlZGVudGlhbHMgbW9kZSBpcyBub3QgXCJpbmNsdWRlXCIgYW5kIGhlYWRlck5hbWVzXG4gICAgICAvLyBjb250YWlucyBgKmAsIHRoZW4gc2V0IHJlc3BvbnNl4oCZcyBDT1JTLWV4cG9zZWQgaGVhZGVyLW5hbWUgbGlzdCB0b1xuICAgICAgLy8gYWxsIHVuaXF1ZSBoZWFkZXIgbmFtZXMgaW4gcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gVE9ET1xuICAgICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiBoZWFkZXJOYW1lcyBpcyBub3QgbnVsbCBvciBmYWlsdXJlLCB0aGVuIHNldFxuICAgICAgLy8gcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0IHRvIGhlYWRlck5hbWVzLlxuICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIC8vIFNldCByZXNwb25zZSB0byB0aGUgZm9sbG93aW5nIGZpbHRlcmVkIHJlc3BvbnNlIHdpdGggcmVzcG9uc2UgYXMgaXRzXG4gICAgLy8gaW50ZXJuYWwgcmVzcG9uc2UsIGRlcGVuZGluZyBvbiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZzpcbiAgICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKSB7XG4gICAgICByZXNwb25zZSA9IGZpbHRlclJlc3BvbnNlKHJlc3BvbnNlLCAnYmFzaWMnKVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycpIHtcbiAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsICdjb3JzJylcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ29wYXF1ZScpIHtcbiAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsICdvcGFxdWUnKVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgLy8gMTQuIExldCBpbnRlcm5hbFJlc3BvbnNlIGJlIHJlc3BvbnNlLCBpZiByZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3IsXG4gIC8vIGFuZCByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2Ugb3RoZXJ3aXNlLlxuICBsZXQgaW50ZXJuYWxSZXNwb25zZSA9XG4gICAgcmVzcG9uc2Uuc3RhdHVzID09PSAwID8gcmVzcG9uc2UgOiByZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlXG5cbiAgLy8gMTUuIElmIGludGVybmFsUmVzcG9uc2XigJlzIFVSTCBsaXN0IGlzIGVtcHR5LCB0aGVuIHNldCBpdCB0byBhIGNsb25lIG9mXG4gIC8vIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICBpZiAoaW50ZXJuYWxSZXNwb25zZS51cmxMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIGludGVybmFsUmVzcG9uc2UudXJsTGlzdC5wdXNoKC4uLnJlcXVlc3QudXJsTGlzdClcbiAgfVxuXG4gIC8vIDE2LiBJZiByZXF1ZXN04oCZcyB0aW1pbmcgYWxsb3cgZmFpbGVkIGZsYWcgaXMgdW5zZXQsIHRoZW4gc2V0XG4gIC8vIGludGVybmFsUmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZy5cbiAgaWYgKCFyZXF1ZXN0LnRpbWluZ0FsbG93RmFpbGVkKSB7XG4gICAgcmVzcG9uc2UudGltaW5nQWxsb3dQYXNzZWQgPSB0cnVlXG4gIH1cblxuICAvLyAxNy4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgYW55IG9mIHRoZSBmb2xsb3dpbmcgcmV0dXJuc1xuICAvLyBibG9ja2VkXG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGFzIG1peGVkIGNvbnRlbnRcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgYnkgQ29udGVudCBTZWN1cml0eSBQb2xpY3lcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgZHVlIHRvIGl0cyBNSU1FIHR5cGVcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgZHVlIHRvIG5vc25pZmZcbiAgLy8gVE9ET1xuXG4gIC8vIDE4LiBJZiByZXNwb25zZeKAmXMgdHlwZSBpcyBcIm9wYXF1ZVwiLCBpbnRlcm5hbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMjA2LFxuICAvLyBpbnRlcm5hbFJlc3BvbnNl4oCZcyByYW5nZS1yZXF1ZXN0ZWQgZmxhZyBpcyBzZXQsIGFuZCByZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gbGlzdCBkb2VzIG5vdCBjb250YWluIGBSYW5nZWAsIHRoZW4gc2V0IHJlc3BvbnNlIGFuZCBpbnRlcm5hbFJlc3BvbnNlXG4gIC8vIHRvIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIHJlc3BvbnNlLnR5cGUgPT09ICdvcGFxdWUnICYmXG4gICAgaW50ZXJuYWxSZXNwb25zZS5zdGF0dXMgPT09IDIwNiAmJlxuICAgIGludGVybmFsUmVzcG9uc2UucmFuZ2VSZXF1ZXN0ZWQgJiZcbiAgICAhcmVxdWVzdC5oZWFkZXJzLmNvbnRhaW5zKCdyYW5nZScpXG4gICkge1xuICAgIHJlc3BvbnNlID0gaW50ZXJuYWxSZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoKVxuICB9XG5cbiAgLy8gMTkuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIGVpdGhlciByZXF1ZXN04oCZcyBtZXRob2QgaXNcbiAgLy8gYEhFQURgIG9yIGBDT05ORUNUYCwgb3IgaW50ZXJuYWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIGEgbnVsbCBib2R5IHN0YXR1cyxcbiAgLy8gc2V0IGludGVybmFsUmVzcG9uc2XigJlzIGJvZHkgdG8gbnVsbCBhbmQgZGlzcmVnYXJkIGFueSBlbnF1ZXVpbmcgdG93YXJkXG4gIC8vIGl0IChpZiBhbnkpLlxuICBpZiAoXG4gICAgcmVzcG9uc2Uuc3RhdHVzICE9PSAwICYmXG4gICAgKHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcgfHxcbiAgICAgIHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcgfHxcbiAgICAgIG51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKGludGVybmFsUmVzcG9uc2Uuc3RhdHVzKSlcbiAgKSB7XG4gICAgaW50ZXJuYWxSZXNwb25zZS5ib2R5ID0gbnVsbFxuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZHVtcCA9IHRydWVcbiAgfVxuXG4gIC8vIDIwLiBJZiByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIHRoZW46XG4gIGlmIChyZXF1ZXN0LmludGVncml0eSkge1xuICAgIC8vIDEuIExldCBwcm9jZXNzQm9keUVycm9yIGJlIHRoaXMgc3RlcDogcnVuIGZldGNoIGZpbmFsZSBnaXZlbiBmZXRjaFBhcmFtc1xuICAgIC8vIGFuZCBhIG5ldHdvcmsgZXJyb3IuXG4gICAgY29uc3QgcHJvY2Vzc0JvZHlFcnJvciA9IChyZWFzb24pID0+XG4gICAgICBmZXRjaEZpbmFsZShmZXRjaFBhcmFtcywgbWFrZU5ldHdvcmtFcnJvcihyZWFzb24pKVxuXG4gICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJvcGFxdWVcIiwgb3IgcmVzcG9uc2XigJlzIGJvZHkgaXMgbnVsbCxcbiAgICAvLyB0aGVuIHJ1biBwcm9jZXNzQm9keUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnb3BhcXVlJyB8fCByZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICAgIHByb2Nlc3NCb2R5RXJyb3IocmVzcG9uc2UuZXJyb3IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgcHJvY2Vzc0JvZHkgZ2l2ZW4gYnl0ZXMgYmUgdGhlc2Ugc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc0JvZHkgPSAoYnl0ZXMpID0+IHtcbiAgICAgIC8vIDEuIElmIGJ5dGVzIGRvIG5vdCBtYXRjaCByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEsXG4gICAgICAvLyB0aGVuIHJ1biBwcm9jZXNzQm9keUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy4gW1NSSV1cbiAgICAgIGlmICghYnl0ZXNNYXRjaChieXRlcywgcmVxdWVzdC5pbnRlZ3JpdHkpKSB7XG4gICAgICAgIHByb2Nlc3NCb2R5RXJyb3IoJ2ludGVncml0eSBtaXNtYXRjaCcpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgcmVzcG9uc2XigJlzIGJvZHkgdG8gYnl0ZXMgYXMgYSBib2R5LlxuICAgICAgcmVzcG9uc2UuYm9keSA9IHNhZmVseUV4dHJhY3RCb2R5KGJ5dGVzKVswXVxuXG4gICAgICAvLyAzLiBSdW4gZmV0Y2ggZmluYWxlIGdpdmVuIGZldGNoUGFyYW1zIGFuZCByZXNwb25zZS5cbiAgICAgIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgICB9XG5cbiAgICAvLyA0LiBGdWxseSByZWFkIHJlc3BvbnNl4oCZcyBib2R5IGdpdmVuIHByb2Nlc3NCb2R5IGFuZCBwcm9jZXNzQm9keUVycm9yLlxuICAgIGF3YWl0IGZ1bGx5UmVhZEJvZHkocmVzcG9uc2UuYm9keSwgcHJvY2Vzc0JvZHksIHByb2Nlc3NCb2R5RXJyb3IpXG4gIH0gZWxzZSB7XG4gICAgLy8gMjEuIE90aGVyd2lzZSwgcnVuIGZldGNoIGZpbmFsZSBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UuXG4gICAgZmV0Y2hGaW5hbGUoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXNjaGVtZS1mZXRjaFxuLy8gZ2l2ZW4gYSBmZXRjaCBwYXJhbXMgZmV0Y2hQYXJhbXNcbmZ1bmN0aW9uIHNjaGVtZUZldGNoIChmZXRjaFBhcmFtcykge1xuICAvLyBOb3RlOiBzaW5jZSB0aGUgY29ubmVjdGlvbiBpcyBkZXN0cm95ZWQgb24gcmVkaXJlY3QsIHdoaWNoIHNldHMgZmV0Y2hQYXJhbXMgdG8gYVxuICAvLyBjYW5jZWxsZWQgc3RhdGUsIHdlIGRvIG5vdCB3YW50IHRoaXMgY29uZGl0aW9uIHRvIHRyaWdnZXIgKnVubGVzcyogdGhlcmUgaGF2ZSBiZWVuXG4gIC8vIG5vIHJlZGlyZWN0cy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNzc2XG4gIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykgJiYgZmV0Y2hQYXJhbXMucmVxdWVzdC5yZWRpcmVjdENvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpKVxuICB9XG5cbiAgLy8gMi4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHsgcmVxdWVzdCB9ID0gZmV0Y2hQYXJhbXNcblxuICBjb25zdCB7IHByb3RvY29sOiBzY2hlbWUgfSA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgLy8gMy4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgYW5kIHJ1biB0aGUgYXNzb2NpYXRlZCBzdGVwczpcbiAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICBjYXNlICdhYm91dDonOiB7XG4gICAgICAvLyBJZiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgcGF0aCBpcyB0aGUgc3RyaW5nIFwiYmxhbmtcIiwgdGhlbiByZXR1cm4gYSBuZXcgcmVzcG9uc2VcbiAgICAgIC8vIHdob3NlIHN0YXR1cyBtZXNzYWdlIGlzIGBPS2AsIGhlYWRlciBsaXN0IGlzIMKrIChgQ29udGVudC1UeXBlYCwgYHRleHQvaHRtbDtjaGFyc2V0PXV0Zi04YCkgwrssXG4gICAgICAvLyBhbmQgYm9keSBpcyB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSBhcyBhIGJvZHkuXG5cbiAgICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignYWJvdXQgc2NoZW1lIGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgICB9XG4gICAgY2FzZSAnYmxvYjonOiB7XG4gICAgICBpZiAoIXJlc29sdmVPYmplY3RVUkwpIHtcbiAgICAgICAgcmVzb2x2ZU9iamVjdFVSTCA9IHJlcXVpcmUoJ2J1ZmZlcicpLnJlc29sdmVPYmplY3RVUkxcbiAgICAgIH1cblxuICAgICAgLy8gMS4gTGV0IGJsb2JVUkxFbnRyeSBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgYmxvYiBVUkwgZW50cnkuXG4gICAgICBjb25zdCBibG9iVVJMRW50cnkgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2ViLXBsYXRmb3JtLXRlc3RzL3dwdC9ibG9iLzdiMGViYWNjYzYyYjU2NmExOTY1Mzk2ZTViZTdiYjJiYzA2Zjg0MWYvRmlsZUFQSS91cmwvcmVzb3VyY2VzL2ZldGNoLXRlc3RzLmpzI0w1Mi1MNTZcbiAgICAgIC8vIEJ1ZmZlci5yZXNvbHZlT2JqZWN0VVJMIGRvZXMgbm90IGlnbm9yZSBVUkwgcXVlcmllcy5cbiAgICAgIGlmIChibG9iVVJMRW50cnkuc2VhcmNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ05ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuJykpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJsb2JVUkxFbnRyeU9iamVjdCA9IHJlc29sdmVPYmplY3RVUkwoYmxvYlVSTEVudHJ5LnRvU3RyaW5nKCkpXG5cbiAgICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBub3QgYEdFVGAsIGJsb2JVUkxFbnRyeSBpcyBudWxsLCBvciBibG9iVVJMRW50cnnigJlzXG4gICAgICAvLyAgICBvYmplY3QgaXMgbm90IGEgQmxvYiBvYmplY3QsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgfHwgIWlzQmxvYkxpa2UoYmxvYlVSTEVudHJ5T2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2ludmFsaWQgbWV0aG9kJykpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIExldCBib2R5V2l0aFR5cGUgYmUgdGhlIHJlc3VsdCBvZiBzYWZlbHkgZXh0cmFjdGluZyBibG9iVVJMRW50cnnigJlzIG9iamVjdC5cbiAgICAgIGNvbnN0IGJvZHlXaXRoVHlwZSA9IHNhZmVseUV4dHJhY3RCb2R5KGJsb2JVUkxFbnRyeU9iamVjdClcblxuICAgICAgLy8gNC4gTGV0IGJvZHkgYmUgYm9keVdpdGhUeXBl4oCZcyBib2R5LlxuICAgICAgY29uc3QgYm9keSA9IGJvZHlXaXRoVHlwZVswXVxuXG4gICAgICAvLyA1LiBMZXQgbGVuZ3RoIGJlIGJvZHnigJlzIGxlbmd0aCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICAgICAgY29uc3QgbGVuZ3RoID0gaXNvbW9ycGhpY0VuY29kZShgJHtib2R5Lmxlbmd0aH1gKVxuXG4gICAgICAvLyA2LiBMZXQgdHlwZSBiZSBib2R5V2l0aFR5cGXigJlzIHR5cGUgaWYgaXQgaXMgbm9uLW51bGw7IG90aGVyd2lzZSB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZS5cbiAgICAgIGNvbnN0IHR5cGUgPSBib2R5V2l0aFR5cGVbMV0gPz8gJydcblxuICAgICAgLy8gNy4gUmV0dXJuIGEgbmV3IHJlc3BvbnNlIHdob3NlIHN0YXR1cyBtZXNzYWdlIGlzIGBPS2AsIGhlYWRlciBsaXN0IGlzXG4gICAgICAvLyAgICDCqyAoYENvbnRlbnQtTGVuZ3RoYCwgbGVuZ3RoKSwgKGBDb250ZW50LVR5cGVgLCB0eXBlKSDCuywgYW5kIGJvZHkgaXMgYm9keS5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gbWFrZVJlc3BvbnNlKHtcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcbiAgICAgICAgaGVhZGVyc0xpc3Q6IFtcbiAgICAgICAgICBbJ2NvbnRlbnQtbGVuZ3RoJywgeyBuYW1lOiAnQ29udGVudC1MZW5ndGgnLCB2YWx1ZTogbGVuZ3RoIH1dLFxuICAgICAgICAgIFsnY29udGVudC10eXBlJywgeyBuYW1lOiAnQ29udGVudC1UeXBlJywgdmFsdWU6IHR5cGUgfV1cbiAgICAgICAgXVxuICAgICAgfSlcblxuICAgICAgcmVzcG9uc2UuYm9keSA9IGJvZHlcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSlcbiAgICB9XG4gICAgY2FzZSAnZGF0YTonOiB7XG4gICAgICAvLyAxLiBMZXQgZGF0YVVSTFN0cnVjdCBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlXG4gICAgICAvLyAgICBkYXRhOiBVUkwgcHJvY2Vzc29yIG9uIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAgICAgY29uc3QgY3VycmVudFVSTCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG4gICAgICBjb25zdCBkYXRhVVJMU3RydWN0ID0gZGF0YVVSTFByb2Nlc3NvcihjdXJyZW50VVJMKVxuXG4gICAgICAvLyAyLiBJZiBkYXRhVVJMU3RydWN0IGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGFcbiAgICAgIC8vICAgIG5ldHdvcmsgZXJyb3IuXG4gICAgICBpZiAoZGF0YVVSTFN0cnVjdCA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignZmFpbGVkIHRvIGZldGNoIHRoZSBkYXRhIFVSTCcpKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBMZXQgbWltZVR5cGUgYmUgZGF0YVVSTFN0cnVjdOKAmXMgTUlNRSB0eXBlLCBzZXJpYWxpemVkLlxuICAgICAgY29uc3QgbWltZVR5cGUgPSBzZXJpYWxpemVBTWltZVR5cGUoZGF0YVVSTFN0cnVjdC5taW1lVHlwZSlcblxuICAgICAgLy8gNC4gUmV0dXJuIGEgcmVzcG9uc2Ugd2hvc2Ugc3RhdHVzIG1lc3NhZ2UgaXMgYE9LYCxcbiAgICAgIC8vICAgIGhlYWRlciBsaXN0IGlzIMKrIChgQ29udGVudC1UeXBlYCwgbWltZVR5cGUpIMK7LFxuICAgICAgLy8gICAgYW5kIGJvZHkgaXMgZGF0YVVSTFN0cnVjdOKAmXMgYm9keSBhcyBhIGJvZHkuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VSZXNwb25zZSh7XG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICAgIGhlYWRlcnNMaXN0OiBbXG4gICAgICAgICAgWydjb250ZW50LXR5cGUnLCB7IG5hbWU6ICdDb250ZW50LVR5cGUnLCB2YWx1ZTogbWltZVR5cGUgfV1cbiAgICAgICAgXSxcbiAgICAgICAgYm9keTogc2FmZWx5RXh0cmFjdEJvZHkoZGF0YVVSTFN0cnVjdC5ib2R5KVswXVxuICAgICAgfSkpXG4gICAgfVxuICAgIGNhc2UgJ2ZpbGU6Jzoge1xuICAgICAgLy8gRm9yIG5vdywgdW5mb3J0dW5hdGUgYXMgaXQgaXMsIGZpbGUgVVJMcyBhcmUgbGVmdCBhcyBhbiBleGVyY2lzZSBmb3IgdGhlIHJlYWRlci5cbiAgICAgIC8vIFdoZW4gaW4gZG91YnQsIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ25vdCBpbXBsZW1lbnRlZC4uLiB5ZXQuLi4nKSlcbiAgICB9XG4gICAgY2FzZSAnaHR0cDonOlxuICAgIGNhc2UgJ2h0dHBzOic6IHtcbiAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cblxuICAgICAgcmV0dXJuIGh0dHBGZXRjaChmZXRjaFBhcmFtcylcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IG1ha2VOZXR3b3JrRXJyb3IoZXJyKSlcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCd1bmtub3duIHNjaGVtZScpKVxuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmluYWxpemUtcmVzcG9uc2VcbmZ1bmN0aW9uIGZpbmFsaXplUmVzcG9uc2UgKGZldGNoUGFyYW1zLCByZXNwb25zZSkge1xuICAvLyAxLiBTZXQgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGRvbmUgZmxhZy5cbiAgZmV0Y2hQYXJhbXMucmVxdWVzdC5kb25lID0gdHJ1ZVxuXG4gIC8vIDIsIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGRvbmUgaXMgbm90IG51bGwsIHRoZW4gcXVldWUgYSBmZXRjaFxuICAvLyB0YXNrIHRvIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBkb25lIGdpdmVuIHJlc3BvbnNlLCB3aXRoXG4gIC8vIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLlxuICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRG9uZSAhPSBudWxsKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRG9uZShyZXNwb25zZSkpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoLWZpbmFsZVxuZnVuY3Rpb24gZmV0Y2hGaW5hbGUgKGZldGNoUGFyYW1zLCByZXNwb25zZSkge1xuICAvLyAxLiBJZiByZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3IsIHRoZW46XG4gIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InKSB7XG4gICAgLy8gMS4gU2V0IHJlc3BvbnNl4oCZcyBVUkwgbGlzdCB0byDCqyBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgVVJMIGxpc3RbMF0gwrsuXG4gICAgcmVzcG9uc2UudXJsTGlzdCA9IFtmZXRjaFBhcmFtcy5yZXF1ZXN0LnVybExpc3RbMF1dXG5cbiAgICAvLyAyLiBTZXQgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvIHRvIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gb3BhcXVlIHRpbWluZ1xuICAgIC8vIGluZm8gZm9yIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgICByZXNwb25zZS50aW1pbmdJbmZvID0gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh7XG4gICAgICBzdGFydFRpbWU6IGZldGNoUGFyYW1zLnRpbWluZ0luZm8uc3RhcnRUaW1lXG4gICAgfSlcbiAgfVxuXG4gIC8vIDIuIExldCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgYmUgdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgY29uc3QgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5ID0gKCkgPT4ge1xuICAgIC8vIDEuIFNldCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgZG9uZSBmbGFnLlxuICAgIGZldGNoUGFyYW1zLnJlcXVlc3QuZG9uZSA9IHRydWVcblxuICAgIC8vIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGVuZC1vZi1ib2R5IGlzIG5vdCBudWxsLFxuICAgIC8vIHRoZW4gcXVldWUgYSBmZXRjaCB0YXNrIHRvIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZVxuICAgIC8vIGVuZC1vZi1ib2R5IGdpdmVuIHJlc3BvbnNlIHdpdGggZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSAhPSBudWxsKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkocmVzcG9uc2UpKVxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGlzIG5vbi1udWxsLCB0aGVuIHF1ZXVlIGEgZmV0Y2ggdGFza1xuICAvLyB0byBydW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgZ2l2ZW4gcmVzcG9uc2UsIHdpdGggZmV0Y2hQYXJhbXPigJlzXG4gIC8vIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZShyZXNwb25zZSkpXG4gIH1cblxuICAvLyA0LiBJZiByZXNwb25zZeKAmXMgYm9keSBpcyBudWxsLCB0aGVuIHJ1biBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkuXG4gIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkoKVxuICB9IGVsc2Uge1xuICAvLyA1LiBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBMZXQgdHJhbnNmb3JtU3RyZWFtIGJlIGEgbmV3IGEgVHJhbnNmb3JtU3RyZWFtLlxuXG4gICAgLy8gMi4gTGV0IGlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtIGJlIGFuIGFsZ29yaXRobSB3aGljaCwgZ2l2ZW4gY2h1bmssXG4gICAgLy8gZW5xdWV1ZXMgY2h1bmsgaW4gdHJhbnNmb3JtU3RyZWFtLlxuICAgIGNvbnN0IGlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtID0gKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspXG4gICAgfVxuXG4gICAgLy8gMy4gU2V0IHVwIHRyYW5zZm9ybVN0cmVhbSB3aXRoIHRyYW5zZm9ybUFsZ29yaXRobSBzZXQgdG8gaWRlbnRpdHlUcmFuc2Zvcm1BbGdvcml0aG1cbiAgICAvLyBhbmQgZmx1c2hBbGdvcml0aG0gc2V0IHRvIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keS5cbiAgICBjb25zdCB0cmFuc2Zvcm1TdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0ICgpIHt9LFxuICAgICAgdHJhbnNmb3JtOiBpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobSxcbiAgICAgIGZsdXNoOiBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHlcbiAgICB9LCB7XG4gICAgICBzaXplICgpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaXplICgpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gNC4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIHRoZSByZXN1bHQgb2YgcGlwaW5nIHJlc3BvbnNl4oCZcyBib2R5IHRocm91Z2ggdHJhbnNmb3JtU3RyZWFtLlxuICAgIHJlc3BvbnNlLmJvZHkgPSB7IHN0cmVhbTogcmVzcG9uc2UuYm9keS5zdHJlYW0ucGlwZVRocm91Z2godHJhbnNmb3JtU3RyZWFtKSB9XG4gIH1cblxuICAvLyA2LiBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBjb25zdW1lIGJvZHkgaXMgbm9uLW51bGwsIHRoZW46XG4gIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSAhPSBudWxsKSB7XG4gICAgLy8gMS4gTGV0IHByb2Nlc3NCb2R5IGdpdmVuIG51bGxPckJ5dGVzIGJlIHRoaXMgc3RlcDogcnVuIGZldGNoUGFyYW1z4oCZc1xuICAgIC8vIHByb2Nlc3MgcmVzcG9uc2UgY29uc3VtZSBib2R5IGdpdmVuIHJlc3BvbnNlIGFuZCBudWxsT3JCeXRlcy5cbiAgICBjb25zdCBwcm9jZXNzQm9keSA9IChudWxsT3JCeXRlcykgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHkocmVzcG9uc2UsIG51bGxPckJ5dGVzKVxuXG4gICAgLy8gMi4gTGV0IHByb2Nlc3NCb2R5RXJyb3IgYmUgdGhpcyBzdGVwOiBydW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3NcbiAgICAvLyByZXNwb25zZSBjb25zdW1lIGJvZHkgZ2l2ZW4gcmVzcG9uc2UgYW5kIGZhaWx1cmUuXG4gICAgY29uc3QgcHJvY2Vzc0JvZHlFcnJvciA9IChmYWlsdXJlKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keShyZXNwb25zZSwgZmFpbHVyZSlcblxuICAgIC8vIDMuIElmIHJlc3BvbnNl4oCZcyBib2R5IGlzIG51bGwsIHRoZW4gcXVldWUgYSBmZXRjaCB0YXNrIHRvIHJ1biBwcm9jZXNzQm9keVxuICAgIC8vIGdpdmVuIG51bGwsIHdpdGggZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gICAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcHJvY2Vzc0JvZHkobnVsbCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDQuIE90aGVyd2lzZSwgZnVsbHkgcmVhZCByZXNwb25zZeKAmXMgYm9keSBnaXZlbiBwcm9jZXNzQm9keSwgcHJvY2Vzc0JvZHlFcnJvcixcbiAgICAgIC8vIGFuZCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgICAgIHJldHVybiBmdWxseVJlYWRCb2R5KHJlc3BvbnNlLmJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gaHR0cEZldGNoIChmZXRjaFBhcmFtcykge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIExldCBhY3R1YWxSZXNwb25zZSBiZSBudWxsLlxuICBsZXQgYWN0dWFsUmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gNC4gTGV0IHRpbWluZ0luZm8gYmUgZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICBjb25zdCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mb1xuXG4gIC8vIDUuIElmIHJlcXVlc3TigJlzIHNlcnZpY2Utd29ya2VycyBtb2RlIGlzIFwiYWxsXCIsIHRoZW46XG4gIGlmIChyZXF1ZXN0LnNlcnZpY2VXb3JrZXJzID09PSAnYWxsJykge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDYuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW46XG4gIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgIC8vIDEuIElmIG1ha2VDT1JTUHJlZmxpZ2h0IGlzIHRydWUgYW5kIG9uZSBvZiB0aGVzZSBjb25kaXRpb25zIGlzIHRydWU6XG4gICAgLy8gVE9ET1xuXG4gICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSBpcyBcImZvbGxvd1wiLCB0aGVuIHNldCByZXF1ZXN04oCZc1xuICAgIC8vIHNlcnZpY2Utd29ya2VycyBtb2RlIHRvIFwibm9uZVwiLlxuICAgIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93Jykge1xuICAgICAgcmVxdWVzdC5zZXJ2aWNlV29ya2VycyA9ICdub25lJ1xuICAgIH1cblxuICAgIC8vIDMuIFNldCByZXNwb25zZSBhbmQgYWN0dWFsUmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgLy8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICAgIGFjdHVhbFJlc3BvbnNlID0gcmVzcG9uc2UgPSBhd2FpdCBodHRwTmV0d29ya09yQ2FjaGVGZXRjaChmZXRjaFBhcmFtcylcblxuICAgIC8vIDQuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiIGFuZCBhIENPUlMgY2hlY2tcbiAgICAvLyBmb3IgcmVxdWVzdCBhbmQgcmVzcG9uc2UgcmV0dXJucyBmYWlsdXJlLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgaWYgKFxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycgJiZcbiAgICAgIGNvcnNDaGVjayhyZXF1ZXN0LCByZXNwb25zZSkgPT09ICdmYWlsdXJlJ1xuICAgICkge1xuICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ2NvcnMgZmFpbHVyZScpXG4gICAgfVxuXG4gICAgLy8gNS4gSWYgdGhlIFRBTyBjaGVjayBmb3IgcmVxdWVzdCBhbmQgcmVzcG9uc2UgcmV0dXJucyBmYWlsdXJlLCB0aGVuIHNldFxuICAgIC8vIHJlcXVlc3TigJlzIHRpbWluZyBhbGxvdyBmYWlsZWQgZmxhZy5cbiAgICBpZiAoVEFPQ2hlY2socmVxdWVzdCwgcmVzcG9uc2UpID09PSAnZmFpbHVyZScpIHtcbiAgICAgIHJlcXVlc3QudGltaW5nQWxsb3dGYWlsZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gNy4gSWYgZWl0aGVyIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIG9yIHJlc3BvbnNl4oCZcyB0eXBlXG4gIC8vIGlzIFwib3BhcXVlXCIsIGFuZCB0aGUgY3Jvc3Mtb3JpZ2luIHJlc291cmNlIHBvbGljeSBjaGVjayB3aXRoXG4gIC8vIHJlcXVlc3TigJlzIG9yaWdpbiwgcmVxdWVzdOKAmXMgY2xpZW50LCByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbixcbiAgLy8gYW5kIGFjdHVhbFJlc3BvbnNlIHJldHVybnMgYmxvY2tlZCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ29wYXF1ZScgfHwgcmVzcG9uc2UudHlwZSA9PT0gJ29wYXF1ZScpICYmXG4gICAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrKFxuICAgICAgcmVxdWVzdC5vcmlnaW4sXG4gICAgICByZXF1ZXN0LmNsaWVudCxcbiAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24sXG4gICAgICBhY3R1YWxSZXNwb25zZVxuICAgICkgPT09ICdibG9ja2VkJ1xuICApIHtcbiAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignYmxvY2tlZCcpXG4gIH1cblxuICAvLyA4LiBJZiBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuOlxuICBpZiAocmVkaXJlY3RTdGF0dXNTZXQuaGFzKGFjdHVhbFJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAvLyAxLiBJZiBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIG5vdCAzMDMsIHJlcXVlc3TigJlzIGJvZHkgaXMgbm90IG51bGwsXG4gICAgLy8gYW5kIHRoZSBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHVzZXIgYWdlbnRzIG1heSwgYW5kIGFyZSBldmVuXG4gICAgLy8gZW5jb3VyYWdlZCB0bywgdHJhbnNtaXQgYW4gUlNUX1NUUkVBTSBmcmFtZS5cbiAgICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyODhcbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ21hbnVhbCcpIHtcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvLyAyLiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZTpcbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2Vycm9yJykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcigndW5leHBlY3RlZCByZWRpcmVjdCcpXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnbWFudWFsJykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIGFuIG9wYXF1ZS1yZWRpcmVjdCBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSBpbnRlcm5hbFxuICAgICAgLy8gcmVzcG9uc2UgaXMgYWN0dWFsUmVzcG9uc2UuXG4gICAgICAvLyBOT1RFKHNwZWMpOiBPbiB0aGUgd2ViIHRoaXMgd291bGQgcmV0dXJuIGFuIGBvcGFxdWVyZWRpcmVjdGAgcmVzcG9uc2UsXG4gICAgICAvLyBidXQgdGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2Ugc2VydmVyIHNpZGUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzExOTMuXG4gICAgICByZXNwb25zZSA9IGFjdHVhbFJlc3BvbnNlXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93Jykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLXJlZGlyZWN0IGZldGNoIGdpdmVuXG4gICAgICAvLyBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UuXG4gICAgICByZXNwb25zZSA9IGF3YWl0IGh0dHBSZWRpcmVjdEZldGNoKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDkuIFNldCByZXNwb25zZeKAmXMgdGltaW5nIGluZm8gdG8gdGltaW5nSW5mby5cbiAgcmVzcG9uc2UudGltaW5nSW5mbyA9IHRpbWluZ0luZm9cblxuICAvLyAxMC4gUmV0dXJuIHJlc3BvbnNlLlxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtcmVkaXJlY3QtZmV0Y2hcbmZ1bmN0aW9uIGh0dHBSZWRpcmVjdEZldGNoIChmZXRjaFBhcmFtcywgcmVzcG9uc2UpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IGFjdHVhbFJlc3BvbnNlIGJlIHJlc3BvbnNlLCBpZiByZXNwb25zZSBpcyBub3QgYSBmaWx0ZXJlZCByZXNwb25zZSxcbiAgLy8gYW5kIHJlc3BvbnNl4oCZcyBpbnRlcm5hbCByZXNwb25zZSBvdGhlcndpc2UuXG4gIGNvbnN0IGFjdHVhbFJlc3BvbnNlID0gcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuICAgID8gcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuICAgIDogcmVzcG9uc2VcblxuICAvLyAzLiBMZXQgbG9jYXRpb25VUkwgYmUgYWN0dWFsUmVzcG9uc2XigJlzIGxvY2F0aW9uIFVSTCBnaXZlbiByZXF1ZXN04oCZcyBjdXJyZW50XG4gIC8vIFVSTOKAmXMgZnJhZ21lbnQuXG4gIGxldCBsb2NhdGlvblVSTFxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb25VUkwgPSByZXNwb25zZUxvY2F0aW9uVVJMKFxuICAgICAgYWN0dWFsUmVzcG9uc2UsXG4gICAgICByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KS5oYXNoXG4gICAgKVxuXG4gICAgLy8gNC4gSWYgbG9jYXRpb25VUkwgaXMgbnVsbCwgdGhlbiByZXR1cm4gcmVzcG9uc2UuXG4gICAgaWYgKGxvY2F0aW9uVVJMID09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gNS4gSWYgbG9jYXRpb25VUkwgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcihlcnIpKVxuICB9XG5cbiAgLy8gNi4gSWYgbG9jYXRpb25VUkzigJlzIHNjaGVtZSBpcyBub3QgYW4gSFRUUChTKSBzY2hlbWUsIHRoZW4gcmV0dXJuIGEgbmV0d29ya1xuICAvLyBlcnJvci5cbiAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShsb2NhdGlvblVSTCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ1VSTCBzY2hlbWUgbXVzdCBiZSBhIEhUVFAoUykgc2NoZW1lJykpXG4gIH1cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyByZWRpcmVjdCBjb3VudCBpcyAyMCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAocmVxdWVzdC5yZWRpcmVjdENvdW50ID09PSAyMCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcigncmVkaXJlY3QgY291bnQgZXhjZWVkZWQnKSlcbiAgfVxuXG4gIC8vIDguIEluY3JlYXNlIHJlcXVlc3TigJlzIHJlZGlyZWN0IGNvdW50IGJ5IDEuXG4gIHJlcXVlc3QucmVkaXJlY3RDb3VudCArPSAxXG5cbiAgLy8gOS4gSWYgcmVxdWVzdOKAmXMgbW9kZSBpcyBcImNvcnNcIiwgbG9jYXRpb25VUkwgaW5jbHVkZXMgY3JlZGVudGlhbHMsIGFuZFxuICAvLyByZXF1ZXN04oCZcyBvcmlnaW4gaXMgbm90IHNhbWUgb3JpZ2luIHdpdGggbG9jYXRpb25VUkzigJlzIG9yaWdpbiwgdGhlbiByZXR1cm5cbiAgLy8gIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIHJlcXVlc3QubW9kZSA9PT0gJ2NvcnMnICYmXG4gICAgKGxvY2F0aW9uVVJMLnVzZXJuYW1lIHx8IGxvY2F0aW9uVVJMLnBhc3N3b3JkKSAmJlxuICAgICFzYW1lT3JpZ2luKHJlcXVlc3QsIGxvY2F0aW9uVVJMKVxuICApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2Nyb3NzIG9yaWdpbiBub3QgYWxsb3dlZCBmb3IgcmVxdWVzdCBtb2RlIFwiY29yc1wiJykpXG4gIH1cblxuICAvLyAxMC4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIgYW5kIGxvY2F0aW9uVVJMIGluY2x1ZGVzXG4gIC8vIGNyZWRlbnRpYWxzLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJyAmJlxuICAgIChsb2NhdGlvblVSTC51c2VybmFtZSB8fCBsb2NhdGlvblVSTC5wYXNzd29yZClcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKFxuICAgICAgJ1VSTCBjYW5ub3QgY29udGFpbiBjcmVkZW50aWFscyBmb3IgcmVxdWVzdCBtb2RlIFwiY29yc1wiJ1xuICAgICkpXG4gIH1cblxuICAvLyAxMS4gSWYgYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBub3QgMzAzLCByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLFxuICAvLyBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG51bGwsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIGFjdHVhbFJlc3BvbnNlLnN0YXR1cyAhPT0gMzAzICYmXG4gICAgcmVxdWVzdC5ib2R5ICE9IG51bGwgJiZcbiAgICByZXF1ZXN0LmJvZHkuc291cmNlID09IG51bGxcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCkpXG4gIH1cblxuICAvLyAxMi4gSWYgb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZVxuICAvLyAtIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzAxIG9yIDMwMiBhbmQgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIGBQT1NUYFxuICAvLyAtIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzAzIGFuZCByZXF1ZXN04oCZcyBtZXRob2QgaXMgbm90IGBHRVRgIG9yIGBIRUFEYFxuICBpZiAoXG4gICAgKFszMDEsIDMwMl0uaW5jbHVkZXMoYWN0dWFsUmVzcG9uc2Uuc3RhdHVzKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSB8fFxuICAgIChhY3R1YWxSZXNwb25zZS5zdGF0dXMgPT09IDMwMyAmJlxuICAgICAgIUdFVF9PUl9IRUFELmluY2x1ZGVzKHJlcXVlc3QubWV0aG9kKSlcbiAgKSB7XG4gICAgLy8gdGhlbjpcbiAgICAvLyAxLiBTZXQgcmVxdWVzdOKAmXMgbWV0aG9kIHRvIGBHRVRgIGFuZCByZXF1ZXN04oCZcyBib2R5IHRvIG51bGwuXG4gICAgcmVxdWVzdC5tZXRob2QgPSAnR0VUJ1xuICAgIHJlcXVlc3QuYm9keSA9IG51bGxcblxuICAgIC8vIDIuIEZvciBlYWNoIGhlYWRlck5hbWUgb2YgcmVxdWVzdC1ib2R5LWhlYWRlciBuYW1lLCBkZWxldGUgaGVhZGVyTmFtZSBmcm9tXG4gICAgLy8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgZm9yIChjb25zdCBoZWFkZXJOYW1lIG9mIHJlcXVlc3RCb2R5SGVhZGVyKSB7XG4gICAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZShoZWFkZXJOYW1lKVxuICAgIH1cbiAgfVxuXG4gIC8vIDEzLiBJZiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIGxvY2F0aW9uVVJM4oCZc1xuICAvLyAgICAgb3JpZ2luLCB0aGVuIGZvciBlYWNoIGhlYWRlck5hbWUgb2YgQ09SUyBub24td2lsZGNhcmQgcmVxdWVzdC1oZWFkZXIgbmFtZSxcbiAgLy8gICAgIGRlbGV0ZSBoZWFkZXJOYW1lIGZyb20gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmICghc2FtZU9yaWdpbihyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSwgbG9jYXRpb25VUkwpKSB7XG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvcnMtbm9uLXdpbGRjYXJkLXJlcXVlc3QtaGVhZGVyLW5hbWVcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnYXV0aG9yaXphdGlvbicpXG5cbiAgICAvLyBcIkNvb2tpZVwiIGFuZCBcIkhvc3RcIiBhcmUgZm9yYmlkZGVuIHJlcXVlc3QtaGVhZGVycywgd2hpY2ggdW5kaWNpIGRvZXNuJ3QgaW1wbGVtZW50LlxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdjb29raWUnKVxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdob3N0JylcbiAgfVxuXG4gIC8vIDE0LiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLCB0aGVuIHNldCByZXF1ZXN04oCZcyBib2R5IHRvIHRoZSBmaXJzdCByZXR1cm5cbiAgLy8gdmFsdWUgb2Ygc2FmZWx5IGV4dHJhY3RpbmcgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlLlxuICBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcbiAgICBhc3NlcnQocmVxdWVzdC5ib2R5LnNvdXJjZSAhPSBudWxsKVxuICAgIHJlcXVlc3QuYm9keSA9IHNhZmVseUV4dHJhY3RCb2R5KHJlcXVlc3QuYm9keS5zb3VyY2UpWzBdXG4gIH1cblxuICAvLyAxNS4gTGV0IHRpbWluZ0luZm8gYmUgZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICBjb25zdCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mb1xuXG4gIC8vIDE2LiBTZXQgdGltaW5nSW5mb+KAmXMgcmVkaXJlY3QgZW5kIHRpbWUgYW5kIHBvc3QtcmVkaXJlY3Qgc3RhcnQgdGltZSB0byB0aGVcbiAgLy8gY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZFxuICAvLyBjYXBhYmlsaXR5LlxuICB0aW1pbmdJbmZvLnJlZGlyZWN0RW5kVGltZSA9IHRpbWluZ0luZm8ucG9zdFJlZGlyZWN0U3RhcnRUaW1lID1cbiAgICBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZShmZXRjaFBhcmFtcy5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcblxuICAvLyAxNy4gSWYgdGltaW5nSW5mb+KAmXMgcmVkaXJlY3Qgc3RhcnQgdGltZSBpcyAwLCB0aGVuIHNldCB0aW1pbmdJbmZv4oCZc1xuICAvLyAgcmVkaXJlY3Qgc3RhcnQgdGltZSB0byB0aW1pbmdJbmZv4oCZcyBzdGFydCB0aW1lLlxuICBpZiAodGltaW5nSW5mby5yZWRpcmVjdFN0YXJ0VGltZSA9PT0gMCkge1xuICAgIHRpbWluZ0luZm8ucmVkaXJlY3RTdGFydFRpbWUgPSB0aW1pbmdJbmZvLnN0YXJ0VGltZVxuICB9XG5cbiAgLy8gMTguIEFwcGVuZCBsb2NhdGlvblVSTCB0byByZXF1ZXN04oCZcyBVUkwgbGlzdC5cbiAgcmVxdWVzdC51cmxMaXN0LnB1c2gobG9jYXRpb25VUkwpXG5cbiAgLy8gMTkuIEludm9rZSBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IG9uIHJlZGlyZWN0IG9uIHJlcXVlc3QgYW5kXG4gIC8vIGFjdHVhbFJlc3BvbnNlLlxuICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0KHJlcXVlc3QsIGFjdHVhbFJlc3BvbnNlKVxuXG4gIC8vIDIwLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIG1haW4gZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHRydWUuXG4gIHJldHVybiBtYWluRmV0Y2goZmV0Y2hQYXJhbXMsIHRydWUpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLW5ldHdvcmstb3ItY2FjaGUtZmV0Y2hcbmFzeW5jIGZ1bmN0aW9uIGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoIChcbiAgZmV0Y2hQYXJhbXMsXG4gIGlzQXV0aGVudGljYXRpb25GZXRjaCA9IGZhbHNlLFxuICBpc05ld0Nvbm5lY3Rpb25GZXRjaCA9IGZhbHNlXG4pIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IGh0dHBGZXRjaFBhcmFtcyBiZSBudWxsLlxuICBsZXQgaHR0cEZldGNoUGFyYW1zID0gbnVsbFxuXG4gIC8vIDMuIExldCBodHRwUmVxdWVzdCBiZSBudWxsLlxuICBsZXQgaHR0cFJlcXVlc3QgPSBudWxsXG5cbiAgLy8gNC4gTGV0IHJlc3BvbnNlIGJlIG51bGwuXG4gIGxldCByZXNwb25zZSA9IG51bGxcblxuICAvLyA1LiBMZXQgc3RvcmVkUmVzcG9uc2UgYmUgbnVsbC5cbiAgLy8gVE9ETzogY2FjaGVcblxuICAvLyA2LiBMZXQgaHR0cENhY2hlIGJlIG51bGwuXG4gIGNvbnN0IGh0dHBDYWNoZSA9IG51bGxcblxuICAvLyA3LiBMZXQgdGhlIHJldmFsaWRhdGluZ0ZsYWcgYmUgdW5zZXQuXG4gIGNvbnN0IHJldmFsaWRhdGluZ0ZsYWcgPSBmYWxzZVxuXG4gIC8vIDguIFJ1biB0aGVzZSBzdGVwcywgYnV0IGFib3J0IHdoZW4gdGhlIG9uZ29pbmcgZmV0Y2ggaXMgdGVybWluYXRlZDpcblxuICAvLyAgICAxLiBJZiByZXF1ZXN04oCZcyB3aW5kb3cgaXMgXCJuby13aW5kb3dcIiBhbmQgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSBpc1xuICAvLyAgICBcImVycm9yXCIsIHRoZW4gc2V0IGh0dHBGZXRjaFBhcmFtcyB0byBmZXRjaFBhcmFtcyBhbmQgaHR0cFJlcXVlc3QgdG9cbiAgLy8gICAgcmVxdWVzdC5cbiAgaWYgKHJlcXVlc3Qud2luZG93ID09PSAnbm8td2luZG93JyAmJiByZXF1ZXN0LnJlZGlyZWN0ID09PSAnZXJyb3InKSB7XG4gICAgaHR0cEZldGNoUGFyYW1zID0gZmV0Y2hQYXJhbXNcbiAgICBodHRwUmVxdWVzdCA9IHJlcXVlc3RcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBTZXQgaHR0cFJlcXVlc3QgdG8gYSBjbG9uZSBvZiByZXF1ZXN0LlxuICAgIGh0dHBSZXF1ZXN0ID0gbWFrZVJlcXVlc3QocmVxdWVzdClcblxuICAgIC8vIDIuIFNldCBodHRwRmV0Y2hQYXJhbXMgdG8gYSBjb3B5IG9mIGZldGNoUGFyYW1zLlxuICAgIGh0dHBGZXRjaFBhcmFtcyA9IHsgLi4uZmV0Y2hQYXJhbXMgfVxuXG4gICAgLy8gMy4gU2V0IGh0dHBGZXRjaFBhcmFtc+KAmXMgcmVxdWVzdCB0byBodHRwUmVxdWVzdC5cbiAgICBodHRwRmV0Y2hQYXJhbXMucmVxdWVzdCA9IGh0dHBSZXF1ZXN0XG4gIH1cblxuICAvLyAgICAzLiBMZXQgaW5jbHVkZUNyZWRlbnRpYWxzIGJlIHRydWUgaWYgb25lIG9mXG4gIGNvbnN0IGluY2x1ZGVDcmVkZW50aWFscyA9XG4gICAgcmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnIHx8XG4gICAgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdzYW1lLW9yaWdpbicgJiZcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2Jhc2ljJylcblxuICAvLyAgICA0LiBMZXQgY29udGVudExlbmd0aCBiZSBodHRwUmVxdWVzdOKAmXMgYm9keeKAmXMgbGVuZ3RoLCBpZiBodHRwUmVxdWVzdOKAmXNcbiAgLy8gICAgYm9keSBpcyBub24tbnVsbDsgb3RoZXJ3aXNlIG51bGwuXG4gIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBodHRwUmVxdWVzdC5ib2R5ID8gaHR0cFJlcXVlc3QuYm9keS5sZW5ndGggOiBudWxsXG5cbiAgLy8gICAgNS4gTGV0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSBiZSBudWxsLlxuICBsZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlID0gbnVsbFxuXG4gIC8vICAgIDYuIElmIGh0dHBSZXF1ZXN04oCZcyBib2R5IGlzIG51bGwgYW5kIGh0dHBSZXF1ZXN04oCZcyBtZXRob2QgaXMgYFBPU1RgIG9yXG4gIC8vICAgIGBQVVRgLCB0aGVuIHNldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgdG8gYDBgLlxuICBpZiAoXG4gICAgaHR0cFJlcXVlc3QuYm9keSA9PSBudWxsICYmXG4gICAgWydQT1NUJywgJ1BVVCddLmluY2x1ZGVzKGh0dHBSZXF1ZXN0Lm1ldGhvZClcbiAgKSB7XG4gICAgY29udGVudExlbmd0aEhlYWRlclZhbHVlID0gJzAnXG4gIH1cblxuICAvLyAgICA3LiBJZiBjb250ZW50TGVuZ3RoIGlzIG5vbi1udWxsLCB0aGVuIHNldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgdG9cbiAgLy8gICAgY29udGVudExlbmd0aCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsKSB7XG4gICAgY29udGVudExlbmd0aEhlYWRlclZhbHVlID0gaXNvbW9ycGhpY0VuY29kZShgJHtjb250ZW50TGVuZ3RofWApXG4gIH1cblxuICAvLyAgICA4LiBJZiBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgaXMgbm9uLW51bGwsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBDb250ZW50LUxlbmd0aGAvY29udGVudExlbmd0aEhlYWRlclZhbHVlIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gICAgbGlzdC5cbiAgaWYgKGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSAhPSBudWxsKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdjb250ZW50LWxlbmd0aCcsIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSlcbiAgfVxuXG4gIC8vICAgIDkuIElmIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSBpcyBub24tbnVsbCwgdGhlbiBhcHBlbmQgKGBDb250ZW50LUxlbmd0aGAsXG4gIC8vICAgIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSkgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuXG4gIC8vICAgIDEwLiBJZiBjb250ZW50TGVuZ3RoIGlzIG5vbi1udWxsIGFuZCBodHRwUmVxdWVzdOKAmXMga2VlcGFsaXZlIGlzIHRydWUsXG4gIC8vICAgIHRoZW46XG4gIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgaHR0cFJlcXVlc3Qua2VlcGFsaXZlKSB7XG4gICAgLy8gTk9URToga2VlcGFsaXZlIGlzIGEgbm9vcCBvdXRzaWRlIG9mIGJyb3dzZXIgY29udGV4dC5cbiAgfVxuXG4gIC8vICAgIDExLiBJZiBodHRwUmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgYSBVUkwsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBSZWZlcmVyYC9odHRwUmVxdWVzdOKAmXMgcmVmZXJyZXIsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCxcbiAgLy8gICAgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKGh0dHBSZXF1ZXN0LnJlZmVycmVyIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdyZWZlcmVyJywgaXNvbW9ycGhpY0VuY29kZShodHRwUmVxdWVzdC5yZWZlcnJlci5ocmVmKSlcbiAgfVxuXG4gIC8vICAgIDEyLiBBcHBlbmQgYSByZXF1ZXN0IGBPcmlnaW5gIGhlYWRlciBmb3IgaHR0cFJlcXVlc3QuXG4gIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIoaHR0cFJlcXVlc3QpXG5cbiAgLy8gICAgMTMuIEFwcGVuZCB0aGUgRmV0Y2ggbWV0YWRhdGEgaGVhZGVycyBmb3IgaHR0cFJlcXVlc3QuIFtGRVRDSC1NRVRBREFUQV1cbiAgYXBwZW5kRmV0Y2hNZXRhZGF0YShodHRwUmVxdWVzdClcblxuICAvLyAgICAxNC4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFVzZXItQWdlbnRgLCB0aGVuXG4gIC8vICAgIHVzZXIgYWdlbnRzIHNob3VsZCBhcHBlbmQgYFVzZXItQWdlbnRgL2RlZmF1bHQgYFVzZXItQWdlbnRgIHZhbHVlIHRvXG4gIC8vICAgIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygndXNlci1hZ2VudCcpKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCd1c2VyLWFnZW50JywgdHlwZW9mIGVzYnVpbGREZXRlY3Rpb24gPT09ICd1bmRlZmluZWQnID8gJ3VuZGljaScgOiAnbm9kZScpXG4gIH1cblxuICAvLyAgICAxNS4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJkZWZhdWx0XCIgYW5kIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gICAgbGlzdCBjb250YWlucyBgSWYtTW9kaWZpZWQtU2luY2VgLCBgSWYtTm9uZS1NYXRjaGAsXG4gIC8vICAgIGBJZi1Vbm1vZGlmaWVkLVNpbmNlYCwgYElmLU1hdGNoYCwgb3IgYElmLVJhbmdlYCwgdGhlbiBzZXRcbiAgLy8gICAgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG8gXCJuby1zdG9yZVwiLlxuICBpZiAoXG4gICAgaHR0cFJlcXVlc3QuY2FjaGUgPT09ICdkZWZhdWx0JyAmJlxuICAgIChodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtbW9kaWZpZWQtc2luY2UnKSB8fFxuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLW5vbmUtbWF0Y2gnKSB8fFxuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLXVubW9kaWZpZWQtc2luY2UnKSB8fFxuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLW1hdGNoJykgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1yYW5nZScpKVxuICApIHtcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9ICduby1zdG9yZSdcbiAgfVxuXG4gIC8vICAgIDE2LiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcIm5vLWNhY2hlXCIsIGh0dHBSZXF1ZXN04oCZcyBwcmV2ZW50XG4gIC8vICAgIG5vLWNhY2hlIGNhY2hlLWNvbnRyb2wgaGVhZGVyIG1vZGlmaWNhdGlvbiBmbGFnIGlzIHVuc2V0LCBhbmRcbiAgLy8gICAgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYENhY2hlLUNvbnRyb2xgLCB0aGVuIGFwcGVuZFxuICAvLyAgICBgQ2FjaGUtQ29udHJvbGAvYG1heC1hZ2U9MGAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoXG4gICAgaHR0cFJlcXVlc3QuY2FjaGUgPT09ICduby1jYWNoZScgJiZcbiAgICAhaHR0cFJlcXVlc3QucHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb24gJiZcbiAgICAhaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2NhY2hlLWNvbnRyb2wnKVxuICApIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NhY2hlLWNvbnRyb2wnLCAnbWF4LWFnZT0wJylcbiAgfVxuXG4gIC8vICAgIDE3LiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcIm5vLXN0b3JlXCIgb3IgXCJyZWxvYWRcIiwgdGhlbjpcbiAgaWYgKGh0dHBSZXF1ZXN0LmNhY2hlID09PSAnbm8tc3RvcmUnIHx8IGh0dHBSZXF1ZXN0LmNhY2hlID09PSAncmVsb2FkJykge1xuICAgIC8vIDEuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBQcmFnbWFgLCB0aGVuIGFwcGVuZFxuICAgIC8vIGBQcmFnbWFgL2Buby1jYWNoZWAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ByYWdtYScpKSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3ByYWdtYScsICduby1jYWNoZScpXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYENhY2hlLUNvbnRyb2xgLFxuICAgIC8vIHRoZW4gYXBwZW5kIGBDYWNoZS1Db250cm9sYC9gbm8tY2FjaGVgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdjYWNoZS1jb250cm9sJykpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnY2FjaGUtY29udHJvbCcsICduby1jYWNoZScpXG4gICAgfVxuICB9XG5cbiAgLy8gICAgMTguIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyBgUmFuZ2VgLCB0aGVuIGFwcGVuZFxuICAvLyAgICBgQWNjZXB0LUVuY29kaW5nYC9gaWRlbnRpdHlgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdyYW5nZScpKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtZW5jb2RpbmcnLCAnaWRlbnRpdHknKVxuICB9XG5cbiAgLy8gICAgMTkuIE1vZGlmeSBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgcGVyIEhUVFAuIERvIG5vdCBhcHBlbmQgYSBnaXZlblxuICAvLyAgICBoZWFkZXIgaWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIHRoYXQgaGVhZGVy4oCZcyBuYW1lLlxuICAvLyAgICBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZldGNoL2lzc3Vlcy8xMjg1I2lzc3VlY29tbWVudC04OTY1NjAxMjlcbiAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnYWNjZXB0LWVuY29kaW5nJykpIHtcbiAgICBpZiAodXJsSGFzSHR0cHNTY2hlbWUocmVxdWVzdEN1cnJlbnRVUkwoaHR0cFJlcXVlc3QpKSkge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtZW5jb2RpbmcnLCAnYnIsIGd6aXAsIGRlZmxhdGUnKVxuICAgIH0gZWxzZSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdC1lbmNvZGluZycsICdnemlwLCBkZWZsYXRlJylcbiAgICB9XG4gIH1cblxuICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2hvc3QnKVxuXG4gIC8vICAgIDIwLiBJZiBpbmNsdWRlQ3JlZGVudGlhbHMgaXMgdHJ1ZSwgdGhlbjpcbiAgaWYgKGluY2x1ZGVDcmVkZW50aWFscykge1xuICAgIC8vIDEuIElmIHRoZSB1c2VyIGFnZW50IGlzIG5vdCBjb25maWd1cmVkIHRvIGJsb2NrIGNvb2tpZXMgZm9yIGh0dHBSZXF1ZXN0XG4gICAgLy8gKHNlZSBzZWN0aW9uIDcgb2YgW0NPT0tJRVNdKSwgdGhlbjpcbiAgICAvLyBUT0RPOiBjcmVkZW50aWFsc1xuICAgIC8vIDIuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBBdXRob3JpemF0aW9uYCwgdGhlbjpcbiAgICAvLyBUT0RPOiBjcmVkZW50aWFsc1xuICB9XG5cbiAgLy8gICAgMjEuIElmIHRoZXJl4oCZcyBhIHByb3h5LWF1dGhlbnRpY2F0aW9uIGVudHJ5LCB1c2UgaXQgYXMgYXBwcm9wcmlhdGUuXG4gIC8vICAgIFRPRE86IHByb3h5LWF1dGhlbnRpY2F0aW9uXG5cbiAgLy8gICAgMjIuIFNldCBodHRwQ2FjaGUgdG8gdGhlIHJlc3VsdCBvZiBkZXRlcm1pbmluZyB0aGUgSFRUUCBjYWNoZVxuICAvLyAgICBwYXJ0aXRpb24sIGdpdmVuIGh0dHBSZXF1ZXN0LlxuICAvLyAgICBUT0RPOiBjYWNoZVxuXG4gIC8vICAgIDIzLiBJZiBodHRwQ2FjaGUgaXMgbnVsbCwgdGhlbiBzZXQgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG9cbiAgLy8gICAgXCJuby1zdG9yZVwiLlxuICBpZiAoaHR0cENhY2hlID09IG51bGwpIHtcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9ICduby1zdG9yZSdcbiAgfVxuXG4gIC8vICAgIDI0LiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBuZWl0aGVyIFwibm8tc3RvcmVcIiBub3IgXCJyZWxvYWRcIixcbiAgLy8gICAgdGhlbjpcbiAgaWYgKGh0dHBSZXF1ZXN0Lm1vZGUgIT09ICduby1zdG9yZScgJiYgaHR0cFJlcXVlc3QubW9kZSAhPT0gJ3JlbG9hZCcpIHtcbiAgICAvLyBUT0RPOiBjYWNoZVxuICB9XG5cbiAgLy8gOS4gSWYgYWJvcnRlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAvLyBUT0RPXG5cbiAgLy8gMTAuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW46XG4gIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgLy8gMS4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJvbmx5LWlmLWNhY2hlZFwiLCB0aGVuIHJldHVybiBhXG4gICAgLy8gbmV0d29yayBlcnJvci5cbiAgICBpZiAoaHR0cFJlcXVlc3QubW9kZSA9PT0gJ29ubHktaWYtY2FjaGVkJykge1xuICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ29ubHkgaWYgY2FjaGVkJylcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgZm9yd2FyZFJlc3BvbnNlIGJlIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLW5ldHdvcmsgZmV0Y2hcbiAgICAvLyBnaXZlbiBodHRwRmV0Y2hQYXJhbXMsIGluY2x1ZGVDcmVkZW50aWFscywgYW5kIGlzTmV3Q29ubmVjdGlvbkZldGNoLlxuICAgIGNvbnN0IGZvcndhcmRSZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrRmV0Y2goXG4gICAgICBodHRwRmV0Y2hQYXJhbXMsXG4gICAgICBpbmNsdWRlQ3JlZGVudGlhbHMsXG4gICAgICBpc05ld0Nvbm5lY3Rpb25GZXRjaFxuICAgIClcblxuICAgIC8vIDMuIElmIGh0dHBSZXF1ZXN04oCZcyBtZXRob2QgaXMgdW5zYWZlIGFuZCBmb3J3YXJkUmVzcG9uc2XigJlzIHN0YXR1cyBpc1xuICAgIC8vIGluIHRoZSByYW5nZSAyMDAgdG8gMzk5LCBpbmNsdXNpdmUsIGludmFsaWRhdGUgYXBwcm9wcmlhdGUgc3RvcmVkXG4gICAgLy8gcmVzcG9uc2VzIGluIGh0dHBDYWNoZSwgYXMgcGVyIHRoZSBcIkludmFsaWRhdGlvblwiIGNoYXB0ZXIgb2YgSFRUUFxuICAgIC8vIENhY2hpbmcsIGFuZCBzZXQgc3RvcmVkUmVzcG9uc2UgdG8gbnVsbC4gW0hUVFAtQ0FDSElOR11cbiAgICBpZiAoXG4gICAgICAhc2FmZU1ldGhvZHNTZXQuaGFzKGh0dHBSZXF1ZXN0Lm1ldGhvZCkgJiZcbiAgICAgIGZvcndhcmRSZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmXG4gICAgICBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzIDw9IDM5OVxuICAgICkge1xuICAgICAgLy8gVE9ETzogY2FjaGVcbiAgICB9XG5cbiAgICAvLyA0LiBJZiB0aGUgcmV2YWxpZGF0aW5nRmxhZyBpcyBzZXQgYW5kIGZvcndhcmRSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDMwNCxcbiAgICAvLyB0aGVuOlxuICAgIGlmIChyZXZhbGlkYXRpbmdGbGFnICYmIGZvcndhcmRSZXNwb25zZS5zdGF0dXMgPT09IDMwNCkge1xuICAgICAgLy8gVE9ETzogY2FjaGVcbiAgICB9XG5cbiAgICAvLyA1LiBJZiByZXNwb25zZSBpcyBudWxsLCB0aGVuOlxuICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAvLyAxLiBTZXQgcmVzcG9uc2UgdG8gZm9yd2FyZFJlc3BvbnNlLlxuICAgICAgcmVzcG9uc2UgPSBmb3J3YXJkUmVzcG9uc2VcblxuICAgICAgLy8gMi4gU3RvcmUgaHR0cFJlcXVlc3QgYW5kIGZvcndhcmRSZXNwb25zZSBpbiBodHRwQ2FjaGUsIGFzIHBlciB0aGVcbiAgICAgIC8vIFwiU3RvcmluZyBSZXNwb25zZXMgaW4gQ2FjaGVzXCIgY2hhcHRlciBvZiBIVFRQIENhY2hpbmcuIFtIVFRQLUNBQ0hJTkddXG4gICAgICAvLyBUT0RPOiBjYWNoZVxuICAgIH1cbiAgfVxuXG4gIC8vIDExLiBTZXQgcmVzcG9uc2XigJlzIFVSTCBsaXN0IHRvIGEgY2xvbmUgb2YgaHR0cFJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICByZXNwb25zZS51cmxMaXN0ID0gWy4uLmh0dHBSZXF1ZXN0LnVybExpc3RdXG5cbiAgLy8gMTIuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyBgUmFuZ2VgLCB0aGVuIHNldCByZXNwb25zZeKAmXNcbiAgLy8gcmFuZ2UtcmVxdWVzdGVkIGZsYWcuXG4gIGlmIChodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncmFuZ2UnKSkge1xuICAgIHJlc3BvbnNlLnJhbmdlUmVxdWVzdGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gMTMuIFNldCByZXNwb25zZeKAmXMgcmVxdWVzdC1pbmNsdWRlcy1jcmVkZW50aWFscyB0byBpbmNsdWRlQ3JlZGVudGlhbHMuXG4gIHJlc3BvbnNlLnJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzID0gaW5jbHVkZUNyZWRlbnRpYWxzXG5cbiAgLy8gMTQuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgNDAxLCBodHRwUmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgbm90XG4gIC8vIFwiY29yc1wiLCBpbmNsdWRlQ3JlZGVudGlhbHMgaXMgdHJ1ZSwgYW5kIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBhbiBlbnZpcm9ubWVudFxuICAvLyBzZXR0aW5ncyBvYmplY3QsIHRoZW46XG4gIC8vIFRPRE9cblxuICAvLyAxNS4gSWYgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyA0MDcsIHRoZW46XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNykge1xuICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBcIm5vLXdpbmRvd1wiLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgaWYgKHJlcXVlc3Qud2luZG93ID09PSAnbm8td2luZG93Jykge1xuICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoKVxuICAgIH1cblxuICAgIC8vIDIuID8/P1xuXG4gICAgLy8gMy4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKVxuICAgIH1cblxuICAgIC8vIDQuIFByb21wdCB0aGUgZW5kIHVzZXIgYXMgYXBwcm9wcmlhdGUgaW4gcmVxdWVzdOKAmXMgd2luZG93IGFuZCBzdG9yZVxuICAgIC8vIHRoZSByZXN1bHQgYXMgYSBwcm94eS1hdXRoZW50aWNhdGlvbiBlbnRyeS4gW0hUVFAtQVVUSF1cbiAgICAvLyBUT0RPOiBJbnZva2Ugc29tZSBraW5kIG9mIGNhbGxiYWNrP1xuXG4gICAgLy8gNS4gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggZ2l2ZW5cbiAgICAvLyBmZXRjaFBhcmFtcy5cbiAgICAvLyBUT0RPXG4gICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ3Byb3h5IGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJylcbiAgfVxuXG4gIC8vIDE2LiBJZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBhcmUgdHJ1ZVxuICBpZiAoXG4gICAgLy8gcmVzcG9uc2XigJlzIHN0YXR1cyBpcyA0MjFcbiAgICByZXNwb25zZS5zdGF0dXMgPT09IDQyMSAmJlxuICAgIC8vIGlzTmV3Q29ubmVjdGlvbkZldGNoIGlzIGZhbHNlXG4gICAgIWlzTmV3Q29ubmVjdGlvbkZldGNoICYmXG4gICAgLy8gcmVxdWVzdOKAmXMgYm9keSBpcyBudWxsLCBvciByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsIGFuZCByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UgaXMgbm9uLW51bGxcbiAgICAocmVxdWVzdC5ib2R5ID09IG51bGwgfHwgcmVxdWVzdC5ib2R5LnNvdXJjZSAhPSBudWxsKVxuICApIHtcbiAgICAvLyB0aGVuOlxuXG4gICAgLy8gMS4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKVxuICAgIH1cblxuICAgIC8vIDIuIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1uZXR3b3JrLW9yLWNhY2hlXG4gICAgLy8gZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMsIGlzQXV0aGVudGljYXRpb25GZXRjaCwgYW5kIHRydWUuXG5cbiAgICAvLyBUT0RPIChzcGVjKTogVGhlIHNwZWMgZG9lc24ndCBzcGVjaWZ5IHRoaXMgYnV0IHdlIG5lZWQgdG8gY2FuY2VsXG4gICAgLy8gdGhlIGFjdGl2ZSByZXNwb25zZSBiZWZvcmUgd2UgY2FuIHN0YXJ0IGEgbmV3IG9uZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZldGNoL2lzc3Vlcy8xMjkzXG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3koKVxuXG4gICAgcmVzcG9uc2UgPSBhd2FpdCBodHRwTmV0d29ya09yQ2FjaGVGZXRjaChcbiAgICAgIGZldGNoUGFyYW1zLFxuICAgICAgaXNBdXRoZW50aWNhdGlvbkZldGNoLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgfVxuXG4gIC8vIDE3LiBJZiBpc0F1dGhlbnRpY2F0aW9uRmV0Y2ggaXMgdHJ1ZSwgdGhlbiBjcmVhdGUgYW4gYXV0aGVudGljYXRpb24gZW50cnlcbiAgaWYgKGlzQXV0aGVudGljYXRpb25GZXRjaCkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE4LiBSZXR1cm4gcmVzcG9uc2UuXG4gIHJldHVybiByZXNwb25zZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1uZXR3b3JrLWZldGNoXG5hc3luYyBmdW5jdGlvbiBodHRwTmV0d29ya0ZldGNoIChcbiAgZmV0Y2hQYXJhbXMsXG4gIGluY2x1ZGVDcmVkZW50aWFscyA9IGZhbHNlLFxuICBmb3JjZU5ld0Nvbm5lY3Rpb24gPSBmYWxzZVxuKSB7XG4gIGFzc2VydCghZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uIHx8IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95ZWQpXG5cbiAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uID0ge1xuICAgIGFib3J0OiBudWxsLFxuICAgIGRlc3Ryb3llZDogZmFsc2UsXG4gICAgZGVzdHJveSAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICAgICAgICB0aGlzLmFib3J0Py4oZXJyID8/IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyA0LiBMZXQgaHR0cENhY2hlIGJlIHRoZSByZXN1bHQgb2YgZGV0ZXJtaW5pbmcgdGhlIEhUVFAgY2FjaGUgcGFydGl0aW9uLFxuICAvLyBnaXZlbiByZXF1ZXN0LlxuICAvLyBUT0RPOiBjYWNoZVxuICBjb25zdCBodHRwQ2FjaGUgPSBudWxsXG5cbiAgLy8gNS4gSWYgaHR0cENhY2hlIGlzIG51bGwsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG8gXCJuby1zdG9yZVwiLlxuICBpZiAoaHR0cENhY2hlID09IG51bGwpIHtcbiAgICByZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gNi4gTGV0IG5ldHdvcmtQYXJ0aXRpb25LZXkgYmUgdGhlIHJlc3VsdCBvZiBkZXRlcm1pbmluZyB0aGUgbmV0d29ya1xuICAvLyBwYXJ0aXRpb24ga2V5IGdpdmVuIHJlcXVlc3QuXG4gIC8vIFRPRE9cblxuICAvLyA3LiBMZXQgbmV3Q29ubmVjdGlvbiBiZSBcInllc1wiIGlmIGZvcmNlTmV3Q29ubmVjdGlvbiBpcyB0cnVlOyBvdGhlcndpc2VcbiAgLy8gXCJub1wiLlxuICBjb25zdCBuZXdDb25uZWN0aW9uID0gZm9yY2VOZXdDb25uZWN0aW9uID8gJ3llcycgOiAnbm8nIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvLyA4LiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgbW9kZTpcbiAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcpIHtcbiAgICAvLyBMZXQgY29ubmVjdGlvbiBiZSB0aGUgcmVzdWx0IG9mIG9idGFpbmluZyBhIFdlYlNvY2tldCBjb25uZWN0aW9uLFxuICAgIC8vIGdpdmVuIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAgIC8vIFRPRE9cbiAgfSBlbHNlIHtcbiAgICAvLyBMZXQgY29ubmVjdGlvbiBiZSB0aGUgcmVzdWx0IG9mIG9idGFpbmluZyBhIGNvbm5lY3Rpb24sIGdpdmVuXG4gICAgLy8gbmV0d29ya1BhcnRpdGlvbktleSwgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIG9yaWdpbixcbiAgICAvLyBpbmNsdWRlQ3JlZGVudGlhbHMsIGFuZCBmb3JjZU5ld0Nvbm5lY3Rpb24uXG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gOS4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIElmIGNvbm5lY3Rpb24gaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuXG4gIC8vICAgIDIuIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHRvIHRoZSByZXN1bHQgb2ZcbiAgLy8gICAgY2FsbGluZyBjbGFtcCBhbmQgY29hcnNlbiBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHdpdGggY29ubmVjdGlvbuKAmXNcbiAgLy8gICAgdGltaW5nIGluZm8sIHRpbWluZ0luZm/igJlzIHBvc3QtcmVkaXJlY3Qgc3RhcnQgdGltZSwgYW5kIGZldGNoUGFyYW1z4oCZc1xuICAvLyAgICBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eS5cblxuICAvLyAgICAzLiBJZiBjb25uZWN0aW9uIGlzIG5vdCBhbiBIVFRQLzIgY29ubmVjdGlvbiwgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCxcbiAgLy8gICAgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLCB0aGVuIGFwcGVuZCAoYFRyYW5zZmVyLUVuY29kaW5nYCxcbiAgLy8gICAgYGNodW5rZWRgKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cblxuICAvLyAgICA0LiBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXF1ZXN0IHN0YXJ0IHRpbWUgdG8gdGhlIGNvYXJzZW5lZFxuICAvLyAgICBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gICAgY2FwYWJpbGl0eS5cblxuICAvLyAgICA1LiBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBtYWtpbmcgYW4gSFRUUCByZXF1ZXN0IG92ZXIgY29ubmVjdGlvblxuICAvLyAgICB1c2luZyByZXF1ZXN0IHdpdGggdGhlIGZvbGxvd2luZyBjYXZlYXRzOlxuXG4gIC8vICAgICAgICAtIEZvbGxvdyB0aGUgcmVsZXZhbnQgcmVxdWlyZW1lbnRzIGZyb20gSFRUUC4gW0hUVFBdIFtIVFRQLVNFTUFOVElDU11cbiAgLy8gICAgICAgIFtIVFRQLUNPTkRdIFtIVFRQLUNBQ0hJTkddIFtIVFRQLUFVVEhdXG5cbiAgLy8gICAgICAgIC0gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCwgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLFxuICAvLyAgICAgICAgdGhlbiB0aGUgdXNlciBhZ2VudCBtYXkgaGF2ZSBhIGJ1ZmZlciBvZiB1cCB0byA2NCBraWJpYnl0ZXMgYW5kIHN0b3JlXG4gIC8vICAgICAgICBhIHBhcnQgb2YgcmVxdWVzdOKAmXMgYm9keSBpbiB0aGF0IGJ1ZmZlci4gSWYgdGhlIHVzZXIgYWdlbnQgcmVhZHMgZnJvbVxuICAvLyAgICAgICAgcmVxdWVzdOKAmXMgYm9keSBiZXlvbmQgdGhhdCBidWZmZXLigJlzIHNpemUgYW5kIHRoZSB1c2VyIGFnZW50IG5lZWRzIHRvXG4gIC8vICAgICAgICByZXNlbmQgcmVxdWVzdCwgdGhlbiBpbnN0ZWFkIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG5cbiAgLy8gICAgICAgIC0gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVzcG9uc2Ugc3RhcnQgdGltZSB0byB0aGUgY29hcnNlbmVkXG4gIC8vICAgICAgICBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eSxcbiAgLy8gICAgICAgIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSB1c2VyIGFnZW504oCZcyBIVFRQIHBhcnNlciByZWNlaXZlcyB0aGUgZmlyc3QgYnl0ZVxuICAvLyAgICAgICAgb2YgdGhlIHJlc3BvbnNlIChlLmcuLCBmcmFtZSBoZWFkZXIgYnl0ZXMgZm9yIEhUVFAvMiBvciByZXNwb25zZSBzdGF0dXNcbiAgLy8gICAgICAgIGxpbmUgZm9yIEhUVFAvMS54KS5cblxuICAvLyAgICAgICAgLSBXYWl0IHVudGlsIGFsbCB0aGUgaGVhZGVycyBhcmUgdHJhbnNtaXR0ZWQuXG5cbiAgLy8gICAgICAgIC0gQW55IHJlc3BvbnNlcyB3aG9zZSBzdGF0dXMgaXMgaW4gdGhlIHJhbmdlIDEwMCB0byAxOTksIGluY2x1c2l2ZSxcbiAgLy8gICAgICAgIGFuZCBpcyBub3QgMTAxLCBhcmUgdG8gYmUgaWdub3JlZCwgZXhjZXB0IGZvciB0aGUgcHVycG9zZXMgb2Ygc2V0dGluZ1xuICAvLyAgICAgICAgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXNwb25zZSBzdGFydCB0aW1lIGFib3ZlLlxuXG4gIC8vICAgIC0gSWYgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgYFRyYW5zZmVyLUVuY29kaW5nYC9gY2h1bmtlZGAgYW5kXG4gIC8vICAgIHJlc3BvbnNlIGlzIHRyYW5zZmVycmVkIHZpYSBIVFRQLzEuMCBvciBvbGRlciwgdGhlbiByZXR1cm4gYSBuZXR3b3JrXG4gIC8vICAgIGVycm9yLlxuXG4gIC8vICAgIC0gSWYgdGhlIEhUVFAgcmVxdWVzdCByZXN1bHRzIGluIGEgVExTIGNsaWVudCBjZXJ0aWZpY2F0ZSBkaWFsb2csIHRoZW46XG5cbiAgLy8gICAgICAgIDEuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBhbiBlbnZpcm9ubWVudCBzZXR0aW5ncyBvYmplY3QsIG1ha2UgdGhlXG4gIC8vICAgICAgICBkaWFsb2cgYXZhaWxhYmxlIGluIHJlcXVlc3TigJlzIHdpbmRvdy5cblxuICAvLyAgICAgICAgMi4gT3RoZXJ3aXNlLCByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuXG4gIC8vIFRvIHRyYW5zbWl0IHJlcXVlc3TigJlzIGJvZHkgYm9keSwgcnVuIHRoZXNlIHN0ZXBzOlxuICBsZXQgcmVxdWVzdEJvZHkgPSBudWxsXG4gIC8vIDEuIElmIGJvZHkgaXMgbnVsbCBhbmQgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpc1xuICAvLyBub24tbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoIHRhc2sgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdFxuICAvLyBlbmQtb2YtYm9keSBhbmQgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChyZXF1ZXN0LmJvZHkgPT0gbnVsbCAmJiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KCkpXG4gIH0gZWxzZSBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcbiAgICAvLyAyLiBPdGhlcndpc2UsIGlmIGJvZHkgaXMgbm9uLW51bGw6XG5cbiAgICAvLyAgICAxLiBMZXQgcHJvY2Vzc0JvZHlDaHVuayBnaXZlbiBieXRlcyBiZSB0aGVzZSBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzQm9keUNodW5rID0gYXN5bmMgZnVuY3Rpb24gKiAoYnl0ZXMpIHtcbiAgICAgIC8vIDEuIElmIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBSdW4gdGhpcyBzdGVwIGluIHBhcmFsbGVsOiB0cmFuc21pdCBieXRlcy5cbiAgICAgIHlpZWxkIGJ5dGVzXG5cbiAgICAgIC8vIDMuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgYm9keSBpcyBub24tbnVsbCwgdGhlbiBydW5cbiAgICAgIC8vIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgYm9keSBnaXZlbiBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGg/LihieXRlcy5ieXRlTGVuZ3RoKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBwcm9jZXNzRW5kT2ZCb2R5IGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NFbmRPZkJvZHkgPSAoKSA9PiB7XG4gICAgICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgZW5kLW9mLWJvZHkgaXMgbm9uLW51bGwsXG4gICAgICAvLyB0aGVuIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5LlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KSB7XG4gICAgICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgcHJvY2Vzc0JvZHlFcnJvciBnaXZlbiBlIGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5RXJyb3IgPSAoZSkgPT4ge1xuICAgICAgLy8gMS4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBlIGlzIGFuIFwiQWJvcnRFcnJvclwiIERPTUV4Y2VwdGlvbiwgdGhlbiBhYm9ydCBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlci5cbiAgICAgIGlmIChlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmFib3J0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gSW5jcmVtZW50YWxseSByZWFkIHJlcXVlc3TigJlzIGJvZHkgZ2l2ZW4gcHJvY2Vzc0JvZHlDaHVuaywgcHJvY2Vzc0VuZE9mQm9keSxcbiAgICAvLyBwcm9jZXNzQm9keUVycm9yLCBhbmQgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gICAgcmVxdWVzdEJvZHkgPSAoYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJ5dGVzIG9mIHJlcXVlc3QuYm9keS5zdHJlYW0pIHtcbiAgICAgICAgICB5aWVsZCAqIHByb2Nlc3NCb2R5Q2h1bmsoYnl0ZXMpXG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0VuZE9mQm9keSgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcHJvY2Vzc0JvZHlFcnJvcihlcnIpXG4gICAgICB9XG4gICAgfSkoKVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzb2NrZXQgaXMgb25seSBwcm92aWRlZCBmb3Igd2Vic29ja2V0c1xuICAgIGNvbnN0IHsgYm9keSwgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCwgc29ja2V0IH0gPSBhd2FpdCBkaXNwYXRjaCh7IGJvZHk6IHJlcXVlc3RCb2R5IH0pXG5cbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICByZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QsIHNvY2tldCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IGJvZHlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKClcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIubmV4dCA9ICgpID0+IGl0ZXJhdG9yLm5leHQoKVxuXG4gICAgICByZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QgfSlcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIDEwLiBJZiBhYm9ydGVkLCB0aGVuOlxuICAgIGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAvLyAxLiBJZiBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHRyYW5zbWl0IGFuIFJTVF9TVFJFQU0gZnJhbWUuXG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG5cbiAgICAgIC8vIDIuIFJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zLCBlcnIpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoZXJyKVxuICB9XG5cbiAgLy8gMTEuIExldCBwdWxsQWxnb3JpdGhtIGJlIGFuIGFjdGlvbiB0aGF0IHJlc3VtZXMgdGhlIG9uZ29pbmcgZmV0Y2hcbiAgLy8gaWYgaXQgaXMgc3VzcGVuZGVkLlxuICBjb25zdCBwdWxsQWxnb3JpdGhtID0gKCkgPT4ge1xuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIucmVzdW1lKClcbiAgfVxuXG4gIC8vIDEyLiBMZXQgY2FuY2VsQWxnb3JpdGhtIGJlIGFuIGFsZ29yaXRobSB0aGF0IGFib3J0cyBmZXRjaFBhcmFtc+KAmXNcbiAgLy8gY29udHJvbGxlciB3aXRoIHJlYXNvbiwgZ2l2ZW4gcmVhc29uLlxuICBjb25zdCBjYW5jZWxBbGdvcml0aG0gPSAocmVhc29uKSA9PiB7XG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5hYm9ydChyZWFzb24pXG4gIH1cblxuICAvLyAxMy4gTGV0IGhpZ2hXYXRlck1hcmsgYmUgYSBub24tbmVnYXRpdmUsIG5vbi1OYU4gbnVtYmVyLCBjaG9zZW4gYnlcbiAgLy8gdGhlIHVzZXIgYWdlbnQuXG4gIC8vIFRPRE9cblxuICAvLyAxNC4gTGV0IHNpemVBbGdvcml0aG0gYmUgYW4gYWxnb3JpdGhtIHRoYXQgYWNjZXB0cyBhIGNodW5rIG9iamVjdFxuICAvLyBhbmQgcmV0dXJucyBhIG5vbi1uZWdhdGl2ZSwgbm9uLU5hTiwgbm9uLWluZmluaXRlIG51bWJlciwgY2hvc2VuIGJ5IHRoZSB1c2VyIGFnZW50LlxuICAvLyBUT0RPXG5cbiAgLy8gMTUuIExldCBzdHJlYW0gYmUgYSBuZXcgUmVhZGFibGVTdHJlYW0uXG4gIC8vIDE2LiBTZXQgdXAgc3RyZWFtIHdpdGggcHVsbEFsZ29yaXRobSBzZXQgdG8gcHVsbEFsZ29yaXRobSxcbiAgLy8gY2FuY2VsQWxnb3JpdGhtIHNldCB0byBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmsgc2V0IHRvXG4gIC8vIGhpZ2hXYXRlck1hcmssIGFuZCBzaXplQWxnb3JpdGhtIHNldCB0byBzaXplQWxnb3JpdGhtLlxuICBpZiAoIVJlYWRhYmxlU3RyZWFtKSB7XG4gICAgUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0vd2ViJykuUmVhZGFibGVTdHJlYW1cbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbShcbiAgICB7XG4gICAgICBhc3luYyBzdGFydCAoY29udHJvbGxlcikge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyXG4gICAgICB9LFxuICAgICAgYXN5bmMgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICBhd2FpdCBwdWxsQWxnb3JpdGhtKGNvbnRyb2xsZXIpXG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsIChyZWFzb24pIHtcbiAgICAgICAgYXdhaXQgY2FuY2VsQWxnb3JpdGhtKHJlYXNvbilcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGhpZ2hXYXRlck1hcms6IDAsXG4gICAgICBzaXplICgpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9XG4gIClcblxuICAvLyAxNy4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIFNldCByZXNwb25zZeKAmXMgYm9keSB0byBhIG5ldyBib2R5IHdob3NlIHN0cmVhbSBpcyBzdHJlYW0uXG4gIHJlc3BvbnNlLmJvZHkgPSB7IHN0cmVhbSB9XG5cbiAgLy8gICAgMi4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpc1xuICAvLyAgICBub3QgXCJuby1zdG9yZVwiLCB0aGVuIHVwZGF0ZSByZXNwb25zZSBpbiBodHRwQ2FjaGUgZm9yIHJlcXVlc3QuXG4gIC8vICAgIFRPRE9cblxuICAvLyAgICAzLiBJZiBpbmNsdWRlQ3JlZGVudGlhbHMgaXMgdHJ1ZSBhbmQgdGhlIHVzZXIgYWdlbnQgaXMgbm90IGNvbmZpZ3VyZWRcbiAgLy8gICAgdG8gYmxvY2sgY29va2llcyBmb3IgcmVxdWVzdCAoc2VlIHNlY3Rpb24gNyBvZiBbQ09PS0lFU10pLCB0aGVuIHJ1biB0aGVcbiAgLy8gICAgXCJzZXQtY29va2llLXN0cmluZ1wiIHBhcnNpbmcgYWxnb3JpdGhtIChzZWUgc2VjdGlvbiA1LjIgb2YgW0NPT0tJRVNdKSBvblxuICAvLyAgICB0aGUgdmFsdWUgb2YgZWFjaCBoZWFkZXIgd2hvc2UgbmFtZSBpcyBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgLy8gICAgYFNldC1Db29raWVgIGluIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCwgaWYgYW55LCBhbmQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gIC8vICAgIFRPRE9cblxuICAvLyAxOC4gSWYgYWJvcnRlZCwgdGhlbjpcbiAgLy8gVE9ET1xuXG4gIC8vIDE5LiBSdW4gdGhlc2Ugc3RlcHMgaW4gcGFyYWxsZWw6XG5cbiAgLy8gICAgMS4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZDpcbiAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vbigndGVybWluYXRlZCcsIG9uQWJvcnRlZClcbiAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXN1bWUgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gMS4gV2hpbGUgdHJ1ZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyAxLTMuIFNlZSBvbkRhdGEuLi5cblxuICAgICAgLy8gNC4gU2V0IGJ5dGVzIHRvIHRoZSByZXN1bHQgb2YgaGFuZGxpbmcgY29udGVudCBjb2RpbmdzIGdpdmVuXG4gICAgICAvLyBjb2RpbmdzIGFuZCBieXRlcy5cbiAgICAgIGxldCBieXRlc1xuICAgICAgbGV0IGlzRmFpbHVyZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5uZXh0KClcblxuICAgICAgICBpZiAoaXNBYm9ydGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBieXRlcyA9IGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLmVuZGVkICYmICF0aW1pbmdJbmZvLmVuY29kZWRCb2R5U2l6ZSkge1xuICAgICAgICAgIC8vIHpsaWIgZG9lc24ndCBsaWtlIGVtcHR5IHN0cmVhbXMuXG4gICAgICAgICAgYnl0ZXMgPSB1bmRlZmluZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBieXRlcyA9IGVyclxuXG4gICAgICAgICAgLy8gZXJyIG1heSBiZSBwcm9wYWdhdGVkIGZyb20gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHJlYWRhYmxlc3RyZWFtLmNhbmNlbCxcbiAgICAgICAgICAvLyB3aGljaCBtaWdodCBub3QgYmUgYW4gZXJyb3IuIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDA5XG4gICAgICAgICAgaXNGYWlsdXJlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChieXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgdGhlIGJ5dGVzIHRyYW5zbWlzc2lvbiBmb3IgcmVzcG9uc2XigJlzIG1lc3NhZ2VcbiAgICAgICAgLy8gYm9keSBpcyBkb25lIG5vcm1hbGx5IGFuZCBzdHJlYW0gaXMgcmVhZGFibGUsIHRoZW4gY2xvc2VcbiAgICAgICAgLy8gc3RyZWFtLCBmaW5hbGl6ZSByZXNwb25zZSBmb3IgZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLCBhbmRcbiAgICAgICAgLy8gYWJvcnQgdGhlc2UgaW4tcGFyYWxsZWwgc3RlcHMuXG4gICAgICAgIHJlYWRhYmxlU3RyZWFtQ2xvc2UoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyKVxuXG4gICAgICAgIGZpbmFsaXplUmVzcG9uc2UoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKVxuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA1LiBJbmNyZWFzZSB0aW1pbmdJbmZv4oCZcyBkZWNvZGVkIGJvZHkgc2l6ZSBieSBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgdGltaW5nSW5mby5kZWNvZGVkQm9keVNpemUgKz0gYnl0ZXM/LmJ5dGVMZW5ndGggPz8gMFxuXG4gICAgICAvLyA2LiBJZiBieXRlcyBpcyBmYWlsdXJlLCB0aGVuIHRlcm1pbmF0ZSBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlci5cbiAgICAgIGlmIChpc0ZhaWx1cmUpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoYnl0ZXMpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA3LiBFbnF1ZXVlIGEgVWludDhBcnJheSB3cmFwcGluZyBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIGJ5dGVzXG4gICAgICAvLyBpbnRvIHN0cmVhbS5cbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ5dGVzKSlcblxuICAgICAgLy8gOC4gSWYgc3RyZWFtIGlzIGVycm9yZWQsIHRoZW4gdGVybWluYXRlIHRoZSBvbmdvaW5nIGZldGNoLlxuICAgICAgaWYgKGlzRXJyb3JlZChzdHJlYW0pKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDkuIElmIHN0cmVhbSBkb2VzbuKAmXQgbmVlZCBtb3JlIGRhdGEgYXNrIHRoZSB1c2VyIGFnZW50IHRvIHN1c3BlbmRcbiAgICAgIC8vIHRoZSBvbmdvaW5nIGZldGNoLlxuICAgICAgaWYgKCFmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZGVzaXJlZFNpemUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gICAgMi4gSWYgYWJvcnRlZCwgdGhlbjpcbiAgZnVuY3Rpb24gb25BYm9ydGVkIChyZWFzb24pIHtcbiAgICAvLyAyLiBJZiBmZXRjaFBhcmFtcyBpcyBhYm9ydGVkLCB0aGVuOlxuICAgIGlmIChpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAvLyAxLiBTZXQgcmVzcG9uc2XigJlzIGFib3J0ZWQgZmxhZy5cbiAgICAgIHJlc3BvbnNlLmFib3J0ZWQgPSB0cnVlXG5cbiAgICAgIC8vIDIuIElmIHN0cmVhbSBpcyByZWFkYWJsZSwgdGhlbiBlcnJvciBzdHJlYW0gd2l0aCB0aGUgcmVzdWx0IG9mXG4gICAgICAvLyAgICBkZXNlcmlhbGl6ZSBhIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIGdpdmVuIGZldGNoUGFyYW1z4oCZc1xuICAgICAgLy8gICAgY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gYW5kIGFuXG4gICAgICAvLyAgICBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHJlYWxtLlxuICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtKSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3IoXG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zZXJpYWxpemVkQWJvcnRSZWFzb25cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAzLiBPdGhlcndpc2UsIGlmIHN0cmVhbSBpcyByZWFkYWJsZSwgZXJyb3Igc3RyZWFtIHdpdGggYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0pKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcihuZXcgVHlwZUVycm9yKCd0ZXJtaW5hdGVkJywge1xuICAgICAgICAgIGNhdXNlOiBpc0Vycm9yTGlrZShyZWFzb24pID8gcmVhc29uIDogdW5kZWZpbmVkXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuIElmIGNvbm5lY3Rpb24gdXNlcyBIVFRQLzIsIHRoZW4gdHJhbnNtaXQgYW4gUlNUX1NUUkVBTSBmcmFtZS5cbiAgICAvLyA1LiBPdGhlcndpc2UsIHRoZSB1c2VyIGFnZW50IHNob3VsZCBjbG9zZSBjb25uZWN0aW9uIHVubGVzcyBpdCB3b3VsZCBiZSBiYWQgZm9yIHBlcmZvcm1hbmNlIHRvIGRvIHNvLlxuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcbiAgfVxuXG4gIC8vIDIwLiBSZXR1cm4gcmVzcG9uc2UuXG4gIHJldHVybiByZXNwb25zZVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGRpc3BhdGNoICh7IGJvZHkgfSkge1xuICAgIGNvbnN0IHVybCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uLy4uJykuQWdlbnR9ICovXG4gICAgY29uc3QgYWdlbnQgPSBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmRpc3BhdGNoZXJcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBhZ2VudC5kaXNwYXRjaChcbiAgICAgIHtcbiAgICAgICAgcGF0aDogdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCxcbiAgICAgICAgb3JpZ2luOiB1cmwub3JpZ2luLFxuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBib2R5OiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmRpc3BhdGNoZXIuaXNNb2NrQWN0aXZlID8gcmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuYm9keS5zb3VyY2UgOiBib2R5LFxuICAgICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnNMaXN0LmVudHJpZXMsXG4gICAgICAgIG1heFJlZGlyZWN0aW9uczogMCxcbiAgICAgICAgdXBncmFkZTogcmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0JyA/ICd3ZWJzb2NrZXQnIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBib2R5OiBudWxsLFxuICAgICAgICBhYm9ydDogbnVsbCxcblxuICAgICAgICBvbkNvbm5lY3QgKGFib3J0KSB7XG4gICAgICAgICAgLy8gVE9ETyAoZml4KTogRG8gd2UgbmVlZCBjb25uZWN0aW9uIGhlcmU/XG4gICAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSBmZXRjaFBhcmFtcy5jb250cm9sbGVyXG5cbiAgICAgICAgICBpZiAoY29ubmVjdGlvbi5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIGFib3J0KG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vbigndGVybWluYXRlZCcsIGFib3J0KVxuICAgICAgICAgICAgdGhpcy5hYm9ydCA9IGNvbm5lY3Rpb24uYWJvcnQgPSBhYm9ydFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkhlYWRlcnMgKHN0YXR1cywgaGVhZGVyc0xpc3QsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgICAgICAgIGlmIChzdGF0dXMgPCAyMDApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBjb2RpbmdzID0gW11cbiAgICAgICAgICBsZXQgbG9jYXRpb24gPSAnJ1xuXG4gICAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcblxuICAgICAgICAgIC8vIEZvciBIMiwgdGhlIGhlYWRlcnMgYXJlIGEgcGxhaW4gSlMgb2JqZWN0XG4gICAgICAgICAgLy8gV2UgZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGVtIGFuZCBpdGVyYXRlIGFjY29yZGluZ2x5XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyc0xpc3QpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGhlYWRlcnNMaXN0Lmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtleSA9IGhlYWRlcnNMaXN0W24gKyAwXS50b1N0cmluZygnbGF0aW4xJylcbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gaGVhZGVyc0xpc3RbbiArIDFdLnRvU3RyaW5nKCdsYXRpbjEnKVxuICAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LWVuY29kaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMxI3NlY3Rpb24tMy4xLjIuMVxuICAgICAgICAgICAgICAgIC8vIFwiQWxsIGNvbnRlbnQtY29kaW5nIHZhbHVlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZS4uLlwiXG4gICAgICAgICAgICAgICAgY29kaW5ncyA9IHZhbC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcsJykubWFwKCh4KSA9PiB4LnRyaW0oKSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2xvY2F0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gdmFsXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnNMaXN0KVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBoZWFkZXJzTGlzdFtrZXldXG4gICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtZW5jb2RpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzEjc2VjdGlvbi0zLjEuMi4xXG4gICAgICAgICAgICAgICAgLy8gXCJBbGwgY29udGVudC1jb2RpbmcgdmFsdWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlLi4uXCJcbiAgICAgICAgICAgICAgICBjb2RpbmdzID0gdmFsLnRvTG93ZXJDYXNlKCkuc3BsaXQoJywnKS5tYXAoKHgpID0+IHgudHJpbSgpKS5yZXZlcnNlKClcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2xvY2F0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gdmFsXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJvZHkgPSBuZXcgUmVhZGFibGUoeyByZWFkOiByZXN1bWUgfSlcblxuICAgICAgICAgIGNvbnN0IGRlY29kZXJzID0gW11cblxuICAgICAgICAgIGNvbnN0IHdpbGxGb2xsb3cgPSByZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93JyAmJlxuICAgICAgICAgICAgbG9jYXRpb24gJiZcbiAgICAgICAgICAgIHJlZGlyZWN0U3RhdHVzU2V0LmhhcyhzdGF0dXMpXG5cbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQ29udGVudC1FbmNvZGluZ1xuICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnICYmIHJlcXVlc3QubWV0aG9kICE9PSAnQ09OTkVDVCcgJiYgIW51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKHN0YXR1cykgJiYgIXdpbGxGb2xsb3cpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29kaW5nIG9mIGNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTIuaHRtbCNzZWN0aW9uLTcuMlxuICAgICAgICAgICAgICBpZiAoY29kaW5nID09PSAneC1nemlwJyB8fCBjb2RpbmcgPT09ICdnemlwJykge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLnB1c2goemxpYi5jcmVhdGVHdW56aXAoe1xuICAgICAgICAgICAgICAgICAgLy8gQmUgbGVzcyBzdHJpY3Qgd2hlbiBkZWNvZGluZyBjb21wcmVzc2VkIHJlc3BvbnNlcywgc2luY2Ugc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgICAvLyBzZXJ2ZXJzIHNlbmQgc2xpZ2h0bHkgaW52YWxpZCByZXNwb25zZXMgdGhhdCBhcmUgc3RpbGwgYWNjZXB0ZWRcbiAgICAgICAgICAgICAgICAgIC8vIGJ5IGNvbW1vbiBicm93c2Vycy5cbiAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1c2luZyBaX1NZTkNfRkxVU0ggaXMgd2hhdCBjVVJMIGRvZXMuXG4gICAgICAgICAgICAgICAgICBmbHVzaDogemxpYi5jb25zdGFudHMuWl9TWU5DX0ZMVVNILFxuICAgICAgICAgICAgICAgICAgZmluaXNoRmx1c2g6IHpsaWIuY29uc3RhbnRzLlpfU1lOQ19GTFVTSFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGluZyA9PT0gJ2RlZmxhdGUnKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcnMucHVzaCh6bGliLmNyZWF0ZUluZmxhdGUoKSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RpbmcgPT09ICdicicpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcygpKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLmxlbmd0aCA9IDBcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVyc0xpc3Q6IGhlYWRlcnNba0hlYWRlcnNMaXN0XSxcbiAgICAgICAgICAgIGJvZHk6IGRlY29kZXJzLmxlbmd0aFxuICAgICAgICAgICAgICA/IHBpcGVsaW5lKHRoaXMuYm9keSwgLi4uZGVjb2RlcnMsICgpID0+IHsgfSlcbiAgICAgICAgICAgICAgOiB0aGlzLmJvZHkub24oJ2Vycm9yJywgKCkgPT4ge30pXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EYXRhIChjaHVuaykge1xuICAgICAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLmR1bXApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDEuIElmIG9uZSBvciBtb3JlIGJ5dGVzIGhhdmUgYmVlbiB0cmFuc21pdHRlZCBmcm9tIHJlc3BvbnNl4oCZc1xuICAgICAgICAgIC8vIG1lc3NhZ2UgYm9keSwgdGhlbjpcblxuICAgICAgICAgIC8vICAxLiBMZXQgYnl0ZXMgYmUgdGhlIHRyYW5zbWl0dGVkIGJ5dGVzLlxuICAgICAgICAgIGNvbnN0IGJ5dGVzID0gY2h1bmtcblxuICAgICAgICAgIC8vICAyLiBMZXQgY29kaW5ncyBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzXG4gICAgICAgICAgLy8gIGdpdmVuIGBDb250ZW50LUVuY29kaW5nYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgICAgIC8vICBTZWUgcHVsbEFsZ29yaXRobS5cblxuICAgICAgICAgIC8vICAzLiBJbmNyZWFzZSB0aW1pbmdJbmZv4oCZcyBlbmNvZGVkIGJvZHkgc2l6ZSBieSBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgICAgIHRpbWluZ0luZm8uZW5jb2RlZEJvZHlTaXplICs9IGJ5dGVzLmJ5dGVMZW5ndGhcblxuICAgICAgICAgIC8vICA0LiBTZWUgcHVsbEFsZ29yaXRobS4uLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5wdXNoKGJ5dGVzKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ29tcGxldGUgKCkge1xuICAgICAgICAgIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9mZigndGVybWluYXRlZCcsIHRoaXMuYWJvcnQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5lbmRlZCA9IHRydWVcblxuICAgICAgICAgIHRoaXMuYm9keS5wdXNoKG51bGwpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FcnJvciAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vZmYoJ3Rlcm1pbmF0ZWQnLCB0aGlzLmFib3J0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYm9keT8uZGVzdHJveShlcnJvcilcblxuICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGVycm9yKVxuXG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uVXBncmFkZSAoc3RhdHVzLCBoZWFkZXJzTGlzdCwgc29ja2V0KSB7XG4gICAgICAgICAgaWYgKHN0YXR1cyAhPT0gMTAxKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuXG4gICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBoZWFkZXJzTGlzdC5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaGVhZGVyc0xpc3RbbiArIDBdLnRvU3RyaW5nKCdsYXRpbjEnKVxuICAgICAgICAgICAgY29uc3QgdmFsID0gaGVhZGVyc0xpc3RbbiArIDFdLnRvU3RyaW5nKCdsYXRpbjEnKVxuXG4gICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IFNUQVRVU19DT0RFU1tzdGF0dXNdLFxuICAgICAgICAgICAgaGVhZGVyc0xpc3Q6IGhlYWRlcnNba0hlYWRlcnNMaXN0XSxcbiAgICAgICAgICAgIHNvY2tldFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmV0Y2gsXG4gIEZldGNoLFxuICBmZXRjaGluZyxcbiAgZmluYWxpemVBbmRSZXBvcnRUaW1pbmdcbn1cbiJdLCJuYW1lcyI6WyJSZXNwb25zZSIsIm1ha2VOZXR3b3JrRXJyb3IiLCJtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IiLCJmaWx0ZXJSZXNwb25zZSIsIm1ha2VSZXNwb25zZSIsInJlcXVpcmUiLCJIZWFkZXJzIiwiUmVxdWVzdCIsIm1ha2VSZXF1ZXN0IiwiemxpYiIsImJ5dGVzTWF0Y2giLCJtYWtlUG9saWN5Q29udGFpbmVyIiwiY2xvbmVQb2xpY3lDb250YWluZXIiLCJyZXF1ZXN0QmFkUG9ydCIsIlRBT0NoZWNrIiwiYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlciIsInJlc3BvbnNlTG9jYXRpb25VUkwiLCJyZXF1ZXN0Q3VycmVudFVSTCIsInNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QiLCJ0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwiLCJjcmVhdGVPcGFxdWVUaW1pbmdJbmZvIiwiYXBwZW5kRmV0Y2hNZXRhZGF0YSIsImNvcnNDaGVjayIsImNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayIsImRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIiLCJjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSIsImNyZWF0ZURlZmVycmVkUHJvbWlzZSIsImlzQmxvYkxpa2UiLCJzYW1lT3JpZ2luIiwiaXNDYW5jZWxsZWQiLCJpc0Fib3J0ZWQiLCJpc0Vycm9yTGlrZSIsImZ1bGx5UmVhZEJvZHkiLCJyZWFkYWJsZVN0cmVhbUNsb3NlIiwiaXNvbW9ycGhpY0VuY29kZSIsInVybElzTG9jYWwiLCJ1cmxJc0h0dHBIdHRwc1NjaGVtZSIsInVybEhhc0h0dHBzU2NoZW1lIiwia1N0YXRlIiwia0hlYWRlcnMiLCJrR3VhcmQiLCJrUmVhbG0iLCJhc3NlcnQiLCJzYWZlbHlFeHRyYWN0Qm9keSIsInJlZGlyZWN0U3RhdHVzU2V0IiwibnVsbEJvZHlTdGF0dXMiLCJzYWZlTWV0aG9kc1NldCIsInJlcXVlc3RCb2R5SGVhZGVyIiwic3VicmVzb3VyY2VTZXQiLCJET01FeGNlcHRpb24iLCJrSGVhZGVyc0xpc3QiLCJFRSIsIlJlYWRhYmxlIiwicGlwZWxpbmUiLCJhZGRBYm9ydExpc3RlbmVyIiwiaXNFcnJvcmVkIiwiaXNSZWFkYWJsZSIsIm5vZGVNYWpvciIsIm5vZGVNaW5vciIsImRhdGFVUkxQcm9jZXNzb3IiLCJzZXJpYWxpemVBTWltZVR5cGUiLCJUcmFuc2Zvcm1TdHJlYW0iLCJnZXRHbG9iYWxEaXNwYXRjaGVyIiwid2ViaWRsIiwiU1RBVFVTX0NPREVTIiwiR0VUX09SX0hFQUQiLCJyZXNvbHZlT2JqZWN0VVJMIiwiUmVhZGFibGVTdHJlYW0iLCJnbG9iYWxUaGlzIiwiRmV0Y2giLCJjb25zdHJ1Y3RvciIsImRpc3BhdGNoZXIiLCJjb25uZWN0aW9uIiwiZHVtcCIsInN0YXRlIiwic2V0TWF4TGlzdGVuZXJzIiwidGVybWluYXRlIiwicmVhc29uIiwiZGVzdHJveSIsImVtaXQiLCJhYm9ydCIsImVycm9yIiwic2VyaWFsaXplZEFib3J0UmVhc29uIiwiZmV0Y2giLCJpbnB1dCIsImluaXQiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiaGVhZGVyIiwicCIsInJlcXVlc3RPYmplY3QiLCJlIiwicmVqZWN0IiwicHJvbWlzZSIsInJlcXVlc3QiLCJzaWduYWwiLCJhYm9ydGVkIiwiYWJvcnRGZXRjaCIsImdsb2JhbE9iamVjdCIsImNsaWVudCIsIm5hbWUiLCJzZXJ2aWNlV29ya2VycyIsInJlc3BvbnNlT2JqZWN0IiwicmVsZXZhbnRSZWFsbSIsImxvY2FsbHlBYm9ydGVkIiwiY29udHJvbGxlciIsImhhbmRsZUZldGNoRG9uZSIsInJlc3BvbnNlIiwiZmluYWxpemVBbmRSZXBvcnRUaW1pbmciLCJwcm9jZXNzUmVzcG9uc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInR5cGUiLCJPYmplY3QiLCJhc3NpZ24iLCJUeXBlRXJyb3IiLCJjYXVzZSIsImhlYWRlcnNMaXN0IiwiZmV0Y2hpbmciLCJwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkiLCJpbml0aWF0b3JUeXBlIiwidXJsTGlzdCIsImxlbmd0aCIsIm9yaWdpbmFsVVJMIiwidGltaW5nSW5mbyIsImNhY2hlU3RhdGUiLCJ0aW1pbmdBbGxvd1Bhc3NlZCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJtYXJrUmVzb3VyY2VUaW1pbmciLCJwZXJmb3JtYW5jZSIsImhyZWYiLCJib2R5Iiwic3RyZWFtIiwiY2FuY2VsIiwiY2F0Y2giLCJlcnIiLCJjb2RlIiwicHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgiLCJwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSIsInByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5IiwidXNlUGFyYWxsZWxRdWV1ZSIsInRhc2tEZXN0aW5hdGlvbiIsImNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5IiwiY3VycmVuVGltZSIsImZldGNoUGFyYW1zIiwid2luZG93Iiwib3JpZ2luIiwicG9saWN5Q29udGFpbmVyIiwiY29udGFpbnMiLCJ2YWx1ZSIsImFwcGVuZCIsInByaW9yaXR5IiwiaGFzIiwiZGVzdGluYXRpb24iLCJtYWluRmV0Y2giLCJyZWN1cnNpdmUiLCJsb2NhbFVSTHNPbmx5IiwicmVmZXJyZXJQb2xpY3kiLCJyZWZlcnJlciIsImN1cnJlbnRVUkwiLCJ1cmwiLCJyZXNwb25zZVRhaW50aW5nIiwicHJvdG9jb2wiLCJtb2RlIiwic2NoZW1lRmV0Y2giLCJyZWRpcmVjdCIsImh0dHBGZXRjaCIsInN0YXR1cyIsImludGVybmFsUmVzcG9uc2UiLCJwdXNoIiwidGltaW5nQWxsb3dGYWlsZWQiLCJyYW5nZVJlcXVlc3RlZCIsImhlYWRlcnMiLCJtZXRob2QiLCJpbmNsdWRlcyIsImludGVncml0eSIsInByb2Nlc3NCb2R5RXJyb3IiLCJmZXRjaEZpbmFsZSIsInByb2Nlc3NCb2R5IiwiYnl0ZXMiLCJyZWRpcmVjdENvdW50Iiwic2NoZW1lIiwiYmxvYlVSTEVudHJ5Iiwic2VhcmNoIiwiYmxvYlVSTEVudHJ5T2JqZWN0IiwidG9TdHJpbmciLCJib2R5V2l0aFR5cGUiLCJzdGF0dXNUZXh0IiwiZGF0YVVSTFN0cnVjdCIsIm1pbWVUeXBlIiwiZmluYWxpemVSZXNwb25zZSIsImRvbmUiLCJwcm9jZXNzUmVzcG9uc2VEb25lIiwicXVldWVNaWNyb3Rhc2siLCJpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobSIsImNodW5rIiwiZW5xdWV1ZSIsInRyYW5zZm9ybVN0cmVhbSIsInN0YXJ0IiwidHJhbnNmb3JtIiwiZmx1c2giLCJzaXplIiwicGlwZVRocm91Z2giLCJudWxsT3JCeXRlcyIsImZhaWx1cmUiLCJhY3R1YWxSZXNwb25zZSIsImh0dHBOZXR3b3JrT3JDYWNoZUZldGNoIiwiaHR0cFJlZGlyZWN0RmV0Y2giLCJsb2NhdGlvblVSTCIsImhhc2giLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwic291cmNlIiwiaGVhZGVyTmFtZSIsImRlbGV0ZSIsInJlZGlyZWN0RW5kVGltZSIsInBvc3RSZWRpcmVjdFN0YXJ0VGltZSIsInJlZGlyZWN0U3RhcnRUaW1lIiwiaXNBdXRoZW50aWNhdGlvbkZldGNoIiwiaXNOZXdDb25uZWN0aW9uRmV0Y2giLCJodHRwRmV0Y2hQYXJhbXMiLCJodHRwUmVxdWVzdCIsImh0dHBDYWNoZSIsInJldmFsaWRhdGluZ0ZsYWciLCJpbmNsdWRlQ3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsImNvbnRlbnRMZW5ndGgiLCJjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUiLCJrZWVwYWxpdmUiLCJVUkwiLCJlc2J1aWxkRGV0ZWN0aW9uIiwiY2FjaGUiLCJwcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbiIsImZvcndhcmRSZXNwb25zZSIsImh0dHBOZXR3b3JrRmV0Y2giLCJyZXF1ZXN0SW5jbHVkZXNDcmVkZW50aWFscyIsImZvcmNlTmV3Q29ubmVjdGlvbiIsImRlc3Ryb3llZCIsIm5ld0Nvbm5lY3Rpb24iLCJyZXF1ZXN0Qm9keSIsInByb2Nlc3NCb2R5Q2h1bmsiLCJieXRlTGVuZ3RoIiwicHJvY2Vzc0VuZE9mQm9keSIsInNvY2tldCIsImRpc3BhdGNoIiwiaXRlcmF0b3IiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwibmV4dCIsInB1bGxBbGdvcml0aG0iLCJyZXN1bWUiLCJjYW5jZWxBbGdvcml0aG0iLCJwdWxsIiwiaGlnaFdhdGVyTWFyayIsIm9uIiwib25BYm9ydGVkIiwiaXNGYWlsdXJlIiwidW5kZWZpbmVkIiwiZW5kZWQiLCJlbmNvZGVkQm9keVNpemUiLCJkZWNvZGVkQm9keVNpemUiLCJVaW50OEFycmF5IiwiZGVzaXJlZFNpemUiLCJhZ2VudCIsInBhdGgiLCJwYXRobmFtZSIsImlzTW9ja0FjdGl2ZSIsImVudHJpZXMiLCJtYXhSZWRpcmVjdGlvbnMiLCJ1cGdyYWRlIiwib25Db25uZWN0Iiwib25IZWFkZXJzIiwiY29kaW5ncyIsImxvY2F0aW9uIiwiQXJyYXkiLCJpc0FycmF5IiwibiIsImtleSIsInZhbCIsInRvTG93ZXJDYXNlIiwic3BsaXQiLCJtYXAiLCJ4IiwidHJpbSIsImtleXMiLCJyZXZlcnNlIiwicmVhZCIsImRlY29kZXJzIiwid2lsbEZvbGxvdyIsImNvZGluZyIsImNyZWF0ZUd1bnppcCIsImNvbnN0YW50cyIsIlpfU1lOQ19GTFVTSCIsImZpbmlzaEZsdXNoIiwiY3JlYXRlSW5mbGF0ZSIsImNyZWF0ZUJyb3RsaURlY29tcHJlc3MiLCJvbkRhdGEiLCJvbkNvbXBsZXRlIiwib2ZmIiwib25FcnJvciIsIm9uVXBncmFkZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/request.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/request.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* globals AbortController */ \nconst { extractBody, mixinBody, cloneBody } = __webpack_require__(/*! ./body */ \"(rsc)/../../node_modules/undici/lib/fetch/body.js\");\nconst { Headers, fill: fillHeaders, HeadersList } = __webpack_require__(/*! ./headers */ \"(rsc)/../../node_modules/undici/lib/fetch/headers.js\");\nconst { FinalizationRegistry } = __webpack_require__(/*! ../compat/dispatcher-weakref */ \"(rsc)/../../node_modules/undici/lib/compat/dispatcher-weakref.js\")();\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { isValidHTTPToken, sameOrigin, normalizeMethod, makePolicyContainer } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/fetch/util.js\");\nconst { forbiddenMethodsSet, corsSafeListedMethodsSet, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/undici/lib/fetch/constants.js\");\nconst { kEnumerableProperty } = util;\nconst { kHeaders, kSignal, kState, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(rsc)/../../node_modules/undici/lib/fetch/global.js\");\nconst { URLSerializer } = __webpack_require__(/*! ./dataURL */ \"(rsc)/../../node_modules/undici/lib/fetch/dataURL.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __webpack_require__(/*! events */ \"events\");\nlet TransformStream = globalThis.TransformStream;\nconst kInit = Symbol(\"init\");\nconst kAbortController = Symbol(\"abortController\");\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort })=>{\n    signal.removeEventListener(\"abort\", abort);\n});\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n    // https://fetch.spec.whatwg.org/#dom-request\n    constructor(input, init = {}){\n        if (input === kInit) {\n            return;\n        }\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Request constructor\"\n        });\n        input = webidl.converters.RequestInfo(input);\n        init = webidl.converters.RequestInit(init);\n        // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\n        this[kRealm] = {\n            settingsObject: {\n                baseUrl: getGlobalOrigin(),\n                get origin () {\n                    return this.baseUrl?.origin;\n                },\n                policyContainer: makePolicyContainer()\n            }\n        };\n        // 1. Let request be null.\n        let request = null;\n        // 2. Let fallbackMode be null.\n        let fallbackMode = null;\n        // 3. Let baseURL be thiss relevant settings objects API base URL.\n        const baseUrl = this[kRealm].settingsObject.baseUrl;\n        // 4. Let signal be null.\n        let signal = null;\n        // 5. If input is a string, then:\n        if (typeof input === \"string\") {\n            // 1. Let parsedURL be the result of parsing input with baseURL.\n            // 2. If parsedURL is failure, then throw a TypeError.\n            let parsedURL;\n            try {\n                parsedURL = new URL(input, baseUrl);\n            } catch (err) {\n                throw new TypeError(\"Failed to parse URL from \" + input, {\n                    cause: err\n                });\n            }\n            // 3. If parsedURL includes credentials, then throw a TypeError.\n            if (parsedURL.username || parsedURL.password) {\n                throw new TypeError(\"Request cannot be constructed from a URL that includes credentials: \" + input);\n            }\n            // 4. Set request to a new request whose URL is parsedURL.\n            request = makeRequest({\n                urlList: [\n                    parsedURL\n                ]\n            });\n            // 5. Set fallbackMode to \"cors\".\n            fallbackMode = \"cors\";\n        } else {\n            // 6. Otherwise:\n            // 7. Assert: input is a Request object.\n            assert(input instanceof Request);\n            // 8. Set request to inputs request.\n            request = input[kState];\n            // 9. Set signal to inputs signal.\n            signal = input[kSignal];\n        }\n        // 7. Let origin be thiss relevant settings objects origin.\n        const origin = this[kRealm].settingsObject.origin;\n        // 8. Let window be \"client\".\n        let window = \"client\";\n        // 9. If requests window is an environment settings object and its origin\n        // is same origin with origin, then set window to requests window.\n        if (request.window?.constructor?.name === \"EnvironmentSettingsObject\" && sameOrigin(request.window, origin)) {\n            window = request.window;\n        }\n        // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n        if (init.window != null) {\n            throw new TypeError(`'window' option '${window}' must be null`);\n        }\n        // 11. If init[\"window\"] exists, then set window to \"no-window\".\n        if (\"window\" in init) {\n            window = \"no-window\";\n        }\n        // 12. Set request to a new request with the following properties:\n        request = makeRequest({\n            // URL requests URL.\n            // undici implementation note: this is set as the first item in request's urlList in makeRequest\n            // method requests method.\n            method: request.method,\n            // header list A copy of requests header list.\n            // undici implementation note: headersList is cloned in makeRequest\n            headersList: request.headersList,\n            // unsafe-request flag Set.\n            unsafeRequest: request.unsafeRequest,\n            // client Thiss relevant settings object.\n            client: this[kRealm].settingsObject,\n            // window window.\n            window,\n            // priority requests priority.\n            priority: request.priority,\n            // origin requests origin. The propagation of the origin is only significant for navigation requests\n            // being handled by a service worker. In this scenario a request can have an origin that is different\n            // from the current client.\n            origin: request.origin,\n            // referrer requests referrer.\n            referrer: request.referrer,\n            // referrer policy requests referrer policy.\n            referrerPolicy: request.referrerPolicy,\n            // mode requests mode.\n            mode: request.mode,\n            // credentials mode requests credentials mode.\n            credentials: request.credentials,\n            // cache mode requests cache mode.\n            cache: request.cache,\n            // redirect mode requests redirect mode.\n            redirect: request.redirect,\n            // integrity metadata requests integrity metadata.\n            integrity: request.integrity,\n            // keepalive requests keepalive.\n            keepalive: request.keepalive,\n            // reload-navigation flag requests reload-navigation flag.\n            reloadNavigation: request.reloadNavigation,\n            // history-navigation flag requests history-navigation flag.\n            historyNavigation: request.historyNavigation,\n            // URL list A clone of requests URL list.\n            urlList: [\n                ...request.urlList\n            ]\n        });\n        // 13. If init is not empty, then:\n        if (Object.keys(init).length > 0) {\n            // 1. If requests mode is \"navigate\", then set it to \"same-origin\".\n            if (request.mode === \"navigate\") {\n                request.mode = \"same-origin\";\n            }\n            // 2. Unset requests reload-navigation flag.\n            request.reloadNavigation = false;\n            // 3. Unset requests history-navigation flag.\n            request.historyNavigation = false;\n            // 4. Set requests origin to \"client\".\n            request.origin = \"client\";\n            // 5. Set requests referrer to \"client\"\n            request.referrer = \"client\";\n            // 6. Set requests referrer policy to the empty string.\n            request.referrerPolicy = \"\";\n            // 7. Set requests URL to requests current URL.\n            request.url = request.urlList[request.urlList.length - 1];\n            // 8. Set requests URL list to  requests URL .\n            request.urlList = [\n                request.url\n            ];\n        }\n        // 14. If init[\"referrer\"] exists, then:\n        if (init.referrer !== undefined) {\n            // 1. Let referrer be init[\"referrer\"].\n            const referrer = init.referrer;\n            // 2. If referrer is the empty string, then set requests referrer to \"no-referrer\".\n            if (referrer === \"\") {\n                request.referrer = \"no-referrer\";\n            } else {\n                // 1. Let parsedReferrer be the result of parsing referrer with\n                // baseURL.\n                // 2. If parsedReferrer is failure, then throw a TypeError.\n                let parsedReferrer;\n                try {\n                    parsedReferrer = new URL(referrer, baseUrl);\n                } catch (err) {\n                    throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, {\n                        cause: err\n                    });\n                }\n                // 3. If one of the following is true\n                // - parsedReferrers scheme is \"about\" and path is the string \"client\"\n                // - parsedReferrers origin is not same origin with origin\n                // then set requests referrer to \"client\".\n                if (parsedReferrer.protocol === \"about:\" && parsedReferrer.hostname === \"client\" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {\n                    request.referrer = \"client\";\n                } else {\n                    // 4. Otherwise, set requests referrer to parsedReferrer.\n                    request.referrer = parsedReferrer;\n                }\n            }\n        }\n        // 15. If init[\"referrerPolicy\"] exists, then set requests referrer policy\n        // to it.\n        if (init.referrerPolicy !== undefined) {\n            request.referrerPolicy = init.referrerPolicy;\n        }\n        // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n        let mode;\n        if (init.mode !== undefined) {\n            mode = init.mode;\n        } else {\n            mode = fallbackMode;\n        }\n        // 17. If mode is \"navigate\", then throw a TypeError.\n        if (mode === \"navigate\") {\n            throw webidl.errors.exception({\n                header: \"Request constructor\",\n                message: \"invalid request mode navigate.\"\n            });\n        }\n        // 18. If mode is non-null, set requests mode to mode.\n        if (mode != null) {\n            request.mode = mode;\n        }\n        // 19. If init[\"credentials\"] exists, then set requests credentials mode\n        // to it.\n        if (init.credentials !== undefined) {\n            request.credentials = init.credentials;\n        }\n        // 18. If init[\"cache\"] exists, then set requests cache mode to it.\n        if (init.cache !== undefined) {\n            request.cache = init.cache;\n        }\n        // 21. If requests cache mode is \"only-if-cached\" and requests mode is\n        // not \"same-origin\", then throw a TypeError.\n        if (request.cache === \"only-if-cached\" && request.mode !== \"same-origin\") {\n            throw new TypeError(\"'only-if-cached' can be set only with 'same-origin' mode\");\n        }\n        // 22. If init[\"redirect\"] exists, then set requests redirect mode to it.\n        if (init.redirect !== undefined) {\n            request.redirect = init.redirect;\n        }\n        // 23. If init[\"integrity\"] exists, then set requests integrity metadata to it.\n        if (init.integrity !== undefined && init.integrity != null) {\n            request.integrity = String(init.integrity);\n        }\n        // 24. If init[\"keepalive\"] exists, then set requests keepalive to it.\n        if (init.keepalive !== undefined) {\n            request.keepalive = Boolean(init.keepalive);\n        }\n        // 25. If init[\"method\"] exists, then:\n        if (init.method !== undefined) {\n            // 1. Let method be init[\"method\"].\n            let method = init.method;\n            // 2. If method is not a method or method is a forbidden method, then\n            // throw a TypeError.\n            if (!isValidHTTPToken(init.method)) {\n                throw TypeError(`'${init.method}' is not a valid HTTP method.`);\n            }\n            if (forbiddenMethodsSet.has(method.toUpperCase())) {\n                throw TypeError(`'${init.method}' HTTP method is unsupported.`);\n            }\n            // 3. Normalize method.\n            method = normalizeMethod(init.method);\n            // 4. Set requests method to method.\n            request.method = method;\n        }\n        // 26. If init[\"signal\"] exists, then set signal to it.\n        if (init.signal !== undefined) {\n            signal = init.signal;\n        }\n        // 27. Set thiss request to request.\n        this[kState] = request;\n        // 28. Set thiss signal to a new AbortSignal object with thiss relevant\n        // Realm.\n        // TODO: could this be simplified with AbortSignal.any\n        // (https://dom.spec.whatwg.org/#dom-abortsignal-any)\n        const ac = new AbortController();\n        this[kSignal] = ac.signal;\n        this[kSignal][kRealm] = this[kRealm];\n        // 29. If signal is not null, then make thiss signal follow signal.\n        if (signal != null) {\n            if (!signal || typeof signal.aborted !== \"boolean\" || typeof signal.addEventListener !== \"function\") {\n                throw new TypeError(\"Failed to construct 'Request': member signal is not of type AbortSignal.\");\n            }\n            if (signal.aborted) {\n                ac.abort(signal.reason);\n            } else {\n                // Keep a strong ref to ac while request object\n                // is alive. This is needed to prevent AbortController\n                // from being prematurely garbage collected.\n                // See, https://github.com/nodejs/undici/issues/1926.\n                this[kAbortController] = ac;\n                const acRef = new WeakRef(ac);\n                const abort = function() {\n                    const ac = acRef.deref();\n                    if (ac !== undefined) {\n                        ac.abort(this.reason);\n                    }\n                };\n                // Third-party AbortControllers may not work with these.\n                // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.\n                try {\n                    // If the max amount of listeners is equal to the default, increase it\n                    // This is only available in node >= v19.9.0\n                    if (typeof getMaxListeners === \"function\" && getMaxListeners(signal) === defaultMaxListeners) {\n                        setMaxListeners(100, signal);\n                    } else if (getEventListeners(signal, \"abort\").length >= defaultMaxListeners) {\n                        setMaxListeners(100, signal);\n                    }\n                } catch  {}\n                util.addAbortListener(signal, abort);\n                requestFinalizer.register(ac, {\n                    signal,\n                    abort\n                });\n            }\n        }\n        // 30. Set thiss headers to a new Headers object with thiss relevant\n        // Realm, whose header list is requests header list and guard is\n        // \"request\".\n        this[kHeaders] = new Headers();\n        this[kHeaders][kHeadersList] = request.headersList;\n        this[kHeaders][kGuard] = \"request\";\n        this[kHeaders][kRealm] = this[kRealm];\n        // 31. If thiss requests mode is \"no-cors\", then:\n        if (mode === \"no-cors\") {\n            // 1. If thiss requests method is not a CORS-safelisted method,\n            // then throw a TypeError.\n            if (!corsSafeListedMethodsSet.has(request.method)) {\n                throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);\n            }\n            // 2. Set thiss headerss guard to \"request-no-cors\".\n            this[kHeaders][kGuard] = \"request-no-cors\";\n        }\n        // 32. If init is not empty, then:\n        if (Object.keys(init).length !== 0) {\n            // 1. Let headers be a copy of thiss headers and its associated header\n            // list.\n            let headers = new Headers(this[kHeaders]);\n            // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n            if (init.headers !== undefined) {\n                headers = init.headers;\n            }\n            // 3. Empty thiss headerss header list.\n            this[kHeaders][kHeadersList].clear();\n            // 4. If headers is a Headers object, then for each header in its header\n            // list, append headers name/headers value to thiss headers.\n            if (headers.constructor.name === \"Headers\") {\n                for (const [key, val] of headers){\n                    this[kHeaders].append(key, val);\n                }\n            } else {\n                // 5. Otherwise, fill thiss headers with headers.\n                fillHeaders(this[kHeaders], headers);\n            }\n        }\n        // 33. Let inputBody be inputs requests body if input is a Request\n        // object; otherwise null.\n        const inputBody = input instanceof Request ? input[kState].body : null;\n        // 34. If either init[\"body\"] exists and is non-null or inputBody is\n        // non-null, and requests method is `GET` or `HEAD`, then throw a\n        // TypeError.\n        if ((init.body != null || inputBody != null) && (request.method === \"GET\" || request.method === \"HEAD\")) {\n            throw new TypeError(\"Request with GET/HEAD method cannot have body.\");\n        }\n        // 35. Let initBody be null.\n        let initBody = null;\n        // 36. If init[\"body\"] exists and is non-null, then:\n        if (init.body != null) {\n            // 1. Let Content-Type be null.\n            // 2. Set initBody and Content-Type to the result of extracting\n            // init[\"body\"], with keepalive set to requests keepalive.\n            const [extractedBody, contentType] = extractBody(init.body, request.keepalive);\n            initBody = extractedBody;\n            // 3, If Content-Type is non-null and thiss headerss header list does\n            // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n            // thiss headers.\n            if (contentType && !this[kHeaders][kHeadersList].contains(\"content-type\")) {\n                this[kHeaders].append(\"content-type\", contentType);\n            }\n        }\n        // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n        // inputBody.\n        const inputOrInitBody = initBody ?? inputBody;\n        // 38. If inputOrInitBody is non-null and inputOrInitBodys source is\n        // null, then:\n        if (inputOrInitBody != null && inputOrInitBody.source == null) {\n            // 1. If initBody is non-null and init[\"duplex\"] does not exist,\n            //    then throw a TypeError.\n            if (initBody != null && init.duplex == null) {\n                throw new TypeError(\"RequestInit: duplex option is required when sending a body.\");\n            }\n            // 2. If thiss requests mode is neither \"same-origin\" nor \"cors\",\n            // then throw a TypeError.\n            if (request.mode !== \"same-origin\" && request.mode !== \"cors\") {\n                throw new TypeError('If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"');\n            }\n            // 3. Set thiss requests use-CORS-preflight flag.\n            request.useCORSPreflightFlag = true;\n        }\n        // 39. Let finalBody be inputOrInitBody.\n        let finalBody = inputOrInitBody;\n        // 40. If initBody is null and inputBody is non-null, then:\n        if (initBody == null && inputBody != null) {\n            // 1. If input is unusable, then throw a TypeError.\n            if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n                throw new TypeError(\"Cannot construct a Request with a Request object that has already been used.\");\n            }\n            // 2. Set finalBody to the result of creating a proxy for inputBody.\n            if (!TransformStream) {\n                TransformStream = (__webpack_require__(/*! stream/web */ \"stream/web\").TransformStream);\n            }\n            // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n            const identityTransform = new TransformStream();\n            inputBody.stream.pipeThrough(identityTransform);\n            finalBody = {\n                source: inputBody.source,\n                length: inputBody.length,\n                stream: identityTransform.readable\n            };\n        }\n        // 41. Set thiss requests body to finalBody.\n        this[kState].body = finalBody;\n    }\n    // Returns requests HTTP method, which is \"GET\" by default.\n    get method() {\n        webidl.brandCheck(this, Request);\n        // The method getter steps are to return thiss requests method.\n        return this[kState].method;\n    }\n    // Returns the URL of request as a string.\n    get url() {\n        webidl.brandCheck(this, Request);\n        // The url getter steps are to return thiss requests URL, serialized.\n        return URLSerializer(this[kState].url);\n    }\n    // Returns a Headers object consisting of the headers associated with request.\n    // Note that headers added in the network layer by the user agent will not\n    // be accounted for in this object, e.g., the \"Host\" header.\n    get headers() {\n        webidl.brandCheck(this, Request);\n        // The headers getter steps are to return thiss headers.\n        return this[kHeaders];\n    }\n    // Returns the kind of resource requested by request, e.g., \"document\"\n    // or \"script\".\n    get destination() {\n        webidl.brandCheck(this, Request);\n        // The destination getter are to return thiss requests destination.\n        return this[kState].destination;\n    }\n    // Returns the referrer of request. Its value can be a same-origin URL if\n    // explicitly set in init, the empty string to indicate no referrer, and\n    // \"about:client\" when defaulting to the globals default. This is used\n    // during fetching to determine the value of the `Referer` header of the\n    // request being made.\n    get referrer() {\n        webidl.brandCheck(this, Request);\n        // 1. If thiss requests referrer is \"no-referrer\", then return the\n        // empty string.\n        if (this[kState].referrer === \"no-referrer\") {\n            return \"\";\n        }\n        // 2. If thiss requests referrer is \"client\", then return\n        // \"about:client\".\n        if (this[kState].referrer === \"client\") {\n            return \"about:client\";\n        }\n        // Return thiss requests referrer, serialized.\n        return this[kState].referrer.toString();\n    }\n    // Returns the referrer policy associated with request.\n    // This is used during fetching to compute the value of the requests\n    // referrer.\n    get referrerPolicy() {\n        webidl.brandCheck(this, Request);\n        // The referrerPolicy getter steps are to return thiss requests referrer policy.\n        return this[kState].referrerPolicy;\n    }\n    // Returns the mode associated with request, which is a string indicating\n    // whether the request will use CORS, or will be restricted to same-origin\n    // URLs.\n    get mode() {\n        webidl.brandCheck(this, Request);\n        // The mode getter steps are to return thiss requests mode.\n        return this[kState].mode;\n    }\n    // Returns the credentials mode associated with request,\n    // which is a string indicating whether credentials will be sent with the\n    // request always, never, or only when sent to a same-origin URL.\n    get credentials() {\n        // The credentials getter steps are to return thiss requests credentials mode.\n        return this[kState].credentials;\n    }\n    // Returns the cache mode associated with request,\n    // which is a string indicating how the request will\n    // interact with the browsers cache when fetching.\n    get cache() {\n        webidl.brandCheck(this, Request);\n        // The cache getter steps are to return thiss requests cache mode.\n        return this[kState].cache;\n    }\n    // Returns the redirect mode associated with request,\n    // which is a string indicating how redirects for the\n    // request will be handled during fetching. A request\n    // will follow redirects by default.\n    get redirect() {\n        webidl.brandCheck(this, Request);\n        // The redirect getter steps are to return thiss requests redirect mode.\n        return this[kState].redirect;\n    }\n    // Returns requests subresource integrity metadata, which is a\n    // cryptographic hash of the resource being fetched. Its value\n    // consists of multiple hashes separated by whitespace. [SRI]\n    get integrity() {\n        webidl.brandCheck(this, Request);\n        // The integrity getter steps are to return thiss requests integrity\n        // metadata.\n        return this[kState].integrity;\n    }\n    // Returns a boolean indicating whether or not request can outlive the\n    // global in which it was created.\n    get keepalive() {\n        webidl.brandCheck(this, Request);\n        // The keepalive getter steps are to return thiss requests keepalive.\n        return this[kState].keepalive;\n    }\n    // Returns a boolean indicating whether or not request is for a reload\n    // navigation.\n    get isReloadNavigation() {\n        webidl.brandCheck(this, Request);\n        // The isReloadNavigation getter steps are to return true if thiss\n        // requests reload-navigation flag is set; otherwise false.\n        return this[kState].reloadNavigation;\n    }\n    // Returns a boolean indicating whether or not request is for a history\n    // navigation (a.k.a. back-foward navigation).\n    get isHistoryNavigation() {\n        webidl.brandCheck(this, Request);\n        // The isHistoryNavigation getter steps are to return true if thiss requests\n        // history-navigation flag is set; otherwise false.\n        return this[kState].historyNavigation;\n    }\n    // Returns the signal associated with request, which is an AbortSignal\n    // object indicating whether or not request has been aborted, and its\n    // abort event handler.\n    get signal() {\n        webidl.brandCheck(this, Request);\n        // The signal getter steps are to return thiss signal.\n        return this[kSignal];\n    }\n    get body() {\n        webidl.brandCheck(this, Request);\n        return this[kState].body ? this[kState].body.stream : null;\n    }\n    get bodyUsed() {\n        webidl.brandCheck(this, Request);\n        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n    get duplex() {\n        webidl.brandCheck(this, Request);\n        return \"half\";\n    }\n    // Returns a clone of request.\n    clone() {\n        webidl.brandCheck(this, Request);\n        // 1. If this is unusable, then throw a TypeError.\n        if (this.bodyUsed || this.body?.locked) {\n            throw new TypeError(\"unusable\");\n        }\n        // 2. Let clonedRequest be the result of cloning thiss request.\n        const clonedRequest = cloneRequest(this[kState]);\n        // 3. Let clonedRequestObject be the result of creating a Request object,\n        // given clonedRequest, thiss headerss guard, and thiss relevant Realm.\n        const clonedRequestObject = new Request(kInit);\n        clonedRequestObject[kState] = clonedRequest;\n        clonedRequestObject[kRealm] = this[kRealm];\n        clonedRequestObject[kHeaders] = new Headers();\n        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;\n        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n        // 4. Make clonedRequestObjects signal follow thiss signal.\n        const ac = new AbortController();\n        if (this.signal.aborted) {\n            ac.abort(this.signal.reason);\n        } else {\n            util.addAbortListener(this.signal, ()=>{\n                ac.abort(this.signal.reason);\n            });\n        }\n        clonedRequestObject[kSignal] = ac.signal;\n        // 4. Return clonedRequestObject.\n        return clonedRequestObject;\n    }\n}\nmixinBody(Request);\nfunction makeRequest(init) {\n    // https://fetch.spec.whatwg.org/#requests\n    const request = {\n        method: \"GET\",\n        localURLsOnly: false,\n        unsafeRequest: false,\n        body: null,\n        client: null,\n        reservedClient: null,\n        replacesClientId: \"\",\n        window: \"client\",\n        keepalive: false,\n        serviceWorkers: \"all\",\n        initiator: \"\",\n        destination: \"\",\n        priority: null,\n        origin: \"client\",\n        policyContainer: \"client\",\n        referrer: \"client\",\n        referrerPolicy: \"\",\n        mode: \"no-cors\",\n        useCORSPreflightFlag: false,\n        credentials: \"same-origin\",\n        useCredentials: false,\n        cache: \"default\",\n        redirect: \"follow\",\n        integrity: \"\",\n        cryptoGraphicsNonceMetadata: \"\",\n        parserMetadata: \"\",\n        reloadNavigation: false,\n        historyNavigation: false,\n        userActivation: false,\n        taintedOrigin: false,\n        redirectCount: 0,\n        responseTainting: \"basic\",\n        preventNoCacheCacheControlHeaderModification: false,\n        done: false,\n        timingAllowFailed: false,\n        ...init,\n        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()\n    };\n    request.url = request.urlList[0];\n    return request;\n}\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest(request) {\n    // To clone a request request, run these steps:\n    // 1. Let newRequest be a copy of request, except for its body.\n    const newRequest = makeRequest({\n        ...request,\n        body: null\n    });\n    // 2. If requests body is non-null, set newRequests body to the\n    // result of cloning requests body.\n    if (request.body != null) {\n        newRequest.body = cloneBody(request.body);\n    }\n    // 3. Return newRequest.\n    return newRequest;\n}\nObject.defineProperties(Request.prototype, {\n    method: kEnumerableProperty,\n    url: kEnumerableProperty,\n    headers: kEnumerableProperty,\n    redirect: kEnumerableProperty,\n    clone: kEnumerableProperty,\n    signal: kEnumerableProperty,\n    duplex: kEnumerableProperty,\n    destination: kEnumerableProperty,\n    body: kEnumerableProperty,\n    bodyUsed: kEnumerableProperty,\n    isHistoryNavigation: kEnumerableProperty,\n    isReloadNavigation: kEnumerableProperty,\n    keepalive: kEnumerableProperty,\n    integrity: kEnumerableProperty,\n    cache: kEnumerableProperty,\n    credentials: kEnumerableProperty,\n    attribute: kEnumerableProperty,\n    referrerPolicy: kEnumerableProperty,\n    referrer: kEnumerableProperty,\n    mode: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"Request\",\n        configurable: true\n    }\n});\nwebidl.converters.Request = webidl.interfaceConverter(Request);\n// https://fetch.spec.whatwg.org/#requestinfo\nwebidl.converters.RequestInfo = function(V) {\n    if (typeof V === \"string\") {\n        return webidl.converters.USVString(V);\n    }\n    if (V instanceof Request) {\n        return webidl.converters.Request(V);\n    }\n    return webidl.converters.USVString(V);\n};\nwebidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);\n// https://fetch.spec.whatwg.org/#requestinit\nwebidl.converters.RequestInit = webidl.dictionaryConverter([\n    {\n        key: \"method\",\n        converter: webidl.converters.ByteString\n    },\n    {\n        key: \"headers\",\n        converter: webidl.converters.HeadersInit\n    },\n    {\n        key: \"body\",\n        converter: webidl.nullableConverter(webidl.converters.BodyInit)\n    },\n    {\n        key: \"referrer\",\n        converter: webidl.converters.USVString\n    },\n    {\n        key: \"referrerPolicy\",\n        converter: webidl.converters.DOMString,\n        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n        allowedValues: referrerPolicy\n    },\n    {\n        key: \"mode\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#concept-request-mode\n        allowedValues: requestMode\n    },\n    {\n        key: \"credentials\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestcredentials\n        allowedValues: requestCredentials\n    },\n    {\n        key: \"cache\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestcache\n        allowedValues: requestCache\n    },\n    {\n        key: \"redirect\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestredirect\n        allowedValues: requestRedirect\n    },\n    {\n        key: \"integrity\",\n        converter: webidl.converters.DOMString\n    },\n    {\n        key: \"keepalive\",\n        converter: webidl.converters.boolean\n    },\n    {\n        key: \"signal\",\n        converter: webidl.nullableConverter((signal)=>webidl.converters.AbortSignal(signal, {\n                strict: false\n            }))\n    },\n    {\n        key: \"window\",\n        converter: webidl.converters.any\n    },\n    {\n        key: \"duplex\",\n        converter: webidl.converters.DOMString,\n        allowedValues: requestDuplex\n    }\n]);\nmodule.exports = {\n    Request,\n    makeRequest\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvcmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsR0FFM0I7QUFFQSxNQUFNLEVBQUVBLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDdEQsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU1DLFdBQVcsRUFBRUMsV0FBVyxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQzVELE1BQU0sRUFBRUssb0JBQW9CLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDekMsTUFBTU0sT0FBT04sbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUNKTyxnQkFBZ0IsRUFDaEJDLFVBQVUsRUFDVkMsZUFBZSxFQUNmQyxtQkFBbUIsRUFDcEIsR0FBR1YsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQ0pXLG1CQUFtQixFQUNuQkMsd0JBQXdCLEVBQ3hCQyxjQUFjLEVBQ2RDLGVBQWUsRUFDZkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEJDLFlBQVksRUFDWkMsYUFBYSxFQUNkLEdBQUdsQixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRW1CLG1CQUFtQixFQUFFLEdBQUdiO0FBQ2hDLE1BQU0sRUFBRWMsUUFBUSxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR3hCLG1CQUFPQSxDQUFDO0FBQzlELE1BQU0sRUFBRXlCLE1BQU0sRUFBRSxHQUFHekIsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFMEIsZUFBZSxFQUFFLEdBQUcxQixtQkFBT0EsQ0FBQztBQUNwQyxNQUFNLEVBQUUyQixhQUFhLEVBQUUsR0FBRzNCLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRTRCLFlBQVksRUFBRSxHQUFHNUIsbUJBQU9BLENBQUM7QUFDakMsTUFBTTZCLFNBQVM3QixtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUU4Qixl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QixVQUFVLENBQUMySCxTQUFTO1FBQ3RDQyxlQUFlNUo7SUFDakI7Q0FDRDtBQUVEZ0ssT0FBT0MsT0FBTyxHQUFHO0lBQUV4STtJQUFTdUI7QUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvcmVxdWVzdC5qcz8yODhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgQWJvcnRDb250cm9sbGVyICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGV4dHJhY3RCb2R5LCBtaXhpbkJvZHksIGNsb25lQm9keSB9ID0gcmVxdWlyZSgnLi9ib2R5JylcbmNvbnN0IHsgSGVhZGVycywgZmlsbDogZmlsbEhlYWRlcnMsIEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuY29uc3QgeyBGaW5hbGl6YXRpb25SZWdpc3RyeSB9ID0gcmVxdWlyZSgnLi4vY29tcGF0L2Rpc3BhdGNoZXItd2Vha3JlZicpKClcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3Qge1xuICBpc1ZhbGlkSFRUUFRva2VuLFxuICBzYW1lT3JpZ2luLFxuICBub3JtYWxpemVNZXRob2QsXG4gIG1ha2VQb2xpY3lDb250YWluZXJcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3Qge1xuICBmb3JiaWRkZW5NZXRob2RzU2V0LFxuICBjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQsXG4gIHJlZmVycmVyUG9saWN5LFxuICByZXF1ZXN0UmVkaXJlY3QsXG4gIHJlcXVlc3RNb2RlLFxuICByZXF1ZXN0Q3JlZGVudGlhbHMsXG4gIHJlcXVlc3RDYWNoZSxcbiAgcmVxdWVzdER1cGxleFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gdXRpbFxuY29uc3QgeyBrSGVhZGVycywga1NpZ25hbCwga1N0YXRlLCBrR3VhcmQsIGtSZWFsbSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9nbG9iYWwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuL2RhdGFVUkwnKVxuY29uc3QgeyBrSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBnZXRNYXhMaXN0ZW5lcnMsIHNldE1heExpc3RlbmVycywgZ2V0RXZlbnRMaXN0ZW5lcnMsIGRlZmF1bHRNYXhMaXN0ZW5lcnMgfSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5cbmxldCBUcmFuc2Zvcm1TdHJlYW0gPSBnbG9iYWxUaGlzLlRyYW5zZm9ybVN0cmVhbVxuXG5jb25zdCBrSW5pdCA9IFN5bWJvbCgnaW5pdCcpXG5jb25zdCBrQWJvcnRDb250cm9sbGVyID0gU3ltYm9sKCdhYm9ydENvbnRyb2xsZXInKVxuXG5jb25zdCByZXF1ZXN0RmluYWxpemVyID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCh7IHNpZ25hbCwgYWJvcnQgfSkgPT4ge1xuICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydClcbn0pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWNsYXNzXG5jbGFzcyBSZXF1ZXN0IHtcbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0XG4gIGNvbnN0cnVjdG9yIChpbnB1dCwgaW5pdCA9IHt9KSB7XG4gICAgaWYgKGlucHV0ID09PSBrSW5pdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ1JlcXVlc3QgY29uc3RydWN0b3InIH0pXG5cbiAgICBpbnB1dCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKGlucHV0KVxuICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5pdChpbml0KVxuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI2Vudmlyb25tZW50LXNldHRpbmdzLW9iamVjdFxuICAgIHRoaXNba1JlYWxtXSA9IHtcbiAgICAgIHNldHRpbmdzT2JqZWN0OiB7XG4gICAgICAgIGJhc2VVcmw6IGdldEdsb2JhbE9yaWdpbigpLFxuICAgICAgICBnZXQgb3JpZ2luICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlVXJsPy5vcmlnaW5cbiAgICAgICAgfSxcbiAgICAgICAgcG9saWN5Q29udGFpbmVyOiBtYWtlUG9saWN5Q29udGFpbmVyKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBudWxsLlxuICAgIGxldCByZXF1ZXN0ID0gbnVsbFxuXG4gICAgLy8gMi4gTGV0IGZhbGxiYWNrTW9kZSBiZSBudWxsLlxuICAgIGxldCBmYWxsYmFja01vZGUgPSBudWxsXG5cbiAgICAvLyAzLiBMZXQgYmFzZVVSTCBiZSB0aGlz4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3TigJlzIEFQSSBiYXNlIFVSTC5cbiAgICBjb25zdCBiYXNlVXJsID0gdGhpc1trUmVhbG1dLnNldHRpbmdzT2JqZWN0LmJhc2VVcmxcblxuICAgIC8vIDQuIExldCBzaWduYWwgYmUgbnVsbC5cbiAgICBsZXQgc2lnbmFsID0gbnVsbFxuXG4gICAgLy8gNS4gSWYgaW5wdXQgaXMgYSBzdHJpbmcsIHRoZW46XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIDEuIExldCBwYXJzZWRVUkwgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIGlucHV0IHdpdGggYmFzZVVSTC5cbiAgICAgIC8vIDIuIElmIHBhcnNlZFVSTCBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgbGV0IHBhcnNlZFVSTFxuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkVVJMID0gbmV3IFVSTChpbnB1dCwgYmFzZVVybClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gcGFyc2UgVVJMIGZyb20gJyArIGlucHV0LCB7IGNhdXNlOiBlcnIgfSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgcGFyc2VkVVJMIGluY2x1ZGVzIGNyZWRlbnRpYWxzLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHBhcnNlZFVSTC51c2VybmFtZSB8fCBwYXJzZWRVUkwucGFzc3dvcmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnUmVxdWVzdCBjYW5ub3QgYmUgY29uc3RydWN0ZWQgZnJvbSBhIFVSTCB0aGF0IGluY2x1ZGVzIGNyZWRlbnRpYWxzOiAnICtcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gNC4gU2V0IHJlcXVlc3QgdG8gYSBuZXcgcmVxdWVzdCB3aG9zZSBVUkwgaXMgcGFyc2VkVVJMLlxuICAgICAgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHsgdXJsTGlzdDogW3BhcnNlZFVSTF0gfSlcblxuICAgICAgLy8gNS4gU2V0IGZhbGxiYWNrTW9kZSB0byBcImNvcnNcIi5cbiAgICAgIGZhbGxiYWNrTW9kZSA9ICdjb3JzJ1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyA2LiBPdGhlcndpc2U6XG5cbiAgICAgIC8vIDcuIEFzc2VydDogaW5wdXQgaXMgYSBSZXF1ZXN0IG9iamVjdC5cbiAgICAgIGFzc2VydChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpXG5cbiAgICAgIC8vIDguIFNldCByZXF1ZXN0IHRvIGlucHV04oCZcyByZXF1ZXN0LlxuICAgICAgcmVxdWVzdCA9IGlucHV0W2tTdGF0ZV1cblxuICAgICAgLy8gOS4gU2V0IHNpZ25hbCB0byBpbnB1dOKAmXMgc2lnbmFsLlxuICAgICAgc2lnbmFsID0gaW5wdXRba1NpZ25hbF1cbiAgICB9XG5cbiAgICAvLyA3LiBMZXQgb3JpZ2luIGJlIHRoaXPigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgb3JpZ2luLlxuICAgIGNvbnN0IG9yaWdpbiA9IHRoaXNba1JlYWxtXS5zZXR0aW5nc09iamVjdC5vcmlnaW5cblxuICAgIC8vIDguIExldCB3aW5kb3cgYmUgXCJjbGllbnRcIi5cbiAgICBsZXQgd2luZG93ID0gJ2NsaWVudCdcblxuICAgIC8vIDkuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBhbiBlbnZpcm9ubWVudCBzZXR0aW5ncyBvYmplY3QgYW5kIGl0cyBvcmlnaW5cbiAgICAvLyBpcyBzYW1lIG9yaWdpbiB3aXRoIG9yaWdpbiwgdGhlbiBzZXQgd2luZG93IHRvIHJlcXVlc3TigJlzIHdpbmRvdy5cbiAgICBpZiAoXG4gICAgICByZXF1ZXN0LndpbmRvdz8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0JyAmJlxuICAgICAgc2FtZU9yaWdpbihyZXF1ZXN0LndpbmRvdywgb3JpZ2luKVxuICAgICkge1xuICAgICAgd2luZG93ID0gcmVxdWVzdC53aW5kb3dcbiAgICB9XG5cbiAgICAvLyAxMC4gSWYgaW5pdFtcIndpbmRvd1wiXSBleGlzdHMgYW5kIGlzIG5vbi1udWxsLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChpbml0LndpbmRvdyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnd2luZG93JyBvcHRpb24gJyR7d2luZG93fScgbXVzdCBiZSBudWxsYClcbiAgICB9XG5cbiAgICAvLyAxMS4gSWYgaW5pdFtcIndpbmRvd1wiXSBleGlzdHMsIHRoZW4gc2V0IHdpbmRvdyB0byBcIm5vLXdpbmRvd1wiLlxuICAgIGlmICgnd2luZG93JyBpbiBpbml0KSB7XG4gICAgICB3aW5kb3cgPSAnbm8td2luZG93J1xuICAgIH1cblxuICAgIC8vIDEyLiBTZXQgcmVxdWVzdCB0byBhIG5ldyByZXF1ZXN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgIHJlcXVlc3QgPSBtYWtlUmVxdWVzdCh7XG4gICAgICAvLyBVUkwgcmVxdWVzdOKAmXMgVVJMLlxuICAgICAgLy8gdW5kaWNpIGltcGxlbWVudGF0aW9uIG5vdGU6IHRoaXMgaXMgc2V0IGFzIHRoZSBmaXJzdCBpdGVtIGluIHJlcXVlc3QncyB1cmxMaXN0IGluIG1ha2VSZXF1ZXN0XG4gICAgICAvLyBtZXRob2QgcmVxdWVzdOKAmXMgbWV0aG9kLlxuICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIC8vIGhlYWRlciBsaXN0IEEgY29weSBvZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIC8vIHVuZGljaSBpbXBsZW1lbnRhdGlvbiBub3RlOiBoZWFkZXJzTGlzdCBpcyBjbG9uZWQgaW4gbWFrZVJlcXVlc3RcbiAgICAgIGhlYWRlcnNMaXN0OiByZXF1ZXN0LmhlYWRlcnNMaXN0LFxuICAgICAgLy8gdW5zYWZlLXJlcXVlc3QgZmxhZyBTZXQuXG4gICAgICB1bnNhZmVSZXF1ZXN0OiByZXF1ZXN0LnVuc2FmZVJlcXVlc3QsXG4gICAgICAvLyBjbGllbnQgVGhpc+KAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAgY2xpZW50OiB0aGlzW2tSZWFsbV0uc2V0dGluZ3NPYmplY3QsXG4gICAgICAvLyB3aW5kb3cgd2luZG93LlxuICAgICAgd2luZG93LFxuICAgICAgLy8gcHJpb3JpdHkgcmVxdWVzdOKAmXMgcHJpb3JpdHkuXG4gICAgICBwcmlvcml0eTogcmVxdWVzdC5wcmlvcml0eSxcbiAgICAgIC8vIG9yaWdpbiByZXF1ZXN04oCZcyBvcmlnaW4uIFRoZSBwcm9wYWdhdGlvbiBvZiB0aGUgb3JpZ2luIGlzIG9ubHkgc2lnbmlmaWNhbnQgZm9yIG5hdmlnYXRpb24gcmVxdWVzdHNcbiAgICAgIC8vIGJlaW5nIGhhbmRsZWQgYnkgYSBzZXJ2aWNlIHdvcmtlci4gSW4gdGhpcyBzY2VuYXJpbyBhIHJlcXVlc3QgY2FuIGhhdmUgYW4gb3JpZ2luIHRoYXQgaXMgZGlmZmVyZW50XG4gICAgICAvLyBmcm9tIHRoZSBjdXJyZW50IGNsaWVudC5cbiAgICAgIG9yaWdpbjogcmVxdWVzdC5vcmlnaW4sXG4gICAgICAvLyByZWZlcnJlciByZXF1ZXN04oCZcyByZWZlcnJlci5cbiAgICAgIHJlZmVycmVyOiByZXF1ZXN0LnJlZmVycmVyLFxuICAgICAgLy8gcmVmZXJyZXIgcG9saWN5IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgICAgIHJlZmVycmVyUG9saWN5OiByZXF1ZXN0LnJlZmVycmVyUG9saWN5LFxuICAgICAgLy8gbW9kZSByZXF1ZXN04oCZcyBtb2RlLlxuICAgICAgbW9kZTogcmVxdWVzdC5tb2RlLFxuICAgICAgLy8gY3JlZGVudGlhbHMgbW9kZSByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlLlxuICAgICAgY3JlZGVudGlhbHM6IHJlcXVlc3QuY3JlZGVudGlhbHMsXG4gICAgICAvLyBjYWNoZSBtb2RlIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUuXG4gICAgICBjYWNoZTogcmVxdWVzdC5jYWNoZSxcbiAgICAgIC8vIHJlZGlyZWN0IG1vZGUgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZS5cbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgLy8gaW50ZWdyaXR5IG1ldGFkYXRhIHJlcXVlc3TigJlzIGludGVncml0eSBtZXRhZGF0YS5cbiAgICAgIGludGVncml0eTogcmVxdWVzdC5pbnRlZ3JpdHksXG4gICAgICAvLyBrZWVwYWxpdmUgcmVxdWVzdOKAmXMga2VlcGFsaXZlLlxuICAgICAga2VlcGFsaXZlOiByZXF1ZXN0LmtlZXBhbGl2ZSxcbiAgICAgIC8vIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcgcmVxdWVzdOKAmXMgcmVsb2FkLW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlbG9hZE5hdmlnYXRpb246IHJlcXVlc3QucmVsb2FkTmF2aWdhdGlvbixcbiAgICAgIC8vIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnIHJlcXVlc3TigJlzIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgaGlzdG9yeU5hdmlnYXRpb246IHJlcXVlc3QuaGlzdG9yeU5hdmlnYXRpb24sXG4gICAgICAvLyBVUkwgbGlzdCBBIGNsb25lIG9mIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICAgICAgdXJsTGlzdDogWy4uLnJlcXVlc3QudXJsTGlzdF1cbiAgICB9KVxuXG4gICAgLy8gMTMuIElmIGluaXQgaXMgbm90IGVtcHR5LCB0aGVuOlxuICAgIGlmIChPYmplY3Qua2V5cyhpbml0KS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyBtb2RlIGlzIFwibmF2aWdhdGVcIiwgdGhlbiBzZXQgaXQgdG8gXCJzYW1lLW9yaWdpblwiLlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJykge1xuICAgICAgICByZXF1ZXN0Lm1vZGUgPSAnc2FtZS1vcmlnaW4nXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFVuc2V0IHJlcXVlc3TigJlzIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcuXG4gICAgICByZXF1ZXN0LnJlbG9hZE5hdmlnYXRpb24gPSBmYWxzZVxuXG4gICAgICAvLyAzLiBVbnNldCByZXF1ZXN04oCZcyBoaXN0b3J5LW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlcXVlc3QuaGlzdG9yeU5hdmlnYXRpb24gPSBmYWxzZVxuXG4gICAgICAvLyA0LiBTZXQgcmVxdWVzdOKAmXMgb3JpZ2luIHRvIFwiY2xpZW50XCIuXG4gICAgICByZXF1ZXN0Lm9yaWdpbiA9ICdjbGllbnQnXG5cbiAgICAgIC8vIDUuIFNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBcImNsaWVudFwiXG4gICAgICByZXF1ZXN0LnJlZmVycmVyID0gJ2NsaWVudCdcblxuICAgICAgLy8gNi4gU2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9ICcnXG5cbiAgICAgIC8vIDcuIFNldCByZXF1ZXN04oCZcyBVUkwgdG8gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gICAgICByZXF1ZXN0LnVybCA9IHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cblxuICAgICAgLy8gOC4gU2V0IHJlcXVlc3TigJlzIFVSTCBsaXN0IHRvIMKrIHJlcXVlc3TigJlzIFVSTCDCuy5cbiAgICAgIHJlcXVlc3QudXJsTGlzdCA9IFtyZXF1ZXN0LnVybF1cbiAgICB9XG5cbiAgICAvLyAxNC4gSWYgaW5pdFtcInJlZmVycmVyXCJdIGV4aXN0cywgdGhlbjpcbiAgICBpZiAoaW5pdC5yZWZlcnJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAxLiBMZXQgcmVmZXJyZXIgYmUgaW5pdFtcInJlZmVycmVyXCJdLlxuICAgICAgY29uc3QgcmVmZXJyZXIgPSBpbml0LnJlZmVycmVyXG5cbiAgICAgIC8vIDIuIElmIHJlZmVycmVyIGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIFwibm8tcmVmZXJyZXJcIi5cbiAgICAgIGlmIChyZWZlcnJlciA9PT0gJycpIHtcbiAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9ICduby1yZWZlcnJlcidcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDEuIExldCBwYXJzZWRSZWZlcnJlciBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgcmVmZXJyZXIgd2l0aFxuICAgICAgICAvLyBiYXNlVVJMLlxuICAgICAgICAvLyAyLiBJZiBwYXJzZWRSZWZlcnJlciBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICBsZXQgcGFyc2VkUmVmZXJyZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWRSZWZlcnJlciA9IG5ldyBVUkwocmVmZXJyZXIsIGJhc2VVcmwpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlZmVycmVyIFwiJHtyZWZlcnJlcn1cIiBpcyBub3QgYSB2YWxpZCBVUkwuYCwgeyBjYXVzZTogZXJyIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBJZiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlXG4gICAgICAgIC8vIC0gcGFyc2VkUmVmZXJyZXLigJlzIHNjaGVtZSBpcyBcImFib3V0XCIgYW5kIHBhdGggaXMgdGhlIHN0cmluZyBcImNsaWVudFwiXG4gICAgICAgIC8vIC0gcGFyc2VkUmVmZXJyZXLigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCBvcmlnaW5cbiAgICAgICAgLy8gdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gXCJjbGllbnRcIi5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIChwYXJzZWRSZWZlcnJlci5wcm90b2NvbCA9PT0gJ2Fib3V0OicgJiYgcGFyc2VkUmVmZXJyZXIuaG9zdG5hbWUgPT09ICdjbGllbnQnKSB8fFxuICAgICAgICAgIChvcmlnaW4gJiYgIXNhbWVPcmlnaW4ocGFyc2VkUmVmZXJyZXIsIHRoaXNba1JlYWxtXS5zZXR0aW5nc09iamVjdC5iYXNlVXJsKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9ICdjbGllbnQnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gNC4gT3RoZXJ3aXNlLCBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gcGFyc2VkUmVmZXJyZXIuXG4gICAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9IHBhcnNlZFJlZmVycmVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxNS4gSWYgaW5pdFtcInJlZmVycmVyUG9saWN5XCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5XG4gICAgLy8gdG8gaXQuXG4gICAgaWYgKGluaXQucmVmZXJyZXJQb2xpY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IGluaXQucmVmZXJyZXJQb2xpY3lcbiAgICB9XG5cbiAgICAvLyAxNi4gTGV0IG1vZGUgYmUgaW5pdFtcIm1vZGVcIl0gaWYgaXQgZXhpc3RzLCBhbmQgZmFsbGJhY2tNb2RlIG90aGVyd2lzZS5cbiAgICBsZXQgbW9kZVxuICAgIGlmIChpbml0Lm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbW9kZSA9IGluaXQubW9kZVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlID0gZmFsbGJhY2tNb2RlXG4gICAgfVxuXG4gICAgLy8gMTcuIElmIG1vZGUgaXMgXCJuYXZpZ2F0ZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChtb2RlID09PSAnbmF2aWdhdGUnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1JlcXVlc3QgY29uc3RydWN0b3InLFxuICAgICAgICBtZXNzYWdlOiAnaW52YWxpZCByZXF1ZXN0IG1vZGUgbmF2aWdhdGUuJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAxOC4gSWYgbW9kZSBpcyBub24tbnVsbCwgc2V0IHJlcXVlc3TigJlzIG1vZGUgdG8gbW9kZS5cbiAgICBpZiAobW9kZSAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0Lm1vZGUgPSBtb2RlXG4gICAgfVxuXG4gICAgLy8gMTkuIElmIGluaXRbXCJjcmVkZW50aWFsc1wiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGVcbiAgICAvLyB0byBpdC5cbiAgICBpZiAoaW5pdC5jcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID0gaW5pdC5jcmVkZW50aWFsc1xuICAgIH1cblxuICAgIC8vIDE4LiBJZiBpbml0W1wiY2FjaGVcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvIGl0LlxuICAgIGlmIChpbml0LmNhY2hlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QuY2FjaGUgPSBpbml0LmNhY2hlXG4gICAgfVxuXG4gICAgLy8gMjEuIElmIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJvbmx5LWlmLWNhY2hlZFwiIGFuZCByZXF1ZXN04oCZcyBtb2RlIGlzXG4gICAgLy8gbm90IFwic2FtZS1vcmlnaW5cIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAocmVxdWVzdC5jYWNoZSA9PT0gJ29ubHktaWYtY2FjaGVkJyAmJiByZXF1ZXN0Lm1vZGUgIT09ICdzYW1lLW9yaWdpbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiJ29ubHktaWYtY2FjaGVkJyBjYW4gYmUgc2V0IG9ubHkgd2l0aCAnc2FtZS1vcmlnaW4nIG1vZGVcIlxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIDIyLiBJZiBpbml0W1wicmVkaXJlY3RcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIHRvIGl0LlxuICAgIGlmIChpbml0LnJlZGlyZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QucmVkaXJlY3QgPSBpbml0LnJlZGlyZWN0XG4gICAgfVxuXG4gICAgLy8gMjMuIElmIGluaXRbXCJpbnRlZ3JpdHlcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEgdG8gaXQuXG4gICAgaWYgKGluaXQuaW50ZWdyaXR5ICE9PSB1bmRlZmluZWQgJiYgaW5pdC5pbnRlZ3JpdHkgIT0gbnVsbCkge1xuICAgICAgcmVxdWVzdC5pbnRlZ3JpdHkgPSBTdHJpbmcoaW5pdC5pbnRlZ3JpdHkpXG4gICAgfVxuXG4gICAgLy8gMjQuIElmIGluaXRbXCJrZWVwYWxpdmVcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBrZWVwYWxpdmUgdG8gaXQuXG4gICAgaWYgKGluaXQua2VlcGFsaXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3Qua2VlcGFsaXZlID0gQm9vbGVhbihpbml0LmtlZXBhbGl2ZSlcbiAgICB9XG5cbiAgICAvLyAyNS4gSWYgaW5pdFtcIm1ldGhvZFwiXSBleGlzdHMsIHRoZW46XG4gICAgaWYgKGluaXQubWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDEuIExldCBtZXRob2QgYmUgaW5pdFtcIm1ldGhvZFwiXS5cbiAgICAgIGxldCBtZXRob2QgPSBpbml0Lm1ldGhvZFxuXG4gICAgICAvLyAyLiBJZiBtZXRob2QgaXMgbm90IGEgbWV0aG9kIG9yIG1ldGhvZCBpcyBhIGZvcmJpZGRlbiBtZXRob2QsIHRoZW5cbiAgICAgIC8vIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKCFpc1ZhbGlkSFRUUFRva2VuKGluaXQubWV0aG9kKSkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoYCcke2luaXQubWV0aG9kfScgaXMgbm90IGEgdmFsaWQgSFRUUCBtZXRob2QuYClcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmJpZGRlbk1ldGhvZHNTZXQuaGFzKG1ldGhvZC50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoYCcke2luaXQubWV0aG9kfScgSFRUUCBtZXRob2QgaXMgdW5zdXBwb3J0ZWQuYClcbiAgICAgIH1cblxuICAgICAgLy8gMy4gTm9ybWFsaXplIG1ldGhvZC5cbiAgICAgIG1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChpbml0Lm1ldGhvZClcblxuICAgICAgLy8gNC4gU2V0IHJlcXVlc3TigJlzIG1ldGhvZCB0byBtZXRob2QuXG4gICAgICByZXF1ZXN0Lm1ldGhvZCA9IG1ldGhvZFxuICAgIH1cblxuICAgIC8vIDI2LiBJZiBpbml0W1wic2lnbmFsXCJdIGV4aXN0cywgdGhlbiBzZXQgc2lnbmFsIHRvIGl0LlxuICAgIGlmIChpbml0LnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzaWduYWwgPSBpbml0LnNpZ25hbFxuICAgIH1cblxuICAgIC8vIDI3LiBTZXQgdGhpc+KAmXMgcmVxdWVzdCB0byByZXF1ZXN0LlxuICAgIHRoaXNba1N0YXRlXSA9IHJlcXVlc3RcblxuICAgIC8vIDI4LiBTZXQgdGhpc+KAmXMgc2lnbmFsIHRvIGEgbmV3IEFib3J0U2lnbmFsIG9iamVjdCB3aXRoIHRoaXPigJlzIHJlbGV2YW50XG4gICAgLy8gUmVhbG0uXG4gICAgLy8gVE9ETzogY291bGQgdGhpcyBiZSBzaW1wbGlmaWVkIHdpdGggQWJvcnRTaWduYWwuYW55XG4gICAgLy8gKGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWFib3J0c2lnbmFsLWFueSlcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIHRoaXNba1NpZ25hbF0gPSBhYy5zaWduYWxcbiAgICB0aGlzW2tTaWduYWxdW2tSZWFsbV0gPSB0aGlzW2tSZWFsbV1cblxuICAgIC8vIDI5LiBJZiBzaWduYWwgaXMgbm90IG51bGwsIHRoZW4gbWFrZSB0aGlz4oCZcyBzaWduYWwgZm9sbG93IHNpZ25hbC5cbiAgICBpZiAoc2lnbmFsICE9IG51bGwpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIXNpZ25hbCB8fFxuICAgICAgICB0eXBlb2Ygc2lnbmFsLmFib3J0ZWQgIT09ICdib29sZWFuJyB8fFxuICAgICAgICB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IG1lbWJlciBzaWduYWwgaXMgbm90IG9mIHR5cGUgQWJvcnRTaWduYWwuXCJcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWMuYWJvcnQoc2lnbmFsLnJlYXNvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEtlZXAgYSBzdHJvbmcgcmVmIHRvIGFjIHdoaWxlIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgIC8vIGlzIGFsaXZlLiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IEFib3J0Q29udHJvbGxlclxuICAgICAgICAvLyBmcm9tIGJlaW5nIHByZW1hdHVyZWx5IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAgICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xOTI2LlxuICAgICAgICB0aGlzW2tBYm9ydENvbnRyb2xsZXJdID0gYWNcblxuICAgICAgICBjb25zdCBhY1JlZiA9IG5ldyBXZWFrUmVmKGFjKVxuICAgICAgICBjb25zdCBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCBhYyA9IGFjUmVmLmRlcmVmKClcbiAgICAgICAgICBpZiAoYWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWMuYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcmQtcGFydHkgQWJvcnRDb250cm9sbGVycyBtYXkgbm90IHdvcmsgd2l0aCB0aGVzZS5cbiAgICAgICAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9wdWxsLzE5MTAjaXNzdWVjb21tZW50LTE0NjQ0OTU2MTkuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSWYgdGhlIG1heCBhbW91bnQgb2YgbGlzdGVuZXJzIGlzIGVxdWFsIHRvIHRoZSBkZWZhdWx0LCBpbmNyZWFzZSBpdFxuICAgICAgICAgIC8vIFRoaXMgaXMgb25seSBhdmFpbGFibGUgaW4gbm9kZSA+PSB2MTkuOS4wXG4gICAgICAgICAgaWYgKHR5cGVvZiBnZXRNYXhMaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicgJiYgZ2V0TWF4TGlzdGVuZXJzKHNpZ25hbCkgPT09IGRlZmF1bHRNYXhMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHNldE1heExpc3RlbmVycygxMDAsIHNpZ25hbClcbiAgICAgICAgICB9IGVsc2UgaWYgKGdldEV2ZW50TGlzdGVuZXJzKHNpZ25hbCwgJ2Fib3J0JykubGVuZ3RoID49IGRlZmF1bHRNYXhMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHNldE1heExpc3RlbmVycygxMDAsIHNpZ25hbClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge31cblxuICAgICAgICB1dGlsLmFkZEFib3J0TGlzdGVuZXIoc2lnbmFsLCBhYm9ydClcbiAgICAgICAgcmVxdWVzdEZpbmFsaXplci5yZWdpc3RlcihhYywgeyBzaWduYWwsIGFib3J0IH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMzAuIFNldCB0aGlz4oCZcyBoZWFkZXJzIHRvIGEgbmV3IEhlYWRlcnMgb2JqZWN0IHdpdGggdGhpc+KAmXMgcmVsZXZhbnRcbiAgICAvLyBSZWFsbSwgd2hvc2UgaGVhZGVyIGxpc3QgaXMgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgYW5kIGd1YXJkIGlzXG4gICAgLy8gXCJyZXF1ZXN0XCIuXG4gICAgdGhpc1trSGVhZGVyc10gPSBuZXcgSGVhZGVycygpXG4gICAgdGhpc1trSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IHJlcXVlc3QuaGVhZGVyc0xpc3RcbiAgICB0aGlzW2tIZWFkZXJzXVtrR3VhcmRdID0gJ3JlcXVlc3QnXG4gICAgdGhpc1trSGVhZGVyc11ba1JlYWxtXSA9IHRoaXNba1JlYWxtXVxuXG4gICAgLy8gMzEuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuby1jb3JzXCIsIHRoZW46XG4gICAgaWYgKG1vZGUgPT09ICduby1jb3JzJykge1xuICAgICAgLy8gMS4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5vdCBhIENPUlMtc2FmZWxpc3RlZCBtZXRob2QsXG4gICAgICAvLyB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKCFjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQuaGFzKHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAnJHtyZXF1ZXN0Lm1ldGhvZH0gaXMgdW5zdXBwb3J0ZWQgaW4gbm8tY29ycyBtb2RlLmBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQgdG8gXCJyZXF1ZXN0LW5vLWNvcnNcIi5cbiAgICAgIHRoaXNba0hlYWRlcnNdW2tHdWFyZF0gPSAncmVxdWVzdC1uby1jb3JzJ1xuICAgIH1cblxuICAgIC8vIDMyLiBJZiBpbml0IGlzIG5vdCBlbXB0eSwgdGhlbjpcbiAgICBpZiAoT2JqZWN0LmtleXMoaW5pdCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAvLyAxLiBMZXQgaGVhZGVycyBiZSBhIGNvcHkgb2YgdGhpc+KAmXMgaGVhZGVycyBhbmQgaXRzIGFzc29jaWF0ZWQgaGVhZGVyXG4gICAgICAvLyBsaXN0LlxuICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzW2tIZWFkZXJzXSlcblxuICAgICAgLy8gMi4gSWYgaW5pdFtcImhlYWRlcnNcIl0gZXhpc3RzLCB0aGVuIHNldCBoZWFkZXJzIHRvIGluaXRbXCJoZWFkZXJzXCJdLlxuICAgICAgaWYgKGluaXQuaGVhZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlYWRlcnMgPSBpbml0LmhlYWRlcnNcbiAgICAgIH1cblxuICAgICAgLy8gMy4gRW1wdHkgdGhpc+KAmXMgaGVhZGVyc+KAmXMgaGVhZGVyIGxpc3QuXG4gICAgICB0aGlzW2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdLmNsZWFyKClcblxuICAgICAgLy8gNC4gSWYgaGVhZGVycyBpcyBhIEhlYWRlcnMgb2JqZWN0LCB0aGVuIGZvciBlYWNoIGhlYWRlciBpbiBpdHMgaGVhZGVyXG4gICAgICAvLyBsaXN0LCBhcHBlbmQgaGVhZGVy4oCZcyBuYW1lL2hlYWRlcuKAmXMgdmFsdWUgdG8gdGhpc+KAmXMgaGVhZGVycy5cbiAgICAgIGlmIChoZWFkZXJzLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdIZWFkZXJzJykge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgaGVhZGVycykge1xuICAgICAgICAgIHRoaXNba0hlYWRlcnNdLmFwcGVuZChrZXksIHZhbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNS4gT3RoZXJ3aXNlLCBmaWxsIHRoaXPigJlzIGhlYWRlcnMgd2l0aCBoZWFkZXJzLlxuICAgICAgICBmaWxsSGVhZGVycyh0aGlzW2tIZWFkZXJzXSwgaGVhZGVycylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzMy4gTGV0IGlucHV0Qm9keSBiZSBpbnB1dOKAmXMgcmVxdWVzdOKAmXMgYm9keSBpZiBpbnB1dCBpcyBhIFJlcXVlc3RcbiAgICAvLyBvYmplY3Q7IG90aGVyd2lzZSBudWxsLlxuICAgIGNvbnN0IGlucHV0Qm9keSA9IGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCA/IGlucHV0W2tTdGF0ZV0uYm9keSA6IG51bGxcblxuICAgIC8vIDM0LiBJZiBlaXRoZXIgaW5pdFtcImJvZHlcIl0gZXhpc3RzIGFuZCBpcyBub24tbnVsbCBvciBpbnB1dEJvZHkgaXNcbiAgICAvLyBub24tbnVsbCwgYW5kIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBgR0VUYCBvciBgSEVBRGAsIHRoZW4gdGhyb3cgYVxuICAgIC8vIFR5cGVFcnJvci5cbiAgICBpZiAoXG4gICAgICAoaW5pdC5ib2R5ICE9IG51bGwgfHwgaW5wdXRCb2R5ICE9IG51bGwpICYmXG4gICAgICAocmVxdWVzdC5tZXRob2QgPT09ICdHRVQnIHx8IHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXF1ZXN0IHdpdGggR0VUL0hFQUQgbWV0aG9kIGNhbm5vdCBoYXZlIGJvZHkuJylcbiAgICB9XG5cbiAgICAvLyAzNS4gTGV0IGluaXRCb2R5IGJlIG51bGwuXG4gICAgbGV0IGluaXRCb2R5ID0gbnVsbFxuXG4gICAgLy8gMzYuIElmIGluaXRbXCJib2R5XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwsIHRoZW46XG4gICAgaWYgKGluaXQuYm9keSAhPSBudWxsKSB7XG4gICAgICAvLyAxLiBMZXQgQ29udGVudC1UeXBlIGJlIG51bGwuXG4gICAgICAvLyAyLiBTZXQgaW5pdEJvZHkgYW5kIENvbnRlbnQtVHlwZSB0byB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmdcbiAgICAgIC8vIGluaXRbXCJib2R5XCJdLCB3aXRoIGtlZXBhbGl2ZSBzZXQgdG8gcmVxdWVzdOKAmXMga2VlcGFsaXZlLlxuICAgICAgY29uc3QgW2V4dHJhY3RlZEJvZHksIGNvbnRlbnRUeXBlXSA9IGV4dHJhY3RCb2R5KFxuICAgICAgICBpbml0LmJvZHksXG4gICAgICAgIHJlcXVlc3Qua2VlcGFsaXZlXG4gICAgICApXG4gICAgICBpbml0Qm9keSA9IGV4dHJhY3RlZEJvZHlcblxuICAgICAgLy8gMywgSWYgQ29udGVudC1UeXBlIGlzIG5vbi1udWxsIGFuZCB0aGlz4oCZcyBoZWFkZXJz4oCZcyBoZWFkZXIgbGlzdCBkb2VzXG4gICAgICAvLyBub3QgY29udGFpbiBgQ29udGVudC1UeXBlYCwgdGhlbiBhcHBlbmQgYENvbnRlbnQtVHlwZWAvQ29udGVudC1UeXBlIHRvXG4gICAgICAvLyB0aGlz4oCZcyBoZWFkZXJzLlxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmICF0aGlzW2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdLmNvbnRhaW5zKCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICB0aGlzW2tIZWFkZXJzXS5hcHBlbmQoJ2NvbnRlbnQtdHlwZScsIGNvbnRlbnRUeXBlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDM3LiBMZXQgaW5wdXRPckluaXRCb2R5IGJlIGluaXRCb2R5IGlmIGl0IGlzIG5vbi1udWxsOyBvdGhlcndpc2VcbiAgICAvLyBpbnB1dEJvZHkuXG4gICAgY29uc3QgaW5wdXRPckluaXRCb2R5ID0gaW5pdEJvZHkgPz8gaW5wdXRCb2R5XG5cbiAgICAvLyAzOC4gSWYgaW5wdXRPckluaXRCb2R5IGlzIG5vbi1udWxsIGFuZCBpbnB1dE9ySW5pdEJvZHnigJlzIHNvdXJjZSBpc1xuICAgIC8vIG51bGwsIHRoZW46XG4gICAgaWYgKGlucHV0T3JJbml0Qm9keSAhPSBudWxsICYmIGlucHV0T3JJbml0Qm9keS5zb3VyY2UgPT0gbnVsbCkge1xuICAgICAgLy8gMS4gSWYgaW5pdEJvZHkgaXMgbm9uLW51bGwgYW5kIGluaXRbXCJkdXBsZXhcIl0gZG9lcyBub3QgZXhpc3QsXG4gICAgICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKGluaXRCb2R5ICE9IG51bGwgJiYgaW5pdC5kdXBsZXggPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXF1ZXN0SW5pdDogZHVwbGV4IG9wdGlvbiBpcyByZXF1aXJlZCB3aGVuIHNlbmRpbmcgYSBib2R5LicpXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIG1vZGUgaXMgbmVpdGhlciBcInNhbWUtb3JpZ2luXCIgbm9yIFwiY29yc1wiLFxuICAgICAgLy8gdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChyZXF1ZXN0Lm1vZGUgIT09ICdzYW1lLW9yaWdpbicgJiYgcmVxdWVzdC5tb2RlICE9PSAnY29ycycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnSWYgcmVxdWVzdCBpcyBtYWRlIGZyb20gUmVhZGFibGVTdHJlYW0sIG1vZGUgc2hvdWxkIGJlIFwic2FtZS1vcmlnaW5cIiBvciBcImNvcnNcIidcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBTZXQgdGhpc+KAmXMgcmVxdWVzdOKAmXMgdXNlLUNPUlMtcHJlZmxpZ2h0IGZsYWcuXG4gICAgICByZXF1ZXN0LnVzZUNPUlNQcmVmbGlnaHRGbGFnID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIDM5LiBMZXQgZmluYWxCb2R5IGJlIGlucHV0T3JJbml0Qm9keS5cbiAgICBsZXQgZmluYWxCb2R5ID0gaW5wdXRPckluaXRCb2R5XG5cbiAgICAvLyA0MC4gSWYgaW5pdEJvZHkgaXMgbnVsbCBhbmQgaW5wdXRCb2R5IGlzIG5vbi1udWxsLCB0aGVuOlxuICAgIGlmIChpbml0Qm9keSA9PSBudWxsICYmIGlucHV0Qm9keSAhPSBudWxsKSB7XG4gICAgICAvLyAxLiBJZiBpbnB1dCBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmICh1dGlsLmlzRGlzdHVyYmVkKGlucHV0Qm9keS5zdHJlYW0pIHx8IGlucHV0Qm9keS5zdHJlYW0ubG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBjb25zdHJ1Y3QgYSBSZXF1ZXN0IHdpdGggYSBSZXF1ZXN0IG9iamVjdCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gdXNlZC4nXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IGZpbmFsQm9keSB0byB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgcHJveHkgZm9yIGlucHV0Qm9keS5cbiAgICAgIGlmICghVHJhbnNmb3JtU3RyZWFtKSB7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbS93ZWInKS5UcmFuc2Zvcm1TdHJlYW1cbiAgICAgIH1cblxuICAgICAgLy8gaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW0tY3JlYXRlLWEtcHJveHlcbiAgICAgIGNvbnN0IGlkZW50aXR5VHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpXG4gICAgICBpbnB1dEJvZHkuc3RyZWFtLnBpcGVUaHJvdWdoKGlkZW50aXR5VHJhbnNmb3JtKVxuICAgICAgZmluYWxCb2R5ID0ge1xuICAgICAgICBzb3VyY2U6IGlucHV0Qm9keS5zb3VyY2UsXG4gICAgICAgIGxlbmd0aDogaW5wdXRCb2R5Lmxlbmd0aCxcbiAgICAgICAgc3RyZWFtOiBpZGVudGl0eVRyYW5zZm9ybS5yZWFkYWJsZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQxLiBTZXQgdGhpc+KAmXMgcmVxdWVzdOKAmXMgYm9keSB0byBmaW5hbEJvZHkuXG4gICAgdGhpc1trU3RhdGVdLmJvZHkgPSBmaW5hbEJvZHlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVxdWVzdOKAmXMgSFRUUCBtZXRob2QsIHdoaWNoIGlzIFwiR0VUXCIgYnkgZGVmYXVsdC5cbiAgZ2V0IG1ldGhvZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBtZXRob2QgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgbWV0aG9kLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubWV0aG9kXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBVUkwgb2YgcmVxdWVzdCBhcyBhIHN0cmluZy5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSB1cmwgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgVVJMLCBzZXJpYWxpemVkLlxuICAgIHJldHVybiBVUkxTZXJpYWxpemVyKHRoaXNba1N0YXRlXS51cmwpXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgSGVhZGVycyBvYmplY3QgY29uc2lzdGluZyBvZiB0aGUgaGVhZGVycyBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdC5cbiAgLy8gTm90ZSB0aGF0IGhlYWRlcnMgYWRkZWQgaW4gdGhlIG5ldHdvcmsgbGF5ZXIgYnkgdGhlIHVzZXIgYWdlbnQgd2lsbCBub3RcbiAgLy8gYmUgYWNjb3VudGVkIGZvciBpbiB0aGlzIG9iamVjdCwgZS5nLiwgdGhlIFwiSG9zdFwiIGhlYWRlci5cbiAgZ2V0IGhlYWRlcnMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaGVhZGVycyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBoZWFkZXJzLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzXVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUga2luZCBvZiByZXNvdXJjZSByZXF1ZXN0ZWQgYnkgcmVxdWVzdCwgZS5nLiwgXCJkb2N1bWVudFwiXG4gIC8vIG9yIFwic2NyaXB0XCIuXG4gIGdldCBkZXN0aW5hdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBkZXN0aW5hdGlvbiBnZXR0ZXIgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbi5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmRlc3RpbmF0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSByZWZlcnJlciBvZiByZXF1ZXN0LiBJdHMgdmFsdWUgY2FuIGJlIGEgc2FtZS1vcmlnaW4gVVJMIGlmXG4gIC8vIGV4cGxpY2l0bHkgc2V0IGluIGluaXQsIHRoZSBlbXB0eSBzdHJpbmcgdG8gaW5kaWNhdGUgbm8gcmVmZXJyZXIsIGFuZFxuICAvLyBcImFib3V0OmNsaWVudFwiIHdoZW4gZGVmYXVsdGluZyB0byB0aGUgZ2xvYmFs4oCZcyBkZWZhdWx0LiBUaGlzIGlzIHVzZWRcbiAgLy8gZHVyaW5nIGZldGNoaW5nIHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgdGhlIGBSZWZlcmVyYCBoZWFkZXIgb2YgdGhlXG4gIC8vIHJlcXVlc3QgYmVpbmcgbWFkZS5cbiAgZ2V0IHJlZmVycmVyICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gMS4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgXCJuby1yZWZlcnJlclwiLCB0aGVuIHJldHVybiB0aGVcbiAgICAvLyBlbXB0eSBzdHJpbmcuXG4gICAgaWYgKHRoaXNba1N0YXRlXS5yZWZlcnJlciA9PT0gJ25vLXJlZmVycmVyJykge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgXCJjbGllbnRcIiwgdGhlbiByZXR1cm5cbiAgICAvLyBcImFib3V0OmNsaWVudFwiLlxuICAgIGlmICh0aGlzW2tTdGF0ZV0ucmVmZXJyZXIgPT09ICdjbGllbnQnKSB7XG4gICAgICByZXR1cm4gJ2Fib3V0OmNsaWVudCdcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIsIHNlcmlhbGl6ZWQuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWZlcnJlci50b1N0cmluZygpXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSByZWZlcnJlciBwb2xpY3kgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QuXG4gIC8vIFRoaXMgaXMgdXNlZCBkdXJpbmcgZmV0Y2hpbmcgdG8gY29tcHV0ZSB0aGUgdmFsdWUgb2YgdGhlIHJlcXVlc3TigJlzXG4gIC8vIHJlZmVycmVyLlxuICBnZXQgcmVmZXJyZXJQb2xpY3kgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgcmVmZXJyZXJQb2xpY3kgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5LlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVmZXJyZXJQb2xpY3lcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmdcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCB3aWxsIHVzZSBDT1JTLCBvciB3aWxsIGJlIHJlc3RyaWN0ZWQgdG8gc2FtZS1vcmlnaW5cbiAgLy8gVVJMcy5cbiAgZ2V0IG1vZGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgbW9kZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubW9kZVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgY3JlZGVudGlhbHMgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCxcbiAgLy8gd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZyB3aGV0aGVyIGNyZWRlbnRpYWxzIHdpbGwgYmUgc2VudCB3aXRoIHRoZVxuICAvLyByZXF1ZXN0IGFsd2F5cywgbmV2ZXIsIG9yIG9ubHkgd2hlbiBzZW50IHRvIGEgc2FtZS1vcmlnaW4gVVJMLlxuICBnZXQgY3JlZGVudGlhbHMgKCkge1xuICAgIC8vIFRoZSBjcmVkZW50aWFscyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uY3JlZGVudGlhbHNcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGNhY2hlIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsXG4gIC8vIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmcgaG93IHRoZSByZXF1ZXN0IHdpbGxcbiAgLy8gaW50ZXJhY3Qgd2l0aCB0aGUgYnJvd3NlcuKAmXMgY2FjaGUgd2hlbiBmZXRjaGluZy5cbiAgZ2V0IGNhY2hlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGNhY2hlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5jYWNoZVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVkaXJlY3QgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCxcbiAgLy8gd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZyBob3cgcmVkaXJlY3RzIGZvciB0aGVcbiAgLy8gcmVxdWVzdCB3aWxsIGJlIGhhbmRsZWQgZHVyaW5nIGZldGNoaW5nLiBBIHJlcXVlc3RcbiAgLy8gd2lsbCBmb2xsb3cgcmVkaXJlY3RzIGJ5IGRlZmF1bHQuXG4gIGdldCByZWRpcmVjdCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSByZWRpcmVjdCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVkaXJlY3RcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVxdWVzdOKAmXMgc3VicmVzb3VyY2UgaW50ZWdyaXR5IG1ldGFkYXRhLCB3aGljaCBpcyBhXG4gIC8vIGNyeXB0b2dyYXBoaWMgaGFzaCBvZiB0aGUgcmVzb3VyY2UgYmVpbmcgZmV0Y2hlZC4gSXRzIHZhbHVlXG4gIC8vIGNvbnNpc3RzIG9mIG11bHRpcGxlIGhhc2hlcyBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZS4gW1NSSV1cbiAgZ2V0IGludGVncml0eSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpbnRlZ3JpdHkgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgaW50ZWdyaXR5XG4gICAgLy8gbWV0YWRhdGEuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5pbnRlZ3JpdHlcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBjYW4gb3V0bGl2ZSB0aGVcbiAgLy8gZ2xvYmFsIGluIHdoaWNoIGl0IHdhcyBjcmVhdGVkLlxuICBnZXQga2VlcGFsaXZlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGtlZXBhbGl2ZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBrZWVwYWxpdmUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5rZWVwYWxpdmVcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBpcyBmb3IgYSByZWxvYWRcbiAgLy8gbmF2aWdhdGlvbi5cbiAgZ2V0IGlzUmVsb2FkTmF2aWdhdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpc1JlbG9hZE5hdmlnYXRpb24gZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZc1xuICAgIC8vIHJlcXVlc3TigJlzIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcgaXMgc2V0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWxvYWROYXZpZ2F0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaXMgZm9yIGEgaGlzdG9yeVxuICAvLyBuYXZpZ2F0aW9uIChhLmsuYS4gYmFjay1mb3dhcmQgbmF2aWdhdGlvbikuXG4gIGdldCBpc0hpc3RvcnlOYXZpZ2F0aW9uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGlzSGlzdG9yeU5hdmlnYXRpb24gZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZcyByZXF1ZXN04oCZc1xuICAgIC8vIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnIGlzIHNldDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uaGlzdG9yeU5hdmlnYXRpb25cbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHNpZ25hbCBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCwgd2hpY2ggaXMgYW4gQWJvcnRTaWduYWxcbiAgLy8gb2JqZWN0IGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBhbmQgaXRzXG4gIC8vIGFib3J0IGV2ZW50IGhhbmRsZXIuXG4gIGdldCBzaWduYWwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgc2lnbmFsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHNpZ25hbC5cbiAgICByZXR1cm4gdGhpc1trU2lnbmFsXVxuICB9XG5cbiAgZ2V0IGJvZHkgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJvZHkgPyB0aGlzW2tTdGF0ZV0uYm9keS5zdHJlYW0gOiBudWxsXG4gIH1cblxuICBnZXQgYm9keVVzZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICByZXR1cm4gISF0aGlzW2tTdGF0ZV0uYm9keSAmJiB1dGlsLmlzRGlzdHVyYmVkKHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSlcbiAgfVxuXG4gIGdldCBkdXBsZXggKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICByZXR1cm4gJ2hhbGYnXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgY2xvbmUgb2YgcmVxdWVzdC5cbiAgY2xvbmUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyAxLiBJZiB0aGlzIGlzIHVudXNhYmxlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh0aGlzLmJvZHlVc2VkIHx8IHRoaXMuYm9keT8ubG9ja2VkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnVzYWJsZScpXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IGNsb25lZFJlcXVlc3QgYmUgdGhlIHJlc3VsdCBvZiBjbG9uaW5nIHRoaXPigJlzIHJlcXVlc3QuXG4gICAgY29uc3QgY2xvbmVkUmVxdWVzdCA9IGNsb25lUmVxdWVzdCh0aGlzW2tTdGF0ZV0pXG5cbiAgICAvLyAzLiBMZXQgY2xvbmVkUmVxdWVzdE9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVxdWVzdCBvYmplY3QsXG4gICAgLy8gZ2l2ZW4gY2xvbmVkUmVxdWVzdCwgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCBjbG9uZWRSZXF1ZXN0T2JqZWN0ID0gbmV3IFJlcXVlc3Qoa0luaXQpXG4gICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrU3RhdGVdID0gY2xvbmVkUmVxdWVzdFxuICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba1JlYWxtXSA9IHRoaXNba1JlYWxtXVxuICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba0hlYWRlcnNdID0gbmV3IEhlYWRlcnMoKVxuICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSBjbG9uZWRSZXF1ZXN0LmhlYWRlcnNMaXN0XG4gICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9IHRoaXNba0hlYWRlcnNdW2tHdWFyZF1cbiAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gdGhpc1trSGVhZGVyc11ba1JlYWxtXVxuXG4gICAgLy8gNC4gTWFrZSBjbG9uZWRSZXF1ZXN0T2JqZWN04oCZcyBzaWduYWwgZm9sbG93IHRoaXPigJlzIHNpZ25hbC5cbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBhYy5hYm9ydCh0aGlzLnNpZ25hbC5yZWFzb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwuYWRkQWJvcnRMaXN0ZW5lcihcbiAgICAgICAgdGhpcy5zaWduYWwsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBhYy5hYm9ydCh0aGlzLnNpZ25hbC5yZWFzb24pXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG4gICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrU2lnbmFsXSA9IGFjLnNpZ25hbFxuXG4gICAgLy8gNC4gUmV0dXJuIGNsb25lZFJlcXVlc3RPYmplY3QuXG4gICAgcmV0dXJuIGNsb25lZFJlcXVlc3RPYmplY3RcbiAgfVxufVxuXG5taXhpbkJvZHkoUmVxdWVzdClcblxuZnVuY3Rpb24gbWFrZVJlcXVlc3QgKGluaXQpIHtcbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RzXG4gIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBsb2NhbFVSTHNPbmx5OiBmYWxzZSxcbiAgICB1bnNhZmVSZXF1ZXN0OiBmYWxzZSxcbiAgICBib2R5OiBudWxsLFxuICAgIGNsaWVudDogbnVsbCxcbiAgICByZXNlcnZlZENsaWVudDogbnVsbCxcbiAgICByZXBsYWNlc0NsaWVudElkOiAnJyxcbiAgICB3aW5kb3c6ICdjbGllbnQnLFxuICAgIGtlZXBhbGl2ZTogZmFsc2UsXG4gICAgc2VydmljZVdvcmtlcnM6ICdhbGwnLFxuICAgIGluaXRpYXRvcjogJycsXG4gICAgZGVzdGluYXRpb246ICcnLFxuICAgIHByaW9yaXR5OiBudWxsLFxuICAgIG9yaWdpbjogJ2NsaWVudCcsXG4gICAgcG9saWN5Q29udGFpbmVyOiAnY2xpZW50JyxcbiAgICByZWZlcnJlcjogJ2NsaWVudCcsXG4gICAgcmVmZXJyZXJQb2xpY3k6ICcnLFxuICAgIG1vZGU6ICduby1jb3JzJyxcbiAgICB1c2VDT1JTUHJlZmxpZ2h0RmxhZzogZmFsc2UsXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgdXNlQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgIGNhY2hlOiAnZGVmYXVsdCcsXG4gICAgcmVkaXJlY3Q6ICdmb2xsb3cnLFxuICAgIGludGVncml0eTogJycsXG4gICAgY3J5cHRvR3JhcGhpY3NOb25jZU1ldGFkYXRhOiAnJyxcbiAgICBwYXJzZXJNZXRhZGF0YTogJycsXG4gICAgcmVsb2FkTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgaGlzdG9yeU5hdmlnYXRpb246IGZhbHNlLFxuICAgIHVzZXJBY3RpdmF0aW9uOiBmYWxzZSxcbiAgICB0YWludGVkT3JpZ2luOiBmYWxzZSxcbiAgICByZWRpcmVjdENvdW50OiAwLFxuICAgIHJlc3BvbnNlVGFpbnRpbmc6ICdiYXNpYycsXG4gICAgcHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb246IGZhbHNlLFxuICAgIGRvbmU6IGZhbHNlLFxuICAgIHRpbWluZ0FsbG93RmFpbGVkOiBmYWxzZSxcbiAgICAuLi5pbml0LFxuICAgIGhlYWRlcnNMaXN0OiBpbml0LmhlYWRlcnNMaXN0XG4gICAgICA/IG5ldyBIZWFkZXJzTGlzdChpbml0LmhlYWRlcnNMaXN0KVxuICAgICAgOiBuZXcgSGVhZGVyc0xpc3QoKVxuICB9XG4gIHJlcXVlc3QudXJsID0gcmVxdWVzdC51cmxMaXN0WzBdXG4gIHJldHVybiByZXF1ZXN0XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJlcXVlc3QtY2xvbmVcbmZ1bmN0aW9uIGNsb25lUmVxdWVzdCAocmVxdWVzdCkge1xuICAvLyBUbyBjbG9uZSBhIHJlcXVlc3QgcmVxdWVzdCwgcnVuIHRoZXNlIHN0ZXBzOlxuXG4gIC8vIDEuIExldCBuZXdSZXF1ZXN0IGJlIGEgY29weSBvZiByZXF1ZXN0LCBleGNlcHQgZm9yIGl0cyBib2R5LlxuICBjb25zdCBuZXdSZXF1ZXN0ID0gbWFrZVJlcXVlc3QoeyAuLi5yZXF1ZXN0LCBib2R5OiBudWxsIH0pXG5cbiAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCwgc2V0IG5ld1JlcXVlc3TigJlzIGJvZHkgdG8gdGhlXG4gIC8vIHJlc3VsdCBvZiBjbG9uaW5nIHJlcXVlc3TigJlzIGJvZHkuXG4gIGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xuICAgIG5ld1JlcXVlc3QuYm9keSA9IGNsb25lQm9keShyZXF1ZXN0LmJvZHkpXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gbmV3UmVxdWVzdC5cbiAgcmV0dXJuIG5ld1JlcXVlc3Rcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVxdWVzdC5wcm90b3R5cGUsIHtcbiAgbWV0aG9kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhlYWRlcnM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZGlyZWN0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9uZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc2lnbmFsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkdXBsZXg6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlc3RpbmF0aW9uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBib2R5OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBib2R5VXNlZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaXNIaXN0b3J5TmF2aWdhdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaXNSZWxvYWROYXZpZ2F0aW9uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZWVwYWxpdmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGludGVncml0eToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2FjaGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNyZWRlbnRpYWxzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhdHRyaWJ1dGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZmVycmVyUG9saWN5OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWZlcnJlcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbW9kZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ1JlcXVlc3QnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG53ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0ID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgUmVxdWVzdFxuKVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGluZm9cbndlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHR5cGVvZiBWID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoVilcbiAgfVxuXG4gIGlmIChWIGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0KFYpXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLkFib3J0U2lnbmFsID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgQWJvcnRTaWduYWxcbilcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3Rpbml0XG53ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ21ldGhvZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdoZWFkZXJzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdib2R5JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcihcbiAgICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkJvZHlJbml0XG4gICAgKVxuICB9LFxuICB7XG4gICAga2V5OiAncmVmZXJyZXInLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdyZWZlcnJlclBvbGljeScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3JlZmVycmVyLXBvbGljeVxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlZmVycmVyUG9saWN5XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdtb2RlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yZXF1ZXN0LW1vZGVcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0TW9kZVxuICB9LFxuICB7XG4gICAga2V5OiAnY3JlZGVudGlhbHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0Y3JlZGVudGlhbHNcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSxcbiAge1xuICAgIGtleTogJ2NhY2hlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGNhY2hlXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdENhY2hlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdyZWRpcmVjdCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RyZWRpcmVjdFxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3RSZWRpcmVjdFxuICB9LFxuICB7XG4gICAga2V5OiAnaW50ZWdyaXR5JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAna2VlcGFsaXZlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW5cbiAgfSxcbiAge1xuICAgIGtleTogJ3NpZ25hbCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIoXG4gICAgICAoc2lnbmFsKSA9PiB3ZWJpZGwuY29udmVydGVycy5BYm9ydFNpZ25hbChcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICB7IHN0cmljdDogZmFsc2UgfVxuICAgICAgKVxuICAgIClcbiAgfSxcbiAge1xuICAgIGtleTogJ3dpbmRvdycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnlcbiAgfSxcbiAge1xuICAgIGtleTogJ2R1cGxleCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdER1cGxleFxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgUmVxdWVzdCwgbWFrZVJlcXVlc3QgfVxuIl0sIm5hbWVzIjpbImV4dHJhY3RCb2R5IiwibWl4aW5Cb2R5IiwiY2xvbmVCb2R5IiwicmVxdWlyZSIsIkhlYWRlcnMiLCJmaWxsIiwiZmlsbEhlYWRlcnMiLCJIZWFkZXJzTGlzdCIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwidXRpbCIsImlzVmFsaWRIVFRQVG9rZW4iLCJzYW1lT3JpZ2luIiwibm9ybWFsaXplTWV0aG9kIiwibWFrZVBvbGljeUNvbnRhaW5lciIsImZvcmJpZGRlbk1ldGhvZHNTZXQiLCJjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQiLCJyZWZlcnJlclBvbGljeSIsInJlcXVlc3RSZWRpcmVjdCIsInJlcXVlc3RNb2RlIiwicmVxdWVzdENyZWRlbnRpYWxzIiwicmVxdWVzdENhY2hlIiwicmVxdWVzdER1cGxleCIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJrSGVhZGVycyIsImtTaWduYWwiLCJrU3RhdGUiLCJrR3VhcmQiLCJrUmVhbG0iLCJ3ZWJpZGwiLCJnZXRHbG9iYWxPcmlnaW4iLCJVUkxTZXJpYWxpemVyIiwia0hlYWRlcnNMaXN0IiwiYXNzZXJ0IiwiZ2V0TWF4TGlzdGVuZXJzIiwic2V0TWF4TGlzdGVuZXJzIiwiZ2V0RXZlbnRMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiVHJhbnNmb3JtU3RyZWFtIiwiZ2xvYmFsVGhpcyIsImtJbml0IiwiU3ltYm9sIiwia0Fib3J0Q29udHJvbGxlciIsInJlcXVlc3RGaW5hbGl6ZXIiLCJzaWduYWwiLCJhYm9ydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJSZXF1ZXN0IiwiY29uc3RydWN0b3IiLCJpbnB1dCIsImluaXQiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiaGVhZGVyIiwiY29udmVydGVycyIsIlJlcXVlc3RJbmZvIiwiUmVxdWVzdEluaXQiLCJzZXR0aW5nc09iamVjdCIsImJhc2VVcmwiLCJvcmlnaW4iLCJwb2xpY3lDb250YWluZXIiLCJyZXF1ZXN0IiwiZmFsbGJhY2tNb2RlIiwicGFyc2VkVVJMIiwiVVJMIiwiZXJyIiwiVHlwZUVycm9yIiwiY2F1c2UiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwibWFrZVJlcXVlc3QiLCJ1cmxMaXN0Iiwid2luZG93IiwibmFtZSIsIm1ldGhvZCIsImhlYWRlcnNMaXN0IiwidW5zYWZlUmVxdWVzdCIsImNsaWVudCIsInByaW9yaXR5IiwicmVmZXJyZXIiLCJtb2RlIiwiY3JlZGVudGlhbHMiLCJjYWNoZSIsInJlZGlyZWN0IiwiaW50ZWdyaXR5Iiwia2VlcGFsaXZlIiwicmVsb2FkTmF2aWdhdGlvbiIsImhpc3RvcnlOYXZpZ2F0aW9uIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInVybCIsInVuZGVmaW5lZCIsInBhcnNlZFJlZmVycmVyIiwicHJvdG9jb2wiLCJob3N0bmFtZSIsImVycm9ycyIsImV4Y2VwdGlvbiIsIm1lc3NhZ2UiLCJTdHJpbmciLCJCb29sZWFuIiwiaGFzIiwidG9VcHBlckNhc2UiLCJhYyIsIkFib3J0Q29udHJvbGxlciIsImFib3J0ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVhc29uIiwiYWNSZWYiLCJXZWFrUmVmIiwiZGVyZWYiLCJhZGRBYm9ydExpc3RlbmVyIiwicmVnaXN0ZXIiLCJoZWFkZXJzIiwiY2xlYXIiLCJrZXkiLCJ2YWwiLCJhcHBlbmQiLCJpbnB1dEJvZHkiLCJib2R5IiwiaW5pdEJvZHkiLCJleHRyYWN0ZWRCb2R5IiwiY29udGVudFR5cGUiLCJjb250YWlucyIsImlucHV0T3JJbml0Qm9keSIsInNvdXJjZSIsImR1cGxleCIsInVzZUNPUlNQcmVmbGlnaHRGbGFnIiwiZmluYWxCb2R5IiwiaXNEaXN0dXJiZWQiLCJzdHJlYW0iLCJsb2NrZWQiLCJpZGVudGl0eVRyYW5zZm9ybSIsInBpcGVUaHJvdWdoIiwicmVhZGFibGUiLCJicmFuZENoZWNrIiwiZGVzdGluYXRpb24iLCJ0b1N0cmluZyIsImlzUmVsb2FkTmF2aWdhdGlvbiIsImlzSGlzdG9yeU5hdmlnYXRpb24iLCJib2R5VXNlZCIsImNsb25lIiwiY2xvbmVkUmVxdWVzdCIsImNsb25lUmVxdWVzdCIsImNsb25lZFJlcXVlc3RPYmplY3QiLCJsb2NhbFVSTHNPbmx5IiwicmVzZXJ2ZWRDbGllbnQiLCJyZXBsYWNlc0NsaWVudElkIiwic2VydmljZVdvcmtlcnMiLCJpbml0aWF0b3IiLCJ1c2VDcmVkZW50aWFscyIsImNyeXB0b0dyYXBoaWNzTm9uY2VNZXRhZGF0YSIsInBhcnNlck1ldGFkYXRhIiwidXNlckFjdGl2YXRpb24iLCJ0YWludGVkT3JpZ2luIiwicmVkaXJlY3RDb3VudCIsInJlc3BvbnNlVGFpbnRpbmciLCJwcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbiIsImRvbmUiLCJ0aW1pbmdBbGxvd0ZhaWxlZCIsIm5ld1JlcXVlc3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiYXR0cmlidXRlIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsImludGVyZmFjZUNvbnZlcnRlciIsIlYiLCJVU1ZTdHJpbmciLCJBYm9ydFNpZ25hbCIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJjb252ZXJ0ZXIiLCJCeXRlU3RyaW5nIiwiSGVhZGVyc0luaXQiLCJudWxsYWJsZUNvbnZlcnRlciIsIkJvZHlJbml0IiwiRE9NU3RyaW5nIiwiYWxsb3dlZFZhbHVlcyIsImJvb2xlYW4iLCJzdHJpY3QiLCJhbnkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/request.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/response.js":
/*!*******************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/response.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Headers, HeadersList, fill } = __webpack_require__(/*! ./headers */ \"(rsc)/../../node_modules/undici/lib/fetch/headers.js\");\nconst { extractBody, cloneBody, mixinBody } = __webpack_require__(/*! ./body */ \"(rsc)/../../node_modules/undici/lib/fetch/body.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { kEnumerableProperty } = util;\nconst { isValidReasonPhrase, isCancelled, isAborted, isBlobLike, serializeJavascriptValueToJSONString, isErrorLike, isomorphicEncode } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/fetch/util.js\");\nconst { redirectStatusSet, nullBodyStatus, DOMException } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/undici/lib/fetch/constants.js\");\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(rsc)/../../node_modules/undici/lib/fetch/formdata.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(rsc)/../../node_modules/undici/lib/fetch/global.js\");\nconst { URLSerializer } = __webpack_require__(/*! ./dataURL */ \"(rsc)/../../node_modules/undici/lib/fetch/dataURL.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { types } = __webpack_require__(/*! util */ \"util\");\nconst ReadableStream = globalThis.ReadableStream || (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\nconst textEncoder = new TextEncoder(\"utf-8\");\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n    // Creates network error Response.\n    static error() {\n        // TODO\n        const relevantRealm = {\n            settingsObject: {}\n        };\n        // The static error() method steps are to return the result of creating a\n        // Response object, given a new network error, \"immutable\", and thiss\n        // relevant Realm.\n        const responseObject = new Response();\n        responseObject[kState] = makeNetworkError();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        return responseObject;\n    }\n    // https://fetch.spec.whatwg.org/#dom-response-json\n    static json(data, init = {}) {\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Response.json\"\n        });\n        if (init !== null) {\n            init = webidl.converters.ResponseInit(init);\n        }\n        // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n        const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));\n        // 2. Let body be the result of extracting bytes.\n        const body = extractBody(bytes);\n        // 3. Let responseObject be the result of creating a Response object, given a new response,\n        //    \"response\", and thiss relevant Realm.\n        const relevantRealm = {\n            settingsObject: {}\n        };\n        const responseObject = new Response();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kGuard] = \"response\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n        initializeResponse(responseObject, init, {\n            body: body[0],\n            type: \"application/json\"\n        });\n        // 5. Return responseObject.\n        return responseObject;\n    }\n    // Creates a redirect Response that redirects to url with status status.\n    static redirect(url, status = 302) {\n        const relevantRealm = {\n            settingsObject: {}\n        };\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Response.redirect\"\n        });\n        url = webidl.converters.USVString(url);\n        status = webidl.converters[\"unsigned short\"](status);\n        // 1. Let parsedURL be the result of parsing url with current settings\n        // objects API base URL.\n        // 2. If parsedURL is failure, then throw a TypeError.\n        // TODO: base-URL?\n        let parsedURL;\n        try {\n            parsedURL = new URL(url, getGlobalOrigin());\n        } catch (err) {\n            throw Object.assign(new TypeError(\"Failed to parse URL from \" + url), {\n                cause: err\n            });\n        }\n        // 3. If status is not a redirect status, then throw a RangeError.\n        if (!redirectStatusSet.has(status)) {\n            throw new RangeError(\"Invalid status code \" + status);\n        }\n        // 4. Let responseObject be the result of creating a Response object,\n        // given a new response, \"immutable\", and thiss relevant Realm.\n        const responseObject = new Response();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        // 5. Set responseObjects responses status to status.\n        responseObject[kState].status = status;\n        // 6. Let value be parsedURL, serialized and isomorphic encoded.\n        const value = isomorphicEncode(URLSerializer(parsedURL));\n        // 7. Append `Location`/value to responseObjects responses header list.\n        responseObject[kState].headersList.append(\"location\", value);\n        // 8. Return responseObject.\n        return responseObject;\n    }\n    // https://fetch.spec.whatwg.org/#dom-response\n    constructor(body = null, init = {}){\n        if (body !== null) {\n            body = webidl.converters.BodyInit(body);\n        }\n        init = webidl.converters.ResponseInit(init);\n        // TODO\n        this[kRealm] = {\n            settingsObject: {}\n        };\n        // 1. Set thiss response to a new response.\n        this[kState] = makeResponse({});\n        // 2. Set thiss headers to a new Headers object with thiss relevant\n        // Realm, whose header list is thiss responses header list and guard\n        // is \"response\".\n        this[kHeaders] = new Headers();\n        this[kHeaders][kGuard] = \"response\";\n        this[kHeaders][kHeadersList] = this[kState].headersList;\n        this[kHeaders][kRealm] = this[kRealm];\n        // 3. Let bodyWithType be null.\n        let bodyWithType = null;\n        // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n        if (body != null) {\n            const [extractedBody, type] = extractBody(body);\n            bodyWithType = {\n                body: extractedBody,\n                type\n            };\n        }\n        // 5. Perform initialize a response given this, init, and bodyWithType.\n        initializeResponse(this, init, bodyWithType);\n    }\n    // Returns responses type, e.g., \"cors\".\n    get type() {\n        webidl.brandCheck(this, Response);\n        // The type getter steps are to return thiss responses type.\n        return this[kState].type;\n    }\n    // Returns responses URL, if it has one; otherwise the empty string.\n    get url() {\n        webidl.brandCheck(this, Response);\n        const urlList = this[kState].urlList;\n        // The url getter steps are to return the empty string if thiss\n        // responses URL is null; otherwise thiss responses URL,\n        // serialized with exclude fragment set to true.\n        const url = urlList[urlList.length - 1] ?? null;\n        if (url === null) {\n            return \"\";\n        }\n        return URLSerializer(url, true);\n    }\n    // Returns whether response was obtained through a redirect.\n    get redirected() {\n        webidl.brandCheck(this, Response);\n        // The redirected getter steps are to return true if thiss responses URL\n        // list has more than one item; otherwise false.\n        return this[kState].urlList.length > 1;\n    }\n    // Returns responses status.\n    get status() {\n        webidl.brandCheck(this, Response);\n        // The status getter steps are to return thiss responses status.\n        return this[kState].status;\n    }\n    // Returns whether responses status is an ok status.\n    get ok() {\n        webidl.brandCheck(this, Response);\n        // The ok getter steps are to return true if thiss responses status is an\n        // ok status; otherwise false.\n        return this[kState].status >= 200 && this[kState].status <= 299;\n    }\n    // Returns responses status message.\n    get statusText() {\n        webidl.brandCheck(this, Response);\n        // The statusText getter steps are to return thiss responses status\n        // message.\n        return this[kState].statusText;\n    }\n    // Returns responses headers as Headers.\n    get headers() {\n        webidl.brandCheck(this, Response);\n        // The headers getter steps are to return thiss headers.\n        return this[kHeaders];\n    }\n    get body() {\n        webidl.brandCheck(this, Response);\n        return this[kState].body ? this[kState].body.stream : null;\n    }\n    get bodyUsed() {\n        webidl.brandCheck(this, Response);\n        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n    // Returns a clone of response.\n    clone() {\n        webidl.brandCheck(this, Response);\n        // 1. If this is unusable, then throw a TypeError.\n        if (this.bodyUsed || this.body && this.body.locked) {\n            throw webidl.errors.exception({\n                header: \"Response.clone\",\n                message: \"Body has already been consumed.\"\n            });\n        }\n        // 2. Let clonedResponse be the result of cloning thiss response.\n        const clonedResponse = cloneResponse(this[kState]);\n        // 3. Return the result of creating a Response object, given\n        // clonedResponse, thiss headerss guard, and thiss relevant Realm.\n        const clonedResponseObject = new Response();\n        clonedResponseObject[kState] = clonedResponse;\n        clonedResponseObject[kRealm] = this[kRealm];\n        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;\n        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n        return clonedResponseObject;\n    }\n}\nmixinBody(Response);\nObject.defineProperties(Response.prototype, {\n    type: kEnumerableProperty,\n    url: kEnumerableProperty,\n    status: kEnumerableProperty,\n    ok: kEnumerableProperty,\n    redirected: kEnumerableProperty,\n    statusText: kEnumerableProperty,\n    headers: kEnumerableProperty,\n    clone: kEnumerableProperty,\n    body: kEnumerableProperty,\n    bodyUsed: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"Response\",\n        configurable: true\n    }\n});\nObject.defineProperties(Response, {\n    json: kEnumerableProperty,\n    redirect: kEnumerableProperty,\n    error: kEnumerableProperty\n});\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse(response) {\n    // To clone a response response, run these steps:\n    // 1. If response is a filtered response, then return a new identical\n    // filtered response whose internal response is a clone of responses\n    // internal response.\n    if (response.internalResponse) {\n        return filterResponse(cloneResponse(response.internalResponse), response.type);\n    }\n    // 2. Let newResponse be a copy of response, except for its body.\n    const newResponse = makeResponse({\n        ...response,\n        body: null\n    });\n    // 3. If responses body is non-null, then set newResponses body to the\n    // result of cloning responses body.\n    if (response.body != null) {\n        newResponse.body = cloneBody(response.body);\n    }\n    // 4. Return newResponse.\n    return newResponse;\n}\nfunction makeResponse(init) {\n    return {\n        aborted: false,\n        rangeRequested: false,\n        timingAllowPassed: false,\n        requestIncludesCredentials: false,\n        type: \"default\",\n        status: 200,\n        timingInfo: null,\n        cacheState: \"\",\n        statusText: \"\",\n        ...init,\n        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),\n        urlList: init.urlList ? [\n            ...init.urlList\n        ] : []\n    };\n}\nfunction makeNetworkError(reason) {\n    const isError = isErrorLike(reason);\n    return makeResponse({\n        type: \"error\",\n        status: 0,\n        error: isError ? reason : new Error(reason ? String(reason) : reason),\n        aborted: reason && reason.name === \"AbortError\"\n    });\n}\nfunction makeFilteredResponse(response, state) {\n    state = {\n        internalResponse: response,\n        ...state\n    };\n    return new Proxy(response, {\n        get (target, p) {\n            return p in state ? state[p] : target[p];\n        },\n        set (target, p, value) {\n            assert(!(p in state));\n            target[p] = value;\n            return true;\n        }\n    });\n}\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse(response, type) {\n    // Set response to the following filtered response with response as its\n    // internal response, depending on requests response tainting:\n    if (type === \"basic\") {\n        // A basic filtered response is a filtered response whose type is \"basic\"\n        // and header list excludes any headers in internal responses header list\n        // whose name is a forbidden response-header name.\n        // Note: undici does not implement forbidden response-header names\n        return makeFilteredResponse(response, {\n            type: \"basic\",\n            headersList: response.headersList\n        });\n    } else if (type === \"cors\") {\n        // A CORS filtered response is a filtered response whose type is \"cors\"\n        // and header list excludes any headers in internal responses header\n        // list whose name is not a CORS-safelisted response-header name, given\n        // internal responses CORS-exposed header-name list.\n        // Note: undici does not implement CORS-safelisted response-header names\n        return makeFilteredResponse(response, {\n            type: \"cors\",\n            headersList: response.headersList\n        });\n    } else if (type === \"opaque\") {\n        // An opaque filtered response is a filtered response whose type is\n        // \"opaque\", URL list is the empty list, status is 0, status message\n        // is the empty byte sequence, header list is empty, and body is null.\n        return makeFilteredResponse(response, {\n            type: \"opaque\",\n            urlList: Object.freeze([]),\n            status: 0,\n            statusText: \"\",\n            body: null\n        });\n    } else if (type === \"opaqueredirect\") {\n        // An opaque-redirect filtered response is a filtered response whose type\n        // is \"opaqueredirect\", status is 0, status message is the empty byte\n        // sequence, header list is empty, and body is null.\n        return makeFilteredResponse(response, {\n            type: \"opaqueredirect\",\n            status: 0,\n            statusText: \"\",\n            headersList: [],\n            body: null\n        });\n    } else {\n        assert(false);\n    }\n}\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError(fetchParams, err = null) {\n    // 1. Assert: fetchParams is canceled.\n    assert(isCancelled(fetchParams));\n    // 2. Return an aborted network error if fetchParams is aborted;\n    // otherwise return a network error.\n    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException(\"The operation was aborted.\", \"AbortError\"), {\n        cause: err\n    })) : makeNetworkError(Object.assign(new DOMException(\"Request was cancelled.\"), {\n        cause: err\n    }));\n}\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse(response, init, body) {\n    // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n    //    throw a RangeError.\n    if (init.status !== null && (init.status < 200 || init.status > 599)) {\n        throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.');\n    }\n    // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n    //    then throw a TypeError.\n    if (\"statusText\" in init && init.statusText != null) {\n        // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n        //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n        if (!isValidReasonPhrase(String(init.statusText))) {\n            throw new TypeError(\"Invalid statusText\");\n        }\n    }\n    // 3. Set responses responses status to init[\"status\"].\n    if (\"status\" in init && init.status != null) {\n        response[kState].status = init.status;\n    }\n    // 4. Set responses responses status message to init[\"statusText\"].\n    if (\"statusText\" in init && init.statusText != null) {\n        response[kState].statusText = init.statusText;\n    }\n    // 5. If init[\"headers\"] exists, then fill responses headers with init[\"headers\"].\n    if (\"headers\" in init && init.headers != null) {\n        fill(response[kHeaders], init.headers);\n    }\n    // 6. If body was given, then:\n    if (body) {\n        // 1. If response's status is a null body status, then throw a TypeError.\n        if (nullBodyStatus.includes(response.status)) {\n            throw webidl.errors.exception({\n                header: \"Response constructor\",\n                message: \"Invalid response status code \" + response.status\n            });\n        }\n        // 2. Set response's body to body's body.\n        response[kState].body = body.body;\n        // 3. If body's type is non-null and response's header list does not contain\n        //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n        if (body.type != null && !response[kState].headersList.contains(\"Content-Type\")) {\n            response[kState].headersList.append(\"content-type\", body.type);\n        }\n    }\n}\nwebidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);\nwebidl.converters.FormData = webidl.interfaceConverter(FormData);\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function(V) {\n    if (typeof V === \"string\") {\n        return webidl.converters.USVString(V);\n    }\n    if (isBlobLike(V)) {\n        return webidl.converters.Blob(V, {\n            strict: false\n        });\n    }\n    if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {\n        return webidl.converters.BufferSource(V);\n    }\n    if (util.isFormDataLike(V)) {\n        return webidl.converters.FormData(V, {\n            strict: false\n        });\n    }\n    if (V instanceof URLSearchParams) {\n        return webidl.converters.URLSearchParams(V);\n    }\n    return webidl.converters.DOMString(V);\n};\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function(V) {\n    if (V instanceof ReadableStream) {\n        return webidl.converters.ReadableStream(V);\n    }\n    // Note: the spec doesn't include async iterables,\n    // this is an undici extension.\n    if (V?.[Symbol.asyncIterator]) {\n        return V;\n    }\n    return webidl.converters.XMLHttpRequestBodyInit(V);\n};\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n    {\n        key: \"status\",\n        converter: webidl.converters[\"unsigned short\"],\n        defaultValue: 200\n    },\n    {\n        key: \"statusText\",\n        converter: webidl.converters.ByteString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"headers\",\n        converter: webidl.converters.HeadersInit\n    }\n]);\nmodule.exports = {\n    makeNetworkError,\n    makeResponse,\n    makeAppropriateNetworkError,\n    filterResponse,\n    Response,\n    cloneResponse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxJQUFJLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDL0MsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQ3RELE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUssbUJBQW1CLEVBQUUsR0FBR0Q7QUFDaEMsTUFBTSxFQUNKRSxtQkFBbUIsRUFDbkJDLFdBQVcsRUFDWEMsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLG9DQUFvQyxFQUNwQ0MsV0FBVyxFQUNYQyxnQkFBZ0IsRUFDakIsR0FBR1osbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQ0phLGlCQUFpQixFQUNqQkMsY0FBYyxFQUNkQyxZQUFZLEVBQ2IsR0FBR2YsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVnQixNQUFNLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR25CLG1CQUFPQSxDQUFDO0FBQ3JELE1BQU0sRUFBRW9CLE1BQU0sRUFBRSxHQUFHcEIsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFcUIsUUFBUSxFQUFFLEdBQUdyQixtQkFBT0EsQ0FBQztBQUM3QixNQUFNLEVBQUVzQixlQUFlLEVBQUUsR0FBR3RCLG1CQUFPQSxDQUFDO0FBQ3BDLE1BQU0sRUFBRXVCLGFBQWEsRUFBRSxHQUFHdkIsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFd0IsWUFBWSxFQUFFLEdBQUd4QixtQkFBT0EsQ0FBQztBQUNqQyxNQUFNeUIsU0FBU3pCLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRTBCLEtBQUssRUFBRSxHQUFHMUIsbUJBQU9BLENBQUM7QUFFMUIsTUFBTTJCLGlCQUFpQkMsV0FBV0Qs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MUM7Q0FDRDtBQUVEQyxPQUFPQyxPQUFPLEdBQUc7SUFDZnpHO0lBQ0FnQztJQUNBaUQ7SUFDQXJCO0lBQ0FqRTtJQUNBd0Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvcmVzcG9uc2UuanM/YjA0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBIZWFkZXJzLCBIZWFkZXJzTGlzdCwgZmlsbCB9ID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcbmNvbnN0IHsgZXh0cmFjdEJvZHksIGNsb25lQm9keSwgbWl4aW5Cb2R5IH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHV0aWxcbmNvbnN0IHtcbiAgaXNWYWxpZFJlYXNvblBocmFzZSxcbiAgaXNDYW5jZWxsZWQsXG4gIGlzQWJvcnRlZCxcbiAgaXNCbG9iTGlrZSxcbiAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nLFxuICBpc0Vycm9yTGlrZSxcbiAgaXNvbW9ycGhpY0VuY29kZVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7XG4gIHJlZGlyZWN0U3RhdHVzU2V0LFxuICBudWxsQm9keVN0YXR1cyxcbiAgRE9NRXhjZXB0aW9uXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBrU3RhdGUsIGtIZWFkZXJzLCBrR3VhcmQsIGtSZWFsbSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IEZvcm1EYXRhIH0gPSByZXF1aXJlKCcuL2Zvcm1kYXRhJylcbmNvbnN0IHsgZ2V0R2xvYmFsT3JpZ2luIH0gPSByZXF1aXJlKCcuL2dsb2JhbCcpXG5jb25zdCB7IFVSTFNlcmlhbGl6ZXIgfSA9IHJlcXVpcmUoJy4vZGF0YVVSTCcpXG5jb25zdCB7IGtIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IHR5cGVzIH0gPSByZXF1aXJlKCd1dGlsJylcblxuY29uc3QgUmVhZGFibGVTdHJlYW0gPSBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtIHx8IHJlcXVpcmUoJ3N0cmVhbS93ZWInKS5SZWFkYWJsZVN0cmVhbVxuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04JylcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3Jlc3BvbnNlLWNsYXNzXG5jbGFzcyBSZXNwb25zZSB7XG4gIC8vIENyZWF0ZXMgbmV0d29yayBlcnJvciBSZXNwb25zZS5cbiAgc3RhdGljIGVycm9yICgpIHtcbiAgICAvLyBUT0RPXG4gICAgY29uc3QgcmVsZXZhbnRSZWFsbSA9IHsgc2V0dGluZ3NPYmplY3Q6IHt9IH1cblxuICAgIC8vIFRoZSBzdGF0aWMgZXJyb3IoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFcbiAgICAvLyBSZXNwb25zZSBvYmplY3QsIGdpdmVuIGEgbmV3IG5ldHdvcmsgZXJyb3IsIFwiaW1tdXRhYmxlXCIsIGFuZCB0aGlz4oCZc1xuICAgIC8vIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gbmV3IFJlc3BvbnNlKClcbiAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdID0gbWFrZU5ldHdvcmtFcnJvcigpXG4gICAgcmVzcG9uc2VPYmplY3Rba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0uaGVhZGVyc0xpc3RcbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9ICdpbW11dGFibGUnXG4gICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tSZWFsbV0gPSByZWxldmFudFJlYWxtXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlc3BvbnNlLWpzb25cbiAgc3RhdGljIGpzb24gKGRhdGEsIGluaXQgPSB7fSkge1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdSZXNwb25zZS5qc29uJyB9KVxuXG4gICAgaWYgKGluaXQgIT09IG51bGwpIHtcbiAgICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQoaW5pdClcbiAgICB9XG5cbiAgICAvLyAxLiBMZXQgYnl0ZXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHNlcmlhbGl6ZSBhIEphdmFTY3JpcHQgdmFsdWUgdG8gSlNPTiBieXRlcyBvbiBkYXRhLlxuICAgIGNvbnN0IGJ5dGVzID0gdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nKGRhdGEpXG4gICAgKVxuXG4gICAgLy8gMi4gTGV0IGJvZHkgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGJ5dGVzLlxuICAgIGNvbnN0IGJvZHkgPSBleHRyYWN0Qm9keShieXRlcylcblxuICAgIC8vIDMuIExldCByZXNwb25zZU9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LCBnaXZlbiBhIG5ldyByZXNwb25zZSxcbiAgICAvLyAgICBcInJlc3BvbnNlXCIsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCByZWxldmFudFJlYWxtID0geyBzZXR0aW5nc09iamVjdDoge30gfVxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gbmV3IFJlc3BvbnNlKClcbiAgICByZXNwb25zZU9iamVjdFtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbVxuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gJ3Jlc3BvbnNlJ1xuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbVxuXG4gICAgLy8gNC4gUGVyZm9ybSBpbml0aWFsaXplIGEgcmVzcG9uc2UgZ2l2ZW4gcmVzcG9uc2VPYmplY3QsIGluaXQsIGFuZCAoYm9keSwgXCJhcHBsaWNhdGlvbi9qc29uXCIpLlxuICAgIGluaXRpYWxpemVSZXNwb25zZShyZXNwb25zZU9iamVjdCwgaW5pdCwgeyBib2R5OiBib2R5WzBdLCB0eXBlOiAnYXBwbGljYXRpb24vanNvbicgfSlcblxuICAgIC8vIDUuIFJldHVybiByZXNwb25zZU9iamVjdC5cbiAgICByZXR1cm4gcmVzcG9uc2VPYmplY3RcbiAgfVxuXG4gIC8vIENyZWF0ZXMgYSByZWRpcmVjdCBSZXNwb25zZSB0aGF0IHJlZGlyZWN0cyB0byB1cmwgd2l0aCBzdGF0dXMgc3RhdHVzLlxuICBzdGF0aWMgcmVkaXJlY3QgKHVybCwgc3RhdHVzID0gMzAyKSB7XG4gICAgY29uc3QgcmVsZXZhbnRSZWFsbSA9IHsgc2V0dGluZ3NPYmplY3Q6IHt9IH1cblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdSZXNwb25zZS5yZWRpcmVjdCcgfSlcblxuICAgIHVybCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh1cmwpXG4gICAgc3RhdHVzID0gd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10oc3RhdHVzKVxuXG4gICAgLy8gMS4gTGV0IHBhcnNlZFVSTCBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdXJsIHdpdGggY3VycmVudCBzZXR0aW5nc1xuICAgIC8vIG9iamVjdOKAmXMgQVBJIGJhc2UgVVJMLlxuICAgIC8vIDIuIElmIHBhcnNlZFVSTCBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIC8vIFRPRE86IGJhc2UtVVJMP1xuICAgIGxldCBwYXJzZWRVUkxcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVVJMID0gbmV3IFVSTCh1cmwsIGdldEdsb2JhbE9yaWdpbigpKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gcGFyc2UgVVJMIGZyb20gJyArIHVybCksIHtcbiAgICAgICAgY2F1c2U6IGVyclxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAzLiBJZiBzdGF0dXMgaXMgbm90IGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuIHRocm93IGEgUmFuZ2VFcnJvci5cbiAgICBpZiAoIXJlZGlyZWN0U3RhdHVzU2V0LmhhcyhzdGF0dXMpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZSAnICsgc3RhdHVzKVxuICAgIH1cblxuICAgIC8vIDQuIExldCByZXNwb25zZU9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LFxuICAgIC8vIGdpdmVuIGEgbmV3IHJlc3BvbnNlLCBcImltbXV0YWJsZVwiLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBuZXcgUmVzcG9uc2UoKVxuICAgIHJlc3BvbnNlT2JqZWN0W2tSZWFsbV0gPSByZWxldmFudFJlYWxtXG4gICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSAnaW1tdXRhYmxlJ1xuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbVxuXG4gICAgLy8gNS4gU2V0IHJlc3BvbnNlT2JqZWN04oCZcyByZXNwb25zZeKAmXMgc3RhdHVzIHRvIHN0YXR1cy5cbiAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdLnN0YXR1cyA9IHN0YXR1c1xuXG4gICAgLy8gNi4gTGV0IHZhbHVlIGJlIHBhcnNlZFVSTCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICAgIGNvbnN0IHZhbHVlID0gaXNvbW9ycGhpY0VuY29kZShVUkxTZXJpYWxpemVyKHBhcnNlZFVSTCkpXG5cbiAgICAvLyA3LiBBcHBlbmQgYExvY2F0aW9uYC92YWx1ZSB0byByZXNwb25zZU9iamVjdOKAmXMgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0uaGVhZGVyc0xpc3QuYXBwZW5kKCdsb2NhdGlvbicsIHZhbHVlKVxuXG4gICAgLy8gOC4gUmV0dXJuIHJlc3BvbnNlT2JqZWN0LlxuICAgIHJldHVybiByZXNwb25zZU9iamVjdFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXNwb25zZVxuICBjb25zdHJ1Y3RvciAoYm9keSA9IG51bGwsIGluaXQgPSB7fSkge1xuICAgIGlmIChib2R5ICE9PSBudWxsKSB7XG4gICAgICBib2R5ID0gd2ViaWRsLmNvbnZlcnRlcnMuQm9keUluaXQoYm9keSlcbiAgICB9XG5cbiAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2VJbml0KGluaXQpXG5cbiAgICAvLyBUT0RPXG4gICAgdGhpc1trUmVhbG1dID0geyBzZXR0aW5nc09iamVjdDoge30gfVxuXG4gICAgLy8gMS4gU2V0IHRoaXPigJlzIHJlc3BvbnNlIHRvIGEgbmV3IHJlc3BvbnNlLlxuICAgIHRoaXNba1N0YXRlXSA9IG1ha2VSZXNwb25zZSh7fSlcblxuICAgIC8vIDIuIFNldCB0aGlz4oCZcyBoZWFkZXJzIHRvIGEgbmV3IEhlYWRlcnMgb2JqZWN0IHdpdGggdGhpc+KAmXMgcmVsZXZhbnRcbiAgICAvLyBSZWFsbSwgd2hvc2UgaGVhZGVyIGxpc3QgaXMgdGhpc+KAmXMgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0IGFuZCBndWFyZFxuICAgIC8vIGlzIFwicmVzcG9uc2VcIi5cbiAgICB0aGlzW2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKClcbiAgICB0aGlzW2tIZWFkZXJzXVtrR3VhcmRdID0gJ3Jlc3BvbnNlJ1xuICAgIHRoaXNba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSB0aGlzW2tTdGF0ZV0uaGVhZGVyc0xpc3RcbiAgICB0aGlzW2tIZWFkZXJzXVtrUmVhbG1dID0gdGhpc1trUmVhbG1dXG5cbiAgICAvLyAzLiBMZXQgYm9keVdpdGhUeXBlIGJlIG51bGwuXG4gICAgbGV0IGJvZHlXaXRoVHlwZSA9IG51bGxcblxuICAgIC8vIDQuIElmIGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gc2V0IGJvZHlXaXRoVHlwZSB0byB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgYm9keS5cbiAgICBpZiAoYm9keSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBbZXh0cmFjdGVkQm9keSwgdHlwZV0gPSBleHRyYWN0Qm9keShib2R5KVxuICAgICAgYm9keVdpdGhUeXBlID0geyBib2R5OiBleHRyYWN0ZWRCb2R5LCB0eXBlIH1cbiAgICB9XG5cbiAgICAvLyA1LiBQZXJmb3JtIGluaXRpYWxpemUgYSByZXNwb25zZSBnaXZlbiB0aGlzLCBpbml0LCBhbmQgYm9keVdpdGhUeXBlLlxuICAgIGluaXRpYWxpemVSZXNwb25zZSh0aGlzLCBpbml0LCBib2R5V2l0aFR5cGUpXG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyB0eXBlLCBlLmcuLCBcImNvcnNcIi5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIHR5cGUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVzcG9uc2XigJlzIHR5cGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS50eXBlXG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyBVUkwsIGlmIGl0IGhhcyBvbmU7IG90aGVyd2lzZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBnZXQgdXJsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIGNvbnN0IHVybExpc3QgPSB0aGlzW2tTdGF0ZV0udXJsTGlzdFxuXG4gICAgLy8gVGhlIHVybCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nIGlmIHRoaXPigJlzXG4gICAgLy8gcmVzcG9uc2XigJlzIFVSTCBpcyBudWxsOyBvdGhlcndpc2UgdGhpc+KAmXMgcmVzcG9uc2XigJlzIFVSTCxcbiAgICAvLyBzZXJpYWxpemVkIHdpdGggZXhjbHVkZSBmcmFnbWVudCBzZXQgdG8gdHJ1ZS5cbiAgICBjb25zdCB1cmwgPSB1cmxMaXN0W3VybExpc3QubGVuZ3RoIC0gMV0gPz8gbnVsbFxuXG4gICAgaWYgKHVybCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIFVSTFNlcmlhbGl6ZXIodXJsLCB0cnVlKVxuICB9XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIHJlc3BvbnNlIHdhcyBvYnRhaW5lZCB0aHJvdWdoIGEgcmVkaXJlY3QuXG4gIGdldCByZWRpcmVjdGVkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSByZWRpcmVjdGVkIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVzcG9uc2XigJlzIFVSTFxuICAgIC8vIGxpc3QgaGFzIG1vcmUgdGhhbiBvbmUgaXRlbTsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0udXJsTGlzdC5sZW5ndGggPiAxXG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyBzdGF0dXMuXG4gIGdldCBzdGF0dXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIHN0YXR1cyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uc3RhdHVzXG4gIH1cblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhbiBvayBzdGF0dXMuXG4gIGdldCBvayAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgb2sgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzIGlzIGFuXG4gICAgLy8gb2sgc3RhdHVzOyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5zdGF0dXMgPj0gMjAwICYmIHRoaXNba1N0YXRlXS5zdGF0dXMgPD0gMjk5XG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyBzdGF0dXMgbWVzc2FnZS5cbiAgZ2V0IHN0YXR1c1RleHQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIHN0YXR1c1RleHQgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVzcG9uc2XigJlzIHN0YXR1c1xuICAgIC8vIG1lc3NhZ2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5zdGF0dXNUZXh0XG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyBoZWFkZXJzIGFzIEhlYWRlcnMuXG4gIGdldCBoZWFkZXJzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSBoZWFkZXJzIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIGhlYWRlcnMuXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNdXG4gIH1cblxuICBnZXQgYm9keSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJvZHkgPyB0aGlzW2tTdGF0ZV0uYm9keS5zdHJlYW0gOiBudWxsXG4gIH1cblxuICBnZXQgYm9keVVzZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgcmV0dXJuICEhdGhpc1trU3RhdGVdLmJvZHkgJiYgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzW2tTdGF0ZV0uYm9keS5zdHJlYW0pXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgY2xvbmUgb2YgcmVzcG9uc2UuXG4gIGNsb25lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIDEuIElmIHRoaXMgaXMgdW51c2FibGUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHRoaXMuYm9keVVzZWQgfHwgKHRoaXMuYm9keSAmJiB0aGlzLmJvZHkubG9ja2VkKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdSZXNwb25zZS5jbG9uZScsXG4gICAgICAgIG1lc3NhZ2U6ICdCb2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgY2xvbmVkUmVzcG9uc2UgYmUgdGhlIHJlc3VsdCBvZiBjbG9uaW5nIHRoaXPigJlzIHJlc3BvbnNlLlxuICAgIGNvbnN0IGNsb25lZFJlc3BvbnNlID0gY2xvbmVSZXNwb25zZSh0aGlzW2tTdGF0ZV0pXG5cbiAgICAvLyAzLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCwgZ2l2ZW5cbiAgICAvLyBjbG9uZWRSZXNwb25zZSwgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCBjbG9uZWRSZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpXG4gICAgY2xvbmVkUmVzcG9uc2VPYmplY3Rba1N0YXRlXSA9IGNsb25lZFJlc3BvbnNlXG4gICAgY2xvbmVkUmVzcG9uc2VPYmplY3Rba1JlYWxtXSA9IHRoaXNba1JlYWxtXVxuICAgIGNsb25lZFJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gY2xvbmVkUmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICBjbG9uZWRSZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9IHRoaXNba0hlYWRlcnNdW2tHdWFyZF1cbiAgICBjbG9uZWRSZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba1JlYWxtXSA9IHRoaXNba0hlYWRlcnNdW2tSZWFsbV1cblxuICAgIHJldHVybiBjbG9uZWRSZXNwb25zZU9iamVjdFxuICB9XG59XG5cbm1peGluQm9keShSZXNwb25zZSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UucHJvdG90eXBlLCB7XG4gIHR5cGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHVybDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc3RhdHVzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvazoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVkaXJlY3RlZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc3RhdHVzVGV4dDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGVhZGVyczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvbmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJvZHk6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJvZHlVc2VkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnUmVzcG9uc2UnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZSwge1xuICBqc29uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJlc3BvbnNlLWNsb25lXG5mdW5jdGlvbiBjbG9uZVJlc3BvbnNlIChyZXNwb25zZSkge1xuICAvLyBUbyBjbG9uZSBhIHJlc3BvbnNlIHJlc3BvbnNlLCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSwgdGhlbiByZXR1cm4gYSBuZXcgaWRlbnRpY2FsXG4gIC8vIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIGludGVybmFsIHJlc3BvbnNlIGlzIGEgY2xvbmUgb2YgcmVzcG9uc2XigJlzXG4gIC8vIGludGVybmFsIHJlc3BvbnNlLlxuICBpZiAocmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSkge1xuICAgIHJldHVybiBmaWx0ZXJSZXNwb25zZShcbiAgICAgIGNsb25lUmVzcG9uc2UocmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSksXG4gICAgICByZXNwb25zZS50eXBlXG4gICAgKVxuICB9XG5cbiAgLy8gMi4gTGV0IG5ld1Jlc3BvbnNlIGJlIGEgY29weSBvZiByZXNwb25zZSwgZXhjZXB0IGZvciBpdHMgYm9keS5cbiAgY29uc3QgbmV3UmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoeyAuLi5yZXNwb25zZSwgYm9keTogbnVsbCB9KVxuXG4gIC8vIDMuIElmIHJlc3BvbnNl4oCZcyBib2R5IGlzIG5vbi1udWxsLCB0aGVuIHNldCBuZXdSZXNwb25zZeKAmXMgYm9keSB0byB0aGVcbiAgLy8gcmVzdWx0IG9mIGNsb25pbmcgcmVzcG9uc2XigJlzIGJvZHkuXG4gIGlmIChyZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICBuZXdSZXNwb25zZS5ib2R5ID0gY2xvbmVCb2R5KHJlc3BvbnNlLmJvZHkpXG4gIH1cblxuICAvLyA0LiBSZXR1cm4gbmV3UmVzcG9uc2UuXG4gIHJldHVybiBuZXdSZXNwb25zZVxufVxuXG5mdW5jdGlvbiBtYWtlUmVzcG9uc2UgKGluaXQpIHtcbiAgcmV0dXJuIHtcbiAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICByYW5nZVJlcXVlc3RlZDogZmFsc2UsXG4gICAgdGltaW5nQWxsb3dQYXNzZWQ6IGZhbHNlLFxuICAgIHJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICB0eXBlOiAnZGVmYXVsdCcsXG4gICAgc3RhdHVzOiAyMDAsXG4gICAgdGltaW5nSW5mbzogbnVsbCxcbiAgICBjYWNoZVN0YXRlOiAnJyxcbiAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAuLi5pbml0LFxuICAgIGhlYWRlcnNMaXN0OiBpbml0LmhlYWRlcnNMaXN0XG4gICAgICA/IG5ldyBIZWFkZXJzTGlzdChpbml0LmhlYWRlcnNMaXN0KVxuICAgICAgOiBuZXcgSGVhZGVyc0xpc3QoKSxcbiAgICB1cmxMaXN0OiBpbml0LnVybExpc3QgPyBbLi4uaW5pdC51cmxMaXN0XSA6IFtdXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZU5ldHdvcmtFcnJvciAocmVhc29uKSB7XG4gIGNvbnN0IGlzRXJyb3IgPSBpc0Vycm9yTGlrZShyZWFzb24pXG4gIHJldHVybiBtYWtlUmVzcG9uc2Uoe1xuICAgIHR5cGU6ICdlcnJvcicsXG4gICAgc3RhdHVzOiAwLFxuICAgIGVycm9yOiBpc0Vycm9yXG4gICAgICA/IHJlYXNvblxuICAgICAgOiBuZXcgRXJyb3IocmVhc29uID8gU3RyaW5nKHJlYXNvbikgOiByZWFzb24pLFxuICAgIGFib3J0ZWQ6IHJlYXNvbiAmJiByZWFzb24ubmFtZSA9PT0gJ0Fib3J0RXJyb3InXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1ha2VGaWx0ZXJlZFJlc3BvbnNlIChyZXNwb25zZSwgc3RhdGUpIHtcbiAgc3RhdGUgPSB7XG4gICAgaW50ZXJuYWxSZXNwb25zZTogcmVzcG9uc2UsXG4gICAgLi4uc3RhdGVcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJveHkocmVzcG9uc2UsIHtcbiAgICBnZXQgKHRhcmdldCwgcCkge1xuICAgICAgcmV0dXJuIHAgaW4gc3RhdGUgPyBzdGF0ZVtwXSA6IHRhcmdldFtwXVxuICAgIH0sXG4gICAgc2V0ICh0YXJnZXQsIHAsIHZhbHVlKSB7XG4gICAgICBhc3NlcnQoIShwIGluIHN0YXRlKSlcbiAgICAgIHRhcmdldFtwXSA9IHZhbHVlXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZmlsdGVyZWQtcmVzcG9uc2VcbmZ1bmN0aW9uIGZpbHRlclJlc3BvbnNlIChyZXNwb25zZSwgdHlwZSkge1xuICAvLyBTZXQgcmVzcG9uc2UgdG8gdGhlIGZvbGxvd2luZyBmaWx0ZXJlZCByZXNwb25zZSB3aXRoIHJlc3BvbnNlIGFzIGl0c1xuICAvLyBpbnRlcm5hbCByZXNwb25zZSwgZGVwZW5kaW5nIG9uIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nOlxuICBpZiAodHlwZSA9PT0gJ2Jhc2ljJykge1xuICAgIC8vIEEgYmFzaWMgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlIGlzIFwiYmFzaWNcIlxuICAgIC8vIGFuZCBoZWFkZXIgbGlzdCBleGNsdWRlcyBhbnkgaGVhZGVycyBpbiBpbnRlcm5hbCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3RcbiAgICAvLyB3aG9zZSBuYW1lIGlzIGEgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLlxuXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWVzXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnYmFzaWMnLFxuICAgICAgaGVhZGVyc0xpc3Q6IHJlc3BvbnNlLmhlYWRlcnNMaXN0XG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnY29ycycpIHtcbiAgICAvLyBBIENPUlMgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlIGlzIFwiY29yc1wiXG4gICAgLy8gYW5kIGhlYWRlciBsaXN0IGV4Y2x1ZGVzIGFueSBoZWFkZXJzIGluIGludGVybmFsIHJlc3BvbnNl4oCZcyBoZWFkZXJcbiAgICAvLyBsaXN0IHdob3NlIG5hbWUgaXMgbm90IGEgQ09SUy1zYWZlbGlzdGVkIHJlc3BvbnNlLWhlYWRlciBuYW1lLCBnaXZlblxuICAgIC8vIGludGVybmFsIHJlc3BvbnNl4oCZcyBDT1JTLWV4cG9zZWQgaGVhZGVyLW5hbWUgbGlzdC5cblxuICAgIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgQ09SUy1zYWZlbGlzdGVkIHJlc3BvbnNlLWhlYWRlciBuYW1lc1xuICAgIHJldHVybiBtYWtlRmlsdGVyZWRSZXNwb25zZShyZXNwb25zZSwge1xuICAgICAgdHlwZTogJ2NvcnMnLFxuICAgICAgaGVhZGVyc0xpc3Q6IHJlc3BvbnNlLmhlYWRlcnNMaXN0XG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb3BhcXVlJykge1xuICAgIC8vIEFuIG9wYXF1ZSBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXNcbiAgICAvLyBcIm9wYXF1ZVwiLCBVUkwgbGlzdCBpcyB0aGUgZW1wdHkgbGlzdCwgc3RhdHVzIGlzIDAsIHN0YXR1cyBtZXNzYWdlXG4gICAgLy8gaXMgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UsIGhlYWRlciBsaXN0IGlzIGVtcHR5LCBhbmQgYm9keSBpcyBudWxsLlxuXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnb3BhcXVlJyxcbiAgICAgIHVybExpc3Q6IE9iamVjdC5mcmVlemUoW10pLFxuICAgICAgc3RhdHVzOiAwLFxuICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICBib2R5OiBudWxsXG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb3BhcXVlcmVkaXJlY3QnKSB7XG4gICAgLy8gQW4gb3BhcXVlLXJlZGlyZWN0IGZpbHRlcmVkIHJlc3BvbnNlIGlzIGEgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgdHlwZVxuICAgIC8vIGlzIFwib3BhcXVlcmVkaXJlY3RcIiwgc3RhdHVzIGlzIDAsIHN0YXR1cyBtZXNzYWdlIGlzIHRoZSBlbXB0eSBieXRlXG4gICAgLy8gc2VxdWVuY2UsIGhlYWRlciBsaXN0IGlzIGVtcHR5LCBhbmQgYm9keSBpcyBudWxsLlxuXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnb3BhcXVlcmVkaXJlY3QnLFxuICAgICAgc3RhdHVzOiAwLFxuICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICBoZWFkZXJzTGlzdDogW10sXG4gICAgICBib2R5OiBudWxsXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoZmFsc2UpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2FwcHJvcHJpYXRlLW5ldHdvcmstZXJyb3JcbmZ1bmN0aW9uIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvciAoZmV0Y2hQYXJhbXMsIGVyciA9IG51bGwpIHtcbiAgLy8gMS4gQXNzZXJ0OiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZC5cbiAgYXNzZXJ0KGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSlcblxuICAvLyAyLiBSZXR1cm4gYW4gYWJvcnRlZCBuZXR3b3JrIGVycm9yIGlmIGZldGNoUGFyYW1zIGlzIGFib3J0ZWQ7XG4gIC8vIG90aGVyd2lzZSByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICByZXR1cm4gaXNBYm9ydGVkKGZldGNoUGFyYW1zKVxuICAgID8gbWFrZU5ldHdvcmtFcnJvcihPYmplY3QuYXNzaWduKG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSwgeyBjYXVzZTogZXJyIH0pKVxuICAgIDogbWFrZU5ldHdvcmtFcnJvcihPYmplY3QuYXNzaWduKG5ldyBET01FeGNlcHRpb24oJ1JlcXVlc3Qgd2FzIGNhbmNlbGxlZC4nKSwgeyBjYXVzZTogZXJyIH0pKVxufVxuXG4vLyBodHRwczovL3doYXRwci5vcmcvZmV0Y2gvMTM5Mi5odG1sI2luaXRpYWxpemUtYS1yZXNwb25zZVxuZnVuY3Rpb24gaW5pdGlhbGl6ZVJlc3BvbnNlIChyZXNwb25zZSwgaW5pdCwgYm9keSkge1xuICAvLyAxLiBJZiBpbml0W1wic3RhdHVzXCJdIGlzIG5vdCBpbiB0aGUgcmFuZ2UgMjAwIHRvIDU5OSwgaW5jbHVzaXZlLCB0aGVuXG4gIC8vICAgIHRocm93IGEgUmFuZ2VFcnJvci5cbiAgaWYgKGluaXQuc3RhdHVzICE9PSBudWxsICYmIChpbml0LnN0YXR1cyA8IDIwMCB8fCBpbml0LnN0YXR1cyA+IDU5OSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5pdFtcInN0YXR1c1wiXSBtdXN0IGJlIGluIHRoZSByYW5nZSBvZiAyMDAgdG8gNTk5LCBpbmNsdXNpdmUuJylcbiAgfVxuXG4gIC8vIDIuIElmIGluaXRbXCJzdGF0dXNUZXh0XCJdIGRvZXMgbm90IG1hdGNoIHRoZSByZWFzb24tcGhyYXNlIHRva2VuIHByb2R1Y3Rpb24sXG4gIC8vICAgIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmICgnc3RhdHVzVGV4dCcgaW4gaW5pdCAmJiBpbml0LnN0YXR1c1RleHQgIT0gbnVsbCkge1xuICAgIC8vIFNlZSwgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4xLjI6XG4gICAgLy8gICByZWFzb24tcGhyYXNlICA9ICooIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVxuICAgIGlmICghaXNWYWxpZFJlYXNvblBocmFzZShTdHJpbmcoaW5pdC5zdGF0dXNUZXh0KSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RhdHVzVGV4dCcpXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gU2V0IHJlc3BvbnNl4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzIHRvIGluaXRbXCJzdGF0dXNcIl0uXG4gIGlmICgnc3RhdHVzJyBpbiBpbml0ICYmIGluaXQuc3RhdHVzICE9IG51bGwpIHtcbiAgICByZXNwb25zZVtrU3RhdGVdLnN0YXR1cyA9IGluaXQuc3RhdHVzXG4gIH1cblxuICAvLyA0LiBTZXQgcmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgbWVzc2FnZSB0byBpbml0W1wic3RhdHVzVGV4dFwiXS5cbiAgaWYgKCdzdGF0dXNUZXh0JyBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgcmVzcG9uc2Vba1N0YXRlXS5zdGF0dXNUZXh0ID0gaW5pdC5zdGF0dXNUZXh0XG4gIH1cblxuICAvLyA1LiBJZiBpbml0W1wiaGVhZGVyc1wiXSBleGlzdHMsIHRoZW4gZmlsbCByZXNwb25zZeKAmXMgaGVhZGVycyB3aXRoIGluaXRbXCJoZWFkZXJzXCJdLlxuICBpZiAoJ2hlYWRlcnMnIGluIGluaXQgJiYgaW5pdC5oZWFkZXJzICE9IG51bGwpIHtcbiAgICBmaWxsKHJlc3BvbnNlW2tIZWFkZXJzXSwgaW5pdC5oZWFkZXJzKVxuICB9XG5cbiAgLy8gNi4gSWYgYm9keSB3YXMgZ2l2ZW4sIHRoZW46XG4gIGlmIChib2R5KSB7XG4gICAgLy8gMS4gSWYgcmVzcG9uc2UncyBzdGF0dXMgaXMgYSBudWxsIGJvZHkgc3RhdHVzLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChudWxsQm9keVN0YXR1cy5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1Jlc3BvbnNlIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1c1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBTZXQgcmVzcG9uc2UncyBib2R5IHRvIGJvZHkncyBib2R5LlxuICAgIHJlc3BvbnNlW2tTdGF0ZV0uYm9keSA9IGJvZHkuYm9keVxuXG4gICAgLy8gMy4gSWYgYm9keSdzIHR5cGUgaXMgbm9uLW51bGwgYW5kIHJlc3BvbnNlJ3MgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpblxuICAgIC8vICAgIGBDb250ZW50LVR5cGVgLCB0aGVuIGFwcGVuZCAoYENvbnRlbnQtVHlwZWAsIGJvZHkncyB0eXBlKSB0byByZXNwb25zZSdzIGhlYWRlciBsaXN0LlxuICAgIGlmIChib2R5LnR5cGUgIT0gbnVsbCAmJiAhcmVzcG9uc2Vba1N0YXRlXS5oZWFkZXJzTGlzdC5jb250YWlucygnQ29udGVudC1UeXBlJykpIHtcbiAgICAgIHJlc3BvbnNlW2tTdGF0ZV0uaGVhZGVyc0xpc3QuYXBwZW5kKCdjb250ZW50LXR5cGUnLCBib2R5LnR5cGUpXG4gICAgfVxuICB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlYWRhYmxlU3RyZWFtID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgUmVhZGFibGVTdHJlYW1cbilcblxud2ViaWRsLmNvbnZlcnRlcnMuRm9ybURhdGEgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBGb3JtRGF0YVxuKVxuXG53ZWJpZGwuY29udmVydGVycy5VUkxTZWFyY2hQYXJhbXMgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBVUkxTZWFyY2hQYXJhbXNcbilcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3R5cGVkZWZkZWYteG1saHR0cHJlcXVlc3Rib2R5aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuWE1MSHR0cFJlcXVlc3RCb2R5SW5pdCA9IGZ1bmN0aW9uIChWKSB7XG4gIGlmICh0eXBlb2YgViA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpXG4gIH1cblxuICBpZiAoaXNCbG9iTGlrZShWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CbG9iKFYsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICB9XG5cbiAgaWYgKFxuICAgIHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoVikgfHxcbiAgICB0eXBlcy5pc1R5cGVkQXJyYXkoVikgfHxcbiAgICB0eXBlcy5pc0RhdGFWaWV3KFYpXG4gICkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CdWZmZXJTb3VyY2UoVilcbiAgfVxuXG4gIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkZvcm1EYXRhKFYsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICB9XG5cbiAgaWYgKFYgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVJMU2VhcmNoUGFyYW1zKFYpXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuQm9keUluaXQgPSBmdW5jdGlvbiAoVikge1xuICBpZiAoViBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlJlYWRhYmxlU3RyZWFtKFYpXG4gIH1cblxuICAvLyBOb3RlOiB0aGUgc3BlYyBkb2Vzbid0IGluY2x1ZGUgYXN5bmMgaXRlcmFibGVzLFxuICAvLyB0aGlzIGlzIGFuIHVuZGljaSBleHRlbnNpb24uXG4gIGlmIChWPy5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgcmV0dXJuIFZcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5YTUxIdHRwUmVxdWVzdEJvZHlJbml0KFYpXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ3N0YXR1cycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXSxcbiAgICBkZWZhdWx0VmFsdWU6IDIwMFxuICB9LFxuICB7XG4gICAga2V5OiAnc3RhdHVzVGV4dCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2hlYWRlcnMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXRcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1ha2VOZXR3b3JrRXJyb3IsXG4gIG1ha2VSZXNwb25zZSxcbiAgbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yLFxuICBmaWx0ZXJSZXNwb25zZSxcbiAgUmVzcG9uc2UsXG4gIGNsb25lUmVzcG9uc2Vcbn1cbiJdLCJuYW1lcyI6WyJIZWFkZXJzIiwiSGVhZGVyc0xpc3QiLCJmaWxsIiwicmVxdWlyZSIsImV4dHJhY3RCb2R5IiwiY2xvbmVCb2R5IiwibWl4aW5Cb2R5IiwidXRpbCIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJpc1ZhbGlkUmVhc29uUGhyYXNlIiwiaXNDYW5jZWxsZWQiLCJpc0Fib3J0ZWQiLCJpc0Jsb2JMaWtlIiwic2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nIiwiaXNFcnJvckxpa2UiLCJpc29tb3JwaGljRW5jb2RlIiwicmVkaXJlY3RTdGF0dXNTZXQiLCJudWxsQm9keVN0YXR1cyIsIkRPTUV4Y2VwdGlvbiIsImtTdGF0ZSIsImtIZWFkZXJzIiwia0d1YXJkIiwia1JlYWxtIiwid2ViaWRsIiwiRm9ybURhdGEiLCJnZXRHbG9iYWxPcmlnaW4iLCJVUkxTZXJpYWxpemVyIiwia0hlYWRlcnNMaXN0IiwiYXNzZXJ0IiwidHlwZXMiLCJSZWFkYWJsZVN0cmVhbSIsImdsb2JhbFRoaXMiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwiUmVzcG9uc2UiLCJlcnJvciIsInJlbGV2YW50UmVhbG0iLCJzZXR0aW5nc09iamVjdCIsInJlc3BvbnNlT2JqZWN0IiwibWFrZU5ldHdvcmtFcnJvciIsImhlYWRlcnNMaXN0IiwianNvbiIsImRhdGEiLCJpbml0IiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsImhlYWRlciIsImNvbnZlcnRlcnMiLCJSZXNwb25zZUluaXQiLCJieXRlcyIsImVuY29kZSIsImJvZHkiLCJpbml0aWFsaXplUmVzcG9uc2UiLCJ0eXBlIiwicmVkaXJlY3QiLCJ1cmwiLCJzdGF0dXMiLCJVU1ZTdHJpbmciLCJwYXJzZWRVUkwiLCJVUkwiLCJlcnIiLCJPYmplY3QiLCJhc3NpZ24iLCJUeXBlRXJyb3IiLCJjYXVzZSIsImhhcyIsIlJhbmdlRXJyb3IiLCJ2YWx1ZSIsImFwcGVuZCIsImNvbnN0cnVjdG9yIiwiQm9keUluaXQiLCJtYWtlUmVzcG9uc2UiLCJib2R5V2l0aFR5cGUiLCJleHRyYWN0ZWRCb2R5IiwiYnJhbmRDaGVjayIsInVybExpc3QiLCJsZW5ndGgiLCJyZWRpcmVjdGVkIiwib2siLCJzdGF0dXNUZXh0IiwiaGVhZGVycyIsInN0cmVhbSIsImJvZHlVc2VkIiwiaXNEaXN0dXJiZWQiLCJjbG9uZSIsImxvY2tlZCIsImVycm9ycyIsImV4Y2VwdGlvbiIsIm1lc3NhZ2UiLCJjbG9uZWRSZXNwb25zZSIsImNsb25lUmVzcG9uc2UiLCJjbG9uZWRSZXNwb25zZU9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImNvbmZpZ3VyYWJsZSIsInJlc3BvbnNlIiwiaW50ZXJuYWxSZXNwb25zZSIsImZpbHRlclJlc3BvbnNlIiwibmV3UmVzcG9uc2UiLCJhYm9ydGVkIiwicmFuZ2VSZXF1ZXN0ZWQiLCJ0aW1pbmdBbGxvd1Bhc3NlZCIsInJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzIiwidGltaW5nSW5mbyIsImNhY2hlU3RhdGUiLCJyZWFzb24iLCJpc0Vycm9yIiwiRXJyb3IiLCJTdHJpbmciLCJuYW1lIiwibWFrZUZpbHRlcmVkUmVzcG9uc2UiLCJzdGF0ZSIsIlByb3h5IiwiZ2V0IiwidGFyZ2V0IiwicCIsInNldCIsImZyZWV6ZSIsIm1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvciIsImZldGNoUGFyYW1zIiwiaW5jbHVkZXMiLCJjb250YWlucyIsImludGVyZmFjZUNvbnZlcnRlciIsIlVSTFNlYXJjaFBhcmFtcyIsIlhNTEh0dHBSZXF1ZXN0Qm9keUluaXQiLCJWIiwiQmxvYiIsInN0cmljdCIsImlzQW55QXJyYXlCdWZmZXIiLCJpc1R5cGVkQXJyYXkiLCJpc0RhdGFWaWV3IiwiQnVmZmVyU291cmNlIiwiaXNGb3JtRGF0YUxpa2UiLCJET01TdHJpbmciLCJhc3luY0l0ZXJhdG9yIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImtleSIsImNvbnZlcnRlciIsImRlZmF1bHRWYWx1ZSIsIkJ5dGVTdHJpbmciLCJIZWFkZXJzSW5pdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/response.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/symbols.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    kUrl: Symbol(\"url\"),\n    kHeaders: Symbol(\"headers\"),\n    kSignal: Symbol(\"signal\"),\n    kState: Symbol(\"state\"),\n    kGuard: Symbol(\"guard\"),\n    kRealm: Symbol(\"realm\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsTUFBTUMsT0FBTztJQUNiQyxVQUFVRCxPQUFPO0lBQ2pCRSxTQUFTRixPQUFPO0lBQ2hCRyxRQUFRSCxPQUFPO0lBQ2ZJLFFBQVFKLE9BQU87SUFDZkssUUFBUUwsT0FBTztBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvc3ltYm9scy5qcz83ZDk2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga1VybDogU3ltYm9sKCd1cmwnKSxcbiAga0hlYWRlcnM6IFN5bWJvbCgnaGVhZGVycycpLFxuICBrU2lnbmFsOiBTeW1ib2woJ3NpZ25hbCcpLFxuICBrU3RhdGU6IFN5bWJvbCgnc3RhdGUnKSxcbiAga0d1YXJkOiBTeW1ib2woJ2d1YXJkJyksXG4gIGtSZWFsbTogU3ltYm9sKCdyZWFsbScpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtVcmwiLCJTeW1ib2wiLCJrSGVhZGVycyIsImtTaWduYWwiLCJrU3RhdGUiLCJrR3VhcmQiLCJrUmVhbG0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/symbols.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/util.js":
/*!***************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/undici/lib/fetch/constants.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(rsc)/../../node_modules/undici/lib/fetch/global.js\");\nconst { performance } = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\nconst { isBlobLike, toUSVString, ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { isUint8Array } = __webpack_require__(/*! util/types */ \"util/types\");\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n} catch  {}\nfunction responseURL(response) {\n    // https://fetch.spec.whatwg.org/#responses\n    // A response has an associated URL. It is a pointer to the last URL\n    // in responses URL list and null if responses URL list is empty.\n    const urlList = response.urlList;\n    const length = urlList.length;\n    return length === 0 ? null : urlList[length - 1].toString();\n}\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL(response, requestFragment) {\n    // 1. If responses status is not a redirect status, then return null.\n    if (!redirectStatusSet.has(response.status)) {\n        return null;\n    }\n    // 2. Let location be the result of extracting header list values given\n    // `Location` and responses header list.\n    let location = response.headersList.get(\"location\");\n    // 3. If location is a header value, then set location to the result of\n    //    parsing location with responses URL.\n    if (location !== null && isValidHeaderValue(location)) {\n        location = new URL(location, responseURL(response));\n    }\n    // 4. If location is a URL whose fragment is null, then set locations\n    // fragment to requestFragment.\n    if (location && !location.hash) {\n        location.hash = requestFragment;\n    }\n    // 5. Return location.\n    return location;\n}\n/** @returns {URL} */ function requestCurrentURL(request) {\n    return request.urlList[request.urlList.length - 1];\n}\nfunction requestBadPort(request) {\n    // 1. Let url be requests current URL.\n    const url = requestCurrentURL(request);\n    // 2. If urls scheme is an HTTP(S) scheme and urls port is a bad port,\n    // then return blocked.\n    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n        return \"blocked\";\n    }\n    // 3. Return allowed.\n    return \"allowed\";\n}\nfunction isErrorLike(object) {\n    return object instanceof Error || object?.constructor?.name === \"Error\" || object?.constructor?.name === \"DOMException\";\n}\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase(statusText) {\n    for(let i = 0; i < statusText.length; ++i){\n        const c = statusText.charCodeAt(i);\n        if (!(c === 0x09 || // HTAB\n        c >= 0x20 && c <= 0x7e || // SP / VCHAR\n        c >= 0x80 && c <= 0xff // obs-text\n        )) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isTokenChar(c) {\n    return !(c >= 0x7f || c <= 0x20 || c === \"(\" || c === \")\" || c === \"<\" || c === \">\" || c === \"@\" || c === \",\" || c === \";\" || c === \":\" || c === \"\\\\\" || c === '\"' || c === \"/\" || c === \"[\" || c === \"]\" || c === \"?\" || c === \"=\" || c === \"{\" || c === \"}\");\n}\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken(characters) {\n    if (!characters || typeof characters !== \"string\") {\n        return false;\n    }\n    for(let i = 0; i < characters.length; ++i){\n        const c = characters.charCodeAt(i);\n        if (c > 0x7f || !isTokenChar(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n// https://fetch.spec.whatwg.org/#header-name\n// https://github.com/chromium/chromium/blob/b3d37e6f94f87d59e44662d6078f6a12de845d17/net/http/http_util.cc#L342\nfunction isValidHeaderName(potentialValue) {\n    if (potentialValue.length === 0) {\n        return false;\n    }\n    return isValidHTTPToken(potentialValue);\n}\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */ function isValidHeaderValue(potentialValue) {\n    // - Has no leading or trailing HTTP tab or space bytes.\n    // - Contains no 0x00 (NUL) or HTTP newline bytes.\n    if (potentialValue.startsWith(\"\t\") || potentialValue.startsWith(\" \") || potentialValue.endsWith(\"\t\") || potentialValue.endsWith(\" \")) {\n        return false;\n    }\n    if (potentialValue.includes(\"\\x00\") || potentialValue.includes(\"\\r\") || potentialValue.includes(\"\\n\")) {\n        return false;\n    }\n    return true;\n}\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n    //  Given a request request and a response actualResponse, this algorithm\n    //  updates requests referrer policy according to the Referrer-Policy\n    //  header (if any) in actualResponse.\n    // 1. Let policy be the result of executing  8.1 Parse a referrer policy\n    // from a Referrer-Policy header on actualResponse.\n    // 8.1 Parse a referrer policy from a Referrer-Policy header\n    // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and responses header list.\n    const { headersList } = actualResponse;\n    // 2. Let policy be the empty string.\n    // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n    // 4. Return policy.\n    const policyHeader = (headersList.get(\"referrer-policy\") ?? \"\").split(\",\");\n    // Note: As the referrer-policy can contain multiple policies\n    // separated by comma, we need to loop through all of them\n    // and pick the first valid one.\n    // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n    let policy = \"\";\n    if (policyHeader.length > 0) {\n        // The right-most policy takes precedence.\n        // The left-most policy is the fallback.\n        for(let i = policyHeader.length; i !== 0; i--){\n            const token = policyHeader[i - 1].trim();\n            if (referrerPolicyTokens.has(token)) {\n                policy = token;\n                break;\n            }\n        }\n    }\n    // 2. If policy is not the empty string, then set requests referrer policy to policy.\n    if (policy !== \"\") {\n        request.referrerPolicy = policy;\n    }\n}\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck() {\n    // TODO\n    return \"allowed\";\n}\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck() {\n    // TODO\n    return \"success\";\n}\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck() {\n    // TODO\n    return \"success\";\n}\nfunction appendFetchMetadata(httpRequest) {\n    //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n    //  TODO\n    //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n    //  1. Assert: rs url is a potentially trustworthy URL.\n    //  TODO\n    //  2. Let header be a Structured Header whose value is a token.\n    let header = null;\n    //  3. Set headers value to rs mode.\n    header = httpRequest.mode;\n    //  4. Set a structured field value `Sec-Fetch-Mode`/header in rs header list.\n    httpRequest.headersList.set(\"sec-fetch-mode\", header);\n//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n//  TODO\n//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n//  TODO\n}\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader(request) {\n    // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n    let serializedOrigin = request.origin;\n    // 2. If requests response tainting is \"cors\" or requests mode is \"websocket\", then append (`Origin`, serializedOrigin) to requests header list.\n    if (request.responseTainting === \"cors\" || request.mode === \"websocket\") {\n        if (serializedOrigin) {\n            request.headersList.append(\"origin\", serializedOrigin);\n        }\n    // 3. Otherwise, if requests method is neither `GET` nor `HEAD`, then:\n    } else if (request.method !== \"GET\" && request.method !== \"HEAD\") {\n        // 1. Switch on requests referrer policy:\n        switch(request.referrerPolicy){\n            case \"no-referrer\":\n                // Set serializedOrigin to `null`.\n                serializedOrigin = null;\n                break;\n            case \"no-referrer-when-downgrade\":\n            case \"strict-origin\":\n            case \"strict-origin-when-cross-origin\":\n                // If requests origin is a tuple origin, its scheme is \"https\", and requests current URLs scheme is not \"https\", then set serializedOrigin to `null`.\n                if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n                    serializedOrigin = null;\n                }\n                break;\n            case \"same-origin\":\n                // If requests origin is not same origin with requests current URLs origin, then set serializedOrigin to `null`.\n                if (!sameOrigin(request, requestCurrentURL(request))) {\n                    serializedOrigin = null;\n                }\n                break;\n            default:\n        }\n        if (serializedOrigin) {\n            // 2. Append (`Origin`, serializedOrigin) to requests header list.\n            request.headersList.append(\"origin\", serializedOrigin);\n        }\n    }\n}\nfunction coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n    // TODO\n    return performance.now();\n}\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo(timingInfo) {\n    return {\n        startTime: timingInfo.startTime ?? 0,\n        redirectStartTime: 0,\n        redirectEndTime: 0,\n        postRedirectStartTime: timingInfo.startTime ?? 0,\n        finalServiceWorkerStartTime: 0,\n        finalNetworkResponseStartTime: 0,\n        finalNetworkRequestStartTime: 0,\n        endTime: 0,\n        encodedBodySize: 0,\n        decodedBodySize: 0,\n        finalConnectionTimingInfo: null\n    };\n}\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer() {\n    // Note: the fetch spec doesn't make use of embedder policy or CSP list\n    return {\n        referrerPolicy: \"strict-origin-when-cross-origin\"\n    };\n}\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer(policyContainer) {\n    return {\n        referrerPolicy: policyContainer.referrerPolicy\n    };\n}\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer(request) {\n    // 1. Let policy be request's referrer policy.\n    const policy = request.referrerPolicy;\n    // Note: policy cannot (shouldn't) be null or an empty string.\n    assert(policy);\n    // 2. Let environment be requests client.\n    let referrerSource = null;\n    // 3. Switch on requests referrer:\n    if (request.referrer === \"client\") {\n        // Note: node isn't a browser and doesn't implement document/iframes,\n        // so we bypass this step and replace it with our own.\n        const globalOrigin = getGlobalOrigin();\n        if (!globalOrigin || globalOrigin.origin === \"null\") {\n            return \"no-referrer\";\n        }\n        // note: we need to clone it as it's mutated\n        referrerSource = new URL(globalOrigin);\n    } else if (request.referrer instanceof URL) {\n        // Let referrerSource be requests referrer.\n        referrerSource = request.referrer;\n    }\n    // 4. Let requests referrerURL be the result of stripping referrerSource for\n    //    use as a referrer.\n    let referrerURL = stripURLForReferrer(referrerSource);\n    // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n    //    a referrer, with the origin-only flag set to true.\n    const referrerOrigin = stripURLForReferrer(referrerSource, true);\n    // 6. If the result of serializing referrerURL is a string whose length is\n    //    greater than 4096, set referrerURL to referrerOrigin.\n    if (referrerURL.toString().length > 4096) {\n        referrerURL = referrerOrigin;\n    }\n    const areSameOrigin = sameOrigin(request, referrerURL);\n    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);\n    // 8. Execute the switch statements corresponding to the value of policy:\n    switch(policy){\n        case \"origin\":\n            return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);\n        case \"unsafe-url\":\n            return referrerURL;\n        case \"same-origin\":\n            return areSameOrigin ? referrerOrigin : \"no-referrer\";\n        case \"origin-when-cross-origin\":\n            return areSameOrigin ? referrerURL : referrerOrigin;\n        case \"strict-origin-when-cross-origin\":\n            {\n                const currentURL = requestCurrentURL(request);\n                // 1. If the origin of referrerURL and the origin of requests current\n                //    URL are the same, then return referrerURL.\n                if (sameOrigin(referrerURL, currentURL)) {\n                    return referrerURL;\n                }\n                // 2. If referrerURL is a potentially trustworthy URL and requests\n                //    current URL is not a potentially trustworthy URL, then return no\n                //    referrer.\n                if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n                    return \"no-referrer\";\n                }\n                // 3. Return referrerOrigin.\n                return referrerOrigin;\n            }\n        case \"strict-origin\":\n        /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * requests current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */ case \"no-referrer-when-downgrade\":\n        /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * requests current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */ default:\n            return isNonPotentiallyTrustWorthy ? \"no-referrer\" : referrerOrigin;\n    }\n}\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */ function stripURLForReferrer(url, originOnly) {\n    // 1. Assert: url is a URL.\n    assert(url instanceof URL);\n    // 2. If urls scheme is a local scheme, then return no referrer.\n    if (url.protocol === \"file:\" || url.protocol === \"about:\" || url.protocol === \"blank:\") {\n        return \"no-referrer\";\n    }\n    // 3. Set urls username to the empty string.\n    url.username = \"\";\n    // 4. Set urls password to the empty string.\n    url.password = \"\";\n    // 5. Set urls fragment to null.\n    url.hash = \"\";\n    // 6. If the origin-only flag is true, then:\n    if (originOnly) {\n        // 1. Set urls path to  the empty string .\n        url.pathname = \"\";\n        // 2. Set urls query to null.\n        url.search = \"\";\n    }\n    // 7. Return url.\n    return url;\n}\nfunction isURLPotentiallyTrustworthy(url) {\n    if (!(url instanceof URL)) {\n        return false;\n    }\n    // If child of about, return true\n    if (url.href === \"about:blank\" || url.href === \"about:srcdoc\") {\n        return true;\n    }\n    // If scheme is data, return true\n    if (url.protocol === \"data:\") return true;\n    // If file, return true\n    if (url.protocol === \"file:\") return true;\n    return isOriginPotentiallyTrustworthy(url.origin);\n    function isOriginPotentiallyTrustworthy(origin) {\n        // If origin is explicitly null, return false\n        if (origin == null || origin === \"null\") return false;\n        const originAsURL = new URL(origin);\n        // If secure, return true\n        if (originAsURL.protocol === \"https:\" || originAsURL.protocol === \"wss:\") {\n            return true;\n        }\n        // If localhost or variants, return true\n        if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) || originAsURL.hostname === \"localhost\" || originAsURL.hostname.includes(\"localhost.\") || originAsURL.hostname.endsWith(\".localhost\")) {\n            return true;\n        }\n        // If any other, return false\n        return false;\n    }\n}\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */ function bytesMatch(bytes, metadataList) {\n    // If node is not built with OpenSSL support, we cannot check\n    // a request's integrity, so allow it by default (the spec will\n    // allow requests if an invalid hash is given, as precedence).\n    /* istanbul ignore if: only if node is built with --without-ssl */ if (crypto === undefined) {\n        return true;\n    }\n    // 1. Let parsedMetadata be the result of parsing metadataList.\n    const parsedMetadata = parseMetadata(metadataList);\n    // 2. If parsedMetadata is no metadata, return true.\n    if (parsedMetadata === \"no metadata\") {\n        return true;\n    }\n    // 3. If parsedMetadata is the empty set, return true.\n    if (parsedMetadata.length === 0) {\n        return true;\n    }\n    // 4. Let metadata be the result of getting the strongest\n    //    metadata from parsedMetadata.\n    const list = parsedMetadata.sort((c, d)=>d.algo.localeCompare(c.algo));\n    // get the strongest algorithm\n    const strongest = list[0].algo;\n    // get all entries that use the strongest algorithm; ignore weaker\n    const metadata = list.filter((item)=>item.algo === strongest);\n    // 5. For each item in metadata:\n    for (const item of metadata){\n        // 1. Let algorithm be the alg component of item.\n        const algorithm = item.algo;\n        // 2. Let expectedValue be the val component of item.\n        let expectedValue = item.hash;\n        // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n        // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n        if (expectedValue.endsWith(\"==\")) {\n            expectedValue = expectedValue.slice(0, -2);\n        }\n        // 3. Let actualValue be the result of applying algorithm to bytes.\n        let actualValue = crypto.createHash(algorithm).update(bytes).digest(\"base64\");\n        if (actualValue.endsWith(\"==\")) {\n            actualValue = actualValue.slice(0, -2);\n        }\n        // 4. If actualValue is a case-sensitive match for expectedValue,\n        //    return true.\n        if (actualValue === expectedValue) {\n            return true;\n        }\n        let actualBase64URL = crypto.createHash(algorithm).update(bytes).digest(\"base64url\");\n        if (actualBase64URL.endsWith(\"==\")) {\n            actualBase64URL = actualBase64URL.slice(0, -2);\n        }\n        if (actualBase64URL === expectedValue) {\n            return true;\n        }\n    }\n    // 6. Return false.\n    return false;\n}\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\\x21-\\x7e]?)?/i;\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */ function parseMetadata(metadata) {\n    // 1. Let result be the empty set.\n    /** @type {{ algo: string, hash: string }[]} */ const result = [];\n    // 2. Let empty be equal to true.\n    let empty = true;\n    const supportedHashes = crypto.getHashes();\n    // 3. For each token returned by splitting metadata on spaces:\n    for (const token of metadata.split(\" \")){\n        // 1. Set empty to false.\n        empty = false;\n        // 2. Parse token as a hash-with-options.\n        const parsedToken = parseHashWithOptions.exec(token);\n        // 3. If token does not parse, continue to the next token.\n        if (parsedToken === null || parsedToken.groups === undefined) {\n            continue;\n        }\n        // 4. Let algorithm be the hash-algo component of token.\n        const algorithm = parsedToken.groups.algo;\n        // 5. If algorithm is a hash function recognized by the user\n        //    agent, add the parsed token to result.\n        if (supportedHashes.includes(algorithm.toLowerCase())) {\n            result.push(parsedToken.groups);\n        }\n    }\n    // 4. Return no metadata if empty is true, otherwise return result.\n    if (empty === true) {\n        return \"no metadata\";\n    }\n    return result;\n}\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {\n// TODO\n}\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */ function sameOrigin(A, B) {\n    // 1. If A and B are the same opaque origin, then return true.\n    if (A.origin === B.origin && A.origin === \"null\") {\n        return true;\n    }\n    // 2. If A and B are both tuple origins and their schemes,\n    //    hosts, and port are identical, then return true.\n    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n        return true;\n    }\n    // 3. Return false.\n    return false;\n}\nfunction createDeferredPromise() {\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    return {\n        promise,\n        resolve: res,\n        reject: rej\n    };\n}\nfunction isAborted(fetchParams) {\n    return fetchParams.controller.state === \"aborted\";\n}\nfunction isCancelled(fetchParams) {\n    return fetchParams.controller.state === \"aborted\" || fetchParams.controller.state === \"terminated\";\n}\n// https://fetch.spec.whatwg.org/#concept-method-normalize\nfunction normalizeMethod(method) {\n    return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;\n}\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString(value) {\n    // 1. Let result be ? Call(%JSON.stringify%, undefined,  value ).\n    const result = JSON.stringify(value);\n    // 2. If result is undefined, then throw a TypeError.\n    if (result === undefined) {\n        throw new TypeError(\"Value is not JSON serializable\");\n    }\n    // 3. Assert: result is a string.\n    assert(typeof result === \"string\");\n    // 4. Return result.\n    return result;\n}\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {() => unknown[]} iterator\n * @param {string} name name of the instance\n * @param {'key'|'value'|'key+value'} kind\n */ function makeIterator(iterator, name, kind) {\n    const object = {\n        index: 0,\n        kind,\n        target: iterator\n    };\n    const i = {\n        next () {\n            // 1. Let interface be the interface for which the iterator prototype object exists.\n            // 2. Let thisValue be the this value.\n            // 3. Let object be ? ToObject(thisValue).\n            // 4. If object is a platform object, then perform a security\n            //    check, passing:\n            // 5. If object is not a default iterator object for interface,\n            //    then throw a TypeError.\n            if (Object.getPrototypeOf(this) !== i) {\n                throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);\n            }\n            // 6. Let index be objects index.\n            // 7. Let kind be objects kind.\n            // 8. Let values be objects target's value pairs to iterate over.\n            const { index, kind, target } = object;\n            const values = target();\n            // 9. Let len be the length of values.\n            const len = values.length;\n            // 10. If index is greater than or equal to len, then return\n            //     CreateIterResultObject(undefined, true).\n            if (index >= len) {\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n            // 11. Let pair be the entry in values at index index.\n            const pair = values[index];\n            // 12. Set objects index to index + 1.\n            object.index = index + 1;\n            // 13. Return the iterator result for pair and kind.\n            return iteratorResult(pair, kind);\n        },\n        // The class string of an iterator prototype object for a given interface is the\n        // result of concatenating the identifier of the interface and the string \" Iterator\".\n        [Symbol.toStringTag]: `${name} Iterator`\n    };\n    // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n    Object.setPrototypeOf(i, esIteratorPrototype);\n    // esIteratorPrototype needs to be the prototype of i\n    // which is the prototype of an empty object. Yes, it's confusing.\n    return Object.setPrototypeOf({}, i);\n}\n// https://webidl.spec.whatwg.org/#iterator-result\nfunction iteratorResult(pair, kind) {\n    let result;\n    // 1. Let result be a value determined by the value of kind:\n    switch(kind){\n        case \"key\":\n            {\n                // 1. Let idlKey be pairs key.\n                // 2. Let key be the result of converting idlKey to an\n                //    ECMAScript value.\n                // 3. result is key.\n                result = pair[0];\n                break;\n            }\n        case \"value\":\n            {\n                // 1. Let idlValue be pairs value.\n                // 2. Let value be the result of converting idlValue to\n                //    an ECMAScript value.\n                // 3. result is value.\n                result = pair[1];\n                break;\n            }\n        case \"key+value\":\n            {\n                // 1. Let idlKey be pairs key.\n                // 2. Let idlValue be pairs value.\n                // 3. Let key be the result of converting idlKey to an\n                //    ECMAScript value.\n                // 4. Let value be the result of converting idlValue to\n                //    an ECMAScript value.\n                // 5. Let array be ! ArrayCreate(2).\n                // 6. Call ! CreateDataProperty(array, \"0\", key).\n                // 7. Call ! CreateDataProperty(array, \"1\", value).\n                // 8. result is array.\n                result = pair;\n                break;\n            }\n    }\n    // 2. Return CreateIterResultObject(result, false).\n    return {\n        value: result,\n        done: false\n    };\n}\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */ async function fullyReadBody(body, processBody, processBodyError) {\n    // 1. If taskDestination is null, then set taskDestination to\n    //    the result of starting a new parallel queue.\n    // 2. Let successSteps given a byte sequence bytes be to queue a\n    //    fetch task to run processBody given bytes, with taskDestination.\n    const successSteps = processBody;\n    // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n    //    with taskDestination.\n    const errorSteps = processBodyError;\n    // 4. Let reader be the result of getting a reader for bodys stream.\n    //    If that threw an exception, then run errorSteps with that\n    //    exception and return.\n    let reader;\n    try {\n        reader = body.stream.getReader();\n    } catch (e) {\n        errorSteps(e);\n        return;\n    }\n    // 5. Read all bytes from reader, given successSteps and errorSteps.\n    try {\n        const result = await readAllBytes(reader);\n        successSteps(result);\n    } catch (e) {\n        errorSteps(e);\n    }\n}\n/** @type {ReadableStream} */ let ReadableStream = globalThis.ReadableStream;\nfunction isReadableStreamLike(stream) {\n    if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    return stream instanceof ReadableStream || stream[Symbol.toStringTag] === \"ReadableStream\" && typeof stream.tee === \"function\";\n}\nconst MAXIMUM_ARGUMENT_LENGTH = 65535;\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {number[]|Uint8Array} input\n */ function isomorphicDecode(input) {\n    // 1. To isomorphic decode a byte sequence input, return a string whose code point\n    //    length is equal to inputs length and whose code points have the same values\n    //    as the values of inputs bytes, in the same order.\n    if (input.length < MAXIMUM_ARGUMENT_LENGTH) {\n        return String.fromCharCode(...input);\n    }\n    return input.reduce((previous, current)=>previous + String.fromCharCode(current), \"\");\n}\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */ function readableStreamClose(controller) {\n    try {\n        controller.close();\n    } catch (err) {\n        // TODO: add comment explaining why this error occurs.\n        if (!err.message.includes(\"Controller is already closed\")) {\n            throw err;\n        }\n    }\n}\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */ function isomorphicEncode(input) {\n    // 1. Assert: input contains no code points greater than U+00FF.\n    for(let i = 0; i < input.length; i++){\n        assert(input.charCodeAt(i) <= 0xFF);\n    }\n    // 2. Return a byte sequence whose length is equal to inputs code\n    //    point length and whose bytes have the same values as the\n    //    values of inputs code points, in the same order\n    return input;\n}\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */ async function readAllBytes(reader) {\n    const bytes = [];\n    let byteLength = 0;\n    while(true){\n        const { done, value: chunk } = await reader.read();\n        if (done) {\n            // 1. Call successSteps with bytes.\n            return Buffer.concat(bytes, byteLength);\n        }\n        // 1. If chunk is not a Uint8Array object, call failureSteps\n        //    with a TypeError and abort these steps.\n        if (!isUint8Array(chunk)) {\n            throw new TypeError(\"Received non-Uint8Array chunk\");\n        }\n        // 2. Append the bytes represented by chunk to bytes.\n        bytes.push(chunk);\n        byteLength += chunk.length;\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n    }\n}\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */ function urlIsLocal(url) {\n    assert(\"protocol\" in url) // ensure it's a url object\n    ;\n    const protocol = url.protocol;\n    return protocol === \"about:\" || protocol === \"blob:\" || protocol === \"data:\";\n}\n/**\n * @param {string|URL} url\n */ function urlHasHttpsScheme(url) {\n    if (typeof url === \"string\") {\n        return url.startsWith(\"https:\");\n    }\n    return url.protocol === \"https:\";\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */ function urlIsHttpHttpsScheme(url) {\n    assert(\"protocol\" in url) // ensure it's a url object\n    ;\n    const protocol = url.protocol;\n    return protocol === \"http:\" || protocol === \"https:\";\n}\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */ const hasOwn = Object.hasOwn || ((dict, key)=>Object.prototype.hasOwnProperty.call(dict, key));\nmodule.exports = {\n    isAborted,\n    isCancelled,\n    createDeferredPromise,\n    ReadableStreamFrom,\n    toUSVString,\n    tryUpgradeRequestToAPotentiallyTrustworthyURL,\n    coarsenedSharedCurrentTime,\n    determineRequestsReferrer,\n    makePolicyContainer,\n    clonePolicyContainer,\n    appendFetchMetadata,\n    appendRequestOriginHeader,\n    TAOCheck,\n    corsCheck,\n    crossOriginResourcePolicyCheck,\n    createOpaqueTimingInfo,\n    setRequestReferrerPolicyOnRedirect,\n    isValidHTTPToken,\n    requestBadPort,\n    requestCurrentURL,\n    responseURL,\n    responseLocationURL,\n    isBlobLike,\n    isURLPotentiallyTrustworthy,\n    isValidReasonPhrase,\n    sameOrigin,\n    normalizeMethod,\n    serializeJavascriptValueToJSONString,\n    makeIterator,\n    isValidHeaderName,\n    isValidHeaderValue,\n    hasOwn,\n    isErrorLike,\n    fullyReadBody,\n    bytesMatch,\n    isReadableStreamLike,\n    readableStreamClose,\n    isomorphicEncode,\n    isomorphicDecode,\n    urlIsLocal,\n    urlHasHttpsScheme,\n    urlIsHttpHttpsScheme,\n    readAllBytes\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsaUJBQWlCLEVBQUVDLG1CQUFtQkMsb0JBQW9CLEVBQUVDLFdBQVcsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM1RixNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUNwQyxNQUFNLEVBQUVFLFdBQVcsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUNoQyxNQUFNLEVBQUVHLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxrQkFBa0IsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUNoRSxNQUFNTSxTQUFTTixtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVPLFlBQVksRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUVqQyxrRkFBa0Y7QUFDbEYsdUNBQXVDLEdBQ3ZDLElBQUlRO0FBRUosSUFBSTtJQUNGQSxTQUFTUixtQkFBT0EsQ0FBQztBQUNuQixFQUFFLE9BQU0sQ0FFUjtBQUVBLFNBQVNTLFlBQWFDLFFBQVE7SUFDNUIsMkNBQTJDO0lBQzNDLG9FQUFvRTtJQUNwRSxtRUFBbUU7SUFDbkUsTUFBTUMsVUFBVUQsU0FBU0MsT0FBTztJQUNoQyxNQUFNQyxTQUFTRCxRQUFRQyxNQUFNO0lBQzdCLE9BQU9BLFdBQVcsSUFBSSxPQUFPRCxPQUFPLENBQUNDLFNBQVMsRUFBRSxDQUFDQyxRQUFRO0FBQzNEO0FBRUEsK0RBQStEO0FBQy9ELFNBQVNDLG9CQUFxQkosUUFBUSxFQUFFSyxlQUFlO0lBQ3JELHNFQUFzRTtJQUN0RSxJQUFJLENBQUNuQixrQkFBa0JvQixHQUFHLENBQUNOLFNBQVNPLE1BQU0sR0FBRztRQUMzQyxPQUFPO0lBQ1Q7SUFFQSx1RUFBdUU7SUFDdkUseUNBQXlDO0lBQ3pDLElBQUlDLFdBQVdSLFNBQVNTLFdBQVcsQ0FBQ0MsR0FBRyxDQUFDO0lBRXhDLHVFQUF1RTtJQUN2RSwy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WDtJQUNBaUc7SUFDQWpFO0lBQ0FvQztJQUNBMEY7SUFDQUU7SUFDQVU7SUFDQWxJO0lBQ0F0QjtJQUNBc007SUFDQTdMO0lBQ0EySjtJQUNBeEU7SUFDQXFGO0lBQ0FVO0lBQ0FJO0lBQ0FYO0lBQ0FpQjtJQUNBcEo7SUFDQTFDO0lBQ0F1SztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC91dGlsLmpzP2YyMGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcmVkaXJlY3RTdGF0dXNTZXQsIHJlZmVycmVyUG9saWN5U2V0OiByZWZlcnJlclBvbGljeVRva2VucywgYmFkUG9ydHNTZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgZ2V0R2xvYmFsT3JpZ2luIH0gPSByZXF1aXJlKCcuL2dsb2JhbCcpXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSByZXF1aXJlKCdwZXJmX2hvb2tzJylcbmNvbnN0IHsgaXNCbG9iTGlrZSwgdG9VU1ZTdHJpbmcsIFJlYWRhYmxlU3RyZWFtRnJvbSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IGlzVWludDhBcnJheSB9ID0gcmVxdWlyZSgndXRpbC90eXBlcycpXG5cbi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY3J5cHRvLmh0bWwjZGV0ZXJtaW5pbmctaWYtY3J5cHRvLXN1cHBvcnQtaXMtdW5hdmFpbGFibGVcbi8qKiBAdHlwZSB7aW1wb3J0KCdjcnlwdG8nKXx1bmRlZmluZWR9ICovXG5sZXQgY3J5cHRvXG5cbnRyeSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG59IGNhdGNoIHtcblxufVxuXG5mdW5jdGlvbiByZXNwb25zZVVSTCAocmVzcG9uc2UpIHtcbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3Jlc3BvbnNlc1xuICAvLyBBIHJlc3BvbnNlIGhhcyBhbiBhc3NvY2lhdGVkIFVSTC4gSXQgaXMgYSBwb2ludGVyIHRvIHRoZSBsYXN0IFVSTFxuICAvLyBpbiByZXNwb25zZeKAmXMgVVJMIGxpc3QgYW5kIG51bGwgaWYgcmVzcG9uc2XigJlzIFVSTCBsaXN0IGlzIGVtcHR5LlxuICBjb25zdCB1cmxMaXN0ID0gcmVzcG9uc2UudXJsTGlzdFxuICBjb25zdCBsZW5ndGggPSB1cmxMaXN0Lmxlbmd0aFxuICByZXR1cm4gbGVuZ3RoID09PSAwID8gbnVsbCA6IHVybExpc3RbbGVuZ3RoIC0gMV0udG9TdHJpbmcoKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yZXNwb25zZS1sb2NhdGlvbi11cmxcbmZ1bmN0aW9uIHJlc3BvbnNlTG9jYXRpb25VUkwgKHJlc3BvbnNlLCByZXF1ZXN0RnJhZ21lbnQpIHtcbiAgLy8gMS4gSWYgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyBub3QgYSByZWRpcmVjdCBzdGF0dXMsIHRoZW4gcmV0dXJuIG51bGwuXG4gIGlmICghcmVkaXJlY3RTdGF0dXNTZXQuaGFzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gMi4gTGV0IGxvY2F0aW9uIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXMgZ2l2ZW5cbiAgLy8gYExvY2F0aW9uYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICBsZXQgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ2xvY2F0aW9uJylcblxuICAvLyAzLiBJZiBsb2NhdGlvbiBpcyBhIGhlYWRlciB2YWx1ZSwgdGhlbiBzZXQgbG9jYXRpb24gdG8gdGhlIHJlc3VsdCBvZlxuICAvLyAgICBwYXJzaW5nIGxvY2F0aW9uIHdpdGggcmVzcG9uc2XigJlzIFVSTC5cbiAgaWYgKGxvY2F0aW9uICE9PSBudWxsICYmIGlzVmFsaWRIZWFkZXJWYWx1ZShsb2NhdGlvbikpIHtcbiAgICBsb2NhdGlvbiA9IG5ldyBVUkwobG9jYXRpb24sIHJlc3BvbnNlVVJMKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8vIDQuIElmIGxvY2F0aW9uIGlzIGEgVVJMIHdob3NlIGZyYWdtZW50IGlzIG51bGwsIHRoZW4gc2V0IGxvY2F0aW9u4oCZc1xuICAvLyBmcmFnbWVudCB0byByZXF1ZXN0RnJhZ21lbnQuXG4gIGlmIChsb2NhdGlvbiAmJiAhbG9jYXRpb24uaGFzaCkge1xuICAgIGxvY2F0aW9uLmhhc2ggPSByZXF1ZXN0RnJhZ21lbnRcbiAgfVxuXG4gIC8vIDUuIFJldHVybiBsb2NhdGlvbi5cbiAgcmV0dXJuIGxvY2F0aW9uXG59XG5cbi8qKiBAcmV0dXJucyB7VVJMfSAqL1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRVUkwgKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdEJhZFBvcnQgKHJlcXVlc3QpIHtcbiAgLy8gMS4gTGV0IHVybCBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBhbiBIVFRQKFMpIHNjaGVtZSBhbmQgdXJs4oCZcyBwb3J0IGlzIGEgYmFkIHBvcnQsXG4gIC8vIHRoZW4gcmV0dXJuIGJsb2NrZWQuXG4gIGlmICh1cmxJc0h0dHBIdHRwc1NjaGVtZSh1cmwpICYmIGJhZFBvcnRzU2V0Lmhhcyh1cmwucG9ydCkpIHtcbiAgICByZXR1cm4gJ2Jsb2NrZWQnXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gYWxsb3dlZC5cbiAgcmV0dXJuICdhbGxvd2VkJ1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBFcnJvciB8fCAoXG4gICAgb2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0Vycm9yJyB8fFxuICAgIG9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdET01FeGNlcHRpb24nXG4gIClcbn1cblxuLy8gQ2hlY2sgd2hldGhlciB8c3RhdHVzVGV4dHwgaXMgYSBCeXRlU3RyaW5nIGFuZFxuLy8gbWF0Y2hlcyB0aGUgUmVhc29uLVBocmFzZSB0b2tlbiBwcm9kdWN0aW9uLlxuLy8gUkZDIDI2MTY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2XG4vLyBSRkMgNzIzMDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzBcbi8vIFwicmVhc29uLXBocmFzZSA9ICooIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVwiXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hyb21pdW0vY2hyb21pdW0vYmxvYi85NC4wLjQ2MDQuMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL2ZldGNoL3Jlc3BvbnNlLmNjI0wxMTZcbmZ1bmN0aW9uIGlzVmFsaWRSZWFzb25QaHJhc2UgKHN0YXR1c1RleHQpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0dXNUZXh0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgYyA9IHN0YXR1c1RleHQuY2hhckNvZGVBdChpKVxuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIChcbiAgICAgICAgICBjID09PSAweDA5IHx8IC8vIEhUQUJcbiAgICAgICAgICAoYyA+PSAweDIwICYmIGMgPD0gMHg3ZSkgfHwgLy8gU1AgLyBWQ0hBUlxuICAgICAgICAgIChjID49IDB4ODAgJiYgYyA8PSAweGZmKVxuICAgICAgICApIC8vIG9icy10ZXh0XG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaXNUb2tlbkNoYXIgKGMpIHtcbiAgcmV0dXJuICEoXG4gICAgYyA+PSAweDdmIHx8XG4gICAgYyA8PSAweDIwIHx8XG4gICAgYyA9PT0gJygnIHx8XG4gICAgYyA9PT0gJyknIHx8XG4gICAgYyA9PT0gJzwnIHx8XG4gICAgYyA9PT0gJz4nIHx8XG4gICAgYyA9PT0gJ0AnIHx8XG4gICAgYyA9PT0gJywnIHx8XG4gICAgYyA9PT0gJzsnIHx8XG4gICAgYyA9PT0gJzonIHx8XG4gICAgYyA9PT0gJ1xcXFwnIHx8XG4gICAgYyA9PT0gJ1wiJyB8fFxuICAgIGMgPT09ICcvJyB8fFxuICAgIGMgPT09ICdbJyB8fFxuICAgIGMgPT09ICddJyB8fFxuICAgIGMgPT09ICc/JyB8fFxuICAgIGMgPT09ICc9JyB8fFxuICAgIGMgPT09ICd7JyB8fFxuICAgIGMgPT09ICd9J1xuICApXG59XG5cbi8vIFNlZSBSRkMgNzIzMCwgU2VjdGlvbiAzLjIuNi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJvbWl1bS9jaHJvbWl1bS9ibG9iL2Q3ZGEwMjQwY2FlNzc4MjRkMWVkYTI1NzQ1YzQwMjI3NTc0OTkxMzEvdGhpcmRfcGFydHkvYmxpbmsvcmVuZGVyZXIvcGxhdGZvcm0vbmV0d29yay9odHRwX3BhcnNlcnMuY2MjTDMyMVxuZnVuY3Rpb24gaXNWYWxpZEhUVFBUb2tlbiAoY2hhcmFjdGVycykge1xuICBpZiAoIWNoYXJhY3RlcnMgfHwgdHlwZW9mIGNoYXJhY3RlcnMgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyYWN0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgYyA9IGNoYXJhY3RlcnMuY2hhckNvZGVBdChpKVxuICAgIGlmIChjID4gMHg3ZiB8fCAhaXNUb2tlbkNoYXIoYykpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVyLW5hbWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJvbWl1bS9jaHJvbWl1bS9ibG9iL2IzZDM3ZTZmOTRmODdkNTllNDQ2NjJkNjA3OGY2YTEyZGU4NDVkMTcvbmV0L2h0dHAvaHR0cF91dGlsLmNjI0wzNDJcbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJOYW1lIChwb3RlbnRpYWxWYWx1ZSkge1xuICBpZiAocG90ZW50aWFsVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gaXNWYWxpZEhUVFBUb2tlbihwb3RlbnRpYWxWYWx1ZSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3RlbnRpYWxWYWx1ZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSGVhZGVyVmFsdWUgKHBvdGVudGlhbFZhbHVlKSB7XG4gIC8vIC0gSGFzIG5vIGxlYWRpbmcgb3IgdHJhaWxpbmcgSFRUUCB0YWIgb3Igc3BhY2UgYnl0ZXMuXG4gIC8vIC0gQ29udGFpbnMgbm8gMHgwMCAoTlVMKSBvciBIVFRQIG5ld2xpbmUgYnl0ZXMuXG4gIGlmIChcbiAgICBwb3RlbnRpYWxWYWx1ZS5zdGFydHNXaXRoKCdcXHQnKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLnN0YXJ0c1dpdGgoJyAnKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmVuZHNXaXRoKCdcXHQnKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmVuZHNXaXRoKCcgJylcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoXG4gICAgcG90ZW50aWFsVmFsdWUuaW5jbHVkZXMoJ1xcMCcpIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuaW5jbHVkZXMoJ1xccicpIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuaW5jbHVkZXMoJ1xcbicpXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3NldC1yZXF1ZXN0cy1yZWZlcnJlci1wb2xpY3ktb24tcmVkaXJlY3RcbmZ1bmN0aW9uIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QgKHJlcXVlc3QsIGFjdHVhbFJlc3BvbnNlKSB7XG4gIC8vICBHaXZlbiBhIHJlcXVlc3QgcmVxdWVzdCBhbmQgYSByZXNwb25zZSBhY3R1YWxSZXNwb25zZSwgdGhpcyBhbGdvcml0aG1cbiAgLy8gIHVwZGF0ZXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IGFjY29yZGluZyB0byB0aGUgUmVmZXJyZXItUG9saWN5XG4gIC8vICBoZWFkZXIgKGlmIGFueSkgaW4gYWN0dWFsUmVzcG9uc2UuXG5cbiAgLy8gMS4gTGV0IHBvbGljeSBiZSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyDCpyA4LjEgUGFyc2UgYSByZWZlcnJlciBwb2xpY3lcbiAgLy8gZnJvbSBhIFJlZmVycmVyLVBvbGljeSBoZWFkZXIgb24gYWN0dWFsUmVzcG9uc2UuXG5cbiAgLy8gOC4xIFBhcnNlIGEgcmVmZXJyZXIgcG9saWN5IGZyb20gYSBSZWZlcnJlci1Qb2xpY3kgaGVhZGVyXG4gIC8vIDEuIExldCBwb2xpY3ktdG9rZW5zIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXMgZ2l2ZW4gYFJlZmVycmVyLVBvbGljeWAgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgY29uc3QgeyBoZWFkZXJzTGlzdCB9ID0gYWN0dWFsUmVzcG9uc2VcbiAgLy8gMi4gTGV0IHBvbGljeSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICAvLyAzLiBGb3IgZWFjaCB0b2tlbiBpbiBwb2xpY3ktdG9rZW5zLCBpZiB0b2tlbiBpcyBhIHJlZmVycmVyIHBvbGljeSBhbmQgdG9rZW4gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHBvbGljeSB0byB0b2tlbi5cbiAgLy8gNC4gUmV0dXJuIHBvbGljeS5cbiAgY29uc3QgcG9saWN5SGVhZGVyID0gKGhlYWRlcnNMaXN0LmdldCgncmVmZXJyZXItcG9saWN5JykgPz8gJycpLnNwbGl0KCcsJylcblxuICAvLyBOb3RlOiBBcyB0aGUgcmVmZXJyZXItcG9saWN5IGNhbiBjb250YWluIG11bHRpcGxlIHBvbGljaWVzXG4gIC8vIHNlcGFyYXRlZCBieSBjb21tYSwgd2UgbmVlZCB0byBsb29wIHRocm91Z2ggYWxsIG9mIHRoZW1cbiAgLy8gYW5kIHBpY2sgdGhlIGZpcnN0IHZhbGlkIG9uZS5cbiAgLy8gUmVmOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvUmVmZXJyZXItUG9saWN5I3NwZWNpZnlfYV9mYWxsYmFja19wb2xpY3lcbiAgbGV0IHBvbGljeSA9ICcnXG4gIGlmIChwb2xpY3lIZWFkZXIubGVuZ3RoID4gMCkge1xuICAgIC8vIFRoZSByaWdodC1tb3N0IHBvbGljeSB0YWtlcyBwcmVjZWRlbmNlLlxuICAgIC8vIFRoZSBsZWZ0LW1vc3QgcG9saWN5IGlzIHRoZSBmYWxsYmFjay5cbiAgICBmb3IgKGxldCBpID0gcG9saWN5SGVhZGVyLmxlbmd0aDsgaSAhPT0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHBvbGljeUhlYWRlcltpIC0gMV0udHJpbSgpXG4gICAgICBpZiAocmVmZXJyZXJQb2xpY3lUb2tlbnMuaGFzKHRva2VuKSkge1xuICAgICAgICBwb2xpY3kgPSB0b2tlblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIDIuIElmIHBvbGljeSBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IHRvIHBvbGljeS5cbiAgaWYgKHBvbGljeSAhPT0gJycpIHtcbiAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gcG9saWN5XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2Nyb3NzLW9yaWdpbi1yZXNvdXJjZS1wb2xpY3ktY2hlY2tcbmZ1bmN0aW9uIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayAoKSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuICdhbGxvd2VkJ1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1jb3JzLWNoZWNrXG5mdW5jdGlvbiBjb3JzQ2hlY2sgKCkge1xuICAvLyBUT0RPXG4gIHJldHVybiAnc3VjY2Vzcydcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdGFvLWNoZWNrXG5mdW5jdGlvbiBUQU9DaGVjayAoKSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuICdzdWNjZXNzJ1xufVxuXG5mdW5jdGlvbiBhcHBlbmRGZXRjaE1ldGFkYXRhIChodHRwUmVxdWVzdCkge1xuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLWRlc3QtaGVhZGVyXG4gIC8vICBUT0RPXG5cbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC1tb2RlLWhlYWRlclxuXG4gIC8vICAxLiBBc3NlcnQ6IHLigJlzIHVybCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTC5cbiAgLy8gIFRPRE9cblxuICAvLyAgMi4gTGV0IGhlYWRlciBiZSBhIFN0cnVjdHVyZWQgSGVhZGVyIHdob3NlIHZhbHVlIGlzIGEgdG9rZW4uXG4gIGxldCBoZWFkZXIgPSBudWxsXG5cbiAgLy8gIDMuIFNldCBoZWFkZXLigJlzIHZhbHVlIHRvIHLigJlzIG1vZGUuXG4gIGhlYWRlciA9IGh0dHBSZXF1ZXN0Lm1vZGVcblxuICAvLyAgNC4gU2V0IGEgc3RydWN0dXJlZCBmaWVsZCB2YWx1ZSBgU2VjLUZldGNoLU1vZGVgL2hlYWRlciBpbiBy4oCZcyBoZWFkZXIgbGlzdC5cbiAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3Quc2V0KCdzZWMtZmV0Y2gtbW9kZScsIGhlYWRlcilcblxuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLXNpdGUtaGVhZGVyXG4gIC8vICBUT0RPXG5cbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC11c2VyLWhlYWRlclxuICAvLyAgVE9ET1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXBwZW5kLWEtcmVxdWVzdC1vcmlnaW4taGVhZGVyXG5mdW5jdGlvbiBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyIChyZXF1ZXN0KSB7XG4gIC8vIDEuIExldCBzZXJpYWxpemVkT3JpZ2luIGJlIHRoZSByZXN1bHQgb2YgYnl0ZS1zZXJpYWxpemluZyBhIHJlcXVlc3Qgb3JpZ2luIHdpdGggcmVxdWVzdC5cbiAgbGV0IHNlcmlhbGl6ZWRPcmlnaW4gPSByZXF1ZXN0Lm9yaWdpblxuXG4gIC8vIDIuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiIG9yIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJ3ZWJzb2NrZXRcIiwgdGhlbiBhcHBlbmQgKGBPcmlnaW5gLCBzZXJpYWxpemVkT3JpZ2luKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnIHx8IHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcpIHtcbiAgICBpZiAoc2VyaWFsaXplZE9yaWdpbikge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ29yaWdpbicsIHNlcmlhbGl6ZWRPcmlnaW4pXG4gICAgfVxuXG4gIC8vIDMuIE90aGVyd2lzZSwgaWYgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5laXRoZXIgYEdFVGAgbm9yIGBIRUFEYCwgdGhlbjpcbiAgfSBlbHNlIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJykge1xuICAgIC8vIDEuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3k6XG4gICAgc3dpdGNoIChyZXF1ZXN0LnJlZmVycmVyUG9saWN5KSB7XG4gICAgICBjYXNlICduby1yZWZlcnJlcic6XG4gICAgICAgIC8vIFNldCBzZXJpYWxpemVkT3JpZ2luIHRvIGBudWxsYC5cbiAgICAgICAgc2VyaWFsaXplZE9yaWdpbiA9IG51bGxcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJzpcbiAgICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4nOlxuICAgICAgY2FzZSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6XG4gICAgICAgIC8vIElmIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBhIHR1cGxlIG9yaWdpbiwgaXRzIHNjaGVtZSBpcyBcImh0dHBzXCIsIGFuZCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBcImh0dHBzXCIsIHRoZW4gc2V0IHNlcmlhbGl6ZWRPcmlnaW4gdG8gYG51bGxgLlxuICAgICAgICBpZiAocmVxdWVzdC5vcmlnaW4gJiYgdXJsSGFzSHR0cHNTY2hlbWUocmVxdWVzdC5vcmlnaW4pICYmICF1cmxIYXNIdHRwc1NjaGVtZShyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSkpIHtcbiAgICAgICAgICBzZXJpYWxpemVkT3JpZ2luID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzYW1lLW9yaWdpbic6XG4gICAgICAgIC8vIElmIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgb3JpZ2luLCB0aGVuIHNldCBzZXJpYWxpemVkT3JpZ2luIHRvIGBudWxsYC5cbiAgICAgICAgaWYgKCFzYW1lT3JpZ2luKHJlcXVlc3QsIHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWRPcmlnaW4gPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfVxuXG4gICAgaWYgKHNlcmlhbGl6ZWRPcmlnaW4pIHtcbiAgICAgIC8vIDIuIEFwcGVuZCAoYE9yaWdpbmAsIHNlcmlhbGl6ZWRPcmlnaW4pIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ29yaWdpbicsIHNlcmlhbGl6ZWRPcmlnaW4pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lIChjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSkge1xuICAvLyBUT0RPXG4gIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY3JlYXRlLWFuLW9wYXF1ZS10aW1pbmctaW5mb1xuZnVuY3Rpb24gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyAodGltaW5nSW5mbykge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0VGltZTogdGltaW5nSW5mby5zdGFydFRpbWUgPz8gMCxcbiAgICByZWRpcmVjdFN0YXJ0VGltZTogMCxcbiAgICByZWRpcmVjdEVuZFRpbWU6IDAsXG4gICAgcG9zdFJlZGlyZWN0U3RhcnRUaW1lOiB0aW1pbmdJbmZvLnN0YXJ0VGltZSA/PyAwLFxuICAgIGZpbmFsU2VydmljZVdvcmtlclN0YXJ0VGltZTogMCxcbiAgICBmaW5hbE5ldHdvcmtSZXNwb25zZVN0YXJ0VGltZTogMCxcbiAgICBmaW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lOiAwLFxuICAgIGVuZFRpbWU6IDAsXG4gICAgZW5jb2RlZEJvZHlTaXplOiAwLFxuICAgIGRlY29kZWRCb2R5U2l6ZTogMCxcbiAgICBmaW5hbENvbm5lY3Rpb25UaW1pbmdJbmZvOiBudWxsXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvb3JpZ2luLmh0bWwjcG9saWN5LWNvbnRhaW5lclxuZnVuY3Rpb24gbWFrZVBvbGljeUNvbnRhaW5lciAoKSB7XG4gIC8vIE5vdGU6IHRoZSBmZXRjaCBzcGVjIGRvZXNuJ3QgbWFrZSB1c2Ugb2YgZW1iZWRkZXIgcG9saWN5IG9yIENTUCBsaXN0XG4gIHJldHVybiB7XG4gICAgcmVmZXJyZXJQb2xpY3k6ICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJ1xuICB9XG59XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI2Nsb25lLWEtcG9saWN5LWNvbnRhaW5lclxuZnVuY3Rpb24gY2xvbmVQb2xpY3lDb250YWluZXIgKHBvbGljeUNvbnRhaW5lcikge1xuICByZXR1cm4ge1xuICAgIHJlZmVycmVyUG9saWN5OiBwb2xpY3lDb250YWluZXIucmVmZXJyZXJQb2xpY3lcbiAgfVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyXG5mdW5jdGlvbiBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIChyZXF1ZXN0KSB7XG4gIC8vIDEuIExldCBwb2xpY3kgYmUgcmVxdWVzdCdzIHJlZmVycmVyIHBvbGljeS5cbiAgY29uc3QgcG9saWN5ID0gcmVxdWVzdC5yZWZlcnJlclBvbGljeVxuXG4gIC8vIE5vdGU6IHBvbGljeSBjYW5ub3QgKHNob3VsZG4ndCkgYmUgbnVsbCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gIGFzc2VydChwb2xpY3kpXG5cbiAgLy8gMi4gTGV0IGVudmlyb25tZW50IGJlIHJlcXVlc3TigJlzIGNsaWVudC5cblxuICBsZXQgcmVmZXJyZXJTb3VyY2UgPSBudWxsXG5cbiAgLy8gMy4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIHJlZmVycmVyOlxuICBpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gJ2NsaWVudCcpIHtcbiAgICAvLyBOb3RlOiBub2RlIGlzbid0IGEgYnJvd3NlciBhbmQgZG9lc24ndCBpbXBsZW1lbnQgZG9jdW1lbnQvaWZyYW1lcyxcbiAgICAvLyBzbyB3ZSBieXBhc3MgdGhpcyBzdGVwIGFuZCByZXBsYWNlIGl0IHdpdGggb3VyIG93bi5cblxuICAgIGNvbnN0IGdsb2JhbE9yaWdpbiA9IGdldEdsb2JhbE9yaWdpbigpXG5cbiAgICBpZiAoIWdsb2JhbE9yaWdpbiB8fCBnbG9iYWxPcmlnaW4ub3JpZ2luID09PSAnbnVsbCcpIHtcbiAgICAgIHJldHVybiAnbm8tcmVmZXJyZXInXG4gICAgfVxuXG4gICAgLy8gbm90ZTogd2UgbmVlZCB0byBjbG9uZSBpdCBhcyBpdCdzIG11dGF0ZWRcbiAgICByZWZlcnJlclNvdXJjZSA9IG5ldyBVUkwoZ2xvYmFsT3JpZ2luKVxuICB9IGVsc2UgaWYgKHJlcXVlc3QucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAvLyBMZXQgcmVmZXJyZXJTb3VyY2UgYmUgcmVxdWVzdOKAmXMgcmVmZXJyZXIuXG4gICAgcmVmZXJyZXJTb3VyY2UgPSByZXF1ZXN0LnJlZmVycmVyXG4gIH1cblxuICAvLyA0LiBMZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXJVUkwgYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yXG4gIC8vICAgIHVzZSBhcyBhIHJlZmVycmVyLlxuICBsZXQgcmVmZXJyZXJVUkwgPSBzdHJpcFVSTEZvclJlZmVycmVyKHJlZmVycmVyU291cmNlKVxuXG4gIC8vIDUuIExldCByZWZlcnJlck9yaWdpbiBiZSB0aGUgcmVzdWx0IG9mIHN0cmlwcGluZyByZWZlcnJlclNvdXJjZSBmb3IgdXNlIGFzXG4gIC8vICAgIGEgcmVmZXJyZXIsIHdpdGggdGhlIG9yaWdpbi1vbmx5IGZsYWcgc2V0IHRvIHRydWUuXG4gIGNvbnN0IHJlZmVycmVyT3JpZ2luID0gc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSlcblxuICAvLyA2LiBJZiB0aGUgcmVzdWx0IG9mIHNlcmlhbGl6aW5nIHJlZmVycmVyVVJMIGlzIGEgc3RyaW5nIHdob3NlIGxlbmd0aCBpc1xuICAvLyAgICBncmVhdGVyIHRoYW4gNDA5Niwgc2V0IHJlZmVycmVyVVJMIHRvIHJlZmVycmVyT3JpZ2luLlxuICBpZiAocmVmZXJyZXJVUkwudG9TdHJpbmcoKS5sZW5ndGggPiA0MDk2KSB7XG4gICAgcmVmZXJyZXJVUkwgPSByZWZlcnJlck9yaWdpblxuICB9XG5cbiAgY29uc3QgYXJlU2FtZU9yaWdpbiA9IHNhbWVPcmlnaW4ocmVxdWVzdCwgcmVmZXJyZXJVUkwpXG4gIGNvbnN0IGlzTm9uUG90ZW50aWFsbHlUcnVzdFdvcnRoeSA9IGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiZcbiAgICAhaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5KHJlcXVlc3QudXJsKVxuXG4gIC8vIDguIEV4ZWN1dGUgdGhlIHN3aXRjaCBzdGF0ZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZhbHVlIG9mIHBvbGljeTpcbiAgc3dpdGNoIChwb2xpY3kpIHtcbiAgICBjYXNlICdvcmlnaW4nOiByZXR1cm4gcmVmZXJyZXJPcmlnaW4gIT0gbnVsbCA/IHJlZmVycmVyT3JpZ2luIDogc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSlcbiAgICBjYXNlICd1bnNhZmUtdXJsJzogcmV0dXJuIHJlZmVycmVyVVJMXG4gICAgY2FzZSAnc2FtZS1vcmlnaW4nOlxuICAgICAgcmV0dXJuIGFyZVNhbWVPcmlnaW4gPyByZWZlcnJlck9yaWdpbiA6ICduby1yZWZlcnJlcidcbiAgICBjYXNlICdvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOlxuICAgICAgcmV0dXJuIGFyZVNhbWVPcmlnaW4gPyByZWZlcnJlclVSTCA6IHJlZmVycmVyT3JpZ2luXG4gICAgY2FzZSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyAxLiBJZiB0aGUgb3JpZ2luIG9mIHJlZmVycmVyVVJMIGFuZCB0aGUgb3JpZ2luIG9mIHJlcXVlc3TigJlzIGN1cnJlbnRcbiAgICAgIC8vICAgIFVSTCBhcmUgdGhlIHNhbWUsIHRoZW4gcmV0dXJuIHJlZmVycmVyVVJMLlxuICAgICAgaWYgKHNhbWVPcmlnaW4ocmVmZXJyZXJVUkwsIGN1cnJlbnRVUkwpKSB7XG4gICAgICAgIHJldHVybiByZWZlcnJlclVSTFxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdOKAmXNcbiAgICAgIC8vICAgIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgdGhlbiByZXR1cm4gbm9cbiAgICAgIC8vICAgIHJlZmVycmVyLlxuICAgICAgaWYgKGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuICAgICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgICAgfVxuXG4gICAgICAvLyAzLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW4uXG4gICAgICByZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICB9XG4gICAgY2FzZSAnc3RyaWN0LW9yaWdpbic6IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8qKlxuICAgICAgICAgKiAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmRcbiAgICAgICAgICogcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLFxuICAgICAgICAgKiB0aGVuIHJldHVybiBubyByZWZlcnJlci5cbiAgICAgICAgICogMi4gUmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgICAgICovXG4gICAgY2FzZSAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvKipcbiAgICAgICAqIDEuIElmIHJlZmVycmVyVVJMIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMIGFuZFxuICAgICAgICogcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLFxuICAgICAgICogdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG4gICAgICAgKiAyLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICAgICovXG5cbiAgICBkZWZhdWx0OiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gaXNOb25Qb3RlbnRpYWxseVRydXN0V29ydGh5ID8gJ25vLXJlZmVycmVyJyA6IHJlZmVycmVyT3JpZ2luXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNzdHJpcC11cmxcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IG9yaWdpbk9ubHlcbiAqL1xuZnVuY3Rpb24gc3RyaXBVUkxGb3JSZWZlcnJlciAodXJsLCBvcmlnaW5Pbmx5KSB7XG4gIC8vIDEuIEFzc2VydDogdXJsIGlzIGEgVVJMLlxuICBhc3NlcnQodXJsIGluc3RhbmNlb2YgVVJMKVxuXG4gIC8vIDIuIElmIHVybOKAmXMgc2NoZW1lIGlzIGEgbG9jYWwgc2NoZW1lLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6JyB8fCB1cmwucHJvdG9jb2wgPT09ICdhYm91dDonIHx8IHVybC5wcm90b2NvbCA9PT0gJ2JsYW5rOicpIHtcbiAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICB9XG5cbiAgLy8gMy4gU2V0IHVybOKAmXMgdXNlcm5hbWUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgdXJsLnVzZXJuYW1lID0gJydcblxuICAvLyA0LiBTZXQgdXJs4oCZcyBwYXNzd29yZCB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICB1cmwucGFzc3dvcmQgPSAnJ1xuXG4gIC8vIDUuIFNldCB1cmzigJlzIGZyYWdtZW50IHRvIG51bGwuXG4gIHVybC5oYXNoID0gJydcblxuICAvLyA2LiBJZiB0aGUgb3JpZ2luLW9ubHkgZmxhZyBpcyB0cnVlLCB0aGVuOlxuICBpZiAob3JpZ2luT25seSkge1xuICAgIC8vIDEuIFNldCB1cmzigJlzIHBhdGggdG8gwqsgdGhlIGVtcHR5IHN0cmluZyDCuy5cbiAgICB1cmwucGF0aG5hbWUgPSAnJ1xuXG4gICAgLy8gMi4gU2V0IHVybOKAmXMgcXVlcnkgdG8gbnVsbC5cbiAgICB1cmwuc2VhcmNoID0gJydcbiAgfVxuXG4gIC8vIDcuIFJldHVybiB1cmwuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5ICh1cmwpIHtcbiAgaWYgKCEodXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gSWYgY2hpbGQgb2YgYWJvdXQsIHJldHVybiB0cnVlXG4gIGlmICh1cmwuaHJlZiA9PT0gJ2Fib3V0OmJsYW5rJyB8fCB1cmwuaHJlZiA9PT0gJ2Fib3V0OnNyY2RvYycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSWYgc2NoZW1lIGlzIGRhdGEsIHJldHVybiB0cnVlXG4gIGlmICh1cmwucHJvdG9jb2wgPT09ICdkYXRhOicpIHJldHVybiB0cnVlXG5cbiAgLy8gSWYgZmlsZSwgcmV0dXJuIHRydWVcbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6JykgcmV0dXJuIHRydWVcblxuICByZXR1cm4gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5KHVybC5vcmlnaW4pXG5cbiAgZnVuY3Rpb24gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5IChvcmlnaW4pIHtcbiAgICAvLyBJZiBvcmlnaW4gaXMgZXhwbGljaXRseSBudWxsLCByZXR1cm4gZmFsc2VcbiAgICBpZiAob3JpZ2luID09IG51bGwgfHwgb3JpZ2luID09PSAnbnVsbCcpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3Qgb3JpZ2luQXNVUkwgPSBuZXcgVVJMKG9yaWdpbilcblxuICAgIC8vIElmIHNlY3VyZSwgcmV0dXJuIHRydWVcbiAgICBpZiAob3JpZ2luQXNVUkwucHJvdG9jb2wgPT09ICdodHRwczonIHx8IG9yaWdpbkFzVVJMLnByb3RvY29sID09PSAnd3NzOicpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgbG9jYWxob3N0IG9yIHZhcmlhbnRzLCByZXR1cm4gdHJ1ZVxuICAgIGlmICgvXjEyNyg/OlxcLlswLTldKyl7MCwyfVxcLlswLTldKyR8XlxcWyg/OjAqOikqPzo/MCoxXFxdJC8udGVzdChvcmlnaW5Bc1VSTC5ob3N0bmFtZSkgfHxcbiAgICAgKG9yaWdpbkFzVVJMLmhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCBvcmlnaW5Bc1VSTC5ob3N0bmFtZS5pbmNsdWRlcygnbG9jYWxob3N0LicpKSB8fFxuICAgICAob3JpZ2luQXNVUkwuaG9zdG5hbWUuZW5kc1dpdGgoJy5sb2NhbGhvc3QnKSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgYW55IG90aGVyLCByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI2RvZXMtcmVzcG9uc2UtbWF0Y2gtbWV0YWRhdGFsaXN0XG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0YWRhdGFMaXN0XG4gKi9cbmZ1bmN0aW9uIGJ5dGVzTWF0Y2ggKGJ5dGVzLCBtZXRhZGF0YUxpc3QpIHtcbiAgLy8gSWYgbm9kZSBpcyBub3QgYnVpbHQgd2l0aCBPcGVuU1NMIHN1cHBvcnQsIHdlIGNhbm5vdCBjaGVja1xuICAvLyBhIHJlcXVlc3QncyBpbnRlZ3JpdHksIHNvIGFsbG93IGl0IGJ5IGRlZmF1bHQgKHRoZSBzcGVjIHdpbGxcbiAgLy8gYWxsb3cgcmVxdWVzdHMgaWYgYW4gaW52YWxpZCBoYXNoIGlzIGdpdmVuLCBhcyBwcmVjZWRlbmNlKS5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBvbmx5IGlmIG5vZGUgaXMgYnVpbHQgd2l0aCAtLXdpdGhvdXQtc3NsICovXG4gIGlmIChjcnlwdG8gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAxLiBMZXQgcGFyc2VkTWV0YWRhdGEgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIG1ldGFkYXRhTGlzdC5cbiAgY29uc3QgcGFyc2VkTWV0YWRhdGEgPSBwYXJzZU1ldGFkYXRhKG1ldGFkYXRhTGlzdClcblxuICAvLyAyLiBJZiBwYXJzZWRNZXRhZGF0YSBpcyBubyBtZXRhZGF0YSwgcmV0dXJuIHRydWUuXG4gIGlmIChwYXJzZWRNZXRhZGF0YSA9PT0gJ25vIG1ldGFkYXRhJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAzLiBJZiBwYXJzZWRNZXRhZGF0YSBpcyB0aGUgZW1wdHkgc2V0LCByZXR1cm4gdHJ1ZS5cbiAgaWYgKHBhcnNlZE1ldGFkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyA0LiBMZXQgbWV0YWRhdGEgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIHRoZSBzdHJvbmdlc3RcbiAgLy8gICAgbWV0YWRhdGEgZnJvbSBwYXJzZWRNZXRhZGF0YS5cbiAgY29uc3QgbGlzdCA9IHBhcnNlZE1ldGFkYXRhLnNvcnQoKGMsIGQpID0+IGQuYWxnby5sb2NhbGVDb21wYXJlKGMuYWxnbykpXG4gIC8vIGdldCB0aGUgc3Ryb25nZXN0IGFsZ29yaXRobVxuICBjb25zdCBzdHJvbmdlc3QgPSBsaXN0WzBdLmFsZ29cbiAgLy8gZ2V0IGFsbCBlbnRyaWVzIHRoYXQgdXNlIHRoZSBzdHJvbmdlc3QgYWxnb3JpdGhtOyBpZ25vcmUgd2Vha2VyXG4gIGNvbnN0IG1ldGFkYXRhID0gbGlzdC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWxnbyA9PT0gc3Ryb25nZXN0KVxuXG4gIC8vIDUuIEZvciBlYWNoIGl0ZW0gaW4gbWV0YWRhdGE6XG4gIGZvciAoY29uc3QgaXRlbSBvZiBtZXRhZGF0YSkge1xuICAgIC8vIDEuIExldCBhbGdvcml0aG0gYmUgdGhlIGFsZyBjb21wb25lbnQgb2YgaXRlbS5cbiAgICBjb25zdCBhbGdvcml0aG0gPSBpdGVtLmFsZ29cblxuICAgIC8vIDIuIExldCBleHBlY3RlZFZhbHVlIGJlIHRoZSB2YWwgY29tcG9uZW50IG9mIGl0ZW0uXG4gICAgbGV0IGV4cGVjdGVkVmFsdWUgPSBpdGVtLmhhc2hcblxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2ViLXBsYXRmb3JtLXRlc3RzL3dwdC9jb21taXQvZTRjNWNjN2E1ZTQ4MDkzMjIwNTI4ZGZkZDFjNDAxMmRjMzgzN2EwZVxuICAgIC8vIFwiYmUgbGliZXJhbCB3aXRoIHBhZGRpbmdcIi4gVGhpcyBpcyBhbm5veWluZywgYW5kIGl0J3Mgbm90IGV2ZW4gaW4gdGhlIHNwZWMuXG5cbiAgICBpZiAoZXhwZWN0ZWRWYWx1ZS5lbmRzV2l0aCgnPT0nKSkge1xuICAgICAgZXhwZWN0ZWRWYWx1ZSA9IGV4cGVjdGVkVmFsdWUuc2xpY2UoMCwgLTIpXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IGFjdHVhbFZhbHVlIGJlIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYWxnb3JpdGhtIHRvIGJ5dGVzLlxuICAgIGxldCBhY3R1YWxWYWx1ZSA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSkudXBkYXRlKGJ5dGVzKS5kaWdlc3QoJ2Jhc2U2NCcpXG5cbiAgICBpZiAoYWN0dWFsVmFsdWUuZW5kc1dpdGgoJz09JykpIHtcbiAgICAgIGFjdHVhbFZhbHVlID0gYWN0dWFsVmFsdWUuc2xpY2UoMCwgLTIpXG4gICAgfVxuXG4gICAgLy8gNC4gSWYgYWN0dWFsVmFsdWUgaXMgYSBjYXNlLXNlbnNpdGl2ZSBtYXRjaCBmb3IgZXhwZWN0ZWRWYWx1ZSxcbiAgICAvLyAgICByZXR1cm4gdHJ1ZS5cbiAgICBpZiAoYWN0dWFsVmFsdWUgPT09IGV4cGVjdGVkVmFsdWUpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgbGV0IGFjdHVhbEJhc2U2NFVSTCA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSkudXBkYXRlKGJ5dGVzKS5kaWdlc3QoJ2Jhc2U2NHVybCcpXG5cbiAgICBpZiAoYWN0dWFsQmFzZTY0VVJMLmVuZHNXaXRoKCc9PScpKSB7XG4gICAgICBhY3R1YWxCYXNlNjRVUkwgPSBhY3R1YWxCYXNlNjRVUkwuc2xpY2UoMCwgLTIpXG4gICAgfVxuXG4gICAgaWYgKGFjdHVhbEJhc2U2NFVSTCA9PT0gZXhwZWN0ZWRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICAvLyA2LiBSZXR1cm4gZmFsc2UuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXN1YnJlc291cmNlLWludGVncml0eS8jZ3JhbW1hcmRlZi1oYXNoLXdpdGgtb3B0aW9uc1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0NTUDIvI3NvdXJjZS1saXN0LXN5bnRheFxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzUyMzQjYXBwZW5kaXgtQi4xXG5jb25zdCBwYXJzZUhhc2hXaXRoT3B0aW9ucyA9IC8oKD88YWxnbz5zaGEyNTZ8c2hhMzg0fHNoYTUxMiktKD88aGFzaD5bQS16MC05Ky9dezF9Lio9ezAsMn0pKSggK1tcXHgyMS1cXHg3ZV0/KT8vaVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI3BhcnNlLW1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gcGFyc2VNZXRhZGF0YSAobWV0YWRhdGEpIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSB0aGUgZW1wdHkgc2V0LlxuICAvKiogQHR5cGUge3sgYWxnbzogc3RyaW5nLCBoYXNoOiBzdHJpbmcgfVtdfSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIC8vIDIuIExldCBlbXB0eSBiZSBlcXVhbCB0byB0cnVlLlxuICBsZXQgZW1wdHkgPSB0cnVlXG5cbiAgY29uc3Qgc3VwcG9ydGVkSGFzaGVzID0gY3J5cHRvLmdldEhhc2hlcygpXG5cbiAgLy8gMy4gRm9yIGVhY2ggdG9rZW4gcmV0dXJuZWQgYnkgc3BsaXR0aW5nIG1ldGFkYXRhIG9uIHNwYWNlczpcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBtZXRhZGF0YS5zcGxpdCgnICcpKSB7XG4gICAgLy8gMS4gU2V0IGVtcHR5IHRvIGZhbHNlLlxuICAgIGVtcHR5ID0gZmFsc2VcblxuICAgIC8vIDIuIFBhcnNlIHRva2VuIGFzIGEgaGFzaC13aXRoLW9wdGlvbnMuXG4gICAgY29uc3QgcGFyc2VkVG9rZW4gPSBwYXJzZUhhc2hXaXRoT3B0aW9ucy5leGVjKHRva2VuKVxuXG4gICAgLy8gMy4gSWYgdG9rZW4gZG9lcyBub3QgcGFyc2UsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHRva2VuLlxuICAgIGlmIChwYXJzZWRUb2tlbiA9PT0gbnVsbCB8fCBwYXJzZWRUb2tlbi5ncm91cHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gTm90ZTogQ2hyb21pdW0gYmxvY2tzIHRoZSByZXF1ZXN0IGF0IHRoaXMgcG9pbnQsIGJ1dCBGaXJlZm94XG4gICAgICAvLyBnaXZlcyBhIHdhcm5pbmcgdGhhdCBhbiBpbnZhbGlkIGludGVncml0eSB3YXMgZ2l2ZW4uIFRoZVxuICAgICAgLy8gY29ycmVjdCBiZWhhdmlvciBpcyB0byBpZ25vcmUgdGhlc2UsIGFuZCBzdWJzZXF1ZW50bHkgbm90XG4gICAgICAvLyBjaGVjayB0aGUgaW50ZWdyaXR5IG9mIHRoZSByZXNvdXJjZS5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gNC4gTGV0IGFsZ29yaXRobSBiZSB0aGUgaGFzaC1hbGdvIGNvbXBvbmVudCBvZiB0b2tlbi5cbiAgICBjb25zdCBhbGdvcml0aG0gPSBwYXJzZWRUb2tlbi5ncm91cHMuYWxnb1xuXG4gICAgLy8gNS4gSWYgYWxnb3JpdGhtIGlzIGEgaGFzaCBmdW5jdGlvbiByZWNvZ25pemVkIGJ5IHRoZSB1c2VyXG4gICAgLy8gICAgYWdlbnQsIGFkZCB0aGUgcGFyc2VkIHRva2VuIHRvIHJlc3VsdC5cbiAgICBpZiAoc3VwcG9ydGVkSGFzaGVzLmluY2x1ZGVzKGFsZ29yaXRobS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgcmVzdWx0LnB1c2gocGFyc2VkVG9rZW4uZ3JvdXBzKVxuICAgIH1cbiAgfVxuXG4gIC8vIDQuIFJldHVybiBubyBtZXRhZGF0YSBpZiBlbXB0eSBpcyB0cnVlLCBvdGhlcndpc2UgcmV0dXJuIHJlc3VsdC5cbiAgaWYgKGVtcHR5ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICdubyBtZXRhZGF0YSdcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy11cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzLyN1cGdyYWRlLXJlcXVlc3RcbmZ1bmN0aW9uIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCAocmVxdWVzdCkge1xuICAvLyBUT0RPXG59XG5cbi8qKlxuICogQGxpbmsge2h0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI3NhbWUtb3JpZ2lufVxuICogQHBhcmFtIHtVUkx9IEFcbiAqIEBwYXJhbSB7VVJMfSBCXG4gKi9cbmZ1bmN0aW9uIHNhbWVPcmlnaW4gKEEsIEIpIHtcbiAgLy8gMS4gSWYgQSBhbmQgQiBhcmUgdGhlIHNhbWUgb3BhcXVlIG9yaWdpbiwgdGhlbiByZXR1cm4gdHJ1ZS5cbiAgaWYgKEEub3JpZ2luID09PSBCLm9yaWdpbiAmJiBBLm9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIDIuIElmIEEgYW5kIEIgYXJlIGJvdGggdHVwbGUgb3JpZ2lucyBhbmQgdGhlaXIgc2NoZW1lcyxcbiAgLy8gICAgaG9zdHMsIGFuZCBwb3J0IGFyZSBpZGVudGljYWwsIHRoZW4gcmV0dXJuIHRydWUuXG4gIGlmIChBLnByb3RvY29sID09PSBCLnByb3RvY29sICYmIEEuaG9zdG5hbWUgPT09IEIuaG9zdG5hbWUgJiYgQS5wb3J0ID09PSBCLnBvcnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIGZhbHNlLlxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWRQcm9taXNlICgpIHtcbiAgbGV0IHJlc1xuICBsZXQgcmVqXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzID0gcmVzb2x2ZVxuICAgIHJlaiA9IHJlamVjdFxuICB9KVxuXG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmU6IHJlcywgcmVqZWN0OiByZWogfVxufVxuXG5mdW5jdGlvbiBpc0Fib3J0ZWQgKGZldGNoUGFyYW1zKSB7XG4gIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAnYWJvcnRlZCdcbn1cblxuZnVuY3Rpb24gaXNDYW5jZWxsZWQgKGZldGNoUGFyYW1zKSB7XG4gIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAnYWJvcnRlZCcgfHxcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAndGVybWluYXRlZCdcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbWV0aG9kLW5vcm1hbGl6ZVxuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kIChtZXRob2QpIHtcbiAgcmV0dXJuIC9eKERFTEVURXxHRVR8SEVBRHxPUFRJT05TfFBPU1R8UFVUKSQvaS50ZXN0KG1ldGhvZClcbiAgICA/IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgOiBtZXRob2Rcbn1cblxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3NlcmlhbGl6ZS1hLWphdmFzY3JpcHQtdmFsdWUtdG8tYS1qc29uLXN0cmluZ1xuZnVuY3Rpb24gc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nICh2YWx1ZSkge1xuICAvLyAxLiBMZXQgcmVzdWx0IGJlID8gQ2FsbCglSlNPTi5zdHJpbmdpZnklLCB1bmRlZmluZWQsIMKrIHZhbHVlIMK7KS5cbiAgY29uc3QgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpXG5cbiAgLy8gMi4gSWYgcmVzdWx0IGlzIHVuZGVmaW5lZCwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgaXMgbm90IEpTT04gc2VyaWFsaXphYmxlJylcbiAgfVxuXG4gIC8vIDMuIEFzc2VydDogcmVzdWx0IGlzIGEgc3RyaW5nLlxuICBhc3NlcnQodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpXG5cbiAgLy8gNC4gUmV0dXJuIHJlc3VsdC5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSUyNWl0ZXJhdG9ycHJvdG90eXBlJTI1LW9iamVjdFxuY29uc3QgZXNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZGZuLWl0ZXJhdG9yLXByb3RvdHlwZS1vYmplY3RcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bltdfSBpdGVyYXRvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7J2tleSd8J3ZhbHVlJ3wna2V5K3ZhbHVlJ30ga2luZFxuICovXG5mdW5jdGlvbiBtYWtlSXRlcmF0b3IgKGl0ZXJhdG9yLCBuYW1lLCBraW5kKSB7XG4gIGNvbnN0IG9iamVjdCA9IHtcbiAgICBpbmRleDogMCxcbiAgICBraW5kLFxuICAgIHRhcmdldDogaXRlcmF0b3JcbiAgfVxuXG4gIGNvbnN0IGkgPSB7XG4gICAgbmV4dCAoKSB7XG4gICAgICAvLyAxLiBMZXQgaW50ZXJmYWNlIGJlIHRoZSBpbnRlcmZhY2UgZm9yIHdoaWNoIHRoZSBpdGVyYXRvciBwcm90b3R5cGUgb2JqZWN0IGV4aXN0cy5cblxuICAgICAgLy8gMi4gTGV0IHRoaXNWYWx1ZSBiZSB0aGUgdGhpcyB2YWx1ZS5cblxuICAgICAgLy8gMy4gTGV0IG9iamVjdCBiZSA/IFRvT2JqZWN0KHRoaXNWYWx1ZSkuXG5cbiAgICAgIC8vIDQuIElmIG9iamVjdCBpcyBhIHBsYXRmb3JtIG9iamVjdCwgdGhlbiBwZXJmb3JtIGEgc2VjdXJpdHlcbiAgICAgIC8vICAgIGNoZWNrLCBwYXNzaW5nOlxuXG4gICAgICAvLyA1LiBJZiBvYmplY3QgaXMgbm90IGEgZGVmYXVsdCBpdGVyYXRvciBvYmplY3QgZm9yIGludGVyZmFjZSxcbiAgICAgIC8vICAgIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYCduZXh0JyBjYWxsZWQgb24gYW4gb2JqZWN0IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSAke25hbWV9IEl0ZXJhdG9yLmBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyA2LiBMZXQgaW5kZXggYmUgb2JqZWN04oCZcyBpbmRleC5cbiAgICAgIC8vIDcuIExldCBraW5kIGJlIG9iamVjdOKAmXMga2luZC5cbiAgICAgIC8vIDguIExldCB2YWx1ZXMgYmUgb2JqZWN04oCZcyB0YXJnZXQncyB2YWx1ZSBwYWlycyB0byBpdGVyYXRlIG92ZXIuXG4gICAgICBjb25zdCB7IGluZGV4LCBraW5kLCB0YXJnZXQgfSA9IG9iamVjdFxuICAgICAgY29uc3QgdmFsdWVzID0gdGFyZ2V0KClcblxuICAgICAgLy8gOS4gTGV0IGxlbiBiZSB0aGUgbGVuZ3RoIG9mIHZhbHVlcy5cbiAgICAgIGNvbnN0IGxlbiA9IHZhbHVlcy5sZW5ndGhcblxuICAgICAgLy8gMTAuIElmIGluZGV4IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBsZW4sIHRoZW4gcmV0dXJuXG4gICAgICAvLyAgICAgQ3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpLlxuICAgICAgaWYgKGluZGV4ID49IGxlbikge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH1cbiAgICAgIH1cblxuICAgICAgLy8gMTEuIExldCBwYWlyIGJlIHRoZSBlbnRyeSBpbiB2YWx1ZXMgYXQgaW5kZXggaW5kZXguXG4gICAgICBjb25zdCBwYWlyID0gdmFsdWVzW2luZGV4XVxuXG4gICAgICAvLyAxMi4gU2V0IG9iamVjdOKAmXMgaW5kZXggdG8gaW5kZXggKyAxLlxuICAgICAgb2JqZWN0LmluZGV4ID0gaW5kZXggKyAxXG5cbiAgICAgIC8vIDEzLiBSZXR1cm4gdGhlIGl0ZXJhdG9yIHJlc3VsdCBmb3IgcGFpciBhbmQga2luZC5cbiAgICAgIHJldHVybiBpdGVyYXRvclJlc3VsdChwYWlyLCBraW5kKVxuICAgIH0sXG4gICAgLy8gVGhlIGNsYXNzIHN0cmluZyBvZiBhbiBpdGVyYXRvciBwcm90b3R5cGUgb2JqZWN0IGZvciBhIGdpdmVuIGludGVyZmFjZSBpcyB0aGVcbiAgICAvLyByZXN1bHQgb2YgY29uY2F0ZW5hdGluZyB0aGUgaWRlbnRpZmllciBvZiB0aGUgaW50ZXJmYWNlIGFuZCB0aGUgc3RyaW5nIFwiIEl0ZXJhdG9yXCIuXG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106IGAke25hbWV9IEl0ZXJhdG9yYFxuICB9XG5cbiAgLy8gVGhlIFtbUHJvdG90eXBlXV0gaW50ZXJuYWwgc2xvdCBvZiBhbiBpdGVyYXRvciBwcm90b3R5cGUgb2JqZWN0IG11c3QgYmUgJUl0ZXJhdG9yUHJvdG90eXBlJS5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGksIGVzSXRlcmF0b3JQcm90b3R5cGUpXG4gIC8vIGVzSXRlcmF0b3JQcm90b3R5cGUgbmVlZHMgdG8gYmUgdGhlIHByb3RvdHlwZSBvZiBpXG4gIC8vIHdoaWNoIGlzIHRoZSBwcm90b3R5cGUgb2YgYW4gZW1wdHkgb2JqZWN0LiBZZXMsIGl0J3MgY29uZnVzaW5nLlxuICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHt9LCBpKVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2l0ZXJhdG9yLXJlc3VsdFxuZnVuY3Rpb24gaXRlcmF0b3JSZXN1bHQgKHBhaXIsIGtpbmQpIHtcbiAgbGV0IHJlc3VsdFxuXG4gIC8vIDEuIExldCByZXN1bHQgYmUgYSB2YWx1ZSBkZXRlcm1pbmVkIGJ5IHRoZSB2YWx1ZSBvZiBraW5kOlxuICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlICdrZXknOiB7XG4gICAgICAvLyAxLiBMZXQgaWRsS2V5IGJlIHBhaXLigJlzIGtleS5cbiAgICAgIC8vIDIuIExldCBrZXkgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbEtleSB0byBhblxuICAgICAgLy8gICAgRUNNQVNjcmlwdCB2YWx1ZS5cbiAgICAgIC8vIDMuIHJlc3VsdCBpcyBrZXkuXG4gICAgICByZXN1bHQgPSBwYWlyWzBdXG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICd2YWx1ZSc6IHtcbiAgICAgIC8vIDEuIExldCBpZGxWYWx1ZSBiZSBwYWly4oCZcyB2YWx1ZS5cbiAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgaWRsVmFsdWUgdG9cbiAgICAgIC8vICAgIGFuIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAvLyAzLiByZXN1bHQgaXMgdmFsdWUuXG4gICAgICByZXN1bHQgPSBwYWlyWzFdXG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICdrZXkrdmFsdWUnOiB7XG4gICAgICAvLyAxLiBMZXQgaWRsS2V5IGJlIHBhaXLigJlzIGtleS5cbiAgICAgIC8vIDIuIExldCBpZGxWYWx1ZSBiZSBwYWly4oCZcyB2YWx1ZS5cbiAgICAgIC8vIDMuIExldCBrZXkgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbEtleSB0byBhblxuICAgICAgLy8gICAgRUNNQVNjcmlwdCB2YWx1ZS5cbiAgICAgIC8vIDQuIExldCB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgaWRsVmFsdWUgdG9cbiAgICAgIC8vICAgIGFuIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAvLyA1LiBMZXQgYXJyYXkgYmUgISBBcnJheUNyZWF0ZSgyKS5cbiAgICAgIC8vIDYuIENhbGwgISBDcmVhdGVEYXRhUHJvcGVydHkoYXJyYXksIFwiMFwiLCBrZXkpLlxuICAgICAgLy8gNy4gQ2FsbCAhIENyZWF0ZURhdGFQcm9wZXJ0eShhcnJheSwgXCIxXCIsIHZhbHVlKS5cbiAgICAgIC8vIDguIHJlc3VsdCBpcyBhcnJheS5cbiAgICAgIHJlc3VsdCA9IHBhaXJcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gMi4gUmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QocmVzdWx0LCBmYWxzZSkuXG4gIHJldHVybiB7IHZhbHVlOiByZXN1bHQsIGRvbmU6IGZhbHNlIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5LWZ1bGx5LXJlYWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZnVsbHlSZWFkQm9keSAoYm9keSwgcHJvY2Vzc0JvZHksIHByb2Nlc3NCb2R5RXJyb3IpIHtcbiAgLy8gMS4gSWYgdGFza0Rlc3RpbmF0aW9uIGlzIG51bGwsIHRoZW4gc2V0IHRhc2tEZXN0aW5hdGlvbiB0b1xuICAvLyAgICB0aGUgcmVzdWx0IG9mIHN0YXJ0aW5nIGEgbmV3IHBhcmFsbGVsIHF1ZXVlLlxuXG4gIC8vIDIuIExldCBzdWNjZXNzU3RlcHMgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzIGJlIHRvIHF1ZXVlIGFcbiAgLy8gICAgZmV0Y2ggdGFzayB0byBydW4gcHJvY2Vzc0JvZHkgZ2l2ZW4gYnl0ZXMsIHdpdGggdGFza0Rlc3RpbmF0aW9uLlxuICBjb25zdCBzdWNjZXNzU3RlcHMgPSBwcm9jZXNzQm9keVxuXG4gIC8vIDMuIExldCBlcnJvclN0ZXBzIGJlIHRvIHF1ZXVlIGEgZmV0Y2ggdGFzayB0byBydW4gcHJvY2Vzc0JvZHlFcnJvcixcbiAgLy8gICAgd2l0aCB0YXNrRGVzdGluYXRpb24uXG4gIGNvbnN0IGVycm9yU3RlcHMgPSBwcm9jZXNzQm9keUVycm9yXG5cbiAgLy8gNC4gTGV0IHJlYWRlciBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgYSByZWFkZXIgZm9yIGJvZHnigJlzIHN0cmVhbS5cbiAgLy8gICAgSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIHRoZW4gcnVuIGVycm9yU3RlcHMgd2l0aCB0aGF0XG4gIC8vICAgIGV4Y2VwdGlvbiBhbmQgcmV0dXJuLlxuICBsZXQgcmVhZGVyXG5cbiAgdHJ5IHtcbiAgICByZWFkZXIgPSBib2R5LnN0cmVhbS5nZXRSZWFkZXIoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JTdGVwcyhlKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gNS4gUmVhZCBhbGwgYnl0ZXMgZnJvbSByZWFkZXIsIGdpdmVuIHN1Y2Nlc3NTdGVwcyBhbmQgZXJyb3JTdGVwcy5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkQWxsQnl0ZXMocmVhZGVyKVxuICAgIHN1Y2Nlc3NTdGVwcyhyZXN1bHQpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvclN0ZXBzKGUpXG4gIH1cbn1cblxuLyoqIEB0eXBlIHtSZWFkYWJsZVN0cmVhbX0gKi9cbmxldCBSZWFkYWJsZVN0cmVhbSA9IGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW1cblxuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbUxpa2UgKHN0cmVhbSkge1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtKSB7XG4gICAgUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0vd2ViJykuUmVhZGFibGVTdHJlYW1cbiAgfVxuXG4gIHJldHVybiBzdHJlYW0gaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSB8fCAoXG4gICAgc3RyZWFtW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdSZWFkYWJsZVN0cmVhbScgJiZcbiAgICB0eXBlb2Ygc3RyZWFtLnRlZSA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5cbmNvbnN0IE1BWElNVU1fQVJHVU1FTlRfTEVOR1RIID0gNjU1MzVcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNpc29tb3JwaGljLWRlY29kZVxuICogQHBhcmFtIHtudW1iZXJbXXxVaW50OEFycmF5fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpc29tb3JwaGljRGVjb2RlIChpbnB1dCkge1xuICAvLyAxLiBUbyBpc29tb3JwaGljIGRlY29kZSBhIGJ5dGUgc2VxdWVuY2UgaW5wdXQsIHJldHVybiBhIHN0cmluZyB3aG9zZSBjb2RlIHBvaW50XG4gIC8vICAgIGxlbmd0aCBpcyBlcXVhbCB0byBpbnB1dOKAmXMgbGVuZ3RoIGFuZCB3aG9zZSBjb2RlIHBvaW50cyBoYXZlIHRoZSBzYW1lIHZhbHVlc1xuICAvLyAgICBhcyB0aGUgdmFsdWVzIG9mIGlucHV04oCZcyBieXRlcywgaW4gdGhlIHNhbWUgb3JkZXIuXG5cbiAgaWYgKGlucHV0Lmxlbmd0aCA8IE1BWElNVU1fQVJHVU1FTlRfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uaW5wdXQpXG4gIH1cblxuICByZXR1cm4gaW5wdXQucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4gcHJldmlvdXMgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGN1cnJlbnQpLCAnJylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxVaW50OEFycmF5Pn0gY29udHJvbGxlclxuICovXG5mdW5jdGlvbiByZWFkYWJsZVN0cmVhbUNsb3NlIChjb250cm9sbGVyKSB7XG4gIHRyeSB7XG4gICAgY29udHJvbGxlci5jbG9zZSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFRPRE86IGFkZCBjb21tZW50IGV4cGxhaW5pbmcgd2h5IHRoaXMgZXJyb3Igb2NjdXJzLlxuICAgIGlmICghZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ0NvbnRyb2xsZXIgaXMgYWxyZWFkeSBjbG9zZWQnKSkge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jaXNvbW9ycGhpYy1lbmNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICovXG5mdW5jdGlvbiBpc29tb3JwaGljRW5jb2RlIChpbnB1dCkge1xuICAvLyAxLiBBc3NlcnQ6IGlucHV0IGNvbnRhaW5zIG5vIGNvZGUgcG9pbnRzIGdyZWF0ZXIgdGhhbiBVKzAwRkYuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBhc3NlcnQoaW5wdXQuY2hhckNvZGVBdChpKSA8PSAweEZGKVxuICB9XG5cbiAgLy8gMi4gUmV0dXJuIGEgYnl0ZSBzZXF1ZW5jZSB3aG9zZSBsZW5ndGggaXMgZXF1YWwgdG8gaW5wdXTigJlzIGNvZGVcbiAgLy8gICAgcG9pbnQgbGVuZ3RoIGFuZCB3aG9zZSBieXRlcyBoYXZlIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgLy8gICAgdmFsdWVzIG9mIGlucHV04oCZcyBjb2RlIHBvaW50cywgaW4gdGhlIHNhbWUgb3JkZXJcbiAgcmV0dXJuIGlucHV0XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyNyZWFkYWJsZXN0cmVhbWRlZmF1bHRyZWFkZXItcmVhZC1hbGwtYnl0ZXNcbiAqIEBzZWUgaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZC1sb29wXG4gKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcn0gcmVhZGVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRBbGxCeXRlcyAocmVhZGVyKSB7XG4gIGNvbnN0IGJ5dGVzID0gW11cbiAgbGV0IGJ5dGVMZW5ndGggPSAwXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlOiBjaHVuayB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuXG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIC8vIDEuIENhbGwgc3VjY2Vzc1N0ZXBzIHdpdGggYnl0ZXMuXG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChieXRlcywgYnl0ZUxlbmd0aClcbiAgICB9XG5cbiAgICAvLyAxLiBJZiBjaHVuayBpcyBub3QgYSBVaW50OEFycmF5IG9iamVjdCwgY2FsbCBmYWlsdXJlU3RlcHNcbiAgICAvLyAgICB3aXRoIGEgVHlwZUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICBpZiAoIWlzVWludDhBcnJheShjaHVuaykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlY2VpdmVkIG5vbi1VaW50OEFycmF5IGNodW5rJylcbiAgICB9XG5cbiAgICAvLyAyLiBBcHBlbmQgdGhlIGJ5dGVzIHJlcHJlc2VudGVkIGJ5IGNodW5rIHRvIGJ5dGVzLlxuICAgIGJ5dGVzLnB1c2goY2h1bmspXG4gICAgYnl0ZUxlbmd0aCArPSBjaHVuay5sZW5ndGhcblxuICAgIC8vIDMuIFJlYWQtbG9vcCBnaXZlbiByZWFkZXIsIGJ5dGVzLCBzdWNjZXNzU3RlcHMsIGFuZCBmYWlsdXJlU3RlcHMuXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNpcy1sb2NhbFxuICogQHBhcmFtIHtVUkx9IHVybFxuICovXG5mdW5jdGlvbiB1cmxJc0xvY2FsICh1cmwpIHtcbiAgYXNzZXJ0KCdwcm90b2NvbCcgaW4gdXJsKSAvLyBlbnN1cmUgaXQncyBhIHVybCBvYmplY3RcblxuICBjb25zdCBwcm90b2NvbCA9IHVybC5wcm90b2NvbFxuXG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2Fib3V0OicgfHwgcHJvdG9jb2wgPT09ICdibG9iOicgfHwgcHJvdG9jb2wgPT09ICdkYXRhOidcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IHVybFxuICovXG5mdW5jdGlvbiB1cmxIYXNIdHRwc1NjaGVtZSAodXJsKSB7XG4gIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmwuc3RhcnRzV2l0aCgnaHR0cHM6JylcbiAgfVxuXG4gIHJldHVybiB1cmwucHJvdG9jb2wgPT09ICdodHRwczonXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1zY2hlbWVcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqL1xuZnVuY3Rpb24gdXJsSXNIdHRwSHR0cHNTY2hlbWUgKHVybCkge1xuICBhc3NlcnQoJ3Byb3RvY29sJyBpbiB1cmwpIC8vIGVuc3VyZSBpdCdzIGEgdXJsIG9iamVjdFxuXG4gIGNvbnN0IHByb3RvY29sID0gdXJsLnByb3RvY29sXG5cbiAgcmV0dXJuIHByb3RvY29sID09PSAnaHR0cDonIHx8IHByb3RvY29sID09PSAnaHR0cHM6J1xufVxuXG4vKipcbiAqIEZldGNoIHN1cHBvcnRzIG5vZGUgPj0gMTYuOC4wLCBidXQgT2JqZWN0Lmhhc093biB3YXMgYWRkZWQgaW4gdjE2LjkuMC5cbiAqL1xuY29uc3QgaGFzT3duID0gT2JqZWN0Lmhhc093biB8fCAoKGRpY3QsIGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpY3QsIGtleSkpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0Fib3J0ZWQsXG4gIGlzQ2FuY2VsbGVkLFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gIFJlYWRhYmxlU3RyZWFtRnJvbSxcbiAgdG9VU1ZTdHJpbmcsXG4gIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCxcbiAgY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUsXG4gIGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIsXG4gIG1ha2VQb2xpY3lDb250YWluZXIsXG4gIGNsb25lUG9saWN5Q29udGFpbmVyLFxuICBhcHBlbmRGZXRjaE1ldGFkYXRhLFxuICBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyLFxuICBUQU9DaGVjayxcbiAgY29yc0NoZWNrLFxuICBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2ssXG4gIGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8sXG4gIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QsXG4gIGlzVmFsaWRIVFRQVG9rZW4sXG4gIHJlcXVlc3RCYWRQb3J0LFxuICByZXF1ZXN0Q3VycmVudFVSTCxcbiAgcmVzcG9uc2VVUkwsXG4gIHJlc3BvbnNlTG9jYXRpb25VUkwsXG4gIGlzQmxvYkxpa2UsXG4gIGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeSxcbiAgaXNWYWxpZFJlYXNvblBocmFzZSxcbiAgc2FtZU9yaWdpbixcbiAgbm9ybWFsaXplTWV0aG9kLFxuICBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcsXG4gIG1ha2VJdGVyYXRvcixcbiAgaXNWYWxpZEhlYWRlck5hbWUsXG4gIGlzVmFsaWRIZWFkZXJWYWx1ZSxcbiAgaGFzT3duLFxuICBpc0Vycm9yTGlrZSxcbiAgZnVsbHlSZWFkQm9keSxcbiAgYnl0ZXNNYXRjaCxcbiAgaXNSZWFkYWJsZVN0cmVhbUxpa2UsXG4gIHJlYWRhYmxlU3RyZWFtQ2xvc2UsXG4gIGlzb21vcnBoaWNFbmNvZGUsXG4gIGlzb21vcnBoaWNEZWNvZGUsXG4gIHVybElzTG9jYWwsXG4gIHVybEhhc0h0dHBzU2NoZW1lLFxuICB1cmxJc0h0dHBIdHRwc1NjaGVtZSxcbiAgcmVhZEFsbEJ5dGVzXG59XG4iXSwibmFtZXMiOlsicmVkaXJlY3RTdGF0dXNTZXQiLCJyZWZlcnJlclBvbGljeVNldCIsInJlZmVycmVyUG9saWN5VG9rZW5zIiwiYmFkUG9ydHNTZXQiLCJyZXF1aXJlIiwiZ2V0R2xvYmFsT3JpZ2luIiwicGVyZm9ybWFuY2UiLCJpc0Jsb2JMaWtlIiwidG9VU1ZTdHJpbmciLCJSZWFkYWJsZVN0cmVhbUZyb20iLCJhc3NlcnQiLCJpc1VpbnQ4QXJyYXkiLCJjcnlwdG8iLCJyZXNwb25zZVVSTCIsInJlc3BvbnNlIiwidXJsTGlzdCIsImxlbmd0aCIsInRvU3RyaW5nIiwicmVzcG9uc2VMb2NhdGlvblVSTCIsInJlcXVlc3RGcmFnbWVudCIsImhhcyIsInN0YXR1cyIsImxvY2F0aW9uIiwiaGVhZGVyc0xpc3QiLCJnZXQiLCJpc1ZhbGlkSGVhZGVyVmFsdWUiLCJVUkwiLCJoYXNoIiwicmVxdWVzdEN1cnJlbnRVUkwiLCJyZXF1ZXN0IiwicmVxdWVzdEJhZFBvcnQiLCJ1cmwiLCJ1cmxJc0h0dHBIdHRwc1NjaGVtZSIsInBvcnQiLCJpc0Vycm9yTGlrZSIsIm9iamVjdCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiaXNWYWxpZFJlYXNvblBocmFzZSIsInN0YXR1c1RleHQiLCJpIiwiYyIsImNoYXJDb2RlQXQiLCJpc1Rva2VuQ2hhciIsImlzVmFsaWRIVFRQVG9rZW4iLCJjaGFyYWN0ZXJzIiwiaXNWYWxpZEhlYWRlck5hbWUiLCJwb3RlbnRpYWxWYWx1ZSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImluY2x1ZGVzIiwic2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCIsImFjdHVhbFJlc3BvbnNlIiwicG9saWN5SGVhZGVyIiwic3BsaXQiLCJwb2xpY3kiLCJ0b2tlbiIsInRyaW0iLCJyZWZlcnJlclBvbGljeSIsImNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayIsImNvcnNDaGVjayIsIlRBT0NoZWNrIiwiYXBwZW5kRmV0Y2hNZXRhZGF0YSIsImh0dHBSZXF1ZXN0IiwiaGVhZGVyIiwibW9kZSIsInNldCIsImFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIiLCJzZXJpYWxpemVkT3JpZ2luIiwib3JpZ2luIiwicmVzcG9uc2VUYWludGluZyIsImFwcGVuZCIsIm1ldGhvZCIsInVybEhhc0h0dHBzU2NoZW1lIiwic2FtZU9yaWdpbiIsImNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lIiwiY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkiLCJub3ciLCJjcmVhdGVPcGFxdWVUaW1pbmdJbmZvIiwidGltaW5nSW5mbyIsInN0YXJ0VGltZSIsInJlZGlyZWN0U3RhcnRUaW1lIiwicmVkaXJlY3RFbmRUaW1lIiwicG9zdFJlZGlyZWN0U3RhcnRUaW1lIiwiZmluYWxTZXJ2aWNlV29ya2VyU3RhcnRUaW1lIiwiZmluYWxOZXR3b3JrUmVzcG9uc2VTdGFydFRpbWUiLCJmaW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lIiwiZW5kVGltZSIsImVuY29kZWRCb2R5U2l6ZSIsImRlY29kZWRCb2R5U2l6ZSIsImZpbmFsQ29ubmVjdGlvblRpbWluZ0luZm8iLCJtYWtlUG9saWN5Q29udGFpbmVyIiwiY2xvbmVQb2xpY3lDb250YWluZXIiLCJwb2xpY3lDb250YWluZXIiLCJkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIiwicmVmZXJyZXJTb3VyY2UiLCJyZWZlcnJlciIsImdsb2JhbE9yaWdpbiIsInJlZmVycmVyVVJMIiwic3RyaXBVUkxGb3JSZWZlcnJlciIsInJlZmVycmVyT3JpZ2luIiwiYXJlU2FtZU9yaWdpbiIsImlzTm9uUG90ZW50aWFsbHlUcnVzdFdvcnRoeSIsImlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeSIsImN1cnJlbnRVUkwiLCJvcmlnaW5Pbmx5IiwicHJvdG9jb2wiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwicGF0aG5hbWUiLCJzZWFyY2giLCJocmVmIiwiaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5Iiwib3JpZ2luQXNVUkwiLCJ0ZXN0IiwiaG9zdG5hbWUiLCJieXRlc01hdGNoIiwiYnl0ZXMiLCJtZXRhZGF0YUxpc3QiLCJ1bmRlZmluZWQiLCJwYXJzZWRNZXRhZGF0YSIsInBhcnNlTWV0YWRhdGEiLCJsaXN0Iiwic29ydCIsImQiLCJhbGdvIiwibG9jYWxlQ29tcGFyZSIsInN0cm9uZ2VzdCIsIm1ldGFkYXRhIiwiZmlsdGVyIiwiaXRlbSIsImFsZ29yaXRobSIsImV4cGVjdGVkVmFsdWUiLCJzbGljZSIsImFjdHVhbFZhbHVlIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImRpZ2VzdCIsImFjdHVhbEJhc2U2NFVSTCIsInBhcnNlSGFzaFdpdGhPcHRpb25zIiwicmVzdWx0IiwiZW1wdHkiLCJzdXBwb3J0ZWRIYXNoZXMiLCJnZXRIYXNoZXMiLCJwYXJzZWRUb2tlbiIsImV4ZWMiLCJncm91cHMiLCJ0b0xvd2VyQ2FzZSIsInB1c2giLCJ0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwiLCJBIiwiQiIsImNyZWF0ZURlZmVycmVkUHJvbWlzZSIsInJlcyIsInJlaiIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImlzQWJvcnRlZCIsImZldGNoUGFyYW1zIiwiY29udHJvbGxlciIsInN0YXRlIiwiaXNDYW5jZWxsZWQiLCJub3JtYWxpemVNZXRob2QiLCJ0b1VwcGVyQ2FzZSIsInNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyIsInZhbHVlIiwiSlNPTiIsInN0cmluZ2lmeSIsIlR5cGVFcnJvciIsImVzSXRlcmF0b3JQcm90b3R5cGUiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibWFrZUl0ZXJhdG9yIiwia2luZCIsImluZGV4IiwidGFyZ2V0IiwibmV4dCIsInZhbHVlcyIsImxlbiIsImRvbmUiLCJwYWlyIiwiaXRlcmF0b3JSZXN1bHQiLCJ0b1N0cmluZ1RhZyIsInNldFByb3RvdHlwZU9mIiwiZnVsbHlSZWFkQm9keSIsImJvZHkiLCJwcm9jZXNzQm9keSIsInByb2Nlc3NCb2R5RXJyb3IiLCJzdWNjZXNzU3RlcHMiLCJlcnJvclN0ZXBzIiwicmVhZGVyIiwic3RyZWFtIiwiZ2V0UmVhZGVyIiwiZSIsInJlYWRBbGxCeXRlcyIsIlJlYWRhYmxlU3RyZWFtIiwiZ2xvYmFsVGhpcyIsImlzUmVhZGFibGVTdHJlYW1MaWtlIiwidGVlIiwiTUFYSU1VTV9BUkdVTUVOVF9MRU5HVEgiLCJpc29tb3JwaGljRGVjb2RlIiwiaW5wdXQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJyZWR1Y2UiLCJwcmV2aW91cyIsImN1cnJlbnQiLCJyZWFkYWJsZVN0cmVhbUNsb3NlIiwiY2xvc2UiLCJlcnIiLCJtZXNzYWdlIiwiaXNvbW9ycGhpY0VuY29kZSIsImJ5dGVMZW5ndGgiLCJjaHVuayIsInJlYWQiLCJCdWZmZXIiLCJjb25jYXQiLCJ1cmxJc0xvY2FsIiwiaGFzT3duIiwiZGljdCIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/util.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fetch/webidl.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/webidl.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { types } = __webpack_require__(/*! util */ \"util\");\nconst { hasOwn, toUSVString } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/fetch/util.js\");\n/** @type {import('../../types/webidl').Webidl} */ const webidl = {};\nwebidl.converters = {};\nwebidl.util = {};\nwebidl.errors = {};\nwebidl.errors.exception = function(message) {\n    return new TypeError(`${message.header}: ${message.message}`);\n};\nwebidl.errors.conversionFailed = function(context) {\n    const plural = context.types.length === 1 ? \"\" : \" one of\";\n    const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(\", \")}.`;\n    return webidl.errors.exception({\n        header: context.prefix,\n        message\n    });\n};\nwebidl.errors.invalidArgument = function(context) {\n    return webidl.errors.exception({\n        header: context.prefix,\n        message: `\"${context.value}\" is an invalid ${context.type}.`\n    });\n};\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function(V, I, opts = undefined) {\n    if (opts?.strict !== false && !(V instanceof I)) {\n        throw new TypeError(\"Illegal invocation\");\n    } else {\n        return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];\n    }\n};\nwebidl.argumentLengthCheck = function({ length }, min, ctx) {\n    if (length < min) {\n        throw webidl.errors.exception({\n            message: `${min} argument${min !== 1 ? \"s\" : \"\"} required, ` + `but${length ? \" only\" : \"\"} ${length} found.`,\n            ...ctx\n        });\n    }\n};\nwebidl.illegalConstructor = function() {\n    throw webidl.errors.exception({\n        header: \"TypeError\",\n        message: \"Illegal constructor\"\n    });\n};\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function(V) {\n    switch(typeof V){\n        case \"undefined\":\n            return \"Undefined\";\n        case \"boolean\":\n            return \"Boolean\";\n        case \"string\":\n            return \"String\";\n        case \"symbol\":\n            return \"Symbol\";\n        case \"number\":\n            return \"Number\";\n        case \"bigint\":\n            return \"BigInt\";\n        case \"function\":\n        case \"object\":\n            {\n                if (V === null) {\n                    return \"Null\";\n                }\n                return \"Object\";\n            }\n    }\n};\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {\n    let upperBound;\n    let lowerBound;\n    // 1. If bitLength is 64, then:\n    if (bitLength === 64) {\n        // 1. Let upperBound be 2^53  1.\n        upperBound = Math.pow(2, 53) - 1;\n        // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n        if (signedness === \"unsigned\") {\n            lowerBound = 0;\n        } else {\n            // 3. Otherwise let lowerBound be 2^53 + 1.\n            lowerBound = Math.pow(-2, 53) + 1;\n        }\n    } else if (signedness === \"unsigned\") {\n        // 2. Otherwise, if signedness is \"unsigned\", then:\n        // 1. Let lowerBound be 0.\n        lowerBound = 0;\n        // 2. Let upperBound be 2^bitLength  1.\n        upperBound = Math.pow(2, bitLength) - 1;\n    } else {\n        // 3. Otherwise:\n        // 1. Let lowerBound be -2^bitLength  1.\n        lowerBound = Math.pow(-2, bitLength) - 1;\n        // 2. Let upperBound be 2^bitLength  1  1.\n        upperBound = Math.pow(2, bitLength - 1) - 1;\n    }\n    // 4. Let x be ? ToNumber(V).\n    let x = Number(V);\n    // 5. If x is 0, then set x to +0.\n    if (x === 0) {\n        x = 0;\n    }\n    // 6. If the conversion is to an IDL type associated\n    //    with the [EnforceRange] extended attribute, then:\n    if (opts.enforceRange === true) {\n        // 1. If x is NaN, +, or , then throw a TypeError.\n        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n            throw webidl.errors.exception({\n                header: \"Integer conversion\",\n                message: `Could not convert ${V} to an integer.`\n            });\n        }\n        // 2. Set x to IntegerPart(x).\n        x = webidl.util.IntegerPart(x);\n        // 3. If x < lowerBound or x > upperBound, then\n        //    throw a TypeError.\n        if (x < lowerBound || x > upperBound) {\n            throw webidl.errors.exception({\n                header: \"Integer conversion\",\n                message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n            });\n        }\n        // 4. Return x.\n        return x;\n    }\n    // 7. If x is not NaN and the conversion is to an IDL\n    //    type associated with the [Clamp] extended\n    //    attribute, then:\n    if (!Number.isNaN(x) && opts.clamp === true) {\n        // 1. Set x to min(max(x, lowerBound), upperBound).\n        x = Math.min(Math.max(x, lowerBound), upperBound);\n        // 2. Round x to the nearest integer, choosing the\n        //    even integer if it lies halfway between two,\n        //    and choosing +0 rather than 0.\n        if (Math.floor(x) % 2 === 0) {\n            x = Math.floor(x);\n        } else {\n            x = Math.ceil(x);\n        }\n        // 3. Return x.\n        return x;\n    }\n    // 8. If x is NaN, +0, +, or , then return +0.\n    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n        return 0;\n    }\n    // 9. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x);\n    // 10. Set x to x modulo 2^bitLength.\n    x = x % Math.pow(2, bitLength);\n    // 11. If signedness is \"signed\" and x  2^bitLength  1,\n    //    then return x  2^bitLength.\n    if (signedness === \"signed\" && x >= Math.pow(2, bitLength) - 1) {\n        return x - Math.pow(2, bitLength);\n    }\n    // 12. Otherwise, return x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function(n) {\n    // 1. Let r be floor(abs(n)).\n    const r = Math.floor(Math.abs(n));\n    // 2. If n < 0, then return -1  r.\n    if (n < 0) {\n        return -1 * r;\n    }\n    // 3. Otherwise, return r.\n    return r;\n};\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function(converter) {\n    return (V)=>{\n        // 1. If Type(V) is not Object, throw a TypeError.\n        if (webidl.util.Type(V) !== \"Object\") {\n            throw webidl.errors.exception({\n                header: \"Sequence\",\n                message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n            });\n        }\n        // 2. Let method be ? GetMethod(V, @@iterator).\n        /** @type {Generator} */ const method = V?.[Symbol.iterator]?.();\n        const seq = [];\n        // 3. If method is undefined, throw a TypeError.\n        if (method === undefined || typeof method.next !== \"function\") {\n            throw webidl.errors.exception({\n                header: \"Sequence\",\n                message: \"Object is not an iterator.\"\n            });\n        }\n        // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n        while(true){\n            const { done, value } = method.next();\n            if (done) {\n                break;\n            }\n            seq.push(converter(value));\n        }\n        return seq;\n    };\n};\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function(keyConverter, valueConverter) {\n    return (O)=>{\n        // 1. If Type(O) is not Object, throw a TypeError.\n        if (webidl.util.Type(O) !== \"Object\") {\n            throw webidl.errors.exception({\n                header: \"Record\",\n                message: `Value of type ${webidl.util.Type(O)} is not an Object.`\n            });\n        }\n        // 2. Let result be a new empty instance of record<K, V>.\n        const result = {};\n        if (!types.isProxy(O)) {\n            // Object.keys only returns enumerable properties\n            const keys = Object.keys(O);\n            for (const key of keys){\n                // 1. Let typedKey be key converted to an IDL value of type K.\n                const typedKey = keyConverter(key);\n                // 2. Let value be ? Get(O, key).\n                // 3. Let typedValue be value converted to an IDL value of type V.\n                const typedValue = valueConverter(O[key]);\n                // 4. Set result[typedKey] to typedValue.\n                result[typedKey] = typedValue;\n            }\n            // 5. Return result.\n            return result;\n        }\n        // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n        const keys = Reflect.ownKeys(O);\n        // 4. For each key of keys.\n        for (const key of keys){\n            // 1. Let desc be ? O.[[GetOwnProperty]](key).\n            const desc = Reflect.getOwnPropertyDescriptor(O, key);\n            // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n            if (desc?.enumerable) {\n                // 1. Let typedKey be key converted to an IDL value of type K.\n                const typedKey = keyConverter(key);\n                // 2. Let value be ? Get(O, key).\n                // 3. Let typedValue be value converted to an IDL value of type V.\n                const typedValue = valueConverter(O[key]);\n                // 4. Set result[typedKey] to typedValue.\n                result[typedKey] = typedValue;\n            }\n        }\n        // 5. Return result.\n        return result;\n    };\n};\nwebidl.interfaceConverter = function(i) {\n    return (V, opts = {})=>{\n        if (opts.strict !== false && !(V instanceof i)) {\n            throw webidl.errors.exception({\n                header: i.name,\n                message: `Expected ${V} to be an instance of ${i.name}.`\n            });\n        }\n        return V;\n    };\n};\nwebidl.dictionaryConverter = function(converters) {\n    return (dictionary)=>{\n        const type = webidl.util.Type(dictionary);\n        const dict = {};\n        if (type === \"Null\" || type === \"Undefined\") {\n            return dict;\n        } else if (type !== \"Object\") {\n            throw webidl.errors.exception({\n                header: \"Dictionary\",\n                message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n            });\n        }\n        for (const options of converters){\n            const { key, defaultValue, required, converter } = options;\n            if (required === true) {\n                if (!hasOwn(dictionary, key)) {\n                    throw webidl.errors.exception({\n                        header: \"Dictionary\",\n                        message: `Missing required key \"${key}\".`\n                    });\n                }\n            }\n            let value = dictionary[key];\n            const hasDefault = hasOwn(options, \"defaultValue\");\n            // Only use defaultValue if value is undefined and\n            // a defaultValue options was provided.\n            if (hasDefault && value !== null) {\n                value = value ?? defaultValue;\n            }\n            // A key can be optional and have no default value.\n            // When this happens, do not perform a conversion,\n            // and do not assign the key a value.\n            if (required || hasDefault || value !== undefined) {\n                value = converter(value);\n                if (options.allowedValues && !options.allowedValues.includes(value)) {\n                    throw webidl.errors.exception({\n                        header: \"Dictionary\",\n                        message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(\", \")}.`\n                    });\n                }\n                dict[key] = value;\n            }\n        }\n        return dict;\n    };\n};\nwebidl.nullableConverter = function(converter) {\n    return (V)=>{\n        if (V === null) {\n            return V;\n        }\n        return converter(V);\n    };\n};\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function(V, opts = {}) {\n    // 1. If V is null and the conversion is to an IDL type\n    //    associated with the [LegacyNullToEmptyString]\n    //    extended attribute, then return the DOMString value\n    //    that represents the empty string.\n    if (V === null && opts.legacyNullToEmptyString) {\n        return \"\";\n    }\n    // 2. Let x be ? ToString(V).\n    if (typeof V === \"symbol\") {\n        throw new TypeError(\"Could not convert argument of type symbol to string.\");\n    }\n    // 3. Return the IDL DOMString value that represents the\n    //    same sequence of code units as the one the\n    //    ECMAScript String value x represents.\n    return String(V);\n};\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function(V) {\n    // 1. Let x be ? ToString(V).\n    // Note: DOMString converter perform ? ToString(V)\n    const x = webidl.converters.DOMString(V);\n    // 2. If the value of any element of x is greater than\n    //    255, then throw a TypeError.\n    for(let index = 0; index < x.length; index++){\n        const charCode = x.charCodeAt(index);\n        if (charCode > 255) {\n            throw new TypeError(\"Cannot convert argument to a ByteString because the character at \" + `index ${index} has a value of ${charCode} which is greater than 255.`);\n        }\n    }\n    // 3. Return an IDL ByteString value whose length is the\n    //    length of x, and where the value of each element is\n    //    the value of the corresponding element of x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-USVString\nwebidl.converters.USVString = toUSVString;\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function(V) {\n    // 1. Let x be the result of computing ToBoolean(V).\n    const x = Boolean(V);\n    // 2. Return the IDL boolean value that is the one that represents\n    //    the same truth value as the ECMAScript Boolean value x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function(V) {\n    return V;\n};\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters[\"long long\"] = function(V) {\n    // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n    const x = webidl.util.ConvertToInt(V, 64, \"signed\");\n    // 2. Return the IDL long long value that represents\n    //    the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters[\"unsigned long long\"] = function(V) {\n    // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 64, \"unsigned\");\n    // 2. Return the IDL unsigned long long value that\n    //    represents the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters[\"unsigned long\"] = function(V) {\n    // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 32, \"unsigned\");\n    // 2. Return the IDL unsigned long value that\n    //    represents the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters[\"unsigned short\"] = function(V, opts) {\n    // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 16, \"unsigned\", opts);\n    // 2. Return the IDL unsigned short value that represents\n    //    the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function(V, opts = {}) {\n    // 1. If Type(V) is not Object, or V does not have an\n    //    [[ArrayBufferData]] internal slot, then throw a\n    //    TypeError.\n    // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n    // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n    if (webidl.util.Type(V) !== \"Object\" || !types.isAnyArrayBuffer(V)) {\n        throw webidl.errors.conversionFailed({\n            prefix: `${V}`,\n            argument: `${V}`,\n            types: [\n                \"ArrayBuffer\"\n            ]\n        });\n    }\n    // 2. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V) is true, then throw a\n    //    TypeError.\n    if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V) is true, then throw a\n    //    TypeError.\n    // Note: resizable ArrayBuffers are currently a proposal.\n    // 4. Return the IDL ArrayBuffer value that is a\n    //    reference to the same object as V.\n    return V;\n};\nwebidl.converters.TypedArray = function(V, T, opts = {}) {\n    // 1. Let T be the IDL type V is being converted to.\n    // 2. If Type(V) is not Object, or V does not have a\n    //    [[TypedArrayName]] internal slot with a value\n    //    equal to Ts name, then throw a TypeError.\n    if (webidl.util.Type(V) !== \"Object\" || !types.isTypedArray(V) || V.constructor.name !== T.name) {\n        throw webidl.errors.conversionFailed({\n            prefix: `${T.name}`,\n            argument: `${V}`,\n            types: [\n                T.name\n            ]\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n    }\n    // 4. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    // Note: resizable array buffers are currently a proposal\n    // 5. Return the IDL value of type T that is a reference\n    //    to the same object as V.\n    return V;\n};\nwebidl.converters.DataView = function(V, opts = {}) {\n    // 1. If Type(V) is not Object, or V does not have a\n    //    [[DataView]] internal slot, then throw a TypeError.\n    if (webidl.util.Type(V) !== \"Object\" || !types.isDataView(V)) {\n        throw webidl.errors.exception({\n            header: \"DataView\",\n            message: \"Object is not a DataView.\"\n        });\n    }\n    // 2. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n    //    then throw a TypeError.\n    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    // Note: resizable ArrayBuffers are currently a proposal\n    // 4. Return the IDL DataView value that is a reference\n    //    to the same object as V.\n    return V;\n};\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function(V, opts = {}) {\n    if (types.isAnyArrayBuffer(V)) {\n        return webidl.converters.ArrayBuffer(V, opts);\n    }\n    if (types.isTypedArray(V)) {\n        return webidl.converters.TypedArray(V, V.constructor);\n    }\n    if (types.isDataView(V)) {\n        return webidl.converters.DataView(V, opts);\n    }\n    throw new TypeError(`Could not convert ${V} to a BufferSource.`);\n};\nwebidl.converters[\"sequence<ByteString>\"] = webidl.sequenceConverter(webidl.converters.ByteString);\nwebidl.converters[\"sequence<sequence<ByteString>>\"] = webidl.sequenceConverter(webidl.converters[\"sequence<ByteString>\"]);\nwebidl.converters[\"record<ByteString, ByteString>\"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);\nmodule.exports = {\n    webidl\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvd2ViaWRsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxLQUFLLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDMUIsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFdBQVcsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUV4QyxnREFBZ0QsR0FDaEQsTUFBTUcsU0FBUyxDQUFDO0FBQ2hCQSxPQUFPQyxVQUFVLEdBQUcsQ0FBQztBQUNyQkQsT0FBT0UsSUFBSSxHQUFHLENBQUM7QUFDZkYsT0FBT0csTUFBTSxHQUFHLENBQUM7QUFFakJILE9BQU9HLE1BQU0sQ0FBQ0MsU0FBUyxHQUFHLFNBQVVDLE9BQU87SUFDekMsT0FBTyxJQUFJQyxVQUFVLENBQUMsRUFBRUQsUUFBUUUsTUFBTSxDQUFDLEVBQUUsRUFBRUYsUUFBUUEsT0FBTyxDQUFDLENBQUM7QUFDOUQ7QUFFQUwsT0FBT0csTUFBTSxDQUFDSyxnQkFBZ0IsR0FBRyxTQUFVQyxPQUFPO0lBQ2hELE1BQU1DLFNBQVNELFFBQVFiLEtBQUssQ0FBQ2UsTUFBTSxLQUFLLElBQUksS0FBSztJQUNqRCxNQUFNTixVQUNKLENBQUMsRUFBRUksUUFBUUcsUUFBUSxDQUFDLDBCQUEwQixDQUFDLEdBQy9DLENBQUMsRUFBRUYsT0FBTyxFQUFFLEVBQUVELFFBQVFiLEtBQUssQ0FBQ2lCLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUUzQyxPQUFPYixPQUFPRyxNQUFNLENBQUNDLFNBQVMsQ0FBQztRQUM3QkcsUUFBUUUsUUFBUUssTUFBTTtRQUN0QlQ7SUFDRjtBQUNGO0FBRUFMLE9BQU9HLE1BQU0sQ0FBQ1ksZUFBZSxHQUFHLFNBQVVOLE9BQU87SUFDL0MsT0FBT1QsT0FBT0csTUFBTSxDQUFDQyxTQUFTLENBQUM7UUFDN0JHLFFBQVFFLFFBQVFLLE1BQU07UUFDdEJULFNBQVMsQ0FBQyxDQUFDLEVBQUVJLFFBQVFPLEtBQUss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ZUFBZSxDQUMxRS9ELE9BQU9DLFVBQVUsQ0FBQzZGLFVBQVUsRUFDNUI5RixPQUFPQyxVQUFVLENBQUM2RixVQUFVO0FBRzlCb0IsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZuSDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC93ZWJpZGwuanM/ZGM0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB0eXBlcyB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCB7IGhhc093biwgdG9VU1ZTdHJpbmcgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi90eXBlcy93ZWJpZGwnKS5XZWJpZGx9ICovXG5jb25zdCB3ZWJpZGwgPSB7fVxud2ViaWRsLmNvbnZlcnRlcnMgPSB7fVxud2ViaWRsLnV0aWwgPSB7fVxud2ViaWRsLmVycm9ycyA9IHt9XG5cbndlYmlkbC5lcnJvcnMuZXhjZXB0aW9uID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYCR7bWVzc2FnZS5oZWFkZXJ9OiAke21lc3NhZ2UubWVzc2FnZX1gKVxufVxuXG53ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBwbHVyYWwgPSBjb250ZXh0LnR5cGVzLmxlbmd0aCA9PT0gMSA/ICcnIDogJyBvbmUgb2YnXG4gIGNvbnN0IG1lc3NhZ2UgPVxuICAgIGAke2NvbnRleHQuYXJndW1lbnR9IGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG9gICtcbiAgICBgJHtwbHVyYWx9OiAke2NvbnRleHQudHlwZXMuam9pbignLCAnKX0uYFxuXG4gIHJldHVybiB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiBjb250ZXh0LnByZWZpeCxcbiAgICBtZXNzYWdlXG4gIH0pXG59XG5cbndlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgcmV0dXJuIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICBoZWFkZXI6IGNvbnRleHQucHJlZml4LFxuICAgIG1lc3NhZ2U6IGBcIiR7Y29udGV4dC52YWx1ZX1cIiBpcyBhbiBpbnZhbGlkICR7Y29udGV4dC50eXBlfS5gXG4gIH0pXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jaW1wbGVtZW50c1xud2ViaWRsLmJyYW5kQ2hlY2sgPSBmdW5jdGlvbiAoViwgSSwgb3B0cyA9IHVuZGVmaW5lZCkge1xuICBpZiAob3B0cz8uc3RyaWN0ICE9PSBmYWxzZSAmJiAhKFYgaW5zdGFuY2VvZiBJKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgaW52b2NhdGlvbicpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFY/LltTeW1ib2wudG9TdHJpbmdUYWddID09PSBJLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddXG4gIH1cbn1cblxud2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2sgPSBmdW5jdGlvbiAoeyBsZW5ndGggfSwgbWluLCBjdHgpIHtcbiAgaWYgKGxlbmd0aCA8IG1pbikge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIG1lc3NhZ2U6IGAke21pbn0gYXJndW1lbnQke21pbiAhPT0gMSA/ICdzJyA6ICcnfSByZXF1aXJlZCwgYCArXG4gICAgICAgICAgICAgICBgYnV0JHtsZW5ndGggPyAnIG9ubHknIDogJyd9ICR7bGVuZ3RofSBmb3VuZC5gLFxuICAgICAgLi4uY3R4XG4gICAgfSlcbiAgfVxufVxuXG53ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiAnVHlwZUVycm9yJyxcbiAgICBtZXNzYWdlOiAnSWxsZWdhbCBjb25zdHJ1Y3RvcidcbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xud2ViaWRsLnV0aWwuVHlwZSA9IGZ1bmN0aW9uIChWKSB7XG4gIHN3aXRjaCAodHlwZW9mIFYpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOiByZXR1cm4gJ1VuZGVmaW5lZCdcbiAgICBjYXNlICdib29sZWFuJzogcmV0dXJuICdCb29sZWFuJ1xuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiAnU3RyaW5nJ1xuICAgIGNhc2UgJ3N5bWJvbCc6IHJldHVybiAnU3ltYm9sJ1xuICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnTnVtYmVyJ1xuICAgIGNhc2UgJ2JpZ2ludCc6IHJldHVybiAnQmlnSW50J1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICBpZiAoViA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ051bGwnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnT2JqZWN0J1xuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Fic3RyYWN0LW9wZGVmLWNvbnZlcnR0b2ludFxud2ViaWRsLnV0aWwuQ29udmVydFRvSW50ID0gZnVuY3Rpb24gKFYsIGJpdExlbmd0aCwgc2lnbmVkbmVzcywgb3B0cyA9IHt9KSB7XG4gIGxldCB1cHBlckJvdW5kXG4gIGxldCBsb3dlckJvdW5kXG5cbiAgLy8gMS4gSWYgYml0TGVuZ3RoIGlzIDY0LCB0aGVuOlxuICBpZiAoYml0TGVuZ3RoID09PSA2NCkge1xuICAgIC8vIDEuIExldCB1cHBlckJvdW5kIGJlIDJeNTMg4oiSIDEuXG4gICAgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIDUzKSAtIDFcblxuICAgIC8vIDIuIElmIHNpZ25lZG5lc3MgaXMgXCJ1bnNpZ25lZFwiLCB0aGVuIGxldCBsb3dlckJvdW5kIGJlIDAuXG4gICAgaWYgKHNpZ25lZG5lc3MgPT09ICd1bnNpZ25lZCcpIHtcbiAgICAgIGxvd2VyQm91bmQgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDMuIE90aGVyd2lzZSBsZXQgbG93ZXJCb3VuZCBiZSDiiJIyXjUzICsgMS5cbiAgICAgIGxvd2VyQm91bmQgPSBNYXRoLnBvdygtMiwgNTMpICsgMVxuICAgIH1cbiAgfSBlbHNlIGlmIChzaWduZWRuZXNzID09PSAndW5zaWduZWQnKSB7XG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiBzaWduZWRuZXNzIGlzIFwidW5zaWduZWRcIiwgdGhlbjpcblxuICAgIC8vIDEuIExldCBsb3dlckJvdW5kIGJlIDAuXG4gICAgbG93ZXJCb3VuZCA9IDBcblxuICAgIC8vIDIuIExldCB1cHBlckJvdW5kIGJlIDJeYml0TGVuZ3RoIOKIkiAxLlxuICAgIHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCBiaXRMZW5ndGgpIC0gMVxuICB9IGVsc2Uge1xuICAgIC8vIDMuIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIExldCBsb3dlckJvdW5kIGJlIC0yXmJpdExlbmd0aCDiiJIgMS5cbiAgICBsb3dlckJvdW5kID0gTWF0aC5wb3coLTIsIGJpdExlbmd0aCkgLSAxXG5cbiAgICAvLyAyLiBMZXQgdXBwZXJCb3VuZCBiZSAyXmJpdExlbmd0aCDiiJIgMSDiiJIgMS5cbiAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoIC0gMSkgLSAxXG4gIH1cblxuICAvLyA0LiBMZXQgeCBiZSA/IFRvTnVtYmVyKFYpLlxuICBsZXQgeCA9IE51bWJlcihWKVxuXG4gIC8vIDUuIElmIHggaXMg4oiSMCwgdGhlbiBzZXQgeCB0byArMC5cbiAgaWYgKHggPT09IDApIHtcbiAgICB4ID0gMFxuICB9XG5cbiAgLy8gNi4gSWYgdGhlIGNvbnZlcnNpb24gaXMgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbRW5mb3JjZVJhbmdlXSBleHRlbmRlZCBhdHRyaWJ1dGUsIHRoZW46XG4gIGlmIChvcHRzLmVuZm9yY2VSYW5nZSA9PT0gdHJ1ZSkge1xuICAgIC8vIDEuIElmIHggaXMgTmFOLCAr4oieLCBvciDiiJLiiJ4sIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKFxuICAgICAgTnVtYmVyLmlzTmFOKHgpIHx8XG4gICAgICB4ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcbiAgICAgIHggPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdJbnRlZ2VyIGNvbnZlcnNpb24nLFxuICAgICAgICBtZXNzYWdlOiBgQ291bGQgbm90IGNvbnZlcnQgJHtWfSB0byBhbiBpbnRlZ2VyLmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gU2V0IHggdG8gSW50ZWdlclBhcnQoeCkuXG4gICAgeCA9IHdlYmlkbC51dGlsLkludGVnZXJQYXJ0KHgpXG5cbiAgICAvLyAzLiBJZiB4IDwgbG93ZXJCb3VuZCBvciB4ID4gdXBwZXJCb3VuZCwgdGhlblxuICAgIC8vICAgIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh4IDwgbG93ZXJCb3VuZCB8fCB4ID4gdXBwZXJCb3VuZCkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdJbnRlZ2VyIGNvbnZlcnNpb24nLFxuICAgICAgICBtZXNzYWdlOiBgVmFsdWUgbXVzdCBiZSBiZXR3ZWVuICR7bG93ZXJCb3VuZH0tJHt1cHBlckJvdW5kfSwgZ290ICR7eH0uYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA0LiBSZXR1cm4geC5cbiAgICByZXR1cm4geFxuICB9XG5cbiAgLy8gNy4gSWYgeCBpcyBub3QgTmFOIGFuZCB0aGUgY29udmVyc2lvbiBpcyB0byBhbiBJRExcbiAgLy8gICAgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIFtDbGFtcF0gZXh0ZW5kZWRcbiAgLy8gICAgYXR0cmlidXRlLCB0aGVuOlxuICBpZiAoIU51bWJlci5pc05hTih4KSAmJiBvcHRzLmNsYW1wID09PSB0cnVlKSB7XG4gICAgLy8gMS4gU2V0IHggdG8gbWluKG1heCh4LCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCkuXG4gICAgeCA9IE1hdGgubWluKE1hdGgubWF4KHgsIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKVxuXG4gICAgLy8gMi4gUm91bmQgeCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLCBjaG9vc2luZyB0aGVcbiAgICAvLyAgICBldmVuIGludGVnZXIgaWYgaXQgbGllcyBoYWxmd2F5IGJldHdlZW4gdHdvLFxuICAgIC8vICAgIGFuZCBjaG9vc2luZyArMCByYXRoZXIgdGhhbiDiiJIwLlxuICAgIGlmIChNYXRoLmZsb29yKHgpICUgMiA9PT0gMCkge1xuICAgICAgeCA9IE1hdGguZmxvb3IoeClcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IE1hdGguY2VpbCh4KVxuICAgIH1cblxuICAgIC8vIDMuIFJldHVybiB4LlxuICAgIHJldHVybiB4XG4gIH1cblxuICAvLyA4LiBJZiB4IGlzIE5hTiwgKzAsICviiJ4sIG9yIOKIkuKIniwgdGhlbiByZXR1cm4gKzAuXG4gIGlmIChcbiAgICBOdW1iZXIuaXNOYU4oeCkgfHxcbiAgICAoeCA9PT0gMCAmJiBPYmplY3QuaXMoMCwgeCkpIHx8XG4gICAgeCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8XG4gICAgeCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICkge1xuICAgIHJldHVybiAwXG4gIH1cblxuICAvLyA5LiBTZXQgeCB0byBJbnRlZ2VyUGFydCh4KS5cbiAgeCA9IHdlYmlkbC51dGlsLkludGVnZXJQYXJ0KHgpXG5cbiAgLy8gMTAuIFNldCB4IHRvIHggbW9kdWxvIDJeYml0TGVuZ3RoLlxuICB4ID0geCAlIE1hdGgucG93KDIsIGJpdExlbmd0aClcblxuICAvLyAxMS4gSWYgc2lnbmVkbmVzcyBpcyBcInNpZ25lZFwiIGFuZCB4IOKJpSAyXmJpdExlbmd0aCDiiJIgMSxcbiAgLy8gICAgdGhlbiByZXR1cm4geCDiiJIgMl5iaXRMZW5ndGguXG4gIGlmIChzaWduZWRuZXNzID09PSAnc2lnbmVkJyAmJiB4ID49IE1hdGgucG93KDIsIGJpdExlbmd0aCkgLSAxKSB7XG4gICAgcmV0dXJuIHggLSBNYXRoLnBvdygyLCBiaXRMZW5ndGgpXG4gIH1cblxuICAvLyAxMi4gT3RoZXJ3aXNlLCByZXR1cm4geC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNhYnN0cmFjdC1vcGRlZi1pbnRlZ2VycGFydFxud2ViaWRsLnV0aWwuSW50ZWdlclBhcnQgPSBmdW5jdGlvbiAobikge1xuICAvLyAxLiBMZXQgciBiZSBmbG9vcihhYnMobikpLlxuICBjb25zdCByID0gTWF0aC5mbG9vcihNYXRoLmFicyhuKSlcblxuICAvLyAyLiBJZiBuIDwgMCwgdGhlbiByZXR1cm4gLTEgw5cgci5cbiAgaWYgKG4gPCAwKSB7XG4gICAgcmV0dXJuIC0xICogclxuICB9XG5cbiAgLy8gMy4gT3RoZXJ3aXNlLCByZXR1cm4gci5cbiAgcmV0dXJuIHJcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1zZXF1ZW5jZVxud2ViaWRsLnNlcXVlbmNlQ29udmVydGVyID0gZnVuY3Rpb24gKGNvbnZlcnRlcikge1xuICByZXR1cm4gKFYpID0+IHtcbiAgICAvLyAxLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSAnT2JqZWN0Jykge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdTZXF1ZW5jZScsXG4gICAgICAgIG1lc3NhZ2U6IGBWYWx1ZSBvZiB0eXBlICR7d2ViaWRsLnV0aWwuVHlwZShWKX0gaXMgbm90IGFuIE9iamVjdC5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIExldCBtZXRob2QgYmUgPyBHZXRNZXRob2QoViwgQEBpdGVyYXRvcikuXG4gICAgLyoqIEB0eXBlIHtHZW5lcmF0b3J9ICovXG4gICAgY29uc3QgbWV0aG9kID0gVj8uW1N5bWJvbC5pdGVyYXRvcl0/LigpXG4gICAgY29uc3Qgc2VxID0gW11cblxuICAgIC8vIDMuIElmIG1ldGhvZCBpcyB1bmRlZmluZWQsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChcbiAgICAgIG1ldGhvZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0eXBlb2YgbWV0aG9kLm5leHQgIT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnU2VxdWVuY2UnLFxuICAgICAgICBtZXNzYWdlOiAnT2JqZWN0IGlzIG5vdCBhbiBpdGVyYXRvci4nXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jY3JlYXRlLXNlcXVlbmNlLWZyb20taXRlcmFibGVcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gbWV0aG9kLm5leHQoKVxuXG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBzZXEucHVzaChjb252ZXJ0ZXIodmFsdWUpKVxuICAgIH1cblxuICAgIHJldHVybiBzZXFcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXRvLXJlY29yZFxud2ViaWRsLnJlY29yZENvbnZlcnRlciA9IGZ1bmN0aW9uIChrZXlDb252ZXJ0ZXIsIHZhbHVlQ29udmVydGVyKSB7XG4gIHJldHVybiAoTykgPT4ge1xuICAgIC8vIDEuIElmIFR5cGUoTykgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoTykgIT09ICdPYmplY3QnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1JlY29yZCcsXG4gICAgICAgIG1lc3NhZ2U6IGBWYWx1ZSBvZiB0eXBlICR7d2ViaWRsLnV0aWwuVHlwZShPKX0gaXMgbm90IGFuIE9iamVjdC5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIExldCByZXN1bHQgYmUgYSBuZXcgZW1wdHkgaW5zdGFuY2Ugb2YgcmVjb3JkPEssIFY+LlxuICAgIGNvbnN0IHJlc3VsdCA9IHt9XG5cbiAgICBpZiAoIXR5cGVzLmlzUHJveHkoTykpIHtcbiAgICAgIC8vIE9iamVjdC5rZXlzIG9ubHkgcmV0dXJucyBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhPKVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIC8vIDEuIExldCB0eXBlZEtleSBiZSBrZXkgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIEsuXG4gICAgICAgIGNvbnN0IHR5cGVkS2V5ID0ga2V5Q29udmVydGVyKGtleSlcblxuICAgICAgICAvLyAyLiBMZXQgdmFsdWUgYmUgPyBHZXQoTywga2V5KS5cbiAgICAgICAgLy8gMy4gTGV0IHR5cGVkVmFsdWUgYmUgdmFsdWUgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIFYuXG4gICAgICAgIGNvbnN0IHR5cGVkVmFsdWUgPSB2YWx1ZUNvbnZlcnRlcihPW2tleV0pXG5cbiAgICAgICAgLy8gNC4gU2V0IHJlc3VsdFt0eXBlZEtleV0gdG8gdHlwZWRWYWx1ZS5cbiAgICAgICAgcmVzdWx0W3R5cGVkS2V5XSA9IHR5cGVkVmFsdWVcbiAgICAgIH1cblxuICAgICAgLy8gNS4gUmV0dXJuIHJlc3VsdC5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvLyAzLiBMZXQga2V5cyBiZSA/IE8uW1tPd25Qcm9wZXJ0eUtleXNdXSgpLlxuICAgIGNvbnN0IGtleXMgPSBSZWZsZWN0Lm93bktleXMoTylcblxuICAgIC8vIDQuIEZvciBlYWNoIGtleSBvZiBrZXlzLlxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIC8vIDEuIExldCBkZXNjIGJlID8gTy5bW0dldE93blByb3BlcnR5XV0oa2V5KS5cbiAgICAgIGNvbnN0IGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkpXG5cbiAgICAgIC8vIDIuIElmIGRlc2MgaXMgbm90IHVuZGVmaW5lZCBhbmQgZGVzYy5bW0VudW1lcmFibGVdXSBpcyB0cnVlOlxuICAgICAgaWYgKGRlc2M/LmVudW1lcmFibGUpIHtcbiAgICAgICAgLy8gMS4gTGV0IHR5cGVkS2V5IGJlIGtleSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgSy5cbiAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBrZXlDb252ZXJ0ZXIoa2V5KVxuXG4gICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSA/IEdldChPLCBrZXkpLlxuICAgICAgICAvLyAzLiBMZXQgdHlwZWRWYWx1ZSBiZSB2YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgVi5cbiAgICAgICAgY29uc3QgdHlwZWRWYWx1ZSA9IHZhbHVlQ29udmVydGVyKE9ba2V5XSlcblxuICAgICAgICAvLyA0LiBTZXQgcmVzdWx0W3R5cGVkS2V5XSB0byB0eXBlZFZhbHVlLlxuICAgICAgICByZXN1bHRbdHlwZWRLZXldID0gdHlwZWRWYWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuIFJldHVybiByZXN1bHQuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbndlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gKFYsIG9wdHMgPSB7fSkgPT4ge1xuICAgIGlmIChvcHRzLnN0cmljdCAhPT0gZmFsc2UgJiYgIShWIGluc3RhbmNlb2YgaSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBpLm5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAke1Z9IHRvIGJlIGFuIGluc3RhbmNlIG9mICR7aS5uYW1lfS5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBWXG4gIH1cbn1cblxud2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVycykge1xuICByZXR1cm4gKGRpY3Rpb25hcnkpID0+IHtcbiAgICBjb25zdCB0eXBlID0gd2ViaWRsLnV0aWwuVHlwZShkaWN0aW9uYXJ5KVxuICAgIGNvbnN0IGRpY3QgPSB7fVxuXG4gICAgaWYgKHR5cGUgPT09ICdOdWxsJyB8fCB0eXBlID09PSAnVW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGRpY3RcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdPYmplY3QnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0RpY3Rpb25hcnknLFxuICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgJHtkaWN0aW9uYXJ5fSB0byBiZSBvbmUgb2Y6IE51bGwsIFVuZGVmaW5lZCwgT2JqZWN0LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBvcHRpb25zIG9mIGNvbnZlcnRlcnMpIHtcbiAgICAgIGNvbnN0IHsga2V5LCBkZWZhdWx0VmFsdWUsIHJlcXVpcmVkLCBjb252ZXJ0ZXIgfSA9IG9wdGlvbnNcblxuICAgICAgaWYgKHJlcXVpcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmICghaGFzT3duKGRpY3Rpb25hcnksIGtleSkpIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6ICdEaWN0aW9uYXJ5JyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBNaXNzaW5nIHJlcXVpcmVkIGtleSBcIiR7a2V5fVwiLmBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCB2YWx1ZSA9IGRpY3Rpb25hcnlba2V5XVxuICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHRpb25zLCAnZGVmYXVsdFZhbHVlJylcblxuICAgICAgLy8gT25seSB1c2UgZGVmYXVsdFZhbHVlIGlmIHZhbHVlIGlzIHVuZGVmaW5lZCBhbmRcbiAgICAgIC8vIGEgZGVmYXVsdFZhbHVlIG9wdGlvbnMgd2FzIHByb3ZpZGVkLlxuICAgICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA/PyBkZWZhdWx0VmFsdWVcbiAgICAgIH1cblxuICAgICAgLy8gQSBrZXkgY2FuIGJlIG9wdGlvbmFsIGFuZCBoYXZlIG5vIGRlZmF1bHQgdmFsdWUuXG4gICAgICAvLyBXaGVuIHRoaXMgaGFwcGVucywgZG8gbm90IHBlcmZvcm0gYSBjb252ZXJzaW9uLFxuICAgICAgLy8gYW5kIGRvIG5vdCBhc3NpZ24gdGhlIGtleSBhIHZhbHVlLlxuICAgICAgaWYgKHJlcXVpcmVkIHx8IGhhc0RlZmF1bHQgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IGNvbnZlcnRlcih2YWx1ZSlcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgb3B0aW9ucy5hbGxvd2VkVmFsdWVzICYmXG4gICAgICAgICAgIW9wdGlvbnMuYWxsb3dlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiAnRGljdGlvbmFyeScsXG4gICAgICAgICAgICBtZXNzYWdlOiBgJHt2YWx1ZX0gaXMgbm90IGFuIGFjY2VwdGVkIHR5cGUuIEV4cGVjdGVkIG9uZSBvZiAke29wdGlvbnMuYWxsb3dlZFZhbHVlcy5qb2luKCcsICcpfS5gXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGRpY3Rba2V5XSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpY3RcbiAgfVxufVxuXG53ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVyKSB7XG4gIHJldHVybiAoVikgPT4ge1xuICAgIGlmIChWID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gVlxuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJ0ZXIoVilcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLURPTVN0cmluZ1xud2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nID0gZnVuY3Rpb24gKFYsIG9wdHMgPSB7fSkge1xuICAvLyAxLiBJZiBWIGlzIG51bGwgYW5kIHRoZSBjb252ZXJzaW9uIGlzIHRvIGFuIElETCB0eXBlXG4gIC8vICAgIGFzc29jaWF0ZWQgd2l0aCB0aGUgW0xlZ2FjeU51bGxUb0VtcHR5U3RyaW5nXVxuICAvLyAgICBleHRlbmRlZCBhdHRyaWJ1dGUsIHRoZW4gcmV0dXJuIHRoZSBET01TdHJpbmcgdmFsdWVcbiAgLy8gICAgdGhhdCByZXByZXNlbnRzIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGlmIChWID09PSBudWxsICYmIG9wdHMubGVnYWN5TnVsbFRvRW1wdHlTdHJpbmcpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIDIuIExldCB4IGJlID8gVG9TdHJpbmcoVikuXG4gIGlmICh0eXBlb2YgViA9PT0gJ3N5bWJvbCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb3VsZCBub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlIHN5bWJvbCB0byBzdHJpbmcuJylcbiAgfVxuXG4gIC8vIDMuIFJldHVybiB0aGUgSURMIERPTVN0cmluZyB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlXG4gIC8vICAgIHNhbWUgc2VxdWVuY2Ugb2YgY29kZSB1bml0cyBhcyB0aGUgb25lIHRoZVxuICAvLyAgICBFQ01BU2NyaXB0IFN0cmluZyB2YWx1ZSB4IHJlcHJlc2VudHMuXG4gIHJldHVybiBTdHJpbmcoVilcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1CeXRlU3RyaW5nXG53ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nID0gZnVuY3Rpb24gKFYpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBUb1N0cmluZyhWKS5cbiAgLy8gTm90ZTogRE9NU3RyaW5nIGNvbnZlcnRlciBwZXJmb3JtID8gVG9TdHJpbmcoVilcbiAgY29uc3QgeCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhWKVxuXG4gIC8vIDIuIElmIHRoZSB2YWx1ZSBvZiBhbnkgZWxlbWVudCBvZiB4IGlzIGdyZWF0ZXIgdGhhblxuICAvLyAgICAyNTUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGNoYXJDb2RlID0geC5jaGFyQ29kZUF0KGluZGV4KVxuXG4gICAgaWYgKGNoYXJDb2RlID4gMjU1KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgdG8gYSBCeXRlU3RyaW5nIGJlY2F1c2UgdGhlIGNoYXJhY3RlciBhdCAnICtcbiAgICAgICAgYGluZGV4ICR7aW5kZXh9IGhhcyBhIHZhbHVlIG9mICR7Y2hhckNvZGV9IHdoaWNoIGlzIGdyZWF0ZXIgdGhhbiAyNTUuYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIFJldHVybiBhbiBJREwgQnl0ZVN0cmluZyB2YWx1ZSB3aG9zZSBsZW5ndGggaXMgdGhlXG4gIC8vICAgIGxlbmd0aCBvZiB4LCBhbmQgd2hlcmUgdGhlIHZhbHVlIG9mIGVhY2ggZWxlbWVudCBpc1xuICAvLyAgICB0aGUgdmFsdWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBvZiB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLVVTVlN0cmluZ1xud2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nID0gdG9VU1ZTdHJpbmdcblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1ib29sZWFuXG53ZWJpZGwuY29udmVydGVycy5ib29sZWFuID0gZnVuY3Rpb24gKFYpIHtcbiAgLy8gMS4gTGV0IHggYmUgdGhlIHJlc3VsdCBvZiBjb21wdXRpbmcgVG9Cb29sZWFuKFYpLlxuICBjb25zdCB4ID0gQm9vbGVhbihWKVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIGJvb2xlYW4gdmFsdWUgdGhhdCBpcyB0aGUgb25lIHRoYXQgcmVwcmVzZW50c1xuICAvLyAgICB0aGUgc2FtZSB0cnV0aCB2YWx1ZSBhcyB0aGUgRUNNQVNjcmlwdCBCb29sZWFuIHZhbHVlIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtYW55XG53ZWJpZGwuY29udmVydGVycy5hbnkgPSBmdW5jdGlvbiAoVikge1xuICByZXR1cm4gVlxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLWxvbmctbG9uZ1xud2ViaWRsLmNvbnZlcnRlcnNbJ2xvbmcgbG9uZyddID0gZnVuY3Rpb24gKFYpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgNjQsIFwic2lnbmVkXCIpLlxuICBjb25zdCB4ID0gd2ViaWRsLnV0aWwuQ29udmVydFRvSW50KFYsIDY0LCAnc2lnbmVkJylcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCBsb25nIGxvbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzXG4gIC8vICAgIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy11bnNpZ25lZC1sb25nLWxvbmdcbndlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSA9IGZ1bmN0aW9uIChWKSB7XG4gIC8vIDEuIExldCB4IGJlID8gQ29udmVydFRvSW50KFYsIDY0LCBcInVuc2lnbmVkXCIpLlxuICBjb25zdCB4ID0gd2ViaWRsLnV0aWwuQ29udmVydFRvSW50KFYsIDY0LCAndW5zaWduZWQnKVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIHVuc2lnbmVkIGxvbmcgbG9uZyB2YWx1ZSB0aGF0XG4gIC8vICAgIHJlcHJlc2VudHMgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXVuc2lnbmVkLWxvbmdcbndlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nJ10gPSBmdW5jdGlvbiAoVikge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCAzMiwgXCJ1bnNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCAzMiwgJ3Vuc2lnbmVkJylcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCB1bnNpZ25lZCBsb25nIHZhbHVlIHRoYXRcbiAgLy8gICAgcmVwcmVzZW50cyB0aGUgc2FtZSBudW1lcmljIHZhbHVlIGFzIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdW5zaWduZWQtc2hvcnRcbndlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddID0gZnVuY3Rpb24gKFYsIG9wdHMpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgMTYsIFwidW5zaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgMTYsICd1bnNpZ25lZCcsIG9wdHMpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgdW5zaWduZWQgc2hvcnQgdmFsdWUgdGhhdCByZXByZXNlbnRzXG4gIC8vICAgIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNpZGwtQXJyYXlCdWZmZXJcbndlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyID0gZnVuY3Rpb24gKFYsIG9wdHMgPSB7fSkge1xuICAvLyAxLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIG9yIFYgZG9lcyBub3QgaGF2ZSBhblxuICAvLyAgICBbW0FycmF5QnVmZmVyRGF0YV1dIGludGVybmFsIHNsb3QsIHRoZW4gdGhyb3cgYVxuICAvLyAgICBUeXBlRXJyb3IuXG4gIC8vIHNlZTogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1hcnJheWJ1ZmZlci1pbnN0YW5jZXNcbiAgLy8gc2VlOiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLXNoYXJlZGFycmF5YnVmZmVyLWluc3RhbmNlc1xuICBpZiAoXG4gICAgd2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gJ09iamVjdCcgfHxcbiAgICAhdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihWKVxuICApIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgcHJlZml4OiBgJHtWfWAsXG4gICAgICBhcmd1bWVudDogYCR7Vn1gLFxuICAgICAgdHlwZXM6IFsnQXJyYXlCdWZmZXInXVxuICAgIH0pXG4gIH1cblxuICAvLyAyLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dTaGFyZWRdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzU2hhcmVkQXJyYXlCdWZmZXIoVikgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhXG4gIC8vICAgIFR5cGVFcnJvci5cbiAgaWYgKG9wdHMuYWxsb3dTaGFyZWQgPT09IGZhbHNlICYmIHR5cGVzLmlzU2hhcmVkQXJyYXlCdWZmZXIoVikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGFsbG93ZWQuJ1xuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dSZXNpemFibGVdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzUmVzaXphYmxlQXJyYXlCdWZmZXIoVikgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhXG4gIC8vICAgIFR5cGVFcnJvci5cbiAgLy8gTm90ZTogcmVzaXphYmxlIEFycmF5QnVmZmVycyBhcmUgY3VycmVudGx5IGEgcHJvcG9zYWwuXG5cbiAgLy8gNC4gUmV0dXJuIHRoZSBJREwgQXJyYXlCdWZmZXIgdmFsdWUgdGhhdCBpcyBhXG4gIC8vICAgIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBvYmplY3QgYXMgVi5cbiAgcmV0dXJuIFZcbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChWLCBULCBvcHRzID0ge30pIHtcbiAgLy8gMS4gTGV0IFQgYmUgdGhlIElETCB0eXBlIFYgaXMgYmVpbmcgY29udmVydGVkIHRvLlxuXG4gIC8vIDIuIElmIFR5cGUoVikgaXMgbm90IE9iamVjdCwgb3IgViBkb2VzIG5vdCBoYXZlIGFcbiAgLy8gICAgW1tUeXBlZEFycmF5TmFtZV1dIGludGVybmFsIHNsb3Qgd2l0aCBhIHZhbHVlXG4gIC8vICAgIGVxdWFsIHRvIFTigJlzIG5hbWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChcbiAgICB3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSAnT2JqZWN0JyB8fFxuICAgICF0eXBlcy5pc1R5cGVkQXJyYXkoVikgfHxcbiAgICBWLmNvbnN0cnVjdG9yLm5hbWUgIT09IFQubmFtZVxuICApIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgcHJlZml4OiBgJHtULm5hbWV9YCxcbiAgICAgIGFyZ3VtZW50OiBgJHtWfWAsXG4gICAgICB0eXBlczogW1QubmFtZV1cbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93U2hhcmVkXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1NoYXJlZEFycmF5QnVmZmVyKFYuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dKSBpc1xuICAvLyAgICB0cnVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAob3B0cy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGFsbG93ZWQuJ1xuICAgIH0pXG4gIH1cblxuICAvLyA0LiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dSZXNpemFibGVdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzUmVzaXphYmxlQXJyYXlCdWZmZXIoVi5bW1ZpZXdlZEFycmF5QnVmZmVyXV0pIGlzXG4gIC8vICAgIHRydWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIC8vIE5vdGU6IHJlc2l6YWJsZSBhcnJheSBidWZmZXJzIGFyZSBjdXJyZW50bHkgYSBwcm9wb3NhbFxuXG4gIC8vIDUuIFJldHVybiB0aGUgSURMIHZhbHVlIG9mIHR5cGUgVCB0aGF0IGlzIGEgcmVmZXJlbmNlXG4gIC8vICAgIHRvIHRoZSBzYW1lIG9iamVjdCBhcyBWLlxuICByZXR1cm4gVlxufVxuXG53ZWJpZGwuY29udmVydGVycy5EYXRhVmlldyA9IGZ1bmN0aW9uIChWLCBvcHRzID0ge30pIHtcbiAgLy8gMS4gSWYgVHlwZShWKSBpcyBub3QgT2JqZWN0LCBvciBWIGRvZXMgbm90IGhhdmUgYVxuICAvLyAgICBbW0RhdGFWaWV3XV0gaW50ZXJuYWwgc2xvdCwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnIHx8ICF0eXBlcy5pc0RhdGFWaWV3KFYpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnRGF0YVZpZXcnLFxuICAgICAgbWVzc2FnZTogJ09iamVjdCBpcyBub3QgYSBEYXRhVmlldy4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDIuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1NoYXJlZF0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNTaGFyZWRBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXMgdHJ1ZSxcbiAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKG9wdHMuYWxsb3dTaGFyZWQgPT09IGZhbHNlICYmIHR5cGVzLmlzU2hhcmVkQXJyYXlCdWZmZXIoVi5idWZmZXIpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnQXJyYXlCdWZmZXInLFxuICAgICAgbWVzc2FnZTogJ1NoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhbGxvd2VkLidcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93UmVzaXphYmxlXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1Jlc2l6YWJsZUFycmF5QnVmZmVyKFYuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dKSBpc1xuICAvLyAgICB0cnVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAvLyBOb3RlOiByZXNpemFibGUgQXJyYXlCdWZmZXJzIGFyZSBjdXJyZW50bHkgYSBwcm9wb3NhbFxuXG4gIC8vIDQuIFJldHVybiB0aGUgSURMIERhdGFWaWV3IHZhbHVlIHRoYXQgaXMgYSByZWZlcmVuY2VcbiAgLy8gICAgdG8gdGhlIHNhbWUgb2JqZWN0IGFzIFYuXG4gIHJldHVybiBWXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jQnVmZmVyU291cmNlXG53ZWJpZGwuY29udmVydGVycy5CdWZmZXJTb3VyY2UgPSBmdW5jdGlvbiAoViwgb3B0cyA9IHt9KSB7XG4gIGlmICh0eXBlcy5pc0FueUFycmF5QnVmZmVyKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyKFYsIG9wdHMpXG4gIH1cblxuICBpZiAodHlwZXMuaXNUeXBlZEFycmF5KFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlR5cGVkQXJyYXkoViwgVi5jb25zdHJ1Y3RvcilcbiAgfVxuXG4gIGlmICh0eXBlcy5pc0RhdGFWaWV3KFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkRhdGFWaWV3KFYsIG9wdHMpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDb3VsZCBub3QgY29udmVydCAke1Z9IHRvIGEgQnVmZmVyU291cmNlLmApXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxCeXRlU3RyaW5nPiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPEJ5dGVTdHJpbmc+J11cbilcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3JlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPiddID0gd2ViaWRsLnJlY29yZENvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyxcbiAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd2ViaWRsXG59XG4iXSwibmFtZXMiOlsidHlwZXMiLCJyZXF1aXJlIiwiaGFzT3duIiwidG9VU1ZTdHJpbmciLCJ3ZWJpZGwiLCJjb252ZXJ0ZXJzIiwidXRpbCIsImVycm9ycyIsImV4Y2VwdGlvbiIsIm1lc3NhZ2UiLCJUeXBlRXJyb3IiLCJoZWFkZXIiLCJjb252ZXJzaW9uRmFpbGVkIiwiY29udGV4dCIsInBsdXJhbCIsImxlbmd0aCIsImFyZ3VtZW50Iiwiam9pbiIsInByZWZpeCIsImludmFsaWRBcmd1bWVudCIsInZhbHVlIiwidHlwZSIsImJyYW5kQ2hlY2siLCJWIiwiSSIsIm9wdHMiLCJ1bmRlZmluZWQiLCJzdHJpY3QiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInByb3RvdHlwZSIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJtaW4iLCJjdHgiLCJpbGxlZ2FsQ29uc3RydWN0b3IiLCJUeXBlIiwiQ29udmVydFRvSW50IiwiYml0TGVuZ3RoIiwic2lnbmVkbmVzcyIsInVwcGVyQm91bmQiLCJsb3dlckJvdW5kIiwiTWF0aCIsInBvdyIsIngiLCJOdW1iZXIiLCJlbmZvcmNlUmFuZ2UiLCJpc05hTiIsIlBPU0lUSVZFX0lORklOSVRZIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJJbnRlZ2VyUGFydCIsImNsYW1wIiwibWF4IiwiZmxvb3IiLCJjZWlsIiwiT2JqZWN0IiwiaXMiLCJuIiwiciIsImFicyIsInNlcXVlbmNlQ29udmVydGVyIiwiY29udmVydGVyIiwibWV0aG9kIiwiaXRlcmF0b3IiLCJzZXEiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJyZWNvcmRDb252ZXJ0ZXIiLCJrZXlDb252ZXJ0ZXIiLCJ2YWx1ZUNvbnZlcnRlciIsIk8iLCJyZXN1bHQiLCJpc1Byb3h5Iiwia2V5cyIsImtleSIsInR5cGVkS2V5IiwidHlwZWRWYWx1ZSIsIlJlZmxlY3QiLCJvd25LZXlzIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJpbnRlcmZhY2VDb252ZXJ0ZXIiLCJpIiwibmFtZSIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJkaWN0aW9uYXJ5IiwiZGljdCIsIm9wdGlvbnMiLCJkZWZhdWx0VmFsdWUiLCJyZXF1aXJlZCIsImhhc0RlZmF1bHQiLCJhbGxvd2VkVmFsdWVzIiwiaW5jbHVkZXMiLCJudWxsYWJsZUNvbnZlcnRlciIsIkRPTVN0cmluZyIsImxlZ2FjeU51bGxUb0VtcHR5U3RyaW5nIiwiU3RyaW5nIiwiQnl0ZVN0cmluZyIsImluZGV4IiwiY2hhckNvZGUiLCJjaGFyQ29kZUF0IiwiVVNWU3RyaW5nIiwiYm9vbGVhbiIsIkJvb2xlYW4iLCJhbnkiLCJBcnJheUJ1ZmZlciIsImlzQW55QXJyYXlCdWZmZXIiLCJhbGxvd1NoYXJlZCIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJUeXBlZEFycmF5IiwiVCIsImlzVHlwZWRBcnJheSIsImNvbnN0cnVjdG9yIiwiYnVmZmVyIiwiRGF0YVZpZXciLCJpc0RhdGFWaWV3IiwiQnVmZmVyU291cmNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fetch/webidl.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fileapi/encoding.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/fileapi/encoding.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\n/**\n * @see https://encoding.spec.whatwg.org/#concept-encoding-get\n * @param {string|undefined} label\n */ function getEncoding(label) {\n    if (!label) {\n        return \"failure\";\n    }\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    // 2. If label is an ASCII case-insensitive match for any of the\n    //    labels listed in the table below, then return the\n    //    corresponding encoding; otherwise return failure.\n    switch(label.trim().toLowerCase()){\n        case \"unicode-1-1-utf-8\":\n        case \"unicode11utf8\":\n        case \"unicode20utf8\":\n        case \"utf-8\":\n        case \"utf8\":\n        case \"x-unicode20utf8\":\n            return \"UTF-8\";\n        case \"866\":\n        case \"cp866\":\n        case \"csibm866\":\n        case \"ibm866\":\n            return \"IBM866\";\n        case \"csisolatin2\":\n        case \"iso-8859-2\":\n        case \"iso-ir-101\":\n        case \"iso8859-2\":\n        case \"iso88592\":\n        case \"iso_8859-2\":\n        case \"iso_8859-2:1987\":\n        case \"l2\":\n        case \"latin2\":\n            return \"ISO-8859-2\";\n        case \"csisolatin3\":\n        case \"iso-8859-3\":\n        case \"iso-ir-109\":\n        case \"iso8859-3\":\n        case \"iso88593\":\n        case \"iso_8859-3\":\n        case \"iso_8859-3:1988\":\n        case \"l3\":\n        case \"latin3\":\n            return \"ISO-8859-3\";\n        case \"csisolatin4\":\n        case \"iso-8859-4\":\n        case \"iso-ir-110\":\n        case \"iso8859-4\":\n        case \"iso88594\":\n        case \"iso_8859-4\":\n        case \"iso_8859-4:1988\":\n        case \"l4\":\n        case \"latin4\":\n            return \"ISO-8859-4\";\n        case \"csisolatincyrillic\":\n        case \"cyrillic\":\n        case \"iso-8859-5\":\n        case \"iso-ir-144\":\n        case \"iso8859-5\":\n        case \"iso88595\":\n        case \"iso_8859-5\":\n        case \"iso_8859-5:1988\":\n            return \"ISO-8859-5\";\n        case \"arabic\":\n        case \"asmo-708\":\n        case \"csiso88596e\":\n        case \"csiso88596i\":\n        case \"csisolatinarabic\":\n        case \"ecma-114\":\n        case \"iso-8859-6\":\n        case \"iso-8859-6-e\":\n        case \"iso-8859-6-i\":\n        case \"iso-ir-127\":\n        case \"iso8859-6\":\n        case \"iso88596\":\n        case \"iso_8859-6\":\n        case \"iso_8859-6:1987\":\n            return \"ISO-8859-6\";\n        case \"csisolatingreek\":\n        case \"ecma-118\":\n        case \"elot_928\":\n        case \"greek\":\n        case \"greek8\":\n        case \"iso-8859-7\":\n        case \"iso-ir-126\":\n        case \"iso8859-7\":\n        case \"iso88597\":\n        case \"iso_8859-7\":\n        case \"iso_8859-7:1987\":\n        case \"sun_eu_greek\":\n            return \"ISO-8859-7\";\n        case \"csiso88598e\":\n        case \"csisolatinhebrew\":\n        case \"hebrew\":\n        case \"iso-8859-8\":\n        case \"iso-8859-8-e\":\n        case \"iso-ir-138\":\n        case \"iso8859-8\":\n        case \"iso88598\":\n        case \"iso_8859-8\":\n        case \"iso_8859-8:1988\":\n        case \"visual\":\n            return \"ISO-8859-8\";\n        case \"csiso88598i\":\n        case \"iso-8859-8-i\":\n        case \"logical\":\n            return \"ISO-8859-8-I\";\n        case \"csisolatin6\":\n        case \"iso-8859-10\":\n        case \"iso-ir-157\":\n        case \"iso8859-10\":\n        case \"iso885910\":\n        case \"l6\":\n        case \"latin6\":\n            return \"ISO-8859-10\";\n        case \"iso-8859-13\":\n        case \"iso8859-13\":\n        case \"iso885913\":\n            return \"ISO-8859-13\";\n        case \"iso-8859-14\":\n        case \"iso8859-14\":\n        case \"iso885914\":\n            return \"ISO-8859-14\";\n        case \"csisolatin9\":\n        case \"iso-8859-15\":\n        case \"iso8859-15\":\n        case \"iso885915\":\n        case \"iso_8859-15\":\n        case \"l9\":\n            return \"ISO-8859-15\";\n        case \"iso-8859-16\":\n            return \"ISO-8859-16\";\n        case \"cskoi8r\":\n        case \"koi\":\n        case \"koi8\":\n        case \"koi8-r\":\n        case \"koi8_r\":\n            return \"KOI8-R\";\n        case \"koi8-ru\":\n        case \"koi8-u\":\n            return \"KOI8-U\";\n        case \"csmacintosh\":\n        case \"mac\":\n        case \"macintosh\":\n        case \"x-mac-roman\":\n            return \"macintosh\";\n        case \"iso-8859-11\":\n        case \"iso8859-11\":\n        case \"iso885911\":\n        case \"tis-620\":\n        case \"windows-874\":\n            return \"windows-874\";\n        case \"cp1250\":\n        case \"windows-1250\":\n        case \"x-cp1250\":\n            return \"windows-1250\";\n        case \"cp1251\":\n        case \"windows-1251\":\n        case \"x-cp1251\":\n            return \"windows-1251\";\n        case \"ansi_x3.4-1968\":\n        case \"ascii\":\n        case \"cp1252\":\n        case \"cp819\":\n        case \"csisolatin1\":\n        case \"ibm819\":\n        case \"iso-8859-1\":\n        case \"iso-ir-100\":\n        case \"iso8859-1\":\n        case \"iso88591\":\n        case \"iso_8859-1\":\n        case \"iso_8859-1:1987\":\n        case \"l1\":\n        case \"latin1\":\n        case \"us-ascii\":\n        case \"windows-1252\":\n        case \"x-cp1252\":\n            return \"windows-1252\";\n        case \"cp1253\":\n        case \"windows-1253\":\n        case \"x-cp1253\":\n            return \"windows-1253\";\n        case \"cp1254\":\n        case \"csisolatin5\":\n        case \"iso-8859-9\":\n        case \"iso-ir-148\":\n        case \"iso8859-9\":\n        case \"iso88599\":\n        case \"iso_8859-9\":\n        case \"iso_8859-9:1989\":\n        case \"l5\":\n        case \"latin5\":\n        case \"windows-1254\":\n        case \"x-cp1254\":\n            return \"windows-1254\";\n        case \"cp1255\":\n        case \"windows-1255\":\n        case \"x-cp1255\":\n            return \"windows-1255\";\n        case \"cp1256\":\n        case \"windows-1256\":\n        case \"x-cp1256\":\n            return \"windows-1256\";\n        case \"cp1257\":\n        case \"windows-1257\":\n        case \"x-cp1257\":\n            return \"windows-1257\";\n        case \"cp1258\":\n        case \"windows-1258\":\n        case \"x-cp1258\":\n            return \"windows-1258\";\n        case \"x-mac-cyrillic\":\n        case \"x-mac-ukrainian\":\n            return \"x-mac-cyrillic\";\n        case \"chinese\":\n        case \"csgb2312\":\n        case \"csiso58gb231280\":\n        case \"gb2312\":\n        case \"gb_2312\":\n        case \"gb_2312-80\":\n        case \"gbk\":\n        case \"iso-ir-58\":\n        case \"x-gbk\":\n            return \"GBK\";\n        case \"gb18030\":\n            return \"gb18030\";\n        case \"big5\":\n        case \"big5-hkscs\":\n        case \"cn-big5\":\n        case \"csbig5\":\n        case \"x-x-big5\":\n            return \"Big5\";\n        case \"cseucpkdfmtjapanese\":\n        case \"euc-jp\":\n        case \"x-euc-jp\":\n            return \"EUC-JP\";\n        case \"csiso2022jp\":\n        case \"iso-2022-jp\":\n            return \"ISO-2022-JP\";\n        case \"csshiftjis\":\n        case \"ms932\":\n        case \"ms_kanji\":\n        case \"shift-jis\":\n        case \"shift_jis\":\n        case \"sjis\":\n        case \"windows-31j\":\n        case \"x-sjis\":\n            return \"Shift_JIS\";\n        case \"cseuckr\":\n        case \"csksc56011987\":\n        case \"euc-kr\":\n        case \"iso-ir-149\":\n        case \"korean\":\n        case \"ks_c_5601-1987\":\n        case \"ks_c_5601-1989\":\n        case \"ksc5601\":\n        case \"ksc_5601\":\n        case \"windows-949\":\n            return \"EUC-KR\";\n        case \"csiso2022kr\":\n        case \"hz-gb-2312\":\n        case \"iso-2022-cn\":\n        case \"iso-2022-cn-ext\":\n        case \"iso-2022-kr\":\n        case \"replacement\":\n            return \"replacement\";\n        case \"unicodefffe\":\n        case \"utf-16be\":\n            return \"UTF-16BE\";\n        case \"csunicode\":\n        case \"iso-10646-ucs-2\":\n        case \"ucs-2\":\n        case \"unicode\":\n        case \"unicodefeff\":\n        case \"utf-16\":\n        case \"utf-16le\":\n            return \"UTF-16LE\";\n        case \"x-user-defined\":\n            return \"x-user-defined\";\n        default:\n            return \"failure\";\n    }\n}\nmodule.exports = {\n    getEncoding\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS9lbmNvZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7Q0FHQyxHQUNELFNBQVNBLFlBQWFDLEtBQUs7SUFDekIsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBRUEsa0VBQWtFO0lBQ2xFLGdFQUFnRTtJQUNoRSx1REFBdUQ7SUFDdkQsdURBQXVEO0lBQ3ZELE9BQVFBLE1BQU1DLElBQUksR0FBR0MsV0FBVztRQUM5QixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVDtZQUFTLE9BQU87SUFDbEI7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZkw7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS9lbmNvZGluZy5qcz9jYzkyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZW5jb2RpbmctZ2V0XG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGxhYmVsXG4gKi9cbmZ1bmN0aW9uIGdldEVuY29kaW5nIChsYWJlbCkge1xuICBpZiAoIWxhYmVsKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gMS4gUmVtb3ZlIGFueSBsZWFkaW5nIGFuZCB0cmFpbGluZyBBU0NJSSB3aGl0ZXNwYWNlIGZyb20gbGFiZWwuXG4gIC8vIDIuIElmIGxhYmVsIGlzIGFuIEFTQ0lJIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIGFueSBvZiB0aGVcbiAgLy8gICAgbGFiZWxzIGxpc3RlZCBpbiB0aGUgdGFibGUgYmVsb3csIHRoZW4gcmV0dXJuIHRoZVxuICAvLyAgICBjb3JyZXNwb25kaW5nIGVuY29kaW5nOyBvdGhlcndpc2UgcmV0dXJuIGZhaWx1cmUuXG4gIHN3aXRjaCAobGFiZWwudHJpbSgpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICd1bmljb2RlLTEtMS11dGYtOCc6XG4gICAgY2FzZSAndW5pY29kZTExdXRmOCc6XG4gICAgY2FzZSAndW5pY29kZTIwdXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3gtdW5pY29kZTIwdXRmOCc6XG4gICAgICByZXR1cm4gJ1VURi04J1xuICAgIGNhc2UgJzg2Nic6XG4gICAgY2FzZSAnY3A4NjYnOlxuICAgIGNhc2UgJ2NzaWJtODY2JzpcbiAgICBjYXNlICdpYm04NjYnOlxuICAgICAgcmV0dXJuICdJQk04NjYnXG4gICAgY2FzZSAnY3Npc29sYXRpbjInOlxuICAgIGNhc2UgJ2lzby04ODU5LTInOlxuICAgIGNhc2UgJ2lzby1pci0xMDEnOlxuICAgIGNhc2UgJ2lzbzg4NTktMic6XG4gICAgY2FzZSAnaXNvODg1OTInOlxuICAgIGNhc2UgJ2lzb184ODU5LTInOlxuICAgIGNhc2UgJ2lzb184ODU5LTI6MTk4Nyc6XG4gICAgY2FzZSAnbDInOlxuICAgIGNhc2UgJ2xhdGluMic6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTInXG4gICAgY2FzZSAnY3Npc29sYXRpbjMnOlxuICAgIGNhc2UgJ2lzby04ODU5LTMnOlxuICAgIGNhc2UgJ2lzby1pci0xMDknOlxuICAgIGNhc2UgJ2lzbzg4NTktMyc6XG4gICAgY2FzZSAnaXNvODg1OTMnOlxuICAgIGNhc2UgJ2lzb184ODU5LTMnOlxuICAgIGNhc2UgJ2lzb184ODU5LTM6MTk4OCc6XG4gICAgY2FzZSAnbDMnOlxuICAgIGNhc2UgJ2xhdGluMyc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTMnXG4gICAgY2FzZSAnY3Npc29sYXRpbjQnOlxuICAgIGNhc2UgJ2lzby04ODU5LTQnOlxuICAgIGNhc2UgJ2lzby1pci0xMTAnOlxuICAgIGNhc2UgJ2lzbzg4NTktNCc6XG4gICAgY2FzZSAnaXNvODg1OTQnOlxuICAgIGNhc2UgJ2lzb184ODU5LTQnOlxuICAgIGNhc2UgJ2lzb184ODU5LTQ6MTk4OCc6XG4gICAgY2FzZSAnbDQnOlxuICAgIGNhc2UgJ2xhdGluNCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTQnXG4gICAgY2FzZSAnY3Npc29sYXRpbmN5cmlsbGljJzpcbiAgICBjYXNlICdjeXJpbGxpYyc6XG4gICAgY2FzZSAnaXNvLTg4NTktNSc6XG4gICAgY2FzZSAnaXNvLWlyLTE0NCc6XG4gICAgY2FzZSAnaXNvODg1OS01JzpcbiAgICBjYXNlICdpc284ODU5NSc6XG4gICAgY2FzZSAnaXNvXzg4NTktNSc6XG4gICAgY2FzZSAnaXNvXzg4NTktNToxOTg4JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktNSdcbiAgICBjYXNlICdhcmFiaWMnOlxuICAgIGNhc2UgJ2FzbW8tNzA4JzpcbiAgICBjYXNlICdjc2lzbzg4NTk2ZSc6XG4gICAgY2FzZSAnY3Npc284ODU5NmknOlxuICAgIGNhc2UgJ2NzaXNvbGF0aW5hcmFiaWMnOlxuICAgIGNhc2UgJ2VjbWEtMTE0JzpcbiAgICBjYXNlICdpc28tODg1OS02JzpcbiAgICBjYXNlICdpc28tODg1OS02LWUnOlxuICAgIGNhc2UgJ2lzby04ODU5LTYtaSc6XG4gICAgY2FzZSAnaXNvLWlyLTEyNyc6XG4gICAgY2FzZSAnaXNvODg1OS02JzpcbiAgICBjYXNlICdpc284ODU5Nic6XG4gICAgY2FzZSAnaXNvXzg4NTktNic6XG4gICAgY2FzZSAnaXNvXzg4NTktNjoxOTg3JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktNidcbiAgICBjYXNlICdjc2lzb2xhdGluZ3JlZWsnOlxuICAgIGNhc2UgJ2VjbWEtMTE4JzpcbiAgICBjYXNlICdlbG90XzkyOCc6XG4gICAgY2FzZSAnZ3JlZWsnOlxuICAgIGNhc2UgJ2dyZWVrOCc6XG4gICAgY2FzZSAnaXNvLTg4NTktNyc6XG4gICAgY2FzZSAnaXNvLWlyLTEyNic6XG4gICAgY2FzZSAnaXNvODg1OS03JzpcbiAgICBjYXNlICdpc284ODU5Nyc6XG4gICAgY2FzZSAnaXNvXzg4NTktNyc6XG4gICAgY2FzZSAnaXNvXzg4NTktNzoxOTg3JzpcbiAgICBjYXNlICdzdW5fZXVfZ3JlZWsnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS03J1xuICAgIGNhc2UgJ2NzaXNvODg1OThlJzpcbiAgICBjYXNlICdjc2lzb2xhdGluaGVicmV3JzpcbiAgICBjYXNlICdoZWJyZXcnOlxuICAgIGNhc2UgJ2lzby04ODU5LTgnOlxuICAgIGNhc2UgJ2lzby04ODU5LTgtZSc6XG4gICAgY2FzZSAnaXNvLWlyLTEzOCc6XG4gICAgY2FzZSAnaXNvODg1OS04JzpcbiAgICBjYXNlICdpc284ODU5OCc6XG4gICAgY2FzZSAnaXNvXzg4NTktOCc6XG4gICAgY2FzZSAnaXNvXzg4NTktODoxOTg4JzpcbiAgICBjYXNlICd2aXN1YWwnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS04J1xuICAgIGNhc2UgJ2NzaXNvODg1OThpJzpcbiAgICBjYXNlICdpc28tODg1OS04LWknOlxuICAgIGNhc2UgJ2xvZ2ljYWwnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS04LUknXG4gICAgY2FzZSAnY3Npc29sYXRpbjYnOlxuICAgIGNhc2UgJ2lzby04ODU5LTEwJzpcbiAgICBjYXNlICdpc28taXItMTU3JzpcbiAgICBjYXNlICdpc284ODU5LTEwJzpcbiAgICBjYXNlICdpc284ODU5MTAnOlxuICAgIGNhc2UgJ2w2JzpcbiAgICBjYXNlICdsYXRpbjYnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0xMCdcbiAgICBjYXNlICdpc28tODg1OS0xMyc6XG4gICAgY2FzZSAnaXNvODg1OS0xMyc6XG4gICAgY2FzZSAnaXNvODg1OTEzJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTMnXG4gICAgY2FzZSAnaXNvLTg4NTktMTQnOlxuICAgIGNhc2UgJ2lzbzg4NTktMTQnOlxuICAgIGNhc2UgJ2lzbzg4NTkxNCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTE0J1xuICAgIGNhc2UgJ2NzaXNvbGF0aW45JzpcbiAgICBjYXNlICdpc28tODg1OS0xNSc6XG4gICAgY2FzZSAnaXNvODg1OS0xNSc6XG4gICAgY2FzZSAnaXNvODg1OTE1JzpcbiAgICBjYXNlICdpc29fODg1OS0xNSc6XG4gICAgY2FzZSAnbDknOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0xNSdcbiAgICBjYXNlICdpc28tODg1OS0xNic6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTE2J1xuICAgIGNhc2UgJ2Nza29pOHInOlxuICAgIGNhc2UgJ2tvaSc6XG4gICAgY2FzZSAna29pOCc6XG4gICAgY2FzZSAna29pOC1yJzpcbiAgICBjYXNlICdrb2k4X3InOlxuICAgICAgcmV0dXJuICdLT0k4LVInXG4gICAgY2FzZSAna29pOC1ydSc6XG4gICAgY2FzZSAna29pOC11JzpcbiAgICAgIHJldHVybiAnS09JOC1VJ1xuICAgIGNhc2UgJ2NzbWFjaW50b3NoJzpcbiAgICBjYXNlICdtYWMnOlxuICAgIGNhc2UgJ21hY2ludG9zaCc6XG4gICAgY2FzZSAneC1tYWMtcm9tYW4nOlxuICAgICAgcmV0dXJuICdtYWNpbnRvc2gnXG4gICAgY2FzZSAnaXNvLTg4NTktMTEnOlxuICAgIGNhc2UgJ2lzbzg4NTktMTEnOlxuICAgIGNhc2UgJ2lzbzg4NTkxMSc6XG4gICAgY2FzZSAndGlzLTYyMCc6XG4gICAgY2FzZSAnd2luZG93cy04NzQnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTg3NCdcbiAgICBjYXNlICdjcDEyNTAnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1MCc6XG4gICAgY2FzZSAneC1jcDEyNTAnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTAnXG4gICAgY2FzZSAnY3AxMjUxJzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTEnOlxuICAgIGNhc2UgJ3gtY3AxMjUxJzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjUxJ1xuICAgIGNhc2UgJ2Fuc2lfeDMuNC0xOTY4JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnY3AxMjUyJzpcbiAgICBjYXNlICdjcDgxOSc6XG4gICAgY2FzZSAnY3Npc29sYXRpbjEnOlxuICAgIGNhc2UgJ2libTgxOSc6XG4gICAgY2FzZSAnaXNvLTg4NTktMSc6XG4gICAgY2FzZSAnaXNvLWlyLTEwMCc6XG4gICAgY2FzZSAnaXNvODg1OS0xJzpcbiAgICBjYXNlICdpc284ODU5MSc6XG4gICAgY2FzZSAnaXNvXzg4NTktMSc6XG4gICAgY2FzZSAnaXNvXzg4NTktMToxOTg3JzpcbiAgICBjYXNlICdsMSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICd1cy1hc2NpaSc6XG4gICAgY2FzZSAnd2luZG93cy0xMjUyJzpcbiAgICBjYXNlICd4LWNwMTI1Mic6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1MidcbiAgICBjYXNlICdjcDEyNTMnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1Myc6XG4gICAgY2FzZSAneC1jcDEyNTMnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTMnXG4gICAgY2FzZSAnY3AxMjU0JzpcbiAgICBjYXNlICdjc2lzb2xhdGluNSc6XG4gICAgY2FzZSAnaXNvLTg4NTktOSc6XG4gICAgY2FzZSAnaXNvLWlyLTE0OCc6XG4gICAgY2FzZSAnaXNvODg1OS05JzpcbiAgICBjYXNlICdpc284ODU5OSc6XG4gICAgY2FzZSAnaXNvXzg4NTktOSc6XG4gICAgY2FzZSAnaXNvXzg4NTktOToxOTg5JzpcbiAgICBjYXNlICdsNSc6XG4gICAgY2FzZSAnbGF0aW41JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTQnOlxuICAgIGNhc2UgJ3gtY3AxMjU0JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU0J1xuICAgIGNhc2UgJ2NwMTI1NSc6XG4gICAgY2FzZSAnd2luZG93cy0xMjU1JzpcbiAgICBjYXNlICd4LWNwMTI1NSc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1NSdcbiAgICBjYXNlICdjcDEyNTYnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1Nic6XG4gICAgY2FzZSAneC1jcDEyNTYnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTYnXG4gICAgY2FzZSAnY3AxMjU3JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTcnOlxuICAgIGNhc2UgJ3gtY3AxMjU3JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU3J1xuICAgIGNhc2UgJ2NwMTI1OCc6XG4gICAgY2FzZSAnd2luZG93cy0xMjU4JzpcbiAgICBjYXNlICd4LWNwMTI1OCc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1OCdcbiAgICBjYXNlICd4LW1hYy1jeXJpbGxpYyc6XG4gICAgY2FzZSAneC1tYWMtdWtyYWluaWFuJzpcbiAgICAgIHJldHVybiAneC1tYWMtY3lyaWxsaWMnXG4gICAgY2FzZSAnY2hpbmVzZSc6XG4gICAgY2FzZSAnY3NnYjIzMTInOlxuICAgIGNhc2UgJ2NzaXNvNThnYjIzMTI4MCc6XG4gICAgY2FzZSAnZ2IyMzEyJzpcbiAgICBjYXNlICdnYl8yMzEyJzpcbiAgICBjYXNlICdnYl8yMzEyLTgwJzpcbiAgICBjYXNlICdnYmsnOlxuICAgIGNhc2UgJ2lzby1pci01OCc6XG4gICAgY2FzZSAneC1nYmsnOlxuICAgICAgcmV0dXJuICdHQksnXG4gICAgY2FzZSAnZ2IxODAzMCc6XG4gICAgICByZXR1cm4gJ2diMTgwMzAnXG4gICAgY2FzZSAnYmlnNSc6XG4gICAgY2FzZSAnYmlnNS1oa3Njcyc6XG4gICAgY2FzZSAnY24tYmlnNSc6XG4gICAgY2FzZSAnY3NiaWc1JzpcbiAgICBjYXNlICd4LXgtYmlnNSc6XG4gICAgICByZXR1cm4gJ0JpZzUnXG4gICAgY2FzZSAnY3NldWNwa2RmbXRqYXBhbmVzZSc6XG4gICAgY2FzZSAnZXVjLWpwJzpcbiAgICBjYXNlICd4LWV1Yy1qcCc6XG4gICAgICByZXR1cm4gJ0VVQy1KUCdcbiAgICBjYXNlICdjc2lzbzIwMjJqcCc6XG4gICAgY2FzZSAnaXNvLTIwMjItanAnOlxuICAgICAgcmV0dXJuICdJU08tMjAyMi1KUCdcbiAgICBjYXNlICdjc3NoaWZ0amlzJzpcbiAgICBjYXNlICdtczkzMic6XG4gICAgY2FzZSAnbXNfa2FuamknOlxuICAgIGNhc2UgJ3NoaWZ0LWppcyc6XG4gICAgY2FzZSAnc2hpZnRfamlzJzpcbiAgICBjYXNlICdzamlzJzpcbiAgICBjYXNlICd3aW5kb3dzLTMxaic6XG4gICAgY2FzZSAneC1zamlzJzpcbiAgICAgIHJldHVybiAnU2hpZnRfSklTJ1xuICAgIGNhc2UgJ2NzZXVja3InOlxuICAgIGNhc2UgJ2Nza3NjNTYwMTE5ODcnOlxuICAgIGNhc2UgJ2V1Yy1rcic6XG4gICAgY2FzZSAnaXNvLWlyLTE0OSc6XG4gICAgY2FzZSAna29yZWFuJzpcbiAgICBjYXNlICdrc19jXzU2MDEtMTk4Nyc6XG4gICAgY2FzZSAna3NfY181NjAxLTE5ODknOlxuICAgIGNhc2UgJ2tzYzU2MDEnOlxuICAgIGNhc2UgJ2tzY181NjAxJzpcbiAgICBjYXNlICd3aW5kb3dzLTk0OSc6XG4gICAgICByZXR1cm4gJ0VVQy1LUidcbiAgICBjYXNlICdjc2lzbzIwMjJrcic6XG4gICAgY2FzZSAnaHotZ2ItMjMxMic6XG4gICAgY2FzZSAnaXNvLTIwMjItY24nOlxuICAgIGNhc2UgJ2lzby0yMDIyLWNuLWV4dCc6XG4gICAgY2FzZSAnaXNvLTIwMjIta3InOlxuICAgIGNhc2UgJ3JlcGxhY2VtZW50JzpcbiAgICAgIHJldHVybiAncmVwbGFjZW1lbnQnXG4gICAgY2FzZSAndW5pY29kZWZmZmUnOlxuICAgIGNhc2UgJ3V0Zi0xNmJlJzpcbiAgICAgIHJldHVybiAnVVRGLTE2QkUnXG4gICAgY2FzZSAnY3N1bmljb2RlJzpcbiAgICBjYXNlICdpc28tMTA2NDYtdWNzLTInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1bmljb2RlJzpcbiAgICBjYXNlICd1bmljb2RlZmVmZic6XG4gICAgY2FzZSAndXRmLTE2JzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gJ1VURi0xNkxFJ1xuICAgIGNhc2UgJ3gtdXNlci1kZWZpbmVkJzpcbiAgICAgIHJldHVybiAneC11c2VyLWRlZmluZWQnXG4gICAgZGVmYXVsdDogcmV0dXJuICdmYWlsdXJlJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRFbmNvZGluZ1xufVxuIl0sIm5hbWVzIjpbImdldEVuY29kaW5nIiwibGFiZWwiLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fileapi/encoding.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fileapi/filereader.js":
/*!***********************************************************!*\
  !*** ../../node_modules/undici/lib/fileapi/filereader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { staticPropertyDescriptors, readOperation, fireAProgressEvent } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/fileapi/util.js\");\nconst { kState, kError, kResult, kEvents, kAborted } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/fileapi/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nclass FileReader extends EventTarget {\n    constructor(){\n        super();\n        this[kState] = \"empty\";\n        this[kResult] = null;\n        this[kError] = null;\n        this[kEvents] = {\n            loadend: null,\n            error: null,\n            abort: null,\n            load: null,\n            progress: null,\n            loadstart: null\n        };\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer\n   * @param {import('buffer').Blob} blob\n   */ readAsArrayBuffer(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FileReader.readAsArrayBuffer\"\n        });\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsArrayBuffer(blob) method, when invoked,\n        // must initiate a read operation for blob with ArrayBuffer.\n        readOperation(this, blob, \"ArrayBuffer\");\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#readAsBinaryString\n   * @param {import('buffer').Blob} blob\n   */ readAsBinaryString(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FileReader.readAsBinaryString\"\n        });\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsBinaryString(blob) method, when invoked,\n        // must initiate a read operation for blob with BinaryString.\n        readOperation(this, blob, \"BinaryString\");\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#readAsDataText\n   * @param {import('buffer').Blob} blob\n   * @param {string?} encoding\n   */ readAsText(blob, encoding = undefined) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FileReader.readAsText\"\n        });\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        if (encoding !== undefined) {\n            encoding = webidl.converters.DOMString(encoding);\n        }\n        // The readAsText(blob, encoding) method, when invoked,\n        // must initiate a read operation for blob with Text and encoding.\n        readOperation(this, blob, \"Text\", encoding);\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL\n   * @param {import('buffer').Blob} blob\n   */ readAsDataURL(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FileReader.readAsDataURL\"\n        });\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsDataURL(blob) method, when invoked, must\n        // initiate a read operation for blob with DataURL.\n        readOperation(this, blob, \"DataURL\");\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-abort\n   */ abort() {\n        // 1. If this's state is \"empty\" or if this's state is\n        //    \"done\" set this's result to null and terminate\n        //    this algorithm.\n        if (this[kState] === \"empty\" || this[kState] === \"done\") {\n            this[kResult] = null;\n            return;\n        }\n        // 2. If this's state is \"loading\" set this's state to\n        //    \"done\" and set this's result to null.\n        if (this[kState] === \"loading\") {\n            this[kState] = \"done\";\n            this[kResult] = null;\n        }\n        // 3. If there are any tasks from this on the file reading\n        //    task source in an affiliated task queue, then remove\n        //    those tasks from that task queue.\n        this[kAborted] = true;\n        // 4. Terminate the algorithm for the read method being processed.\n        // TODO\n        // 5. Fire a progress event called abort at this.\n        fireAProgressEvent(\"abort\", this);\n        // 6. If this's state is not \"loading\", fire a progress\n        //    event called loadend at this.\n        if (this[kState] !== \"loading\") {\n            fireAProgressEvent(\"loadend\", this);\n        }\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate\n   */ get readyState() {\n        webidl.brandCheck(this, FileReader);\n        switch(this[kState]){\n            case \"empty\":\n                return this.EMPTY;\n            case \"loading\":\n                return this.LOADING;\n            case \"done\":\n                return this.DONE;\n        }\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-result\n   */ get result() {\n        webidl.brandCheck(this, FileReader);\n        // The result attributes getter, when invoked, must return\n        // this's result.\n        return this[kResult];\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-error\n   */ get error() {\n        webidl.brandCheck(this, FileReader);\n        // The error attributes getter, when invoked, must return\n        // this's error.\n        return this[kError];\n    }\n    get onloadend() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].loadend;\n    }\n    set onloadend(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].loadend) {\n            this.removeEventListener(\"loadend\", this[kEvents].loadend);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].loadend = fn;\n            this.addEventListener(\"loadend\", fn);\n        } else {\n            this[kEvents].loadend = null;\n        }\n    }\n    get onerror() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].error;\n    }\n    set onerror(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].error) {\n            this.removeEventListener(\"error\", this[kEvents].error);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].error = fn;\n            this.addEventListener(\"error\", fn);\n        } else {\n            this[kEvents].error = null;\n        }\n    }\n    get onloadstart() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].loadstart;\n    }\n    set onloadstart(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].loadstart) {\n            this.removeEventListener(\"loadstart\", this[kEvents].loadstart);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].loadstart = fn;\n            this.addEventListener(\"loadstart\", fn);\n        } else {\n            this[kEvents].loadstart = null;\n        }\n    }\n    get onprogress() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].progress;\n    }\n    set onprogress(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].progress) {\n            this.removeEventListener(\"progress\", this[kEvents].progress);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].progress = fn;\n            this.addEventListener(\"progress\", fn);\n        } else {\n            this[kEvents].progress = null;\n        }\n    }\n    get onload() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].load;\n    }\n    set onload(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].load) {\n            this.removeEventListener(\"load\", this[kEvents].load);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].load = fn;\n            this.addEventListener(\"load\", fn);\n        } else {\n            this[kEvents].load = null;\n        }\n    }\n    get onabort() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].abort;\n    }\n    set onabort(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].abort) {\n            this.removeEventListener(\"abort\", this[kEvents].abort);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].abort = fn;\n            this.addEventListener(\"abort\", fn);\n        } else {\n            this[kEvents].abort = null;\n        }\n    }\n}\n// https://w3c.github.io/FileAPI/#dom-filereader-empty\nFileReader.EMPTY = FileReader.prototype.EMPTY = 0;\n// https://w3c.github.io/FileAPI/#dom-filereader-loading\nFileReader.LOADING = FileReader.prototype.LOADING = 1;\n// https://w3c.github.io/FileAPI/#dom-filereader-done\nFileReader.DONE = FileReader.prototype.DONE = 2;\nObject.defineProperties(FileReader.prototype, {\n    EMPTY: staticPropertyDescriptors,\n    LOADING: staticPropertyDescriptors,\n    DONE: staticPropertyDescriptors,\n    readAsArrayBuffer: kEnumerableProperty,\n    readAsBinaryString: kEnumerableProperty,\n    readAsText: kEnumerableProperty,\n    readAsDataURL: kEnumerableProperty,\n    abort: kEnumerableProperty,\n    readyState: kEnumerableProperty,\n    result: kEnumerableProperty,\n    error: kEnumerableProperty,\n    onloadstart: kEnumerableProperty,\n    onprogress: kEnumerableProperty,\n    onload: kEnumerableProperty,\n    onabort: kEnumerableProperty,\n    onerror: kEnumerableProperty,\n    onloadend: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"FileReader\",\n        writable: false,\n        enumerable: false,\n        configurable: true\n    }\n});\nObject.defineProperties(FileReader, {\n    EMPTY: staticPropertyDescriptors,\n    LOADING: staticPropertyDescriptors,\n    DONE: staticPropertyDescriptors\n});\nmodule.exports = {\n    FileReader\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS9maWxlcmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSx5QkFBeUIsRUFDekJDLGFBQWEsRUFDYkMsa0JBQWtCLEVBQ25CLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUNKQyxNQUFNLEVBQ05DLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxPQUFPLEVBQ1BDLFFBQVEsRUFDVCxHQUFHTCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRU0sTUFBTSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRU8sbUJBQW1CLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFFeEMsTUFBTVEsbUJBQW1CQztJQUN2QkMsYUFBZTtRQUNiLEtBQUs7UUFFTCxJQUFJLENBQUNULE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0UsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRSxRQUFRLEdBQUc7WUFDZE8sU0FBUztZQUNUQyxPQUFPO1lBQ1BDLE9BQU87WUFDUEMsTUFBTTtZQUNOQyxVQUFVO1lBQ1ZDLFdBQVc7UUFDYjtJQUNGO0lBRUE7OztHQUdDLEdBQ0RDLGtCQUFtQkMsSUFBSSxFQUFFO1FBQ3ZCWixPQUFPYSxVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QkYsT0FBT2MsbUJBQW1CLENBQUNDLFdBQVcsR0FBRztZQUFFQyxRQUFRO1FBQStCO1FBRWxGSixPQUFPWixPQUFPaUIsVUFBVSxDQUFDQyxJQUFJLENBQUNOLE1BQU07WUFBRU8sUUFBUTtRQUFNO1FBRXBELG9EQUFvRDtRQUNwRCw0REFBNEQ7UUFDNUQzQixjQUFjLElBQUksRUFBRW9CLE1BQU07SUFDNUI7SUFFQTs7O0dBR0MsR0FDRFEsbUJBQW9CUixJQUFJLEVBQUU7UUFDeEJaLE9BQU9hLFVBQVUsQ0FBQyxJQUFJLEVBQUVYO1FBRXhCRixPQUFP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QVMsQ0FBQ1gsSUFBSSxHQUFHO0FBRTlDWSxPQUFPQyxnQkFBZ0IsQ0FBQ3hDLFdBQVdzQyxTQUFTLEVBQUU7SUFDNUNiLE9BQU9wQztJQUNQcUMsU0FBU3JDO0lBQ1RzQyxNQUFNdEM7SUFDTm9CLG1CQUFtQlY7SUFDbkJtQixvQkFBb0JuQjtJQUNwQm9CLFlBQVlwQjtJQUNad0IsZUFBZXhCO0lBQ2ZNLE9BQU9OO0lBQ1B5QixZQUFZekI7SUFDWjZCLFFBQVE3QjtJQUNSSyxPQUFPTDtJQUNQbUMsYUFBYW5DO0lBQ2JvQyxZQUFZcEM7SUFDWnFDLFFBQVFyQztJQUNSc0MsU0FBU3RDO0lBQ1RrQyxTQUFTbEM7SUFDVDhCLFdBQVc5QjtJQUNYLENBQUMwQyxPQUFPQyxXQUFXLENBQUMsRUFBRTtRQUNwQkMsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsY0FBYztJQUNoQjtBQUNGO0FBRUFQLE9BQU9DLGdCQUFnQixDQUFDeEMsWUFBWTtJQUNsQ3lCLE9BQU9wQztJQUNQcUMsU0FBU3JDO0lBQ1RzQyxNQUFNdEM7QUFDUjtBQUVBMEQsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZoRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL2ZpbGVyZWFkZXIuanM/NGI3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICByZWFkT3BlcmF0aW9uLFxuICBmaXJlQVByb2dyZXNzRXZlbnRcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3Qge1xuICBrU3RhdGUsXG4gIGtFcnJvcixcbiAga1Jlc3VsdCxcbiAga0V2ZW50cyxcbiAga0Fib3J0ZWRcbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmNsYXNzIEZpbGVSZWFkZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzW2tTdGF0ZV0gPSAnZW1wdHknXG4gICAgdGhpc1trUmVzdWx0XSA9IG51bGxcbiAgICB0aGlzW2tFcnJvcl0gPSBudWxsXG4gICAgdGhpc1trRXZlbnRzXSA9IHtcbiAgICAgIGxvYWRlbmQ6IG51bGwsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICAgIGFib3J0OiBudWxsLFxuICAgICAgbG9hZDogbnVsbCxcbiAgICAgIHByb2dyZXNzOiBudWxsLFxuICAgICAgbG9hZHN0YXJ0OiBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2Rmbi1yZWFkQXNBcnJheUJ1ZmZlclxuICAgKiBAcGFyYW0ge2ltcG9ydCgnYnVmZmVyJykuQmxvYn0gYmxvYlxuICAgKi9cbiAgcmVhZEFzQXJyYXlCdWZmZXIgKGJsb2IpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0ZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXInIH0pXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIC8vIFRoZSByZWFkQXNBcnJheUJ1ZmZlcihibG9iKSBtZXRob2QsIHdoZW4gaW52b2tlZCxcbiAgICAvLyBtdXN0IGluaXRpYXRlIGEgcmVhZCBvcGVyYXRpb24gZm9yIGJsb2Igd2l0aCBBcnJheUJ1ZmZlci5cbiAgICByZWFkT3BlcmF0aW9uKHRoaXMsIGJsb2IsICdBcnJheUJ1ZmZlcicpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jcmVhZEFzQmluYXJ5U3RyaW5nXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqL1xuICByZWFkQXNCaW5hcnlTdHJpbmcgKGJsb2IpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0ZpbGVSZWFkZXIucmVhZEFzQmluYXJ5U3RyaW5nJyB9KVxuXG4gICAgYmxvYiA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoYmxvYiwgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgICAvLyBUaGUgcmVhZEFzQmluYXJ5U3RyaW5nKGJsb2IpIG1ldGhvZCwgd2hlbiBpbnZva2VkLFxuICAgIC8vIG11c3QgaW5pdGlhdGUgYSByZWFkIG9wZXJhdGlvbiBmb3IgYmxvYiB3aXRoIEJpbmFyeVN0cmluZy5cbiAgICByZWFkT3BlcmF0aW9uKHRoaXMsIGJsb2IsICdCaW5hcnlTdHJpbmcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI3JlYWRBc0RhdGFUZXh0XG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqIEBwYXJhbSB7c3RyaW5nP30gZW5jb2RpbmdcbiAgICovXG4gIHJlYWRBc1RleHQgKGJsb2IsIGVuY29kaW5nID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGaWxlUmVhZGVyLnJlYWRBc1RleHQnIH0pXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmNvZGluZyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhlbmNvZGluZylcbiAgICB9XG5cbiAgICAvLyBUaGUgcmVhZEFzVGV4dChibG9iLCBlbmNvZGluZykgbWV0aG9kLCB3aGVuIGludm9rZWQsXG4gICAgLy8gbXVzdCBpbml0aWF0ZSBhIHJlYWQgb3BlcmF0aW9uIGZvciBibG9iIHdpdGggVGV4dCBhbmQgZW5jb2RpbmcuXG4gICAgcmVhZE9wZXJhdGlvbih0aGlzLCBibG9iLCAnVGV4dCcsIGVuY29kaW5nKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2Rmbi1yZWFkQXNEYXRhVVJMXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqL1xuICByZWFkQXNEYXRhVVJMIChibG9iKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwnIH0pXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIC8vIFRoZSByZWFkQXNEYXRhVVJMKGJsb2IpIG1ldGhvZCwgd2hlbiBpbnZva2VkLCBtdXN0XG4gICAgLy8gaW5pdGlhdGUgYSByZWFkIG9wZXJhdGlvbiBmb3IgYmxvYiB3aXRoIERhdGFVUkwuXG4gICAgcmVhZE9wZXJhdGlvbih0aGlzLCBibG9iLCAnRGF0YVVSTCcpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZGZuLWFib3J0XG4gICAqL1xuICBhYm9ydCAoKSB7XG4gICAgLy8gMS4gSWYgdGhpcydzIHN0YXRlIGlzIFwiZW1wdHlcIiBvciBpZiB0aGlzJ3Mgc3RhdGUgaXNcbiAgICAvLyAgICBcImRvbmVcIiBzZXQgdGhpcydzIHJlc3VsdCB0byBudWxsIGFuZCB0ZXJtaW5hdGVcbiAgICAvLyAgICB0aGlzIGFsZ29yaXRobS5cbiAgICBpZiAodGhpc1trU3RhdGVdID09PSAnZW1wdHknIHx8IHRoaXNba1N0YXRlXSA9PT0gJ2RvbmUnKSB7XG4gICAgICB0aGlzW2tSZXN1bHRdID0gbnVsbFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpcydzIHN0YXRlIGlzIFwibG9hZGluZ1wiIHNldCB0aGlzJ3Mgc3RhdGUgdG9cbiAgICAvLyAgICBcImRvbmVcIiBhbmQgc2V0IHRoaXMncyByZXN1bHQgdG8gbnVsbC5cbiAgICBpZiAodGhpc1trU3RhdGVdID09PSAnbG9hZGluZycpIHtcbiAgICAgIHRoaXNba1N0YXRlXSA9ICdkb25lJ1xuICAgICAgdGhpc1trUmVzdWx0XSA9IG51bGxcbiAgICB9XG5cbiAgICAvLyAzLiBJZiB0aGVyZSBhcmUgYW55IHRhc2tzIGZyb20gdGhpcyBvbiB0aGUgZmlsZSByZWFkaW5nXG4gICAgLy8gICAgdGFzayBzb3VyY2UgaW4gYW4gYWZmaWxpYXRlZCB0YXNrIHF1ZXVlLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHRob3NlIHRhc2tzIGZyb20gdGhhdCB0YXNrIHF1ZXVlLlxuICAgIHRoaXNba0Fib3J0ZWRdID0gdHJ1ZVxuXG4gICAgLy8gNC4gVGVybWluYXRlIHRoZSBhbGdvcml0aG0gZm9yIHRoZSByZWFkIG1ldGhvZCBiZWluZyBwcm9jZXNzZWQuXG4gICAgLy8gVE9ET1xuXG4gICAgLy8gNS4gRmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBhYm9ydCBhdCB0aGlzLlxuICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnYWJvcnQnLCB0aGlzKVxuXG4gICAgLy8gNi4gSWYgdGhpcydzIHN0YXRlIGlzIG5vdCBcImxvYWRpbmdcIiwgZmlyZSBhIHByb2dyZXNzXG4gICAgLy8gICAgZXZlbnQgY2FsbGVkIGxvYWRlbmQgYXQgdGhpcy5cbiAgICBpZiAodGhpc1trU3RhdGVdICE9PSAnbG9hZGluZycpIHtcbiAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZGVuZCcsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLXJlYWR5c3RhdGVcbiAgICovXG4gIGdldCByZWFkeVN0YXRlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgc3dpdGNoICh0aGlzW2tTdGF0ZV0pIHtcbiAgICAgIGNhc2UgJ2VtcHR5JzogcmV0dXJuIHRoaXMuRU1QVFlcbiAgICAgIGNhc2UgJ2xvYWRpbmcnOiByZXR1cm4gdGhpcy5MT0FESU5HXG4gICAgICBjYXNlICdkb25lJzogcmV0dXJuIHRoaXMuRE9ORVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1yZXN1bHRcbiAgICovXG4gIGdldCByZXN1bHQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICAvLyBUaGUgcmVzdWx0IGF0dHJpYnV0ZeKAmXMgZ2V0dGVyLCB3aGVuIGludm9rZWQsIG11c3QgcmV0dXJuXG4gICAgLy8gdGhpcydzIHJlc3VsdC5cbiAgICByZXR1cm4gdGhpc1trUmVzdWx0XVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLWVycm9yXG4gICAqL1xuICBnZXQgZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICAvLyBUaGUgZXJyb3IgYXR0cmlidXRl4oCZcyBnZXR0ZXIsIHdoZW4gaW52b2tlZCwgbXVzdCByZXR1cm5cbiAgICAvLyB0aGlzJ3MgZXJyb3IuXG4gICAgcmV0dXJuIHRoaXNba0Vycm9yXVxuICB9XG5cbiAgZ2V0IG9ubG9hZGVuZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmxvYWRlbmRcbiAgfVxuXG4gIHNldCBvbmxvYWRlbmQgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLmxvYWRlbmQpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIHRoaXNba0V2ZW50c10ubG9hZGVuZClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWRlbmQgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZGVuZCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25lcnJvciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmVycm9yXG4gIH1cblxuICBzZXQgb25lcnJvciAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10uZXJyb3IpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzW2tFdmVudHNdLmVycm9yKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10uZXJyb3IgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmVycm9yID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmxvYWRzdGFydCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmxvYWRzdGFydFxuICB9XG5cbiAgc2V0IG9ubG9hZHN0YXJ0IChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9ucHJvZ3Jlc3MgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5wcm9ncmVzc1xuICB9XG5cbiAgc2V0IG9ucHJvZ3Jlc3MgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLnByb2dyZXNzKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpc1trRXZlbnRzXS5wcm9ncmVzcylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLnByb2dyZXNzID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5wcm9ncmVzcyA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25sb2FkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10ubG9hZFxuICB9XG5cbiAgc2V0IG9ubG9hZCAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10ubG9hZCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpc1trRXZlbnRzXS5sb2FkKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZCA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2FkID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmFib3J0ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10uYWJvcnRcbiAgfVxuXG4gIHNldCBvbmFib3J0IChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5hYm9ydCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIHRoaXNba0V2ZW50c10uYWJvcnQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5hYm9ydCA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10uYWJvcnQgPSBudWxsXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1lbXB0eVxuRmlsZVJlYWRlci5FTVBUWSA9IEZpbGVSZWFkZXIucHJvdG90eXBlLkVNUFRZID0gMFxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLWxvYWRpbmdcbkZpbGVSZWFkZXIuTE9BRElORyA9IEZpbGVSZWFkZXIucHJvdG90eXBlLkxPQURJTkcgPSAxXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItZG9uZVxuRmlsZVJlYWRlci5ET05FID0gRmlsZVJlYWRlci5wcm90b3R5cGUuRE9ORSA9IDJcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRmlsZVJlYWRlci5wcm90b3R5cGUsIHtcbiAgRU1QVFk6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIExPQURJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIERPTkU6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHJlYWRBc0FycmF5QnVmZmVyOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkQXNCaW5hcnlTdHJpbmc6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWRBc1RleHQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWRBc0RhdGFVUkw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGFib3J0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkeVN0YXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZXN1bHQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmxvYWRzdGFydDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25wcm9ncmVzczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25sb2FkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmFib3J0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmxvYWRlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdGaWxlUmVhZGVyJyxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZpbGVSZWFkZXIsIHtcbiAgRU1QVFk6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIExPQURJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIERPTkU6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnNcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGaWxlUmVhZGVyXG59XG4iXSwibmFtZXMiOlsic3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyIsInJlYWRPcGVyYXRpb24iLCJmaXJlQVByb2dyZXNzRXZlbnQiLCJyZXF1aXJlIiwia1N0YXRlIiwia0Vycm9yIiwia1Jlc3VsdCIsImtFdmVudHMiLCJrQWJvcnRlZCIsIndlYmlkbCIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJGaWxlUmVhZGVyIiwiRXZlbnRUYXJnZXQiLCJjb25zdHJ1Y3RvciIsImxvYWRlbmQiLCJlcnJvciIsImFib3J0IiwibG9hZCIsInByb2dyZXNzIiwibG9hZHN0YXJ0IiwicmVhZEFzQXJyYXlCdWZmZXIiLCJibG9iIiwiYnJhbmRDaGVjayIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJoZWFkZXIiLCJjb252ZXJ0ZXJzIiwiQmxvYiIsInN0cmljdCIsInJlYWRBc0JpbmFyeVN0cmluZyIsInJlYWRBc1RleHQiLCJlbmNvZGluZyIsInVuZGVmaW5lZCIsIkRPTVN0cmluZyIsInJlYWRBc0RhdGFVUkwiLCJyZWFkeVN0YXRlIiwiRU1QVFkiLCJMT0FESU5HIiwiRE9ORSIsInJlc3VsdCIsIm9ubG9hZGVuZCIsImZuIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmVycm9yIiwib25sb2Fkc3RhcnQiLCJvbnByb2dyZXNzIiwib25sb2FkIiwib25hYm9ydCIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fileapi/filereader.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fileapi/progressevent.js":
/*!**************************************************************!*\
  !*** ../../node_modules/undici/lib/fileapi/progressevent.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst kState = Symbol(\"ProgressEvent state\");\n/**\n * @see https://xhr.spec.whatwg.org/#progressevent\n */ class ProgressEvent extends Event {\n    constructor(type, eventInitDict = {}){\n        type = webidl.converters.DOMString(type);\n        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});\n        super(type, eventInitDict);\n        this[kState] = {\n            lengthComputable: eventInitDict.lengthComputable,\n            loaded: eventInitDict.loaded,\n            total: eventInitDict.total\n        };\n    }\n    get lengthComputable() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].lengthComputable;\n    }\n    get loaded() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].loaded;\n    }\n    get total() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].total;\n    }\n}\nwebidl.converters.ProgressEventInit = webidl.dictionaryConverter([\n    {\n        key: \"lengthComputable\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"loaded\",\n        converter: webidl.converters[\"unsigned long long\"],\n        defaultValue: 0\n    },\n    {\n        key: \"total\",\n        converter: webidl.converters[\"unsigned long long\"],\n        defaultValue: 0\n    },\n    {\n        key: \"bubbles\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"cancelable\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"composed\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    }\n]);\nmodule.exports = {\n    ProgressEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS9wcm9ncmVzc2V2ZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFM0IsTUFBTUMsU0FBU0MsT0FBTztBQUV0Qjs7Q0FFQyxHQUNELE1BQU1DLHNCQUFzQkM7SUFDMUJDLFlBQWFDLElBQUksRUFBRUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFFO1FBQ3JDRCxPQUFPUCxPQUFPUyxVQUFVLENBQUNDLFNBQVMsQ0FBQ0g7UUFDbkNDLGdCQUFnQlIsT0FBT1MsVUFBVSxDQUFDRSxpQkFBaUIsQ0FBQ0gsaUJBQWlCLENBQUM7UUFFdEUsS0FBSyxDQUFDRCxNQUFNQztRQUVaLElBQUksQ0FBQ04sT0FBTyxHQUFHO1lBQ2JVLGtCQUFrQkosY0FBY0ksZ0JBQWdCO1lBQ2hEQyxRQUFRTCxjQUFjSyxNQUFNO1lBQzVCQyxPQUFPTixjQUFjTSxLQUFLO1FBQzVCO0lBQ0Y7SUFFQSxJQUFJRixtQkFBb0I7UUFDdEJaLE9BQU9lLFVBQVUsQ0FBQyxJQUFJLEVBQUVYO1FBRXhCLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNVLGdCQUFnQjtJQUN0QztJQUVBLElBQUlDLFNBQVU7UUFDWmIsT0FBT2UsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ1csTUFBTTtJQUM1QjtJQUVBLElBQUlDLFFBQVM7UUFDWGQsT0FBT2UsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ1ksS0FBSztJQUMzQjtBQUNGO0FBRUFkLE9BQU9TLFVBQVUsQ0FBQ0UsaUJBQWlCLEdBQUdYLE9BQU9nQixtQkFBbUIsQ0FBQztJQUMvRDtRQUNFQyxLQUFLO1FBQ0xDLFdBQVdsQixPQUFPUyxVQUFVLENBQUNVLE9BQU87UUFDcENDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdsQixPQUFPUyxVQUFVLENBQUMscUJBQXFCO1FBQ2xEVyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXbEIsT0FBT1MsVUFBVSxDQUFDLHFCQUFxQjtRQUNsRFcsY0FBYztJQUNoQjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2xCLE9BQU9TLFVBQVUsQ0FBQ1UsT0FBTztRQUNwQ0MsY0FBYztJQUNoQjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2xCLE9BQU9TLFVBQVUsQ0FBQ1UsT0FBTztRQUNwQ0MsY0FBYztJQUNoQjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2xCLE9BQU9TLFVBQVUsQ0FBQ1UsT0FBTztRQUNwQ0MsY0FBYztJQUNoQjtDQUNEO0FBRURDLE9BQU9DLE9BQU8sR0FBRztJQUNmbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS9wcm9ncmVzc2V2ZW50LmpzPzgxYjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuXG5jb25zdCBrU3RhdGUgPSBTeW1ib2woJ1Byb2dyZXNzRXZlbnQgc3RhdGUnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly94aHIuc3BlYy53aGF0d2cub3JnLyNwcm9ncmVzc2V2ZW50XG4gKi9cbmNsYXNzIFByb2dyZXNzRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIGNvbnN0cnVjdG9yICh0eXBlLCBldmVudEluaXREaWN0ID0ge30pIHtcbiAgICB0eXBlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHR5cGUpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlByb2dyZXNzRXZlbnRJbml0KGV2ZW50SW5pdERpY3QgPz8ge30pXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuXG4gICAgdGhpc1trU3RhdGVdID0ge1xuICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogZXZlbnRJbml0RGljdC5sZW5ndGhDb21wdXRhYmxlLFxuICAgICAgbG9hZGVkOiBldmVudEluaXREaWN0LmxvYWRlZCxcbiAgICAgIHRvdGFsOiBldmVudEluaXREaWN0LnRvdGFsXG4gICAgfVxuICB9XG5cbiAgZ2V0IGxlbmd0aENvbXB1dGFibGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFByb2dyZXNzRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxlbmd0aENvbXB1dGFibGVcbiAgfVxuXG4gIGdldCBsb2FkZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFByb2dyZXNzRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxvYWRlZFxuICB9XG5cbiAgZ2V0IHRvdGFsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBQcm9ncmVzc0V2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS50b3RhbFxuICB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlByb2dyZXNzRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnbGVuZ3RoQ29tcHV0YWJsZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2xvYWRlZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICd0b3RhbCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdidWJibGVzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY2FuY2VsYWJsZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NvbXBvc2VkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUHJvZ3Jlc3NFdmVudFxufVxuIl0sIm5hbWVzIjpbIndlYmlkbCIsInJlcXVpcmUiLCJrU3RhdGUiLCJTeW1ib2wiLCJQcm9ncmVzc0V2ZW50IiwiRXZlbnQiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJldmVudEluaXREaWN0IiwiY29udmVydGVycyIsIkRPTVN0cmluZyIsIlByb2dyZXNzRXZlbnRJbml0IiwibGVuZ3RoQ29tcHV0YWJsZSIsImxvYWRlZCIsInRvdGFsIiwiYnJhbmRDaGVjayIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJrZXkiLCJjb252ZXJ0ZXIiLCJib29sZWFuIiwiZGVmYXVsdFZhbHVlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fileapi/progressevent.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fileapi/symbols.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/fileapi/symbols.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    kState: Symbol(\"FileReader state\"),\n    kResult: Symbol(\"FileReader result\"),\n    kError: Symbol(\"FileReader error\"),\n    kLastProgressEventFired: Symbol(\"FileReader last progress event fired timestamp\"),\n    kEvents: Symbol(\"FileReader events\"),\n    kAborted: Symbol(\"FileReader aborted\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxRQUFRQyxPQUFPO0lBQ2ZDLFNBQVNELE9BQU87SUFDaEJFLFFBQVFGLE9BQU87SUFDZkcseUJBQXlCSCxPQUFPO0lBQ2hDSSxTQUFTSixPQUFPO0lBQ2hCSyxVQUFVTCxPQUFPO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL3N5bWJvbHMuanM/ZGMzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtTdGF0ZTogU3ltYm9sKCdGaWxlUmVhZGVyIHN0YXRlJyksXG4gIGtSZXN1bHQ6IFN5bWJvbCgnRmlsZVJlYWRlciByZXN1bHQnKSxcbiAga0Vycm9yOiBTeW1ib2woJ0ZpbGVSZWFkZXIgZXJyb3InKSxcbiAga0xhc3RQcm9ncmVzc0V2ZW50RmlyZWQ6IFN5bWJvbCgnRmlsZVJlYWRlciBsYXN0IHByb2dyZXNzIGV2ZW50IGZpcmVkIHRpbWVzdGFtcCcpLFxuICBrRXZlbnRzOiBTeW1ib2woJ0ZpbGVSZWFkZXIgZXZlbnRzJyksXG4gIGtBYm9ydGVkOiBTeW1ib2woJ0ZpbGVSZWFkZXIgYWJvcnRlZCcpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtTdGF0ZSIsIlN5bWJvbCIsImtSZXN1bHQiLCJrRXJyb3IiLCJrTGFzdFByb2dyZXNzRXZlbnRGaXJlZCIsImtFdmVudHMiLCJrQWJvcnRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fileapi/symbols.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/fileapi/util.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/fileapi/util.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kState, kError, kResult, kAborted, kLastProgressEventFired } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/fileapi/symbols.js\");\nconst { ProgressEvent } = __webpack_require__(/*! ./progressevent */ \"(rsc)/../../node_modules/undici/lib/fileapi/progressevent.js\");\nconst { getEncoding } = __webpack_require__(/*! ./encoding */ \"(rsc)/../../node_modules/undici/lib/fileapi/encoding.js\");\nconst { DOMException } = __webpack_require__(/*! ../fetch/constants */ \"(rsc)/../../node_modules/undici/lib/fetch/constants.js\");\nconst { serializeAMimeType, parseMIMEType } = __webpack_require__(/*! ../fetch/dataURL */ \"(rsc)/../../node_modules/undici/lib/fetch/dataURL.js\");\nconst { types } = __webpack_require__(/*! util */ \"util\");\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\");\nconst { btoa } = __webpack_require__(/*! buffer */ \"buffer\");\n/** @type {PropertyDescriptor} */ const staticPropertyDescriptors = {\n    enumerable: true,\n    writable: false,\n    configurable: false\n};\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */ function readOperation(fr, blob, type, encodingName) {\n    // 1. If frs state is \"loading\", throw an InvalidStateError\n    //    DOMException.\n    if (fr[kState] === \"loading\") {\n        throw new DOMException(\"Invalid state\", \"InvalidStateError\");\n    }\n    // 2. Set frs state to \"loading\".\n    fr[kState] = \"loading\";\n    // 3. Set frs result to null.\n    fr[kResult] = null;\n    // 4. Set frs error to null.\n    fr[kError] = null;\n    // 5. Let stream be the result of calling get stream on blob.\n    /** @type {import('stream/web').ReadableStream} */ const stream = blob.stream();\n    // 6. Let reader be the result of getting a reader from stream.\n    const reader = stream.getReader();\n    // 7. Let bytes be an empty byte sequence.\n    /** @type {Uint8Array[]} */ const bytes = [];\n    // 8. Let chunkPromise be the result of reading a chunk from\n    //    stream with reader.\n    let chunkPromise = reader.read();\n    // 9. Let isFirstChunk be true.\n    let isFirstChunk = true;\n    (async ()=>{\n        while(!fr[kAborted]){\n            // 1. Wait for chunkPromise to be fulfilled or rejected.\n            try {\n                const { done, value } = await chunkPromise;\n                // 2. If chunkPromise is fulfilled, and isFirstChunk is\n                //    true, queue a task to fire a progress event called\n                //    loadstart at fr.\n                if (isFirstChunk && !fr[kAborted]) {\n                    queueMicrotask(()=>{\n                        fireAProgressEvent(\"loadstart\", fr);\n                    });\n                }\n                // 3. Set isFirstChunk to false.\n                isFirstChunk = false;\n                // 4. If chunkPromise is fulfilled with an object whose\n                //    done property is false and whose value property is\n                //    a Uint8Array object, run these steps:\n                if (!done && types.isUint8Array(value)) {\n                    // 1. Let bs be the byte sequence represented by the\n                    //    Uint8Array object.\n                    // 2. Append bs to bytes.\n                    bytes.push(value);\n                    // 3. If roughly 50ms have passed since these steps\n                    //    were last invoked, queue a task to fire a\n                    //    progress event called progress at fr.\n                    if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {\n                        fr[kLastProgressEventFired] = Date.now();\n                        queueMicrotask(()=>{\n                            fireAProgressEvent(\"progress\", fr);\n                        });\n                    }\n                    // 4. Set chunkPromise to the result of reading a\n                    //    chunk from stream with reader.\n                    chunkPromise = reader.read();\n                } else if (done) {\n                    // 5. Otherwise, if chunkPromise is fulfilled with an\n                    //    object whose done property is true, queue a task\n                    //    to run the following steps and abort this algorithm:\n                    queueMicrotask(()=>{\n                        // 1. Set frs state to \"done\".\n                        fr[kState] = \"done\";\n                        // 2. Let result be the result of package data given\n                        //    bytes, type, blobs type, and encodingName.\n                        try {\n                            const result = packageData(bytes, type, blob.type, encodingName);\n                            // 4. Else:\n                            if (fr[kAborted]) {\n                                return;\n                            }\n                            // 1. Set frs result to result.\n                            fr[kResult] = result;\n                            // 2. Fire a progress event called load at the fr.\n                            fireAProgressEvent(\"load\", fr);\n                        } catch (error) {\n                            // 3. If package data threw an exception error:\n                            // 1. Set frs error to error.\n                            fr[kError] = error;\n                            // 2. Fire a progress event called error at fr.\n                            fireAProgressEvent(\"error\", fr);\n                        }\n                        // 5. If frs state is not \"loading\", fire a progress\n                        //    event called loadend at the fr.\n                        if (fr[kState] !== \"loading\") {\n                            fireAProgressEvent(\"loadend\", fr);\n                        }\n                    });\n                    break;\n                }\n            } catch (error) {\n                if (fr[kAborted]) {\n                    return;\n                }\n                // 6. Otherwise, if chunkPromise is rejected with an\n                //    error error, queue a task to run the following\n                //    steps and abort this algorithm:\n                queueMicrotask(()=>{\n                    // 1. Set frs state to \"done\".\n                    fr[kState] = \"done\";\n                    // 2. Set frs error to error.\n                    fr[kError] = error;\n                    // 3. Fire a progress event called error at fr.\n                    fireAProgressEvent(\"error\", fr);\n                    // 4. If frs state is not \"loading\", fire a progress\n                    //    event called loadend at fr.\n                    if (fr[kState] !== \"loading\") {\n                        fireAProgressEvent(\"loadend\", fr);\n                    }\n                });\n                break;\n            }\n        }\n    })();\n}\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */ function fireAProgressEvent(e, reader) {\n    // The progress event e does not bubble. e.bubbles must be false\n    // The progress event e is NOT cancelable. e.cancelable must be false\n    const event = new ProgressEvent(e, {\n        bubbles: false,\n        cancelable: false\n    });\n    reader.dispatchEvent(event);\n}\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */ function packageData(bytes, type, mimeType, encodingName) {\n    // 1. A Blob has an associated package data algorithm, given\n    //    bytes, a type, a optional mimeType, and a optional\n    //    encodingName, which switches on type and runs the\n    //    associated steps:\n    switch(type){\n        case \"DataURL\":\n            {\n                // 1. Return bytes as a DataURL [RFC2397] subject to\n                //    the considerations below:\n                //  * Use mimeType as part of the Data URL if it is\n                //    available in keeping with the Data URL\n                //    specification [RFC2397].\n                //  * If mimeType is not available return a Data URL\n                //    without a media-type. [RFC2397].\n                // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n                // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n                // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n                // data       := *urlchar\n                // parameter  := attribute \"=\" value\n                let dataURL = \"data:\";\n                const parsed = parseMIMEType(mimeType || \"application/octet-stream\");\n                if (parsed !== \"failure\") {\n                    dataURL += serializeAMimeType(parsed);\n                }\n                dataURL += \";base64,\";\n                const decoder = new StringDecoder(\"latin1\");\n                for (const chunk of bytes){\n                    dataURL += btoa(decoder.write(chunk));\n                }\n                dataURL += btoa(decoder.end());\n                return dataURL;\n            }\n        case \"Text\":\n            {\n                // 1. Let encoding be failure\n                let encoding = \"failure\";\n                // 2. If the encodingName is present, set encoding to the\n                //    result of getting an encoding from encodingName.\n                if (encodingName) {\n                    encoding = getEncoding(encodingName);\n                }\n                // 3. If encoding is failure, and mimeType is present:\n                if (encoding === \"failure\" && mimeType) {\n                    // 1. Let type be the result of parse a MIME type\n                    //    given mimeType.\n                    const type = parseMIMEType(mimeType);\n                    // 2. If type is not failure, set encoding to the result\n                    //    of getting an encoding from types parameters[\"charset\"].\n                    if (type !== \"failure\") {\n                        encoding = getEncoding(type.parameters.get(\"charset\"));\n                    }\n                }\n                // 4. If encoding is failure, then set encoding to UTF-8.\n                if (encoding === \"failure\") {\n                    encoding = \"UTF-8\";\n                }\n                // 5. Decode bytes using fallback encoding encoding, and\n                //    return the result.\n                return decode(bytes, encoding);\n            }\n        case \"ArrayBuffer\":\n            {\n                // Return a new ArrayBuffer whose contents are bytes.\n                const sequence = combineByteSequences(bytes);\n                return sequence.buffer;\n            }\n        case \"BinaryString\":\n            {\n                // Return bytes as a binary string, in which every byte\n                //  is represented by a code unit of equal value [0..255].\n                let binaryString = \"\";\n                const decoder = new StringDecoder(\"latin1\");\n                for (const chunk of bytes){\n                    binaryString += decoder.write(chunk);\n                }\n                binaryString += decoder.end();\n                return binaryString;\n            }\n    }\n}\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */ function decode(ioQueue, encoding) {\n    const bytes = combineByteSequences(ioQueue);\n    // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n    const BOMEncoding = BOMSniffing(bytes);\n    let slice = 0;\n    // 2. If BOMEncoding is non-null:\n    if (BOMEncoding !== null) {\n        // 1. Set encoding to BOMEncoding.\n        encoding = BOMEncoding;\n        // 2. Read three bytes from ioQueue, if BOMEncoding is\n        //    UTF-8; otherwise read two bytes.\n        //    (Do nothing with those bytes.)\n        slice = BOMEncoding === \"UTF-8\" ? 3 : 2;\n    }\n    // 3. Process a queue with an instance of encodings\n    //    decoder, ioQueue, output, and \"replacement\".\n    // 4. Return output.\n    const sliced = bytes.slice(slice);\n    return new TextDecoder(encoding).decode(sliced);\n}\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */ function BOMSniffing(ioQueue) {\n    // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n    //    converted to a byte sequence.\n    const [a, b, c] = ioQueue;\n    // 2. For each of the rows in the table below, starting with\n    //    the first one and going down, if BOM starts with the\n    //    bytes given in the first column, then return the\n    //    encoding given in the cell in the second column of that\n    //    row. Otherwise, return null.\n    if (a === 0xEF && b === 0xBB && c === 0xBF) {\n        return \"UTF-8\";\n    } else if (a === 0xFE && b === 0xFF) {\n        return \"UTF-16BE\";\n    } else if (a === 0xFF && b === 0xFE) {\n        return \"UTF-16LE\";\n    }\n    return null;\n}\n/**\n * @param {Uint8Array[]} sequences\n */ function combineByteSequences(sequences) {\n    const size = sequences.reduce((a, b)=>{\n        return a + b.byteLength;\n    }, 0);\n    let offset = 0;\n    return sequences.reduce((a, b)=>{\n        a.set(b, offset);\n        offset += b.byteLength;\n        return a;\n    }, new Uint8Array(size));\n}\nmodule.exports = {\n    staticPropertyDescriptors,\n    readOperation,\n    fireAProgressEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmlsZWFwaS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSxNQUFNLEVBQ05DLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1JDLHVCQUF1QixFQUN4QixHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRUUsV0FBVyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU0sRUFBRUcsWUFBWSxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU0sRUFBRUksa0JBQWtCLEVBQUVDLGFBQWEsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUN0RCxNQUFNLEVBQUVNLEtBQUssRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUMxQixNQUFNLEVBQUVPLGFBQWEsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVRLElBQUksRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUV6QiwrQkFBK0IsR0FDL0IsTUFBTVMsNEJBQTRCO0lBQ2hDQyxZQUFZO0lBQ1pDLFVBQVU7SUFDVkMsY0FBYztBQUNoQjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGNBQWVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFlBQVk7SUFDbEQsNERBQTREO0lBQzVELG1CQUFtQjtJQUNuQixJQUFJSCxFQUFFLENBQUNuQixPQUFPLEtBQUssV0FBVztRQUM1QixNQUFNLElBQUlRLGFBQWEsaUJBQWlCO0lBQzFDO0lBRUEsa0NBQWtDO0lBQ2xDVyxFQUFFLENBQUNuQixPQUFPLEdBQUc7SUFFYiw4QkFBOEI7SUFDOUJtQixFQUFFLENBQUNqQixRQUFRLEdBQUc7SUFFZCw2QkFBNkI7SUFDN0JpQixFQUFFLENBQUNsQixPQUFPLEdBQUc7SUFFYiw2REFBNkQ7SUFDN0QsZ0RBQWdE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Oi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL3V0aWwuanM/ZTk5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBrU3RhdGUsXG4gIGtFcnJvcixcbiAga1Jlc3VsdCxcbiAga0Fib3J0ZWQsXG4gIGtMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgUHJvZ3Jlc3NFdmVudCB9ID0gcmVxdWlyZSgnLi9wcm9ncmVzc2V2ZW50JylcbmNvbnN0IHsgZ2V0RW5jb2RpbmcgfSA9IHJlcXVpcmUoJy4vZW5jb2RpbmcnKVxuY29uc3QgeyBET01FeGNlcHRpb24gfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2NvbnN0YW50cycpXG5jb25zdCB7IHNlcmlhbGl6ZUFNaW1lVHlwZSwgcGFyc2VNSU1FVHlwZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YVVSTCcpXG5jb25zdCB7IHR5cGVzIH0gPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IHsgU3RyaW5nRGVjb2RlciB9ID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKVxuY29uc3QgeyBidG9hIH0gPSByZXF1aXJlKCdidWZmZXInKVxuXG4vKiogQHR5cGUge1Byb3BlcnR5RGVzY3JpcHRvcn0gKi9cbmNvbnN0IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMgPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI3JlYWRPcGVyYXRpb25cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ZpbGVyZWFkZXInKS5GaWxlUmVhZGVyfSBmclxuICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZz99IGVuY29kaW5nTmFtZVxuICovXG5mdW5jdGlvbiByZWFkT3BlcmF0aW9uIChmciwgYmxvYiwgdHlwZSwgZW5jb2RpbmdOYW1lKSB7XG4gIC8vIDEuIElmIGZy4oCZcyBzdGF0ZSBpcyBcImxvYWRpbmdcIiwgdGhyb3cgYW4gSW52YWxpZFN0YXRlRXJyb3JcbiAgLy8gICAgRE9NRXhjZXB0aW9uLlxuICBpZiAoZnJba1N0YXRlXSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignSW52YWxpZCBzdGF0ZScsICdJbnZhbGlkU3RhdGVFcnJvcicpXG4gIH1cblxuICAvLyAyLiBTZXQgZnLigJlzIHN0YXRlIHRvIFwibG9hZGluZ1wiLlxuICBmcltrU3RhdGVdID0gJ2xvYWRpbmcnXG5cbiAgLy8gMy4gU2V0IGZy4oCZcyByZXN1bHQgdG8gbnVsbC5cbiAgZnJba1Jlc3VsdF0gPSBudWxsXG5cbiAgLy8gNC4gU2V0IGZy4oCZcyBlcnJvciB0byBudWxsLlxuICBmcltrRXJyb3JdID0gbnVsbFxuXG4gIC8vIDUuIExldCBzdHJlYW0gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGdldCBzdHJlYW0gb24gYmxvYi5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJ3N0cmVhbS93ZWInKS5SZWFkYWJsZVN0cmVhbX0gKi9cbiAgY29uc3Qgc3RyZWFtID0gYmxvYi5zdHJlYW0oKVxuXG4gIC8vIDYuIExldCByZWFkZXIgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGEgcmVhZGVyIGZyb20gc3RyZWFtLlxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKClcblxuICAvLyA3LiBMZXQgYnl0ZXMgYmUgYW4gZW1wdHkgYnl0ZSBzZXF1ZW5jZS5cbiAgLyoqIEB0eXBlIHtVaW50OEFycmF5W119ICovXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICAvLyA4LiBMZXQgY2h1bmtQcm9taXNlIGJlIHRoZSByZXN1bHQgb2YgcmVhZGluZyBhIGNodW5rIGZyb21cbiAgLy8gICAgc3RyZWFtIHdpdGggcmVhZGVyLlxuICBsZXQgY2h1bmtQcm9taXNlID0gcmVhZGVyLnJlYWQoKVxuXG4gIC8vIDkuIExldCBpc0ZpcnN0Q2h1bmsgYmUgdHJ1ZS5cbiAgbGV0IGlzRmlyc3RDaHVuayA9IHRydWVcblxuICAvLyAxMC4gSW4gcGFyYWxsZWwsIHdoaWxlIHRydWU6XG4gIC8vIE5vdGU6IFwiSW4gcGFyYWxsZWxcIiBqdXN0IG1lYW5zIG5vbi1ibG9ja2luZ1xuICAvLyBOb3RlIDI6IHJlYWRPcGVyYXRpb24gaXRzZWxmIGNhbm5vdCBiZSBhc3luYyBhcyBkb3VibGVcbiAgLy8gcmVhZGluZyB0aGUgYm9keSB3b3VsZCB0aGVuIHJlamVjdCB0aGUgcHJvbWlzZSwgaW5zdGVhZFxuICAvLyBvZiB0aHJvd2luZyBhbiBlcnJvci5cbiAgOyhhc3luYyAoKSA9PiB7XG4gICAgd2hpbGUgKCFmcltrQWJvcnRlZF0pIHtcbiAgICAgIC8vIDEuIFdhaXQgZm9yIGNodW5rUHJvbWlzZSB0byBiZSBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBjaHVua1Byb21pc2VcblxuICAgICAgICAvLyAyLiBJZiBjaHVua1Byb21pc2UgaXMgZnVsZmlsbGVkLCBhbmQgaXNGaXJzdENodW5rIGlzXG4gICAgICAgIC8vICAgIHRydWUsIHF1ZXVlIGEgdGFzayB0byBmaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkXG4gICAgICAgIC8vICAgIGxvYWRzdGFydCBhdCBmci5cbiAgICAgICAgaWYgKGlzRmlyc3RDaHVuayAmJiAhZnJba0Fib3J0ZWRdKSB7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2Fkc3RhcnQnLCBmcilcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gU2V0IGlzRmlyc3RDaHVuayB0byBmYWxzZS5cbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2VcblxuICAgICAgICAvLyA0LiBJZiBjaHVua1Byb21pc2UgaXMgZnVsZmlsbGVkIHdpdGggYW4gb2JqZWN0IHdob3NlXG4gICAgICAgIC8vICAgIGRvbmUgcHJvcGVydHkgaXMgZmFsc2UgYW5kIHdob3NlIHZhbHVlIHByb3BlcnR5IGlzXG4gICAgICAgIC8vICAgIGEgVWludDhBcnJheSBvYmplY3QsIHJ1biB0aGVzZSBzdGVwczpcbiAgICAgICAgaWYgKCFkb25lICYmIHR5cGVzLmlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAvLyAxLiBMZXQgYnMgYmUgdGhlIGJ5dGUgc2VxdWVuY2UgcmVwcmVzZW50ZWQgYnkgdGhlXG4gICAgICAgICAgLy8gICAgVWludDhBcnJheSBvYmplY3QuXG5cbiAgICAgICAgICAvLyAyLiBBcHBlbmQgYnMgdG8gYnl0ZXMuXG4gICAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSlcblxuICAgICAgICAgIC8vIDMuIElmIHJvdWdobHkgNTBtcyBoYXZlIHBhc3NlZCBzaW5jZSB0aGVzZSBzdGVwc1xuICAgICAgICAgIC8vICAgIHdlcmUgbGFzdCBpbnZva2VkLCBxdWV1ZSBhIHRhc2sgdG8gZmlyZSBhXG4gICAgICAgICAgLy8gICAgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIHByb2dyZXNzIGF0IGZyLlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgZnJba0xhc3RQcm9ncmVzc0V2ZW50RmlyZWRdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgRGF0ZS5ub3coKSAtIGZyW2tMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkXSA+PSA1MFxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgIWZyW2tBYm9ydGVkXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZnJba0xhc3RQcm9ncmVzc0V2ZW50RmlyZWRdID0gRGF0ZS5ub3coKVxuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ3Byb2dyZXNzJywgZnIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuIFNldCBjaHVua1Byb21pc2UgdG8gdGhlIHJlc3VsdCBvZiByZWFkaW5nIGFcbiAgICAgICAgICAvLyAgICBjaHVuayBmcm9tIHN0cmVhbSB3aXRoIHJlYWRlci5cbiAgICAgICAgICBjaHVua1Byb21pc2UgPSByZWFkZXIucmVhZCgpXG4gICAgICAgIH0gZWxzZSBpZiAoZG9uZSkge1xuICAgICAgICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgY2h1bmtQcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGFuXG4gICAgICAgICAgLy8gICAgb2JqZWN0IHdob3NlIGRvbmUgcHJvcGVydHkgaXMgdHJ1ZSwgcXVldWUgYSB0YXNrXG4gICAgICAgICAgLy8gICAgdG8gcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHMgYW5kIGFib3J0IHRoaXMgYWxnb3JpdGhtOlxuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIFNldCBmcuKAmXMgc3RhdGUgdG8gXCJkb25lXCIuXG4gICAgICAgICAgICBmcltrU3RhdGVdID0gJ2RvbmUnXG5cbiAgICAgICAgICAgIC8vIDIuIExldCByZXN1bHQgYmUgdGhlIHJlc3VsdCBvZiBwYWNrYWdlIGRhdGEgZ2l2ZW5cbiAgICAgICAgICAgIC8vICAgIGJ5dGVzLCB0eXBlLCBibG9i4oCZcyB0eXBlLCBhbmQgZW5jb2RpbmdOYW1lLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFja2FnZURhdGEoYnl0ZXMsIHR5cGUsIGJsb2IudHlwZSwgZW5jb2RpbmdOYW1lKVxuXG4gICAgICAgICAgICAgIC8vIDQuIEVsc2U6XG5cbiAgICAgICAgICAgICAgaWYgKGZyW2tBYm9ydGVkXSkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gMS4gU2V0IGZy4oCZcyByZXN1bHQgdG8gcmVzdWx0LlxuICAgICAgICAgICAgICBmcltrUmVzdWx0XSA9IHJlc3VsdFxuXG4gICAgICAgICAgICAgIC8vIDIuIEZpcmUgYSBwcm9ncmVzcyBldmVudCBjYWxsZWQgbG9hZCBhdCB0aGUgZnIuXG4gICAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZCcsIGZyKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gMy4gSWYgcGFja2FnZSBkYXRhIHRocmV3IGFuIGV4Y2VwdGlvbiBlcnJvcjpcblxuICAgICAgICAgICAgICAvLyAxLiBTZXQgZnLigJlzIGVycm9yIHRvIGVycm9yLlxuICAgICAgICAgICAgICBmcltrRXJyb3JdID0gZXJyb3JcblxuICAgICAgICAgICAgICAvLyAyLiBGaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIGVycm9yIGF0IGZyLlxuICAgICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2Vycm9yJywgZnIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDUuIElmIGZy4oCZcyBzdGF0ZSBpcyBub3QgXCJsb2FkaW5nXCIsIGZpcmUgYSBwcm9ncmVzc1xuICAgICAgICAgICAgLy8gICAgZXZlbnQgY2FsbGVkIGxvYWRlbmQgYXQgdGhlIGZyLlxuICAgICAgICAgICAgaWYgKGZyW2tTdGF0ZV0gIT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2xvYWRlbmQnLCBmcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGZyW2tBYm9ydGVkXSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNi4gT3RoZXJ3aXNlLCBpZiBjaHVua1Byb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCBhblxuICAgICAgICAvLyAgICBlcnJvciBlcnJvciwgcXVldWUgYSB0YXNrIHRvIHJ1biB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vICAgIHN0ZXBzIGFuZCBhYm9ydCB0aGlzIGFsZ29yaXRobTpcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgIC8vIDEuIFNldCBmcuKAmXMgc3RhdGUgdG8gXCJkb25lXCIuXG4gICAgICAgICAgZnJba1N0YXRlXSA9ICdkb25lJ1xuXG4gICAgICAgICAgLy8gMi4gU2V0IGZy4oCZcyBlcnJvciB0byBlcnJvci5cbiAgICAgICAgICBmcltrRXJyb3JdID0gZXJyb3JcblxuICAgICAgICAgIC8vIDMuIEZpcmUgYSBwcm9ncmVzcyBldmVudCBjYWxsZWQgZXJyb3IgYXQgZnIuXG4gICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdlcnJvcicsIGZyKVxuXG4gICAgICAgICAgLy8gNC4gSWYgZnLigJlzIHN0YXRlIGlzIG5vdCBcImxvYWRpbmdcIiwgZmlyZSBhIHByb2dyZXNzXG4gICAgICAgICAgLy8gICAgZXZlbnQgY2FsbGVkIGxvYWRlbmQgYXQgZnIuXG4gICAgICAgICAgaWYgKGZyW2tTdGF0ZV0gIT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2FkZW5kJywgZnIpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9KSgpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZmlyZS1hLXByb2dyZXNzLWV2ZW50XG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ldmVudC1maXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ZpbGVyZWFkZXInKS5GaWxlUmVhZGVyfSByZWFkZXJcbiAqL1xuZnVuY3Rpb24gZmlyZUFQcm9ncmVzc0V2ZW50IChlLCByZWFkZXIpIHtcbiAgLy8gVGhlIHByb2dyZXNzIGV2ZW50IGUgZG9lcyBub3QgYnViYmxlLiBlLmJ1YmJsZXMgbXVzdCBiZSBmYWxzZVxuICAvLyBUaGUgcHJvZ3Jlc3MgZXZlbnQgZSBpcyBOT1QgY2FuY2VsYWJsZS4gZS5jYW5jZWxhYmxlIG11c3QgYmUgZmFsc2VcbiAgY29uc3QgZXZlbnQgPSBuZXcgUHJvZ3Jlc3NFdmVudChlLCB7XG4gICAgYnViYmxlczogZmFsc2UsXG4gICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgfSlcblxuICByZWFkZXIuZGlzcGF0Y2hFdmVudChldmVudClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNibG9iLXBhY2thZ2UtZGF0YVxuICogQHBhcmFtIHtVaW50OEFycmF5W119IGJ5dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmc/fSBtaW1lVHlwZVxuICogQHBhcmFtIHtzdHJpbmc/fSBlbmNvZGluZ05hbWVcbiAqL1xuZnVuY3Rpb24gcGFja2FnZURhdGEgKGJ5dGVzLCB0eXBlLCBtaW1lVHlwZSwgZW5jb2RpbmdOYW1lKSB7XG4gIC8vIDEuIEEgQmxvYiBoYXMgYW4gYXNzb2NpYXRlZCBwYWNrYWdlIGRhdGEgYWxnb3JpdGhtLCBnaXZlblxuICAvLyAgICBieXRlcywgYSB0eXBlLCBhIG9wdGlvbmFsIG1pbWVUeXBlLCBhbmQgYSBvcHRpb25hbFxuICAvLyAgICBlbmNvZGluZ05hbWUsIHdoaWNoIHN3aXRjaGVzIG9uIHR5cGUgYW5kIHJ1bnMgdGhlXG4gIC8vICAgIGFzc29jaWF0ZWQgc3RlcHM6XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnRGF0YVVSTCc6IHtcbiAgICAgIC8vIDEuIFJldHVybiBieXRlcyBhcyBhIERhdGFVUkwgW1JGQzIzOTddIHN1YmplY3QgdG9cbiAgICAgIC8vICAgIHRoZSBjb25zaWRlcmF0aW9ucyBiZWxvdzpcbiAgICAgIC8vICAqIFVzZSBtaW1lVHlwZSBhcyBwYXJ0IG9mIHRoZSBEYXRhIFVSTCBpZiBpdCBpc1xuICAgICAgLy8gICAgYXZhaWxhYmxlIGluIGtlZXBpbmcgd2l0aCB0aGUgRGF0YSBVUkxcbiAgICAgIC8vICAgIHNwZWNpZmljYXRpb24gW1JGQzIzOTddLlxuICAgICAgLy8gICogSWYgbWltZVR5cGUgaXMgbm90IGF2YWlsYWJsZSByZXR1cm4gYSBEYXRhIFVSTFxuICAgICAgLy8gICAgd2l0aG91dCBhIG1lZGlhLXR5cGUuIFtSRkMyMzk3XS5cblxuICAgICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMyMzk3I3NlY3Rpb24tM1xuICAgICAgLy8gZGF0YXVybCAgICA6PSBcImRhdGE6XCIgWyBtZWRpYXR5cGUgXSBbIFwiO2Jhc2U2NFwiIF0gXCIsXCIgZGF0YVxuICAgICAgLy8gbWVkaWF0eXBlICA6PSBbIHR5cGUgXCIvXCIgc3VidHlwZSBdICooIFwiO1wiIHBhcmFtZXRlciApXG4gICAgICAvLyBkYXRhICAgICAgIDo9ICp1cmxjaGFyXG4gICAgICAvLyBwYXJhbWV0ZXIgIDo9IGF0dHJpYnV0ZSBcIj1cIiB2YWx1ZVxuICAgICAgbGV0IGRhdGFVUkwgPSAnZGF0YTonXG5cbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTUlNRVR5cGUobWltZVR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpXG5cbiAgICAgIGlmIChwYXJzZWQgIT09ICdmYWlsdXJlJykge1xuICAgICAgICBkYXRhVVJMICs9IHNlcmlhbGl6ZUFNaW1lVHlwZShwYXJzZWQpXG4gICAgICB9XG5cbiAgICAgIGRhdGFVUkwgKz0gJztiYXNlNjQsJ1xuXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoJ2xhdGluMScpXG5cbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgYnl0ZXMpIHtcbiAgICAgICAgZGF0YVVSTCArPSBidG9hKGRlY29kZXIud3JpdGUoY2h1bmspKVxuICAgICAgfVxuXG4gICAgICBkYXRhVVJMICs9IGJ0b2EoZGVjb2Rlci5lbmQoKSlcblxuICAgICAgcmV0dXJuIGRhdGFVUkxcbiAgICB9XG4gICAgY2FzZSAnVGV4dCc6IHtcbiAgICAgIC8vIDEuIExldCBlbmNvZGluZyBiZSBmYWlsdXJlXG4gICAgICBsZXQgZW5jb2RpbmcgPSAnZmFpbHVyZSdcblxuICAgICAgLy8gMi4gSWYgdGhlIGVuY29kaW5nTmFtZSBpcyBwcmVzZW50LCBzZXQgZW5jb2RpbmcgdG8gdGhlXG4gICAgICAvLyAgICByZXN1bHQgb2YgZ2V0dGluZyBhbiBlbmNvZGluZyBmcm9tIGVuY29kaW5nTmFtZS5cbiAgICAgIGlmIChlbmNvZGluZ05hbWUpIHtcbiAgICAgICAgZW5jb2RpbmcgPSBnZXRFbmNvZGluZyhlbmNvZGluZ05hbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIElmIGVuY29kaW5nIGlzIGZhaWx1cmUsIGFuZCBtaW1lVHlwZSBpcyBwcmVzZW50OlxuICAgICAgaWYgKGVuY29kaW5nID09PSAnZmFpbHVyZScgJiYgbWltZVR5cGUpIHtcbiAgICAgICAgLy8gMS4gTGV0IHR5cGUgYmUgdGhlIHJlc3VsdCBvZiBwYXJzZSBhIE1JTUUgdHlwZVxuICAgICAgICAvLyAgICBnaXZlbiBtaW1lVHlwZS5cbiAgICAgICAgY29uc3QgdHlwZSA9IHBhcnNlTUlNRVR5cGUobWltZVR5cGUpXG5cbiAgICAgICAgLy8gMi4gSWYgdHlwZSBpcyBub3QgZmFpbHVyZSwgc2V0IGVuY29kaW5nIHRvIHRoZSByZXN1bHRcbiAgICAgICAgLy8gICAgb2YgZ2V0dGluZyBhbiBlbmNvZGluZyBmcm9tIHR5cGXigJlzIHBhcmFtZXRlcnNbXCJjaGFyc2V0XCJdLlxuICAgICAgICBpZiAodHlwZSAhPT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgZW5jb2RpbmcgPSBnZXRFbmNvZGluZyh0eXBlLnBhcmFtZXRlcnMuZ2V0KCdjaGFyc2V0JykpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gNC4gSWYgZW5jb2RpbmcgaXMgZmFpbHVyZSwgdGhlbiBzZXQgZW5jb2RpbmcgdG8gVVRGLTguXG4gICAgICBpZiAoZW5jb2RpbmcgPT09ICdmYWlsdXJlJykge1xuICAgICAgICBlbmNvZGluZyA9ICdVVEYtOCdcbiAgICAgIH1cblxuICAgICAgLy8gNS4gRGVjb2RlIGJ5dGVzIHVzaW5nIGZhbGxiYWNrIGVuY29kaW5nIGVuY29kaW5nLCBhbmRcbiAgICAgIC8vICAgIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgcmV0dXJuIGRlY29kZShieXRlcywgZW5jb2RpbmcpXG4gICAgfVxuICAgIGNhc2UgJ0FycmF5QnVmZmVyJzoge1xuICAgICAgLy8gUmV0dXJuIGEgbmV3IEFycmF5QnVmZmVyIHdob3NlIGNvbnRlbnRzIGFyZSBieXRlcy5cbiAgICAgIGNvbnN0IHNlcXVlbmNlID0gY29tYmluZUJ5dGVTZXF1ZW5jZXMoYnl0ZXMpXG5cbiAgICAgIHJldHVybiBzZXF1ZW5jZS5idWZmZXJcbiAgICB9XG4gICAgY2FzZSAnQmluYXJ5U3RyaW5nJzoge1xuICAgICAgLy8gUmV0dXJuIGJ5dGVzIGFzIGEgYmluYXJ5IHN0cmluZywgaW4gd2hpY2ggZXZlcnkgYnl0ZVxuICAgICAgLy8gIGlzIHJlcHJlc2VudGVkIGJ5IGEgY29kZSB1bml0IG9mIGVxdWFsIHZhbHVlIFswLi4yNTVdLlxuICAgICAgbGV0IGJpbmFyeVN0cmluZyA9ICcnXG5cbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcignbGF0aW4xJylcblxuICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBieXRlcykge1xuICAgICAgICBiaW5hcnlTdHJpbmcgKz0gZGVjb2Rlci53cml0ZShjaHVuaylcbiAgICAgIH1cblxuICAgICAgYmluYXJ5U3RyaW5nICs9IGRlY29kZXIuZW5kKClcblxuICAgICAgcmV0dXJuIGJpbmFyeVN0cmluZ1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI2RlY29kZVxuICogQHBhcmFtIHtVaW50OEFycmF5W119IGlvUXVldWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICovXG5mdW5jdGlvbiBkZWNvZGUgKGlvUXVldWUsIGVuY29kaW5nKSB7XG4gIGNvbnN0IGJ5dGVzID0gY29tYmluZUJ5dGVTZXF1ZW5jZXMoaW9RdWV1ZSlcblxuICAvLyAxLiBMZXQgQk9NRW5jb2RpbmcgYmUgdGhlIHJlc3VsdCBvZiBCT00gc25pZmZpbmcgaW9RdWV1ZS5cbiAgY29uc3QgQk9NRW5jb2RpbmcgPSBCT01TbmlmZmluZyhieXRlcylcblxuICBsZXQgc2xpY2UgPSAwXG5cbiAgLy8gMi4gSWYgQk9NRW5jb2RpbmcgaXMgbm9uLW51bGw6XG4gIGlmIChCT01FbmNvZGluZyAhPT0gbnVsbCkge1xuICAgIC8vIDEuIFNldCBlbmNvZGluZyB0byBCT01FbmNvZGluZy5cbiAgICBlbmNvZGluZyA9IEJPTUVuY29kaW5nXG5cbiAgICAvLyAyLiBSZWFkIHRocmVlIGJ5dGVzIGZyb20gaW9RdWV1ZSwgaWYgQk9NRW5jb2RpbmcgaXNcbiAgICAvLyAgICBVVEYtODsgb3RoZXJ3aXNlIHJlYWQgdHdvIGJ5dGVzLlxuICAgIC8vICAgIChEbyBub3RoaW5nIHdpdGggdGhvc2UgYnl0ZXMuKVxuICAgIHNsaWNlID0gQk9NRW5jb2RpbmcgPT09ICdVVEYtOCcgPyAzIDogMlxuICB9XG5cbiAgLy8gMy4gUHJvY2VzcyBhIHF1ZXVlIHdpdGggYW4gaW5zdGFuY2Ugb2YgZW5jb2RpbmfigJlzXG4gIC8vICAgIGRlY29kZXIsIGlvUXVldWUsIG91dHB1dCwgYW5kIFwicmVwbGFjZW1lbnRcIi5cblxuICAvLyA0LiBSZXR1cm4gb3V0cHV0LlxuXG4gIGNvbnN0IHNsaWNlZCA9IGJ5dGVzLnNsaWNlKHNsaWNlKVxuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nKS5kZWNvZGUoc2xpY2VkKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI2JvbS1zbmlmZlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBpb1F1ZXVlXG4gKi9cbmZ1bmN0aW9uIEJPTVNuaWZmaW5nIChpb1F1ZXVlKSB7XG4gIC8vIDEuIExldCBCT00gYmUgdGhlIHJlc3VsdCBvZiBwZWVraW5nIDMgYnl0ZXMgZnJvbSBpb1F1ZXVlLFxuICAvLyAgICBjb252ZXJ0ZWQgdG8gYSBieXRlIHNlcXVlbmNlLlxuICBjb25zdCBbYSwgYiwgY10gPSBpb1F1ZXVlXG5cbiAgLy8gMi4gRm9yIGVhY2ggb2YgdGhlIHJvd3MgaW4gdGhlIHRhYmxlIGJlbG93LCBzdGFydGluZyB3aXRoXG4gIC8vICAgIHRoZSBmaXJzdCBvbmUgYW5kIGdvaW5nIGRvd24sIGlmIEJPTSBzdGFydHMgd2l0aCB0aGVcbiAgLy8gICAgYnl0ZXMgZ2l2ZW4gaW4gdGhlIGZpcnN0IGNvbHVtbiwgdGhlbiByZXR1cm4gdGhlXG4gIC8vICAgIGVuY29kaW5nIGdpdmVuIGluIHRoZSBjZWxsIGluIHRoZSBzZWNvbmQgY29sdW1uIG9mIHRoYXRcbiAgLy8gICAgcm93LiBPdGhlcndpc2UsIHJldHVybiBudWxsLlxuICBpZiAoYSA9PT0gMHhFRiAmJiBiID09PSAweEJCICYmIGMgPT09IDB4QkYpIHtcbiAgICByZXR1cm4gJ1VURi04J1xuICB9IGVsc2UgaWYgKGEgPT09IDB4RkUgJiYgYiA9PT0gMHhGRikge1xuICAgIHJldHVybiAnVVRGLTE2QkUnXG4gIH0gZWxzZSBpZiAoYSA9PT0gMHhGRiAmJiBiID09PSAweEZFKSB7XG4gICAgcmV0dXJuICdVVEYtMTZMRSdcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5W119IHNlcXVlbmNlc1xuICovXG5mdW5jdGlvbiBjb21iaW5lQnl0ZVNlcXVlbmNlcyAoc2VxdWVuY2VzKSB7XG4gIGNvbnN0IHNpemUgPSBzZXF1ZW5jZXMucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGEgKyBiLmJ5dGVMZW5ndGhcbiAgfSwgMClcblxuICBsZXQgb2Zmc2V0ID0gMFxuXG4gIHJldHVybiBzZXF1ZW5jZXMucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgYS5zZXQoYiwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBiLmJ5dGVMZW5ndGhcbiAgICByZXR1cm4gYVxuICB9LCBuZXcgVWludDhBcnJheShzaXplKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHJlYWRPcGVyYXRpb24sXG4gIGZpcmVBUHJvZ3Jlc3NFdmVudFxufVxuIl0sIm5hbWVzIjpbImtTdGF0ZSIsImtFcnJvciIsImtSZXN1bHQiLCJrQWJvcnRlZCIsImtMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkIiwicmVxdWlyZSIsIlByb2dyZXNzRXZlbnQiLCJnZXRFbmNvZGluZyIsIkRPTUV4Y2VwdGlvbiIsInNlcmlhbGl6ZUFNaW1lVHlwZSIsInBhcnNlTUlNRVR5cGUiLCJ0eXBlcyIsIlN0cmluZ0RlY29kZXIiLCJidG9hIiwic3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInJlYWRPcGVyYXRpb24iLCJmciIsImJsb2IiLCJ0eXBlIiwiZW5jb2RpbmdOYW1lIiwic3RyZWFtIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiYnl0ZXMiLCJjaHVua1Byb21pc2UiLCJyZWFkIiwiaXNGaXJzdENodW5rIiwiZG9uZSIsInZhbHVlIiwicXVldWVNaWNyb3Rhc2siLCJmaXJlQVByb2dyZXNzRXZlbnQiLCJpc1VpbnQ4QXJyYXkiLCJwdXNoIiwidW5kZWZpbmVkIiwiRGF0ZSIsIm5vdyIsInJlc3VsdCIsInBhY2thZ2VEYXRhIiwiZXJyb3IiLCJlIiwiZXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRpc3BhdGNoRXZlbnQiLCJtaW1lVHlwZSIsImRhdGFVUkwiLCJwYXJzZWQiLCJkZWNvZGVyIiwiY2h1bmsiLCJ3cml0ZSIsImVuZCIsImVuY29kaW5nIiwicGFyYW1ldGVycyIsImdldCIsImRlY29kZSIsInNlcXVlbmNlIiwiY29tYmluZUJ5dGVTZXF1ZW5jZXMiLCJidWZmZXIiLCJiaW5hcnlTdHJpbmciLCJpb1F1ZXVlIiwiQk9NRW5jb2RpbmciLCJCT01TbmlmZmluZyIsInNsaWNlIiwic2xpY2VkIiwiVGV4dERlY29kZXIiLCJhIiwiYiIsImMiLCJzZXF1ZW5jZXMiLCJzaXplIiwicmVkdWNlIiwiYnl0ZUxlbmd0aCIsIm9mZnNldCIsInNldCIsIlVpbnQ4QXJyYXkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/fileapi/util.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/global.js":
/*!***********************************************!*\
  !*** ../../node_modules/undici/lib/global.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// We include a version number for the Dispatcher API. In case of breaking changes,\n// this version number must be increased to avoid conflicts.\nconst globalDispatcher = Symbol.for(\"undici.globalDispatcher.1\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst Agent = __webpack_require__(/*! ./agent */ \"(rsc)/../../node_modules/undici/lib/agent.js\");\nif (getGlobalDispatcher() === undefined) {\n    setGlobalDispatcher(new Agent());\n}\nfunction setGlobalDispatcher(agent) {\n    if (!agent || typeof agent.dispatch !== \"function\") {\n        throw new InvalidArgumentError(\"Argument agent must implement Agent\");\n    }\n    Object.defineProperty(globalThis, globalDispatcher, {\n        value: agent,\n        writable: true,\n        enumerable: false,\n        configurable: false\n    });\n}\nfunction getGlobalDispatcher() {\n    return globalThis[globalDispatcher];\n}\nmodule.exports = {\n    setGlobalDispatcher,\n    getGlobalDispatcher\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZ2xvYmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsbUZBQW1GO0FBQ25GLDREQUE0RDtBQUM1RCxNQUFNQSxtQkFBbUJDLE9BQU9DLEdBQUcsQ0FBQztBQUNwQyxNQUFNLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3pDLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDO0FBRXRCLElBQUlFLDBCQUEwQkMsV0FBVztJQUN2Q0Msb0JBQW9CLElBQUlIO0FBQzFCO0FBRUEsU0FBU0csb0JBQXFCQyxLQUFLO0lBQ2pDLElBQUksQ0FBQ0EsU0FBUyxPQUFPQSxNQUFNQyxRQUFRLEtBQUssWUFBWTtRQUNsRCxNQUFNLElBQUlQLHFCQUFxQjtJQUNqQztJQUNBUSxPQUFPQyxjQUFjLENBQUNDLFlBQVliLGtCQUFrQjtRQUNsRGMsT0FBT0w7UUFDUE0sVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLGNBQWM7SUFDaEI7QUFDRjtBQUVBLFNBQVNYO0lBQ1AsT0FBT08sVUFBVSxDQUFDYixpQkFBaUI7QUFDckM7QUFFQWtCLE9BQU9DLE9BQU8sR0FBRztJQUNmWDtJQUNBRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9nbG9iYWwuanM/ZmE5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gV2UgaW5jbHVkZSBhIHZlcnNpb24gbnVtYmVyIGZvciB0aGUgRGlzcGF0Y2hlciBBUEkuIEluIGNhc2Ugb2YgYnJlYWtpbmcgY2hhbmdlcyxcbi8vIHRoaXMgdmVyc2lvbiBudW1iZXIgbXVzdCBiZSBpbmNyZWFzZWQgdG8gYXZvaWQgY29uZmxpY3RzLlxuY29uc3QgZ2xvYmFsRGlzcGF0Y2hlciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5nbG9iYWxEaXNwYXRjaGVyLjEnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQnKVxuXG5pZiAoZ2V0R2xvYmFsRGlzcGF0Y2hlcigpID09PSB1bmRlZmluZWQpIHtcbiAgc2V0R2xvYmFsRGlzcGF0Y2hlcihuZXcgQWdlbnQoKSlcbn1cblxuZnVuY3Rpb24gc2V0R2xvYmFsRGlzcGF0Y2hlciAoYWdlbnQpIHtcbiAgaWYgKCFhZ2VudCB8fCB0eXBlb2YgYWdlbnQuZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IGFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50JylcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgZ2xvYmFsRGlzcGF0Y2hlciwge1xuICAgIHZhbHVlOiBhZ2VudCxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldEdsb2JhbERpc3BhdGNoZXIgKCkge1xuICByZXR1cm4gZ2xvYmFsVGhpc1tnbG9iYWxEaXNwYXRjaGVyXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0R2xvYmFsRGlzcGF0Y2hlcixcbiAgZ2V0R2xvYmFsRGlzcGF0Y2hlclxufVxuIl0sIm5hbWVzIjpbImdsb2JhbERpc3BhdGNoZXIiLCJTeW1ib2wiLCJmb3IiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsInJlcXVpcmUiLCJBZ2VudCIsImdldEdsb2JhbERpc3BhdGNoZXIiLCJ1bmRlZmluZWQiLCJzZXRHbG9iYWxEaXNwYXRjaGVyIiwiYWdlbnQiLCJkaXNwYXRjaCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2xvYmFsVGhpcyIsInZhbHVlIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/global.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/handler/DecoratorHandler.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/undici/lib/handler/DecoratorHandler.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = class DecoratorHandler {\n    constructor(handler){\n        this.handler = handler;\n    }\n    onConnect(...args) {\n        return this.handler.onConnect(...args);\n    }\n    onError(...args) {\n        return this.handler.onError(...args);\n    }\n    onUpgrade(...args) {\n        return this.handler.onUpgrade(...args);\n    }\n    onHeaders(...args) {\n        return this.handler.onHeaders(...args);\n    }\n    onData(...args) {\n        return this.handler.onData(...args);\n    }\n    onComplete(...args) {\n        return this.handler.onComplete(...args);\n    }\n    onBodySent(...args) {\n        return this.handler.onBodySent(...args);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9EZWNvcmF0b3JIYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRyxNQUFNQztJQUNyQkMsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUVBQyxVQUFXLEdBQUdDLElBQUksRUFBRTtRQUNsQixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDQyxTQUFTLElBQUlDO0lBQ25DO0lBRUFDLFFBQVMsR0FBR0QsSUFBSSxFQUFFO1FBQ2hCLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNHLE9BQU8sSUFBSUQ7SUFDakM7SUFFQUUsVUFBVyxHQUFHRixJQUFJLEVBQUU7UUFDbEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ0ksU0FBUyxJQUFJRjtJQUNuQztJQUVBRyxVQUFXLEdBQUdILElBQUksRUFBRTtRQUNsQixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDSyxTQUFTLElBQUlIO0lBQ25DO0lBRUFJLE9BQVEsR0FBR0osSUFBSSxFQUFFO1FBQ2YsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ00sTUFBTSxJQUFJSjtJQUNoQztJQUVBSyxXQUFZLEdBQUdMLElBQUksRUFBRTtRQUNuQixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDTyxVQUFVLElBQUlMO0lBQ3BDO0lBRUFNLFdBQVksR0FBR04sSUFBSSxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNRLFVBQVUsSUFBSU47SUFDcEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9EZWNvcmF0b3JIYW5kbGVyLmpzPzc3YTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRGVjb3JhdG9ySGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChoYW5kbGVyKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlclxuICB9XG5cbiAgb25Db25uZWN0ICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkNvbm5lY3QoLi4uYXJncylcbiAgfVxuXG4gIG9uRXJyb3IgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRXJyb3IoLi4uYXJncylcbiAgfVxuXG4gIG9uVXBncmFkZSAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25VcGdyYWRlKC4uLmFyZ3MpXG4gIH1cblxuICBvbkhlYWRlcnMgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uSGVhZGVycyguLi5hcmdzKVxuICB9XG5cbiAgb25EYXRhICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkRhdGEoLi4uYXJncylcbiAgfVxuXG4gIG9uQ29tcGxldGUgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uQ29tcGxldGUoLi4uYXJncylcbiAgfVxuXG4gIG9uQm9keVNlbnQgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uQm9keVNlbnQoLi4uYXJncylcbiAgfVxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJEZWNvcmF0b3JIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJoYW5kbGVyIiwib25Db25uZWN0IiwiYXJncyIsIm9uRXJyb3IiLCJvblVwZ3JhZGUiLCJvbkhlYWRlcnMiLCJvbkRhdGEiLCJvbkNvbXBsZXRlIiwib25Cb2R5U2VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/handler/DecoratorHandler.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/handler/RedirectHandler.js":
/*!****************************************************************!*\
  !*** ../../node_modules/undici/lib/handler/RedirectHandler.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst EE = __webpack_require__(/*! events */ \"events\");\nconst redirectableStatusCodes = [\n    300,\n    301,\n    302,\n    303,\n    307,\n    308\n];\nconst kBody = Symbol(\"body\");\nclass BodyAsyncIterable {\n    constructor(body){\n        this[kBody] = body;\n        this[kBodyUsed] = false;\n    }\n    async *[Symbol.asyncIterator]() {\n        assert(!this[kBodyUsed], \"disturbed\");\n        this[kBodyUsed] = true;\n        yield* this[kBody];\n    }\n}\nclass RedirectHandler {\n    constructor(dispatch, maxRedirections, opts, handler){\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n            throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        util.validateHandler(handler, opts.method, opts.upgrade);\n        this.dispatch = dispatch;\n        this.location = null;\n        this.abort = null;\n        this.opts = {\n            ...opts,\n            maxRedirections: 0\n        } // opts must be a copy\n        ;\n        this.maxRedirections = maxRedirections;\n        this.handler = handler;\n        this.history = [];\n        if (util.isStream(this.opts.body)) {\n            // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n            // so that it can be dispatched again?\n            // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n            if (util.bodyLength(this.opts.body) === 0) {\n                this.opts.body.on(\"data\", function() {\n                    assert(false);\n                });\n            }\n            if (typeof this.opts.body.readableDidRead !== \"boolean\") {\n                this.opts.body[kBodyUsed] = false;\n                EE.prototype.on.call(this.opts.body, \"data\", function() {\n                    this[kBodyUsed] = true;\n                });\n            }\n        } else if (this.opts.body && typeof this.opts.body.pipeTo === \"function\") {\n            // TODO (fix): We can't access ReadableStream internal state\n            // to determine whether or not it has been disturbed. This is just\n            // a workaround.\n            this.opts.body = new BodyAsyncIterable(this.opts.body);\n        } else if (this.opts.body && typeof this.opts.body !== \"string\" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {\n            // TODO: Should we allow re-using iterable if !this.opts.idempotent\n            // or through some other flag?\n            this.opts.body = new BodyAsyncIterable(this.opts.body);\n        }\n    }\n    onConnect(abort) {\n        this.abort = abort;\n        this.handler.onConnect(abort, {\n            history: this.history\n        });\n    }\n    onUpgrade(statusCode, headers, socket) {\n        this.handler.onUpgrade(statusCode, headers, socket);\n    }\n    onError(error) {\n        this.handler.onError(error);\n    }\n    onHeaders(statusCode, headers, resume, statusText) {\n        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);\n        if (this.opts.origin) {\n            this.history.push(new URL(this.opts.path, this.opts.origin));\n        }\n        if (!this.location) {\n            return this.handler.onHeaders(statusCode, headers, resume, statusText);\n        }\n        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));\n        const path = search ? `${pathname}${search}` : pathname;\n        // Remove headers referring to the original URL.\n        // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n        // https://tools.ietf.org/html/rfc7231#section-6.4\n        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);\n        this.opts.path = path;\n        this.opts.origin = origin;\n        this.opts.maxRedirections = 0;\n        this.opts.query = null;\n        // https://tools.ietf.org/html/rfc7231#section-6.4.4\n        // In case of HTTP 303, always replace method to be either HEAD or GET\n        if (statusCode === 303 && this.opts.method !== \"HEAD\") {\n            this.opts.method = \"GET\";\n            this.opts.body = null;\n        }\n    }\n    onData(chunk) {\n        if (this.location) {\n        /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it is assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitily chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */ } else {\n            return this.handler.onData(chunk);\n        }\n    }\n    onComplete(trailers) {\n        if (this.location) {\n            /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed informations.\n      */ this.location = null;\n            this.abort = null;\n            this.dispatch(this.opts, this);\n        } else {\n            this.handler.onComplete(trailers);\n        }\n    }\n    onBodySent(chunk) {\n        if (this.handler.onBodySent) {\n            this.handler.onBodySent(chunk);\n        }\n    }\n}\nfunction parseLocation(statusCode, headers) {\n    if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n        return null;\n    }\n    for(let i = 0; i < headers.length; i += 2){\n        if (headers[i].toString().toLowerCase() === \"location\") {\n            return headers[i + 1];\n        }\n    }\n}\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader(header, removeContent, unknownOrigin) {\n    return header.length === 4 && header.toString().toLowerCase() === \"host\" || removeContent && header.toString().toLowerCase().indexOf(\"content-\") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === \"authorization\" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === \"cookie\";\n}\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders(headers, removeContent, unknownOrigin) {\n    const ret = [];\n    if (Array.isArray(headers)) {\n        for(let i = 0; i < headers.length; i += 2){\n            if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n                ret.push(headers[i], headers[i + 1]);\n            }\n        }\n    } else if (headers && typeof headers === \"object\") {\n        for (const key of Object.keys(headers)){\n            if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n                ret.push(key, headers[key]);\n            }\n        }\n    } else {\n        assert(headers == null, \"headers must be an object or an array\");\n    }\n    return ret;\n}\nmodule.exports = RedirectHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9SZWRpcmVjdEhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVDLFNBQVMsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUM5QixNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVHLG9CQUFvQixFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQ3pDLE1BQU1JLEtBQUtKLG1CQUFPQSxDQUFDO0FBRW5CLE1BQU1LLDBCQUEwQjtJQUFDO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztDQUFJO0FBRTlELE1BQU1DLFFBQVFDLE9BQU87QUFFckIsTUFBTUM7SUFDSkMsWUFBYUMsSUFBSSxDQUFFO1FBQ2pCLElBQUksQ0FBQ0osTUFBTSxHQUFHSTtRQUNkLElBQUksQ0FBQ1QsVUFBVSxHQUFHO0lBQ3BCO0lBRUEsT0FBUSxDQUFDTSxPQUFPSSxhQUFhLENBQUMsR0FBSTtRQUNoQ1QsT0FBTyxDQUFDLElBQUksQ0FBQ0QsVUFBVSxFQUFFO1FBQ3pCLElBQUksQ0FBQ0EsVUFBVSxHQUFHO1FBQ2xCLE9BQVEsSUFBSSxDQUFDSyxNQUFNO0lBQ3JCO0FBQ0Y7QUFFQSxNQUFNTTtJQUNKSCxZQUFhSSxRQUFRLEVBQUVDLGVBQWUsRUFBRUMsSUFBSSxFQUFFQyxPQUFPLENBQUU7UUFDckQsSUFBSUYsbUJBQW1CLFFBQVMsRUFBQ0csT0FBT0MsU0FBUyxDQUFDSixvQkFBb0JBLGtCQUFrQixJQUFJO1lBQzFGLE1BQU0sSUFBSVgscUJBQXFCO1FBQ2pDO1FBRUFKLEtBQUtvQixlQUFlLENBQUNILFNBQVNELEtBQUtLLE1BQU0sRUFBRUwsS0FBS00sT0FBTztRQUV2RCxJQUFJLENBQUNSLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDUyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFD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ZXMvdW5kaWNpL2xpYi9oYW5kbGVyL1JlZGlyZWN0SGFuZGxlci5qcz8wNGQ2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsga0JvZHlVc2VkIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJylcblxuY29uc3QgcmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMgPSBbMzAwLCAzMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuY29uc3Qga0JvZHkgPSBTeW1ib2woJ2JvZHknKVxuXG5jbGFzcyBCb2R5QXN5bmNJdGVyYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChib2R5KSB7XG4gICAgdGhpc1trQm9keV0gPSBib2R5XG4gICAgdGhpc1trQm9keVVzZWRdID0gZmFsc2VcbiAgfVxuXG4gIGFzeW5jICogW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAoKSB7XG4gICAgYXNzZXJ0KCF0aGlzW2tCb2R5VXNlZF0sICdkaXN0dXJiZWQnKVxuICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICB5aWVsZCAqIHRoaXNba0JvZHldXG4gIH1cbn1cblxuY2xhc3MgUmVkaXJlY3RIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGRpc3BhdGNoLCBtYXhSZWRpcmVjdGlvbnMsIG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAobWF4UmVkaXJlY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIHV0aWwudmFsaWRhdGVIYW5kbGVyKGhhbmRsZXIsIG9wdHMubWV0aG9kLCBvcHRzLnVwZ3JhZGUpXG5cbiAgICB0aGlzLmRpc3BhdGNoID0gZGlzcGF0Y2hcbiAgICB0aGlzLmxvY2F0aW9uID0gbnVsbFxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBtYXhSZWRpcmVjdGlvbnM6IDAgfSAvLyBvcHRzIG11c3QgYmUgYSBjb3B5XG4gICAgdGhpcy5tYXhSZWRpcmVjdGlvbnMgPSBtYXhSZWRpcmVjdGlvbnNcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyXG4gICAgdGhpcy5oaXN0b3J5ID0gW11cblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKHRoaXMub3B0cy5ib2R5KSkge1xuICAgICAgLy8gVE9ETyAoZml4KTogUHJvdmlkZSBzb21lIHdheSBmb3IgdGhlIHVzZXIgdG8gY2FjaGUgdGhlIGZpbGUgdG8gZS5nLiAvdG1wXG4gICAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGFnYWluP1xuICAgICAgLy8gVE9ETyAoZml4KTogRG8gd2UgbmVlZCAxMDAtZXhwZWN0IHN1cHBvcnQgdG8gcHJvdmlkZSBhIHdheSB0byBkbyB0aGlzIHByb3Blcmx5P1xuICAgICAgaWYgKHV0aWwuYm9keUxlbmd0aCh0aGlzLm9wdHMuYm9keSkgPT09IDApIHtcbiAgICAgICAgdGhpcy5vcHRzLmJvZHlcbiAgICAgICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UpXG4gICAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMuYm9keS5yZWFkYWJsZURpZFJlYWQgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLm9wdHMuYm9keVtrQm9keVVzZWRdID0gZmFsc2VcbiAgICAgICAgRUUucHJvdG90eXBlLm9uLmNhbGwodGhpcy5vcHRzLmJvZHksICdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy5ib2R5ICYmIHR5cGVvZiB0aGlzLm9wdHMuYm9keS5waXBlVG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRPRE8gKGZpeCk6IFdlIGNhbid0IGFjY2VzcyBSZWFkYWJsZVN0cmVhbSBpbnRlcm5hbCBzdGF0ZVxuICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGl0IGhhcyBiZWVuIGRpc3R1cmJlZC4gVGhpcyBpcyBqdXN0XG4gICAgICAvLyBhIHdvcmthcm91bmQuXG4gICAgICB0aGlzLm9wdHMuYm9keSA9IG5ldyBCb2R5QXN5bmNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSlcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5vcHRzLmJvZHkgJiZcbiAgICAgIHR5cGVvZiB0aGlzLm9wdHMuYm9keSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICFBcnJheUJ1ZmZlci5pc1ZpZXcodGhpcy5vcHRzLmJvZHkpICYmXG4gICAgICB1dGlsLmlzSXRlcmFibGUodGhpcy5vcHRzLmJvZHkpXG4gICAgKSB7XG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgYWxsb3cgcmUtdXNpbmcgaXRlcmFibGUgaWYgIXRoaXMub3B0cy5pZGVtcG90ZW50XG4gICAgICAvLyBvciB0aHJvdWdoIHNvbWUgb3RoZXIgZmxhZz9cbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQpIHtcbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmhhbmRsZXIub25Db25uZWN0KGFib3J0LCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSB9KVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICB0aGlzLmhhbmRsZXIub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycm9yKSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uRXJyb3IoZXJyb3IpXG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgIHRoaXMubG9jYXRpb24gPSB0aGlzLmhpc3RvcnkubGVuZ3RoID49IHRoaXMubWF4UmVkaXJlY3Rpb25zIHx8IHV0aWwuaXNEaXN0dXJiZWQodGhpcy5vcHRzLmJvZHkpXG4gICAgICA/IG51bGxcbiAgICAgIDogcGFyc2VMb2NhdGlvbihzdGF0dXNDb2RlLCBoZWFkZXJzKVxuXG4gICAgaWYgKHRoaXMub3B0cy5vcmlnaW4pIHtcbiAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKG5ldyBVUkwodGhpcy5vcHRzLnBhdGgsIHRoaXMub3B0cy5vcmlnaW4pKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KVxuICAgIH1cblxuICAgIGNvbnN0IHsgb3JpZ2luLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1dGlsLnBhcnNlVVJMKG5ldyBVUkwodGhpcy5sb2NhdGlvbiwgdGhpcy5vcHRzLm9yaWdpbiAmJiBuZXcgVVJMKHRoaXMub3B0cy5wYXRoLCB0aGlzLm9wdHMub3JpZ2luKSkpXG4gICAgY29uc3QgcGF0aCA9IHNlYXJjaCA/IGAke3BhdGhuYW1lfSR7c2VhcmNofWAgOiBwYXRobmFtZVxuXG4gICAgLy8gUmVtb3ZlIGhlYWRlcnMgcmVmZXJyaW5nIHRvIHRoZSBvcmlnaW5hbCBVUkwuXG4gICAgLy8gQnkgZGVmYXVsdCBpdCBpcyBIb3N0IG9ubHksIHVubGVzcyBpdCdzIGEgMzAzIChzZWUgYmVsb3cpLCB3aGljaCByZW1vdmVzIGFsc28gYWxsIENvbnRlbnQtKiBoZWFkZXJzLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG4gICAgdGhpcy5vcHRzLmhlYWRlcnMgPSBjbGVhblJlcXVlc3RIZWFkZXJzKHRoaXMub3B0cy5oZWFkZXJzLCBzdGF0dXNDb2RlID09PSAzMDMsIHRoaXMub3B0cy5vcmlnaW4gIT09IG9yaWdpbilcbiAgICB0aGlzLm9wdHMucGF0aCA9IHBhdGhcbiAgICB0aGlzLm9wdHMub3JpZ2luID0gb3JpZ2luXG4gICAgdGhpcy5vcHRzLm1heFJlZGlyZWN0aW9ucyA9IDBcbiAgICB0aGlzLm9wdHMucXVlcnkgPSBudWxsXG5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNC40XG4gICAgLy8gSW4gY2FzZSBvZiBIVFRQIDMwMywgYWx3YXlzIHJlcGxhY2UgbWV0aG9kIHRvIGJlIGVpdGhlciBIRUFEIG9yIEdFVFxuICAgIGlmIChzdGF0dXNDb2RlID09PSAzMDMgJiYgdGhpcy5vcHRzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLm9wdHMubWV0aG9kID0gJ0dFVCdcbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgICAgLypcbiAgICAgICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcblxuICAgICAgICBUTERSOiB1bmRpY2kgYWx3YXlzIGlnbm9yZXMgM3h4IHJlc3BvbnNlIGJvZGllcy5cblxuICAgICAgICBSZWRpcmVjdGlvbiBpcyB1c2VkIHRvIHNlcnZlIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgZnJvbSBhbm90aGVyIFVSTCwgc28gaXQgaXMgYXNzdW1lcyB0aGF0XG4gICAgICAgIG5vIGJvZHkgaXMgZ2VuZXJhdGVkIChhbmQgdGh1cyBjYW4gYmUgaWdub3JlZCkuIEV2ZW4gdGhvdWdoIGdlbmVyYXRpbmcgYSBib2R5IGlzIG5vdCBwcm9oaWJpdGVkLlxuXG4gICAgICAgIEZvciBzdGF0dXMgMzAxLCAzMDIsIDMwMywgMzA3IGFuZCAzMDggKHRoZSBsYXR0ZXIgZnJvbSBSRkMgNzIzOCksIHRoZSBzcGVjcyBtZW50aW9uIHRoYXQgdGhlIGJvZHkgdXN1YWxseVxuICAgICAgICAod2hpY2ggbWVhbnMgaXQncyBvcHRpb25hbCBhbmQgbm90IG1hbmRhdGVkKSBjb250YWluIGp1c3QgYW4gaHlwZXJsaW5rIHRvIHRoZSB2YWx1ZSBvZlxuICAgICAgICB0aGUgTG9jYXRpb24gcmVzcG9uc2UgaGVhZGVyLCBzbyB0aGUgYm9keSBjYW4gYmUgaWdub3JlZCBzYWZlbHkuXG5cbiAgICAgICAgRm9yIHN0YXR1cyAzMDAsIHdoaWNoIGlzIFwiTXVsdGlwbGUgQ2hvaWNlc1wiLCB0aGUgc3BlYyBtZW50aW9ucyBib3RoIGdlbmVyYXRpbmcgYSBMb2NhdGlvblxuICAgICAgICByZXNwb25zZSBoZWFkZXIgQU5EIGEgcmVzcG9uc2UgYm9keSB3aXRoIHRoZSBvdGhlciBwb3NzaWJsZSBsb2NhdGlvbiB0byBmb2xsb3cuXG4gICAgICAgIFNpbmNlIHRoZSBzcGVjIGV4cGxpY2l0aWx5IGNob29zZXMgbm90IHRvIHNwZWNpZnkgYSBmb3JtYXQgZm9yIHN1Y2ggYm9keSBhbmQgbGVhdmUgaXQgdG9cbiAgICAgICAgc2VydmVycyBhbmQgYnJvd3NlcnMgaW1wbGVtZW50b3JzLCB3ZSBpZ25vcmUgdGhlIGJvZHkgYXMgdGhlcmUgaXMgbm8gc3BlY2lmaWVkIHdheSB0byBldmVudHVhbGx5IHBhcnNlIGl0LlxuICAgICAgKi9cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkRhdGEoY2h1bmspXG4gICAgfVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgICAgLypcbiAgICAgICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcblxuICAgICAgICBUTERSOiB1bmRpY2kgYWx3YXlzIGlnbm9yZXMgM3h4IHJlc3BvbnNlIHRyYWlsZXJzIGFzIHRoZXkgYXJlIG5vdCBleHBlY3RlZCBpbiBjYXNlIG9mIHJlZGlyZWN0aW9uc1xuICAgICAgICBhbmQgbmVpdGhlciBhcmUgdXNlZnVsIGlmIHByZXNlbnQuXG5cbiAgICAgICAgU2VlIGNvbW1lbnQgb24gb25EYXRhIG1ldGhvZCBhYm92ZSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbnMuXG4gICAgICAqL1xuXG4gICAgICB0aGlzLmxvY2F0aW9uID0gbnVsbFxuICAgICAgdGhpcy5hYm9ydCA9IG51bGxcblxuICAgICAgdGhpcy5kaXNwYXRjaCh0aGlzLm9wdHMsIHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlci5vbkNvbXBsZXRlKHRyYWlsZXJzKVxuICAgIH1cbiAgfVxuXG4gIG9uQm9keVNlbnQgKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlci5vbkJvZHlTZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25Cb2R5U2VudChjaHVuaylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VMb2NhdGlvbiAoc3RhdHVzQ29kZSwgaGVhZGVycykge1xuICBpZiAocmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMuaW5kZXhPZihzdGF0dXNDb2RlKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaWYgKGhlYWRlcnNbaV0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAnbG9jYXRpb24nKSB7XG4gICAgICByZXR1cm4gaGVhZGVyc1tpICsgMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjQuNFxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlSGVhZGVyIChoZWFkZXIsIHJlbW92ZUNvbnRlbnQsIHVua25vd25PcmlnaW4pIHtcbiAgcmV0dXJuIChcbiAgICAoaGVhZGVyLmxlbmd0aCA9PT0gNCAmJiBoZWFkZXIudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAnaG9zdCcpIHx8XG4gICAgKHJlbW92ZUNvbnRlbnQgJiYgaGVhZGVyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjb250ZW50LScpID09PSAwKSB8fFxuICAgICh1bmtub3duT3JpZ2luICYmIGhlYWRlci5sZW5ndGggPT09IDEzICYmIGhlYWRlci50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09ICdhdXRob3JpemF0aW9uJykgfHxcbiAgICAodW5rbm93bk9yaWdpbiAmJiBoZWFkZXIubGVuZ3RoID09PSA2ICYmIGhlYWRlci50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09ICdjb29raWUnKVxuICApXG59XG5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG5mdW5jdGlvbiBjbGVhblJlcXVlc3RIZWFkZXJzIChoZWFkZXJzLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSB7XG4gIGNvbnN0IHJldCA9IFtdXG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAoIXNob3VsZFJlbW92ZUhlYWRlcihoZWFkZXJzW2ldLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSkge1xuICAgICAgICByZXQucHVzaChoZWFkZXJzW2ldLCBoZWFkZXJzW2kgKyAxXSlcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgaWYgKCFzaG91bGRSZW1vdmVIZWFkZXIoa2V5LCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSkge1xuICAgICAgICByZXQucHVzaChrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGhlYWRlcnMgPT0gbnVsbCwgJ2hlYWRlcnMgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXknKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWRpcmVjdEhhbmRsZXJcbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsImtCb2R5VXNlZCIsImFzc2VydCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiRUUiLCJyZWRpcmVjdGFibGVTdGF0dXNDb2RlcyIsImtCb2R5IiwiU3ltYm9sIiwiQm9keUFzeW5jSXRlcmFibGUiLCJjb25zdHJ1Y3RvciIsImJvZHkiLCJhc3luY0l0ZXJhdG9yIiwiUmVkaXJlY3RIYW5kbGVyIiwiZGlzcGF0Y2giLCJtYXhSZWRpcmVjdGlvbnMiLCJvcHRzIiwiaGFuZGxlciIsIk51bWJlciIsImlzSW50ZWdlciIsInZhbGlkYXRlSGFuZGxlciIsIm1ldGhvZCIsInVwZ3JhZGUiLCJsb2NhdGlvbiIsImFib3J0IiwiaGlzdG9yeSIsImlzU3RyZWFtIiwiYm9keUxlbmd0aCIsIm9uIiwicmVhZGFibGVEaWRSZWFkIiwicHJvdG90eXBlIiwiY2FsbCIsInBpcGVUbyIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiaXNJdGVyYWJsZSIsIm9uQ29ubmVjdCIsIm9uVXBncmFkZSIsInN0YXR1c0NvZGUiLCJoZWFkZXJzIiwic29ja2V0Iiwib25FcnJvciIsImVycm9yIiwib25IZWFkZXJzIiwicmVzdW1lIiwic3RhdHVzVGV4dCIsImxlbmd0aCIsImlzRGlzdHVyYmVkIiwicGFyc2VMb2NhdGlvbiIsIm9yaWdpbiIsInB1c2giLCJVUkwiLCJwYXRoIiwicGF0aG5hbWUiLCJzZWFyY2giLCJwYXJzZVVSTCIsImNsZWFuUmVxdWVzdEhlYWRlcnMiLCJxdWVyeSIsIm9uRGF0YSIsImNodW5rIiwib25Db21wbGV0ZSIsInRyYWlsZXJzIiwib25Cb2R5U2VudCIsImluZGV4T2YiLCJpIiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInNob3VsZFJlbW92ZUhlYWRlciIsImhlYWRlciIsInJlbW92ZUNvbnRlbnQiLCJ1bmtub3duT3JpZ2luIiwicmV0IiwiQXJyYXkiLCJpc0FycmF5Iiwia2V5IiwiT2JqZWN0Iiwia2V5cyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/handler/RedirectHandler.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/interceptor/redirectInterceptor.js":
/*!************************************************************************!*\
  !*** ../../node_modules/undici/lib/interceptor/redirectInterceptor.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst RedirectHandler = __webpack_require__(/*! ../handler/RedirectHandler */ \"(rsc)/../../node_modules/undici/lib/handler/RedirectHandler.js\");\nfunction createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {\n    return (dispatch)=>{\n        return function Intercept(opts, handler) {\n            const { maxRedirections = defaultMaxRedirections } = opts;\n            if (!maxRedirections) {\n                return dispatch(opts, handler);\n            }\n            const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);\n            opts = {\n                ...opts,\n                maxRedirections: 0\n            } // Stop sub dispatcher from also redirecting.\n            ;\n            return dispatch(opts, redirectHandler);\n        };\n    };\n}\nmodule.exports = createRedirectInterceptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3RJbnRlcmNlcHRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGtCQUFrQkMsbUJBQU9BLENBQUM7QUFFaEMsU0FBU0MsMEJBQTJCLEVBQUVDLGlCQUFpQkMsc0JBQXNCLEVBQUU7SUFDN0UsT0FBTyxDQUFDQztRQUNOLE9BQU8sU0FBU0MsVUFBV0MsSUFBSSxFQUFFQyxPQUFPO1lBQ3RDLE1BQU0sRUFBRUwsa0JBQWtCQyxzQkFBc0IsRUFBRSxHQUFHRztZQUVyRCxJQUFJLENBQUNKLGlCQUFpQjtnQkFDcEIsT0FBT0UsU0FBU0UsTUFBTUM7WUFDeEI7WUFFQSxNQUFNQyxrQkFBa0IsSUFBSVQsZ0JBQWdCSyxVQUFVRixpQkFBaUJJLE1BQU1DO1lBQzdFRCxPQUFPO2dCQUFFLEdBQUdBLElBQUk7Z0JBQUVKLGlCQUFpQjtZQUFFLEVBQUUsNkNBQTZDOztZQUNwRixPQUFPRSxTQUFTRSxNQUFNRTtRQUN4QjtJQUNGO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHVCIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3RJbnRlcmNlcHRvci5qcz8yNWI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSZWRpcmVjdEhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL1JlZGlyZWN0SGFuZGxlcicpXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgKHsgbWF4UmVkaXJlY3Rpb25zOiBkZWZhdWx0TWF4UmVkaXJlY3Rpb25zIH0pIHtcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBJbnRlcmNlcHQgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IHsgbWF4UmVkaXJlY3Rpb25zID0gZGVmYXVsdE1heFJlZGlyZWN0aW9ucyB9ID0gb3B0c1xuXG4gICAgICBpZiAoIW1heFJlZGlyZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVkaXJlY3RIYW5kbGVyID0gbmV3IFJlZGlyZWN0SGFuZGxlcihkaXNwYXRjaCwgbWF4UmVkaXJlY3Rpb25zLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgb3B0cyA9IHsgLi4ub3B0cywgbWF4UmVkaXJlY3Rpb25zOiAwIH0gLy8gU3RvcCBzdWIgZGlzcGF0Y2hlciBmcm9tIGFsc28gcmVkaXJlY3RpbmcuXG4gICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgcmVkaXJlY3RIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3JcbiJdLCJuYW1lcyI6WyJSZWRpcmVjdEhhbmRsZXIiLCJyZXF1aXJlIiwiY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciIsIm1heFJlZGlyZWN0aW9ucyIsImRlZmF1bHRNYXhSZWRpcmVjdGlvbnMiLCJkaXNwYXRjaCIsIkludGVyY2VwdCIsIm9wdHMiLCJoYW5kbGVyIiwicmVkaXJlY3RIYW5kbGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/interceptor/redirectInterceptor.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/llhttp/constants.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/llhttp/constants.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/undici/lib/llhttp/utils.js\");\n// C headers\nvar ERROR;\n(function(ERROR) {\n    ERROR[ERROR[\"OK\"] = 0] = \"OK\";\n    ERROR[ERROR[\"INTERNAL\"] = 1] = \"INTERNAL\";\n    ERROR[ERROR[\"STRICT\"] = 2] = \"STRICT\";\n    ERROR[ERROR[\"LF_EXPECTED\"] = 3] = \"LF_EXPECTED\";\n    ERROR[ERROR[\"UNEXPECTED_CONTENT_LENGTH\"] = 4] = \"UNEXPECTED_CONTENT_LENGTH\";\n    ERROR[ERROR[\"CLOSED_CONNECTION\"] = 5] = \"CLOSED_CONNECTION\";\n    ERROR[ERROR[\"INVALID_METHOD\"] = 6] = \"INVALID_METHOD\";\n    ERROR[ERROR[\"INVALID_URL\"] = 7] = \"INVALID_URL\";\n    ERROR[ERROR[\"INVALID_CONSTANT\"] = 8] = \"INVALID_CONSTANT\";\n    ERROR[ERROR[\"INVALID_VERSION\"] = 9] = \"INVALID_VERSION\";\n    ERROR[ERROR[\"INVALID_HEADER_TOKEN\"] = 10] = \"INVALID_HEADER_TOKEN\";\n    ERROR[ERROR[\"INVALID_CONTENT_LENGTH\"] = 11] = \"INVALID_CONTENT_LENGTH\";\n    ERROR[ERROR[\"INVALID_CHUNK_SIZE\"] = 12] = \"INVALID_CHUNK_SIZE\";\n    ERROR[ERROR[\"INVALID_STATUS\"] = 13] = \"INVALID_STATUS\";\n    ERROR[ERROR[\"INVALID_EOF_STATE\"] = 14] = \"INVALID_EOF_STATE\";\n    ERROR[ERROR[\"INVALID_TRANSFER_ENCODING\"] = 15] = \"INVALID_TRANSFER_ENCODING\";\n    ERROR[ERROR[\"CB_MESSAGE_BEGIN\"] = 16] = \"CB_MESSAGE_BEGIN\";\n    ERROR[ERROR[\"CB_HEADERS_COMPLETE\"] = 17] = \"CB_HEADERS_COMPLETE\";\n    ERROR[ERROR[\"CB_MESSAGE_COMPLETE\"] = 18] = \"CB_MESSAGE_COMPLETE\";\n    ERROR[ERROR[\"CB_CHUNK_HEADER\"] = 19] = \"CB_CHUNK_HEADER\";\n    ERROR[ERROR[\"CB_CHUNK_COMPLETE\"] = 20] = \"CB_CHUNK_COMPLETE\";\n    ERROR[ERROR[\"PAUSED\"] = 21] = \"PAUSED\";\n    ERROR[ERROR[\"PAUSED_UPGRADE\"] = 22] = \"PAUSED_UPGRADE\";\n    ERROR[ERROR[\"PAUSED_H2_UPGRADE\"] = 23] = \"PAUSED_H2_UPGRADE\";\n    ERROR[ERROR[\"USER\"] = 24] = \"USER\";\n})(ERROR = exports.ERROR || (exports.ERROR = {}));\nvar TYPE;\n(function(TYPE) {\n    TYPE[TYPE[\"BOTH\"] = 0] = \"BOTH\";\n    TYPE[TYPE[\"REQUEST\"] = 1] = \"REQUEST\";\n    TYPE[TYPE[\"RESPONSE\"] = 2] = \"RESPONSE\";\n})(TYPE = exports.TYPE || (exports.TYPE = {}));\nvar FLAGS;\n(function(FLAGS) {\n    FLAGS[FLAGS[\"CONNECTION_KEEP_ALIVE\"] = 1] = \"CONNECTION_KEEP_ALIVE\";\n    FLAGS[FLAGS[\"CONNECTION_CLOSE\"] = 2] = \"CONNECTION_CLOSE\";\n    FLAGS[FLAGS[\"CONNECTION_UPGRADE\"] = 4] = \"CONNECTION_UPGRADE\";\n    FLAGS[FLAGS[\"CHUNKED\"] = 8] = \"CHUNKED\";\n    FLAGS[FLAGS[\"UPGRADE\"] = 16] = \"UPGRADE\";\n    FLAGS[FLAGS[\"CONTENT_LENGTH\"] = 32] = \"CONTENT_LENGTH\";\n    FLAGS[FLAGS[\"SKIPBODY\"] = 64] = \"SKIPBODY\";\n    FLAGS[FLAGS[\"TRAILING\"] = 128] = \"TRAILING\";\n    // 1 << 8 is unused\n    FLAGS[FLAGS[\"TRANSFER_ENCODING\"] = 512] = \"TRANSFER_ENCODING\";\n})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\nvar LENIENT_FLAGS;\n(function(LENIENT_FLAGS) {\n    LENIENT_FLAGS[LENIENT_FLAGS[\"HEADERS\"] = 1] = \"HEADERS\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"CHUNKED_LENGTH\"] = 2] = \"CHUNKED_LENGTH\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"KEEP_ALIVE\"] = 4] = \"KEEP_ALIVE\";\n})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));\nvar METHODS;\n(function(METHODS) {\n    METHODS[METHODS[\"DELETE\"] = 0] = \"DELETE\";\n    METHODS[METHODS[\"GET\"] = 1] = \"GET\";\n    METHODS[METHODS[\"HEAD\"] = 2] = \"HEAD\";\n    METHODS[METHODS[\"POST\"] = 3] = \"POST\";\n    METHODS[METHODS[\"PUT\"] = 4] = \"PUT\";\n    /* pathological */ METHODS[METHODS[\"CONNECT\"] = 5] = \"CONNECT\";\n    METHODS[METHODS[\"OPTIONS\"] = 6] = \"OPTIONS\";\n    METHODS[METHODS[\"TRACE\"] = 7] = \"TRACE\";\n    /* WebDAV */ METHODS[METHODS[\"COPY\"] = 8] = \"COPY\";\n    METHODS[METHODS[\"LOCK\"] = 9] = \"LOCK\";\n    METHODS[METHODS[\"MKCOL\"] = 10] = \"MKCOL\";\n    METHODS[METHODS[\"MOVE\"] = 11] = \"MOVE\";\n    METHODS[METHODS[\"PROPFIND\"] = 12] = \"PROPFIND\";\n    METHODS[METHODS[\"PROPPATCH\"] = 13] = \"PROPPATCH\";\n    METHODS[METHODS[\"SEARCH\"] = 14] = \"SEARCH\";\n    METHODS[METHODS[\"UNLOCK\"] = 15] = \"UNLOCK\";\n    METHODS[METHODS[\"BIND\"] = 16] = \"BIND\";\n    METHODS[METHODS[\"REBIND\"] = 17] = \"REBIND\";\n    METHODS[METHODS[\"UNBIND\"] = 18] = \"UNBIND\";\n    METHODS[METHODS[\"ACL\"] = 19] = \"ACL\";\n    /* subversion */ METHODS[METHODS[\"REPORT\"] = 20] = \"REPORT\";\n    METHODS[METHODS[\"MKACTIVITY\"] = 21] = \"MKACTIVITY\";\n    METHODS[METHODS[\"CHECKOUT\"] = 22] = \"CHECKOUT\";\n    METHODS[METHODS[\"MERGE\"] = 23] = \"MERGE\";\n    /* upnp */ METHODS[METHODS[\"M-SEARCH\"] = 24] = \"M-SEARCH\";\n    METHODS[METHODS[\"NOTIFY\"] = 25] = \"NOTIFY\";\n    METHODS[METHODS[\"SUBSCRIBE\"] = 26] = \"SUBSCRIBE\";\n    METHODS[METHODS[\"UNSUBSCRIBE\"] = 27] = \"UNSUBSCRIBE\";\n    /* RFC-5789 */ METHODS[METHODS[\"PATCH\"] = 28] = \"PATCH\";\n    METHODS[METHODS[\"PURGE\"] = 29] = \"PURGE\";\n    /* CalDAV */ METHODS[METHODS[\"MKCALENDAR\"] = 30] = \"MKCALENDAR\";\n    /* RFC-2068, section 19.6.1.2 */ METHODS[METHODS[\"LINK\"] = 31] = \"LINK\";\n    METHODS[METHODS[\"UNLINK\"] = 32] = \"UNLINK\";\n    /* icecast */ METHODS[METHODS[\"SOURCE\"] = 33] = \"SOURCE\";\n    /* RFC-7540, section 11.6 */ METHODS[METHODS[\"PRI\"] = 34] = \"PRI\";\n    /* RFC-2326 RTSP */ METHODS[METHODS[\"DESCRIBE\"] = 35] = \"DESCRIBE\";\n    METHODS[METHODS[\"ANNOUNCE\"] = 36] = \"ANNOUNCE\";\n    METHODS[METHODS[\"SETUP\"] = 37] = \"SETUP\";\n    METHODS[METHODS[\"PLAY\"] = 38] = \"PLAY\";\n    METHODS[METHODS[\"PAUSE\"] = 39] = \"PAUSE\";\n    METHODS[METHODS[\"TEARDOWN\"] = 40] = \"TEARDOWN\";\n    METHODS[METHODS[\"GET_PARAMETER\"] = 41] = \"GET_PARAMETER\";\n    METHODS[METHODS[\"SET_PARAMETER\"] = 42] = \"SET_PARAMETER\";\n    METHODS[METHODS[\"REDIRECT\"] = 43] = \"REDIRECT\";\n    METHODS[METHODS[\"RECORD\"] = 44] = \"RECORD\";\n    /* RAOP */ METHODS[METHODS[\"FLUSH\"] = 45] = \"FLUSH\";\n})(METHODS = exports.METHODS || (exports.METHODS = {}));\nexports.METHODS_HTTP = [\n    METHODS.DELETE,\n    METHODS.GET,\n    METHODS.HEAD,\n    METHODS.POST,\n    METHODS.PUT,\n    METHODS.CONNECT,\n    METHODS.OPTIONS,\n    METHODS.TRACE,\n    METHODS.COPY,\n    METHODS.LOCK,\n    METHODS.MKCOL,\n    METHODS.MOVE,\n    METHODS.PROPFIND,\n    METHODS.PROPPATCH,\n    METHODS.SEARCH,\n    METHODS.UNLOCK,\n    METHODS.BIND,\n    METHODS.REBIND,\n    METHODS.UNBIND,\n    METHODS.ACL,\n    METHODS.REPORT,\n    METHODS.MKACTIVITY,\n    METHODS.CHECKOUT,\n    METHODS.MERGE,\n    METHODS[\"M-SEARCH\"],\n    METHODS.NOTIFY,\n    METHODS.SUBSCRIBE,\n    METHODS.UNSUBSCRIBE,\n    METHODS.PATCH,\n    METHODS.PURGE,\n    METHODS.MKCALENDAR,\n    METHODS.LINK,\n    METHODS.UNLINK,\n    METHODS.PRI,\n    // TODO(indutny): should we allow it with HTTP?\n    METHODS.SOURCE\n];\nexports.METHODS_ICE = [\n    METHODS.SOURCE\n];\nexports.METHODS_RTSP = [\n    METHODS.OPTIONS,\n    METHODS.DESCRIBE,\n    METHODS.ANNOUNCE,\n    METHODS.SETUP,\n    METHODS.PLAY,\n    METHODS.PAUSE,\n    METHODS.TEARDOWN,\n    METHODS.GET_PARAMETER,\n    METHODS.SET_PARAMETER,\n    METHODS.REDIRECT,\n    METHODS.RECORD,\n    METHODS.FLUSH,\n    // For AirPlay\n    METHODS.GET,\n    METHODS.POST\n];\nexports.METHOD_MAP = utils_1.enumToMap(METHODS);\nexports.H_METHOD_MAP = {};\nObject.keys(exports.METHOD_MAP).forEach((key)=>{\n    if (/^H/.test(key)) {\n        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];\n    }\n});\nvar FINISH;\n(function(FINISH) {\n    FINISH[FINISH[\"SAFE\"] = 0] = \"SAFE\";\n    FINISH[FINISH[\"SAFE_WITH_CB\"] = 1] = \"SAFE_WITH_CB\";\n    FINISH[FINISH[\"UNSAFE\"] = 2] = \"UNSAFE\";\n})(FINISH = exports.FINISH || (exports.FINISH = {}));\nexports.ALPHA = [];\nfor(let i = \"A\".charCodeAt(0); i <= \"Z\".charCodeAt(0); i++){\n    // Upper case\n    exports.ALPHA.push(String.fromCharCode(i));\n    // Lower case\n    exports.ALPHA.push(String.fromCharCode(i + 0x20));\n}\nexports.NUM_MAP = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9\n};\nexports.HEX_MAP = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9,\n    A: 0XA,\n    B: 0XB,\n    C: 0XC,\n    D: 0XD,\n    E: 0XE,\n    F: 0XF,\n    a: 0xa,\n    b: 0xb,\n    c: 0xc,\n    d: 0xd,\n    e: 0xe,\n    f: 0xf\n};\nexports.NUM = [\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\"\n];\nexports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\nexports.MARK = [\n    \"-\",\n    \"_\",\n    \".\",\n    \"!\",\n    \"~\",\n    \"*\",\n    \"'\",\n    \"(\",\n    \")\"\n];\nexports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([\n    \"%\",\n    \";\",\n    \":\",\n    \"&\",\n    \"=\",\n    \"+\",\n    \"$\",\n    \",\"\n]);\n// TODO(indutny): use RFC\nexports.STRICT_URL_CHAR = [\n    \"!\",\n    '\"',\n    \"$\",\n    \"%\",\n    \"&\",\n    \"'\",\n    \"(\",\n    \")\",\n    \"*\",\n    \"+\",\n    \",\",\n    \"-\",\n    \".\",\n    \"/\",\n    \":\",\n    \";\",\n    \"<\",\n    \"=\",\n    \">\",\n    \"@\",\n    \"[\",\n    \"\\\\\",\n    \"]\",\n    \"^\",\n    \"_\",\n    \"`\",\n    \"{\",\n    \"|\",\n    \"}\",\n    \"~\"\n].concat(exports.ALPHANUM);\nexports.URL_CHAR = exports.STRICT_URL_CHAR.concat([\n    \"\t\",\n    \"\\f\"\n]);\n// All characters with 0x80 bit set to 1\nfor(let i = 0x80; i <= 0xff; i++){\n    exports.URL_CHAR.push(i);\n}\nexports.HEX = exports.NUM.concat([\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\"\n]);\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */ exports.STRICT_TOKEN = [\n    \"!\",\n    \"#\",\n    \"$\",\n    \"%\",\n    \"&\",\n    \"'\",\n    \"*\",\n    \"+\",\n    \"-\",\n    \".\",\n    \"^\",\n    \"_\",\n    \"`\",\n    \"|\",\n    \"~\"\n].concat(exports.ALPHANUM);\nexports.TOKEN = exports.STRICT_TOKEN.concat([\n    \" \"\n]);\n/*\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n */ exports.HEADER_CHARS = [\n    \"\t\"\n];\nfor(let i = 32; i <= 255; i++){\n    if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n    }\n}\n// ',' = \\x44\nexports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c)=>c !== 44);\nexports.MAJOR = exports.NUM_MAP;\nexports.MINOR = exports.MAJOR;\nvar HEADER_STATE;\n(function(HEADER_STATE) {\n    HEADER_STATE[HEADER_STATE[\"GENERAL\"] = 0] = \"GENERAL\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION\"] = 1] = \"CONNECTION\";\n    HEADER_STATE[HEADER_STATE[\"CONTENT_LENGTH\"] = 2] = \"CONTENT_LENGTH\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING\"] = 3] = \"TRANSFER_ENCODING\";\n    HEADER_STATE[HEADER_STATE[\"UPGRADE\"] = 4] = \"UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_KEEP_ALIVE\"] = 5] = \"CONNECTION_KEEP_ALIVE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_CLOSE\"] = 6] = \"CONNECTION_CLOSE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_UPGRADE\"] = 7] = \"CONNECTION_UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING_CHUNKED\"] = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));\nexports.SPECIAL_HEADERS = {\n    \"connection\": HEADER_STATE.CONNECTION,\n    \"content-length\": HEADER_STATE.CONTENT_LENGTH,\n    \"proxy-connection\": HEADER_STATE.CONNECTION,\n    \"transfer-encoding\": HEADER_STATE.TRANSFER_ENCODING,\n    \"upgrade\": HEADER_STATE.UPGRADE\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUdBLG9CQUFvQixHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsOEJBQThCLEdBQUdBLG9CQUFvQixHQUFHQSxhQUFhLEdBQUdBLG9CQUFvQixHQUFHQSxXQUFXLEdBQUdBLGdCQUFnQixHQUFHQSx1QkFBdUIsR0FBR0Esc0JBQXNCLEdBQUdBLFlBQVksR0FBR0EsZ0JBQWdCLEdBQUdBLFdBQVcsR0FBR0EsZUFBZSxHQUFHQSxlQUFlLEdBQUdBLGFBQWEsR0FBR0EsY0FBYyxHQUFHQSxvQkFBb0IsR0FBR0Esa0JBQWtCLEdBQUdBLG9CQUFvQixHQUFHQSxtQkFBbUIsR0FBR0Esb0JBQW9CLEdBQUdBLGVBQWUsR0FBR0EscUJBQXFCLEdBQUdBLGFBQWEsR0FBR0EsWUFBWSxHQUFHQSxhQUFhLEdBQUcsS0FBSztBQUN2a0IsTUFBTStCLFVBQVVDLG1CQUFPQSxDQUFDLG9FQUFTO0FBQ2pDLFlBQVk7QUFDWixJQUFJRjtBQUNILFVBQVVBLEtBQUs7SUFDWkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsS0FBSyxHQUFHLEVBQUUsR0FBRztJQUN6QkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztJQUMvQkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUM3QkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUNsQ0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsNEJBQTRCLEdBQUcsRUFBRSxHQUFHO0lBQ2hEQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7SUFDeENBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLGlCQUFpQixHQUFHLEVBQUUsR0FBRztJQUNyQ0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUNsQ0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsbUJBQW1CLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLEdBQUc7SUFDdENBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLHVCQUF1QixHQUFHLEdBQUcsR0FBRztJQUM1Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMseUJBQXlCLEdBQUcsR0FBRyxHQUFHO0lBQzlDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxxQkFBcUIsR0FBRyxHQUFHLEdBQUc7SUFDMUNBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLGlCQUFpQixHQUFHLEdBQUcsR0FBRztJQUN0Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsb0JBQW9CLEdBQUcsR0FBRyxHQUFHO0lBQ3pDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyw0QkFBNEIsR0FBRyxHQUFHLEdBQUc7SUFDakRBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLG1CQUFtQixHQUFHLEdBQUcsR0FBRztJQUN4Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsc0JBQXNCLEdBQUcsR0FBRyxHQUFHO0lBQzNDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxzQkFBc0IsR0FBRyxHQUFHLEdBQUc7SUFDM0NBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLGtCQUFrQixHQUFHLEdBQUcsR0FBRztJQUN2Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsb0JBQW9CLEdBQUcsR0FBRyxHQUFHO0lBQ3pDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQzlCQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxpQkFBaUIsR0FBRyxHQUFHLEdBQUc7SUFDdENBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLG9CQUFvQixHQUFHLEdBQUcsR0FBRztJQUN6Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRztBQUNoQyxHQUFHQSxRQUFROUIsUUFBUThCLEtBQUssSUFBSzlCLENBQUFBLGFBQWEsR0FBRyxDQUFDO0FBQzlDLElBQUk2QjtBQUNILFVBQVVBLElBQUk7SUFDWEEsSUFBSSxDQUFDQSxJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUN6QkEsSUFBSSxDQUFDQSxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM1QkEsSUFBSSxDQUFDQSxJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztBQUNqQyxHQUFHQSxPQUFPN0IsUUFBUTZCLElBQUksSUFBSzdCLENBQUFBLFlBQVksR0FBRyxDQUFDO0FBQzNDLElBQUk0QjtBQUNILFVBQVVBLEtBQUs7SUFDWkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsd0JBQXdCLEdBQUcsRUFBRSxHQUFHO0lBQzVDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxtQkFBbUIsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLHFCQUFxQixHQUFHLEVBQUUsR0FBRztJQUN6Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM5QkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsVUFBVSxHQUFHLEdBQUcsR0FBRztJQUMvQkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsaUJBQWlCLEdBQUcsR0FBRyxHQUFHO0lBQ3RDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxXQUFXLEdBQUcsR0FBRyxHQUFHO0lBQ2hDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxXQUFXLEdBQUcsSUFBSSxHQUFHO0lBQ2pDLG1CQUFtQjtJQUNuQkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxHQUFHO0FBQzlDLEdBQUdBLFFBQVE1QixRQUFRNEIsS0FBSyxJQUFLNUIsQ0FBQUEsYUFBYSxHQUFHLENBQUM7QUFDOUMsSUFBSTJCO0FBQ0gsVUFBVUEsYUFBYTtJQUNwQkEsYUFBYSxDQUFDQSxhQUFhLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxHQUFHO0lBQ3JEQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHO0FBQ3JELEdBQUdBLGdCQUFnQjNCLFFBQVEyQixhQUFhLElBQUszQixDQUFBQSxxQkFBcUIsR0FBRyxDQUFDO0FBQ3RFLElBQUkwQjtBQUNILFVBQVVBLE9BQU87SUFDZEEsT0FBTyxDQUFDQSxPQUFPLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUNqQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUM5QkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUMvQkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUMvQkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUM5QixnQkFBZ0IsR0FDaEJBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDbENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDbENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDaEMsVUFBVSxHQUNWQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQy9CQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQy9CQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxRQUFRLEdBQUcsR0FBRyxHQUFHO0lBQ2pDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxPQUFPLEdBQUcsR0FBRyxHQUFHO0lBQ2hDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxXQUFXLEdBQUcsR0FBRyxHQUFHO0lBQ3BDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxZQUFZLEdBQUcsR0FBRyxHQUFHO0lBQ3JDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxPQUFPLEdBQUcsR0FBRyxHQUFHO0lBQ2hDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxNQUFNLEdBQUcsR0FBRyxHQUFHO0lBQy9CLGNBQWMsR0FDZEEsT0FBTyxDQUFDQSxPQUFPLENBQUMsU0FBUyxHQUFHLEdBQUcsR0FBRztJQUNsQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsYUFBYSxHQUFHLEdBQUcsR0FBRztJQUN0Q0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUNwQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztJQUNqQyxRQUFRLEdBQ1JBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDcENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7SUFDbENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFlBQVksR0FBRyxHQUFHLEdBQUc7SUFDckNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLGNBQWMsR0FBRyxHQUFHLEdBQUc7SUFDdkMsWUFBWSxHQUNaQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxRQUFRLEdBQUcsR0FBRyxHQUFHO0lBQ2pDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxRQUFRLEdBQUcsR0FBRyxHQUFHO0lBQ2pDLFVBQVUsR0FDVkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsYUFBYSxHQUFHLEdBQUcsR0FBRztJQUN0Qyw4QkFBOEIsR0FDOUJBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLE9BQU8sR0FBRyxHQUFHLEdBQUc7SUFDaENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7SUFDbEMsV0FBVyxHQUNYQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDLDBCQUEwQixHQUMxQkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsTUFBTSxHQUFHLEdBQUcsR0FBRztJQUMvQixpQkFBaUIsR0FDakJBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDcENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDcENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFFBQVEsR0FBRyxHQUFHLEdBQUc7SUFDakNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLE9BQU8sR0FBRyxHQUFHLEdBQUc7SUFDaENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFFBQVEsR0FBRyxHQUFHLEdBQUc7SUFDakNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDcENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRztJQUN6Q0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsR0FBRyxHQUFHO0lBQ3pDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxXQUFXLEdBQUcsR0FBRyxHQUFHO0lBQ3BDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDLFFBQVEsR0FDUkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztBQUNyQyxHQUFHQSxVQUFVMUIsUUFBUTBCLE9BQU8sSUFBSzFCLENBQUFBLGVBQWUsR0FBRyxDQUFDO0FBQ3BEQSxvQkFBb0IsR0FBRztJQUNuQjBCLFFBQVFPLE1BQU07SUFDZFAsUUFBUVEsR0FBRztJQUNYUixRQUFRUyxJQUFJO0lBQ1pULFFBQVFVLElBQUk7SUFDWlYsUUFBUVcsR0FBRztJQUNYWCxRQUFRWSxPQUFPO0lBQ2ZaLFFBQVFhLE9BQU87SUFDZmIsUUFBUWMsS0FBSztJQUNiZCxRQUFRZSxJQUFJO0lBQ1pmLFFBQVFnQixJQUFJO0lBQ1poQixRQUFRaUIsS0FBSztJQUNiakIsUUFBUWtCLElBQUk7SUFDWmxCLFFBQVFtQixRQUFRO0lBQ2hCbkIsUUFBUW9CLFNBQVM7SUFDakJwQixRQUFRcUIsTUFBTTtJQUNkckIsUUFBUXNCLE1BQU07SUFDZHRCLFFBQVF1QixJQUFJO0lBQ1p2QixRQUFRd0IsTUFBTTtJQUNkeEIsUUFBUXlCLE1BQU07SUFDZHpCLFFBQVEwQixHQUFHO0lBQ1gxQixRQUFRMkIsTUFBTTtJQUNkM0IsUUFBUTRCLFVBQVU7SUFDbEI1QixRQUFRNkIsUUFBUTtJQUNoQjdCLFFBQVE4QixLQUFLO0lBQ2I5QixPQUFPLENBQUMsV0FBVztJQUNuQkEsUUFBUStCLE1BQU07SUFDZC9CLFFBQVFnQyxTQUFTO0lBQ2pCaEMsUUFBUWlDLFdBQVc7SUFDbkJqQyxRQUFRa0MsS0FBSztJQUNibEMsUUFBUW1DLEtBQUs7SUFDYm5DLFFBQVFvQyxVQUFVO0lBQ2xCcEMsUUFBUXFDLElBQUk7SUFDWnJDLFFBQVFzQyxNQUFNO0lBQ2R0QyxRQUFRdUMsR0FBRztJQUNYLCtDQUErQztJQUMvQ3ZDLFFBQVF3QyxNQUFNO0NBQ2pCO0FBQ0RsRSxtQkFBbUIsR0FBRztJQUNsQjBCLFFBQVF3QyxNQUFNO0NBQ2pCO0FBQ0RsRSxvQkFBb0IsR0FBRztJQUNuQjBCLFFBQVFhLE9BQU87SUFDZmIsUUFBUXlDLFFBQVE7SUFDaEJ6QyxRQUFRMEMsUUFBUTtJQUNoQjFDLFFBQVEyQyxLQUFLO0lBQ2IzQyxRQUFRNEMsSUFBSTtJQUNaNUMsUUFBUTZDLEtBQUs7SUFDYjdDLFFBQVE4QyxRQUFRO0lBQ2hCOUMsUUFBUStDLGFBQWE7SUFDckIvQyxRQUFRZ0QsYUFBYTtJQUNyQmhELFFBQVFpRCxRQUFRO0lBQ2hCakQsUUFBUWtELE1BQU07SUFDZGxELFFBQVFtRCxLQUFLO0lBQ2IsY0FBYztJQUNkbkQsUUFBUVEsR0FBRztJQUNYUixRQUFRVSxJQUFJO0NBQ2Y7QUFDRHBDLGtCQUFrQixHQUFHK0IsUUFBUStDLFNBQVMsQ0FBQ3BEO0FBQ3ZDMUIsb0JBQW9CLEdBQUcsQ0FBQztBQUN4QkYsT0FBT2lGLElBQUksQ0FBQy9FLFFBQVFzQixVQUFVLEVBQUUwRCxPQUFPLENBQUMsQ0FBQ0M7SUFDckMsSUFBSSxLQUFLQyxJQUFJLENBQUNELE1BQU07UUFDaEJqRixRQUFRcUIsWUFBWSxDQUFDNEQsSUFBSSxHQUFHakYsUUFBUXNCLFVBQVUsQ0FBQzJELElBQUk7SUFDdkQ7QUFDSjtBQUNBLElBQUk3RDtBQUNILFVBQVVBLE1BQU07SUFDYkEsTUFBTSxDQUFDQSxNQUFNLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUM3QkEsTUFBTSxDQUFDQSxNQUFNLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztJQUNyQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztBQUNuQyxHQUFHQSxTQUFTcEIsUUFBUW9CLE1BQU0sSUFBS3BCLENBQUFBLGNBQWMsR0FBRyxDQUFDO0FBQ2pEQSxhQUFhLEdBQUcsRUFBRTtBQUNsQixJQUFLLElBQUltRixJQUFJLElBQUlDLFVBQVUsQ0FBQyxJQUFJRCxLQUFLLElBQUlDLFVBQVUsQ0FBQyxJQUFJRCxJQUFLO0lBQ3pELGFBQWE7SUFDYm5GLFFBQVFtQixLQUFLLENBQUNrRSxJQUFJLENBQUNDLE9BQU9DLFlBQVksQ0FBQ0o7SUFDdkMsYUFBYTtJQUNibkYsUUFBUW1CLEtBQUssQ0FBQ2tFLElBQUksQ0FBQ0MsT0FBT0MsWUFBWSxDQUFDSixJQUFJO0FBQy9DO0FBQ0FuRixlQUFlLEdBQUc7SUFDZCxHQUFHO0lBQUcsR0FBRztJQUFHLEdBQUc7SUFBRyxHQUFHO0lBQUcsR0FBRztJQUMzQixHQUFHO0lBQUcsR0FBRztJQUFHLEdBQUc7SUFBRyxHQUFHO0lBQUcsR0FBRztBQUMvQjtBQUNBQSxlQUFlLEdBQUc7SUFDZCxHQUFHO0lBQUcsR0FBRztJQUFHLEdBQUc7SUFBRyxHQUFHO0lBQUcsR0FBRztJQUMzQixHQUFHO0lBQUcsR0FBRztJQUFHLEdBQUc7SUFBRyxHQUFHO0lBQUcsR0FBRztJQUMzQndGLEdBQUc7SUFBS0MsR0FBRztJQUFLQyxHQUFHO0lBQUtDLEdBQUc7SUFBS0MsR0FBRztJQUFLQyxHQUFHO0lBQzNDQyxHQUFHO0lBQUtDLEdBQUc7SUFBS0MsR0FBRztJQUFLQyxHQUFHO0lBQUtDLEdBQUc7SUFBS0MsR0FBRztBQUMvQztBQUNBbkcsV0FBVyxHQUFHO0lBQ1Y7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7Q0FDaEQ7QUFDREEsZ0JBQWdCLEdBQUdBLFFBQVFtQixLQUFLLENBQUNpRixNQUFNLENBQUNwRyxRQUFRZ0IsR0FBRztBQUNuRGhCLFlBQVksR0FBRztJQUFDO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQU07SUFBSztDQUFJO0FBQzdEQSxzQkFBc0IsR0FBR0EsUUFBUWUsUUFBUSxDQUNwQ3FGLE1BQU0sQ0FBQ3BHLFFBQVFjLElBQUksRUFDbkJzRixNQUFNLENBQUM7SUFBQztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFDcEQseUJBQXlCO0FBQ3pCcEcsdUJBQXVCLEdBQUc7SUFDdEI7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQ3pCO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFDbkM7SUFBSztJQUFLO0lBQUs7SUFBSztJQUNwQjtJQUFLO0lBQUs7SUFBTTtJQUFLO0lBQUs7SUFDMUI7SUFDQTtJQUFLO0lBQUs7SUFBSztDQUNsQixDQUFDb0csTUFBTSxDQUFDcEcsUUFBUWUsUUFBUTtBQUN6QmYsZ0JBQWdCLEdBQUdBLFFBQVFZLGVBQWUsQ0FDckN3RixNQUFNLENBQUM7SUFBQztJQUFNO0NBQUs7QUFDeEIsd0NBQXdDO0FBQ3hDLElBQUssSUFBSWpCLElBQUksTUFBTUEsS0FBSyxNQUFNQSxJQUFLO0lBQy9CbkYsUUFBUVcsUUFBUSxDQUFDMEUsSUFBSSxDQUFDRjtBQUMxQjtBQUNBbkYsV0FBVyxHQUFHQSxRQUFRZ0IsR0FBRyxDQUFDb0YsTUFBTSxDQUFDO0lBQUM7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFDN0Y7Ozs7OztDQU1DLEdBQ0RwRyxvQkFBb0IsR0FBRztJQUNuQjtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFDekI7SUFBSztJQUFLO0lBQUs7SUFDZjtJQUFLO0lBQUs7SUFDVjtJQUFLO0NBQ1IsQ0FBQ29HLE1BQU0sQ0FBQ3BHLFFBQVFlLFFBQVE7QUFDekJmLGFBQWEsR0FBR0EsUUFBUVMsWUFBWSxDQUFDMkYsTUFBTSxDQUFDO0lBQUM7Q0FBSTtBQUNqRDs7O0NBR0MsR0FDRHBHLG9CQUFvQixHQUFHO0lBQUM7Q0FBSztBQUM3QixJQUFLLElBQUltRixJQUFJLElBQUlBLEtBQUssS0FBS0EsSUFBSztJQUM1QixJQUFJQSxNQUFNLEtBQUs7UUFDWG5GLFFBQVFPLFlBQVksQ0FBQzhFLElBQUksQ0FBQ0Y7SUFDOUI7QUFDSjtBQUNBLGFBQWE7QUFDYm5GLDhCQUE4QixHQUFHQSxRQUFRTyxZQUFZLENBQUM4RixNQUFNLENBQUMsQ0FBQ0wsSUFBTUEsTUFBTTtBQUMxRWhHLGFBQWEsR0FBR0EsUUFBUWtCLE9BQU87QUFDL0JsQixhQUFhLEdBQUdBLFFBQVFLLEtBQUs7QUFDN0IsSUFBSUY7QUFDSCxVQUFVQSxZQUFZO0lBQ25CQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzVDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHO0lBQy9DQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLEdBQUc7SUFDbkRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRztJQUN0REEsWUFBWSxDQUFDQSxZQUFZLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM1Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsd0JBQXdCLEdBQUcsRUFBRSxHQUFHO0lBQzFEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxtQkFBbUIsR0FBRyxFQUFFLEdBQUc7SUFDckRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLHFCQUFxQixHQUFHLEVBQUUsR0FBRztJQUN2REEsWUFBWSxDQUFDQSxZQUFZLENBQUMsNEJBQTRCLEdBQUcsRUFBRSxHQUFHO0FBQ2xFLEdBQUdBLGVBQWVILFFBQVFHLFlBQVksSUFBS0gsQ0FBQUEsb0JBQW9CLEdBQUcsQ0FBQztBQUNuRUEsdUJBQXVCLEdBQUc7SUFDdEIsY0FBY0csYUFBYW1HLFVBQVU7SUFDckMsa0JBQWtCbkcsYUFBYW9HLGNBQWM7SUFDN0Msb0JBQW9CcEcsYUFBYW1HLFVBQVU7SUFDM0MscUJBQXFCbkcsYUFBYXFHLGlCQUFpQjtJQUNuRCxXQUFXckcsYUFBYXNHLE9BQU87QUFDbkMsR0FDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9jb25zdGFudHMuanM/ZmViYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU1BFQ0lBTF9IRUFERVJTID0gZXhwb3J0cy5IRUFERVJfU1RBVEUgPSBleHBvcnRzLk1JTk9SID0gZXhwb3J0cy5NQUpPUiA9IGV4cG9ydHMuQ09OTkVDVElPTl9UT0tFTl9DSEFSUyA9IGV4cG9ydHMuSEVBREVSX0NIQVJTID0gZXhwb3J0cy5UT0tFTiA9IGV4cG9ydHMuU1RSSUNUX1RPS0VOID0gZXhwb3J0cy5IRVggPSBleHBvcnRzLlVSTF9DSEFSID0gZXhwb3J0cy5TVFJJQ1RfVVJMX0NIQVIgPSBleHBvcnRzLlVTRVJJTkZPX0NIQVJTID0gZXhwb3J0cy5NQVJLID0gZXhwb3J0cy5BTFBIQU5VTSA9IGV4cG9ydHMuTlVNID0gZXhwb3J0cy5IRVhfTUFQID0gZXhwb3J0cy5OVU1fTUFQID0gZXhwb3J0cy5BTFBIQSA9IGV4cG9ydHMuRklOSVNIID0gZXhwb3J0cy5IX01FVEhPRF9NQVAgPSBleHBvcnRzLk1FVEhPRF9NQVAgPSBleHBvcnRzLk1FVEhPRFNfUlRTUCA9IGV4cG9ydHMuTUVUSE9EU19JQ0UgPSBleHBvcnRzLk1FVEhPRFNfSFRUUCA9IGV4cG9ydHMuTUVUSE9EUyA9IGV4cG9ydHMuTEVOSUVOVF9GTEFHUyA9IGV4cG9ydHMuRkxBR1MgPSBleHBvcnRzLlRZUEUgPSBleHBvcnRzLkVSUk9SID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLy8gQyBoZWFkZXJzXG52YXIgRVJST1I7XG4oZnVuY3Rpb24gKEVSUk9SKSB7XG4gICAgRVJST1JbRVJST1JbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5URVJOQUxcIl0gPSAxXSA9IFwiSU5URVJOQUxcIjtcbiAgICBFUlJPUltFUlJPUltcIlNUUklDVFwiXSA9IDJdID0gXCJTVFJJQ1RcIjtcbiAgICBFUlJPUltFUlJPUltcIkxGX0VYUEVDVEVEXCJdID0gM10gPSBcIkxGX0VYUEVDVEVEXCI7XG4gICAgRVJST1JbRVJST1JbXCJVTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIXCJdID0gNF0gPSBcIlVORVhQRUNURURfQ09OVEVOVF9MRU5HVEhcIjtcbiAgICBFUlJPUltFUlJPUltcIkNMT1NFRF9DT05ORUNUSU9OXCJdID0gNV0gPSBcIkNMT1NFRF9DT05ORUNUSU9OXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX01FVEhPRFwiXSA9IDZdID0gXCJJTlZBTElEX01FVEhPRFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9VUkxcIl0gPSA3XSA9IFwiSU5WQUxJRF9VUkxcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfQ09OU1RBTlRcIl0gPSA4XSA9IFwiSU5WQUxJRF9DT05TVEFOVFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9WRVJTSU9OXCJdID0gOV0gPSBcIklOVkFMSURfVkVSU0lPTlwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9IRUFERVJfVE9LRU5cIl0gPSAxMF0gPSBcIklOVkFMSURfSEVBREVSX1RPS0VOXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0NPTlRFTlRfTEVOR1RIXCJdID0gMTFdID0gXCJJTlZBTElEX0NPTlRFTlRfTEVOR1RIXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0NIVU5LX1NJWkVcIl0gPSAxMl0gPSBcIklOVkFMSURfQ0hVTktfU0laRVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9TVEFUVVNcIl0gPSAxM10gPSBcIklOVkFMSURfU1RBVFVTXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0VPRl9TVEFURVwiXSA9IDE0XSA9IFwiSU5WQUxJRF9FT0ZfU1RBVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkdcIl0gPSAxNV0gPSBcIklOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkdcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX01FU1NBR0VfQkVHSU5cIl0gPSAxNl0gPSBcIkNCX01FU1NBR0VfQkVHSU5cIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX0hFQURFUlNfQ09NUExFVEVcIl0gPSAxN10gPSBcIkNCX0hFQURFUlNfQ09NUExFVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX01FU1NBR0VfQ09NUExFVEVcIl0gPSAxOF0gPSBcIkNCX01FU1NBR0VfQ09NUExFVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX0NIVU5LX0hFQURFUlwiXSA9IDE5XSA9IFwiQ0JfQ0hVTktfSEVBREVSXCI7XG4gICAgRVJST1JbRVJST1JbXCJDQl9DSFVOS19DT01QTEVURVwiXSA9IDIwXSA9IFwiQ0JfQ0hVTktfQ09NUExFVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIlBBVVNFRFwiXSA9IDIxXSA9IFwiUEFVU0VEXCI7XG4gICAgRVJST1JbRVJST1JbXCJQQVVTRURfVVBHUkFERVwiXSA9IDIyXSA9IFwiUEFVU0VEX1VQR1JBREVcIjtcbiAgICBFUlJPUltFUlJPUltcIlBBVVNFRF9IMl9VUEdSQURFXCJdID0gMjNdID0gXCJQQVVTRURfSDJfVVBHUkFERVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiVVNFUlwiXSA9IDI0XSA9IFwiVVNFUlwiO1xufSkoRVJST1IgPSBleHBvcnRzLkVSUk9SIHx8IChleHBvcnRzLkVSUk9SID0ge30pKTtcbnZhciBUWVBFO1xuKGZ1bmN0aW9uIChUWVBFKSB7XG4gICAgVFlQRVtUWVBFW1wiQk9USFwiXSA9IDBdID0gXCJCT1RIXCI7XG4gICAgVFlQRVtUWVBFW1wiUkVRVUVTVFwiXSA9IDFdID0gXCJSRVFVRVNUXCI7XG4gICAgVFlQRVtUWVBFW1wiUkVTUE9OU0VcIl0gPSAyXSA9IFwiUkVTUE9OU0VcIjtcbn0pKFRZUEUgPSBleHBvcnRzLlRZUEUgfHwgKGV4cG9ydHMuVFlQRSA9IHt9KSk7XG52YXIgRkxBR1M7XG4oZnVuY3Rpb24gKEZMQUdTKSB7XG4gICAgRkxBR1NbRkxBR1NbXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIl0gPSAxXSA9IFwiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJDT05ORUNUSU9OX0NMT1NFXCJdID0gMl0gPSBcIkNPTk5FQ1RJT05fQ0xPU0VcIjtcbiAgICBGTEFHU1tGTEFHU1tcIkNPTk5FQ1RJT05fVVBHUkFERVwiXSA9IDRdID0gXCJDT05ORUNUSU9OX1VQR1JBREVcIjtcbiAgICBGTEFHU1tGTEFHU1tcIkNIVU5LRURcIl0gPSA4XSA9IFwiQ0hVTktFRFwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiVVBHUkFERVwiXSA9IDE2XSA9IFwiVVBHUkFERVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiQ09OVEVOVF9MRU5HVEhcIl0gPSAzMl0gPSBcIkNPTlRFTlRfTEVOR1RIXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJTS0lQQk9EWVwiXSA9IDY0XSA9IFwiU0tJUEJPRFlcIjtcbiAgICBGTEFHU1tGTEFHU1tcIlRSQUlMSU5HXCJdID0gMTI4XSA9IFwiVFJBSUxJTkdcIjtcbiAgICAvLyAxIDw8IDggaXMgdW51c2VkXG4gICAgRkxBR1NbRkxBR1NbXCJUUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDUxMl0gPSBcIlRSQU5TRkVSX0VOQ09ESU5HXCI7XG59KShGTEFHUyA9IGV4cG9ydHMuRkxBR1MgfHwgKGV4cG9ydHMuRkxBR1MgPSB7fSkpO1xudmFyIExFTklFTlRfRkxBR1M7XG4oZnVuY3Rpb24gKExFTklFTlRfRkxBR1MpIHtcbiAgICBMRU5JRU5UX0ZMQUdTW0xFTklFTlRfRkxBR1NbXCJIRUFERVJTXCJdID0gMV0gPSBcIkhFQURFUlNcIjtcbiAgICBMRU5JRU5UX0ZMQUdTW0xFTklFTlRfRkxBR1NbXCJDSFVOS0VEX0xFTkdUSFwiXSA9IDJdID0gXCJDSFVOS0VEX0xFTkdUSFwiO1xuICAgIExFTklFTlRfRkxBR1NbTEVOSUVOVF9GTEFHU1tcIktFRVBfQUxJVkVcIl0gPSA0XSA9IFwiS0VFUF9BTElWRVwiO1xufSkoTEVOSUVOVF9GTEFHUyA9IGV4cG9ydHMuTEVOSUVOVF9GTEFHUyB8fCAoZXhwb3J0cy5MRU5JRU5UX0ZMQUdTID0ge30pKTtcbnZhciBNRVRIT0RTO1xuKGZ1bmN0aW9uIChNRVRIT0RTKSB7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiREVMRVRFXCJdID0gMF0gPSBcIkRFTEVURVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkdFVFwiXSA9IDFdID0gXCJHRVRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJIRUFEXCJdID0gMl0gPSBcIkhFQURcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQT1NUXCJdID0gM10gPSBcIlBPU1RcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQVVRcIl0gPSA0XSA9IFwiUFVUXCI7XG4gICAgLyogcGF0aG9sb2dpY2FsICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQ09OTkVDVFwiXSA9IDVdID0gXCJDT05ORUNUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiT1BUSU9OU1wiXSA9IDZdID0gXCJPUFRJT05TXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVFJBQ0VcIl0gPSA3XSA9IFwiVFJBQ0VcIjtcbiAgICAvKiBXZWJEQVYgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJDT1BZXCJdID0gOF0gPSBcIkNPUFlcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJMT0NLXCJdID0gOV0gPSBcIkxPQ0tcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNS0NPTFwiXSA9IDEwXSA9IFwiTUtDT0xcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNT1ZFXCJdID0gMTFdID0gXCJNT1ZFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFJPUEZJTkRcIl0gPSAxMl0gPSBcIlBST1BGSU5EXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFJPUFBBVENIXCJdID0gMTNdID0gXCJQUk9QUEFUQ0hcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTRUFSQ0hcIl0gPSAxNF0gPSBcIlNFQVJDSFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOTE9DS1wiXSA9IDE1XSA9IFwiVU5MT0NLXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQklORFwiXSA9IDE2XSA9IFwiQklORFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFQklORFwiXSA9IDE3XSA9IFwiUkVCSU5EXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5CSU5EXCJdID0gMThdID0gXCJVTkJJTkRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJBQ0xcIl0gPSAxOV0gPSBcIkFDTFwiO1xuICAgIC8qIHN1YnZlcnNpb24gKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJSRVBPUlRcIl0gPSAyMF0gPSBcIlJFUE9SVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1LQUNUSVZJVFlcIl0gPSAyMV0gPSBcIk1LQUNUSVZJVFlcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJDSEVDS09VVFwiXSA9IDIyXSA9IFwiQ0hFQ0tPVVRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNRVJHRVwiXSA9IDIzXSA9IFwiTUVSR0VcIjtcbiAgICAvKiB1cG5wICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTS1TRUFSQ0hcIl0gPSAyNF0gPSBcIk0tU0VBUkNIXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTk9USUZZXCJdID0gMjVdID0gXCJOT1RJRllcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTVUJTQ1JJQkVcIl0gPSAyNl0gPSBcIlNVQlNDUklCRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOU1VCU0NSSUJFXCJdID0gMjddID0gXCJVTlNVQlNDUklCRVwiO1xuICAgIC8qIFJGQy01Nzg5ICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUEFUQ0hcIl0gPSAyOF0gPSBcIlBBVENIXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFVSR0VcIl0gPSAyOV0gPSBcIlBVUkdFXCI7XG4gICAgLyogQ2FsREFWICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTUtDQUxFTkRBUlwiXSA9IDMwXSA9IFwiTUtDQUxFTkRBUlwiO1xuICAgIC8qIFJGQy0yMDY4LCBzZWN0aW9uIDE5LjYuMS4yICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTElOS1wiXSA9IDMxXSA9IFwiTElOS1wiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOTElOS1wiXSA9IDMyXSA9IFwiVU5MSU5LXCI7XG4gICAgLyogaWNlY2FzdCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNPVVJDRVwiXSA9IDMzXSA9IFwiU09VUkNFXCI7XG4gICAgLyogUkZDLTc1NDAsIHNlY3Rpb24gMTEuNiAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBSSVwiXSA9IDM0XSA9IFwiUFJJXCI7XG4gICAgLyogUkZDLTIzMjYgUlRTUCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkRFU0NSSUJFXCJdID0gMzVdID0gXCJERVNDUklCRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkFOTk9VTkNFXCJdID0gMzZdID0gXCJBTk5PVU5DRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNFVFVQXCJdID0gMzddID0gXCJTRVRVUFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBMQVlcIl0gPSAzOF0gPSBcIlBMQVlcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQQVVTRVwiXSA9IDM5XSA9IFwiUEFVU0VcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJURUFSRE9XTlwiXSA9IDQwXSA9IFwiVEVBUkRPV05cIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJHRVRfUEFSQU1FVEVSXCJdID0gNDFdID0gXCJHRVRfUEFSQU1FVEVSXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiU0VUX1BBUkFNRVRFUlwiXSA9IDQyXSA9IFwiU0VUX1BBUkFNRVRFUlwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFRElSRUNUXCJdID0gNDNdID0gXCJSRURJUkVDVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFQ09SRFwiXSA9IDQ0XSA9IFwiUkVDT1JEXCI7XG4gICAgLyogUkFPUCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkZMVVNIXCJdID0gNDVdID0gXCJGTFVTSFwiO1xufSkoTUVUSE9EUyA9IGV4cG9ydHMuTUVUSE9EUyB8fCAoZXhwb3J0cy5NRVRIT0RTID0ge30pKTtcbmV4cG9ydHMuTUVUSE9EU19IVFRQID0gW1xuICAgIE1FVEhPRFMuREVMRVRFLFxuICAgIE1FVEhPRFMuR0VULFxuICAgIE1FVEhPRFMuSEVBRCxcbiAgICBNRVRIT0RTLlBPU1QsXG4gICAgTUVUSE9EUy5QVVQsXG4gICAgTUVUSE9EUy5DT05ORUNULFxuICAgIE1FVEhPRFMuT1BUSU9OUyxcbiAgICBNRVRIT0RTLlRSQUNFLFxuICAgIE1FVEhPRFMuQ09QWSxcbiAgICBNRVRIT0RTLkxPQ0ssXG4gICAgTUVUSE9EUy5NS0NPTCxcbiAgICBNRVRIT0RTLk1PVkUsXG4gICAgTUVUSE9EUy5QUk9QRklORCxcbiAgICBNRVRIT0RTLlBST1BQQVRDSCxcbiAgICBNRVRIT0RTLlNFQVJDSCxcbiAgICBNRVRIT0RTLlVOTE9DSyxcbiAgICBNRVRIT0RTLkJJTkQsXG4gICAgTUVUSE9EUy5SRUJJTkQsXG4gICAgTUVUSE9EUy5VTkJJTkQsXG4gICAgTUVUSE9EUy5BQ0wsXG4gICAgTUVUSE9EUy5SRVBPUlQsXG4gICAgTUVUSE9EUy5NS0FDVElWSVRZLFxuICAgIE1FVEhPRFMuQ0hFQ0tPVVQsXG4gICAgTUVUSE9EUy5NRVJHRSxcbiAgICBNRVRIT0RTWydNLVNFQVJDSCddLFxuICAgIE1FVEhPRFMuTk9USUZZLFxuICAgIE1FVEhPRFMuU1VCU0NSSUJFLFxuICAgIE1FVEhPRFMuVU5TVUJTQ1JJQkUsXG4gICAgTUVUSE9EUy5QQVRDSCxcbiAgICBNRVRIT0RTLlBVUkdFLFxuICAgIE1FVEhPRFMuTUtDQUxFTkRBUixcbiAgICBNRVRIT0RTLkxJTkssXG4gICAgTUVUSE9EUy5VTkxJTkssXG4gICAgTUVUSE9EUy5QUkksXG4gICAgLy8gVE9ETyhpbmR1dG55KTogc2hvdWxkIHdlIGFsbG93IGl0IHdpdGggSFRUUD9cbiAgICBNRVRIT0RTLlNPVVJDRSxcbl07XG5leHBvcnRzLk1FVEhPRFNfSUNFID0gW1xuICAgIE1FVEhPRFMuU09VUkNFLFxuXTtcbmV4cG9ydHMuTUVUSE9EU19SVFNQID0gW1xuICAgIE1FVEhPRFMuT1BUSU9OUyxcbiAgICBNRVRIT0RTLkRFU0NSSUJFLFxuICAgIE1FVEhPRFMuQU5OT1VOQ0UsXG4gICAgTUVUSE9EUy5TRVRVUCxcbiAgICBNRVRIT0RTLlBMQVksXG4gICAgTUVUSE9EUy5QQVVTRSxcbiAgICBNRVRIT0RTLlRFQVJET1dOLFxuICAgIE1FVEhPRFMuR0VUX1BBUkFNRVRFUixcbiAgICBNRVRIT0RTLlNFVF9QQVJBTUVURVIsXG4gICAgTUVUSE9EUy5SRURJUkVDVCxcbiAgICBNRVRIT0RTLlJFQ09SRCxcbiAgICBNRVRIT0RTLkZMVVNILFxuICAgIC8vIEZvciBBaXJQbGF5XG4gICAgTUVUSE9EUy5HRVQsXG4gICAgTUVUSE9EUy5QT1NULFxuXTtcbmV4cG9ydHMuTUVUSE9EX01BUCA9IHV0aWxzXzEuZW51bVRvTWFwKE1FVEhPRFMpO1xuZXhwb3J0cy5IX01FVEhPRF9NQVAgPSB7fTtcbk9iamVjdC5rZXlzKGV4cG9ydHMuTUVUSE9EX01BUCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKC9eSC8udGVzdChrZXkpKSB7XG4gICAgICAgIGV4cG9ydHMuSF9NRVRIT0RfTUFQW2tleV0gPSBleHBvcnRzLk1FVEhPRF9NQVBba2V5XTtcbiAgICB9XG59KTtcbnZhciBGSU5JU0g7XG4oZnVuY3Rpb24gKEZJTklTSCkge1xuICAgIEZJTklTSFtGSU5JU0hbXCJTQUZFXCJdID0gMF0gPSBcIlNBRkVcIjtcbiAgICBGSU5JU0hbRklOSVNIW1wiU0FGRV9XSVRIX0NCXCJdID0gMV0gPSBcIlNBRkVfV0lUSF9DQlwiO1xuICAgIEZJTklTSFtGSU5JU0hbXCJVTlNBRkVcIl0gPSAyXSA9IFwiVU5TQUZFXCI7XG59KShGSU5JU0ggPSBleHBvcnRzLkZJTklTSCB8fCAoZXhwb3J0cy5GSU5JU0ggPSB7fSkpO1xuZXhwb3J0cy5BTFBIQSA9IFtdO1xuZm9yIChsZXQgaSA9ICdBJy5jaGFyQ29kZUF0KDApOyBpIDw9ICdaJy5jaGFyQ29kZUF0KDApOyBpKyspIHtcbiAgICAvLyBVcHBlciBjYXNlXG4gICAgZXhwb3J0cy5BTFBIQS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xuICAgIC8vIExvd2VyIGNhc2VcbiAgICBleHBvcnRzLkFMUEhBLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMHgyMCkpO1xufVxuZXhwb3J0cy5OVU1fTUFQID0ge1xuICAgIDA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsXG4gICAgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSxcbn07XG5leHBvcnRzLkhFWF9NQVAgPSB7XG4gICAgMDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCxcbiAgICA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LFxuICAgIEE6IDBYQSwgQjogMFhCLCBDOiAwWEMsIEQ6IDBYRCwgRTogMFhFLCBGOiAwWEYsXG4gICAgYTogMHhhLCBiOiAweGIsIGM6IDB4YywgZDogMHhkLCBlOiAweGUsIGY6IDB4Zixcbn07XG5leHBvcnRzLk5VTSA9IFtcbiAgICAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG5dO1xuZXhwb3J0cy5BTFBIQU5VTSA9IGV4cG9ydHMuQUxQSEEuY29uY2F0KGV4cG9ydHMuTlVNKTtcbmV4cG9ydHMuTUFSSyA9IFsnLScsICdfJywgJy4nLCAnIScsICd+JywgJyonLCAnXFwnJywgJygnLCAnKSddO1xuZXhwb3J0cy5VU0VSSU5GT19DSEFSUyA9IGV4cG9ydHMuQUxQSEFOVU1cbiAgICAuY29uY2F0KGV4cG9ydHMuTUFSSylcbiAgICAuY29uY2F0KFsnJScsICc7JywgJzonLCAnJicsICc9JywgJysnLCAnJCcsICcsJ10pO1xuLy8gVE9ETyhpbmR1dG55KTogdXNlIFJGQ1xuZXhwb3J0cy5TVFJJQ1RfVVJMX0NIQVIgPSBbXG4gICAgJyEnLCAnXCInLCAnJCcsICclJywgJyYnLCAnXFwnJyxcbiAgICAnKCcsICcpJywgJyonLCAnKycsICcsJywgJy0nLCAnLicsICcvJyxcbiAgICAnOicsICc7JywgJzwnLCAnPScsICc+JyxcbiAgICAnQCcsICdbJywgJ1xcXFwnLCAnXScsICdeJywgJ18nLFxuICAgICdgJyxcbiAgICAneycsICd8JywgJ30nLCAnficsXG5dLmNvbmNhdChleHBvcnRzLkFMUEhBTlVNKTtcbmV4cG9ydHMuVVJMX0NIQVIgPSBleHBvcnRzLlNUUklDVF9VUkxfQ0hBUlxuICAgIC5jb25jYXQoWydcXHQnLCAnXFxmJ10pO1xuLy8gQWxsIGNoYXJhY3RlcnMgd2l0aCAweDgwIGJpdCBzZXQgdG8gMVxuZm9yIChsZXQgaSA9IDB4ODA7IGkgPD0gMHhmZjsgaSsrKSB7XG4gICAgZXhwb3J0cy5VUkxfQ0hBUi5wdXNoKGkpO1xufVxuZXhwb3J0cy5IRVggPSBleHBvcnRzLk5VTS5jb25jYXQoWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRiddKTtcbi8qIFRva2VucyBhcyBkZWZpbmVkIGJ5IHJmYyAyNjE2LiBBbHNvIGxvd2VyY2FzZXMgdGhlbS5cbiAqICAgICAgICB0b2tlbiAgICAgICA9IDEqPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIHNlcGFyYXRvcnM+XG4gKiAgICAgc2VwYXJhdG9ycyAgICAgPSBcIihcIiB8IFwiKVwiIHwgXCI8XCIgfCBcIj5cIiB8IFwiQFwiXG4gKiAgICAgICAgICAgICAgICAgICAgfCBcIixcIiB8IFwiO1wiIHwgXCI6XCIgfCBcIlxcXCIgfCA8XCI+XG4gKiAgICAgICAgICAgICAgICAgICAgfCBcIi9cIiB8IFwiW1wiIHwgXCJdXCIgfCBcIj9cIiB8IFwiPVwiXG4gKiAgICAgICAgICAgICAgICAgICAgfCBcIntcIiB8IFwifVwiIHwgU1AgfCBIVFxuICovXG5leHBvcnRzLlNUUklDVF9UT0tFTiA9IFtcbiAgICAnIScsICcjJywgJyQnLCAnJScsICcmJywgJ1xcJycsXG4gICAgJyonLCAnKycsICctJywgJy4nLFxuICAgICdeJywgJ18nLCAnYCcsXG4gICAgJ3wnLCAnficsXG5dLmNvbmNhdChleHBvcnRzLkFMUEhBTlVNKTtcbmV4cG9ydHMuVE9LRU4gPSBleHBvcnRzLlNUUklDVF9UT0tFTi5jb25jYXQoWycgJ10pO1xuLypcbiAqIFZlcmlmeSB0aGF0IGEgY2hhciBpcyBhIHZhbGlkIHZpc2libGUgKHByaW50YWJsZSkgVVMtQVNDSUlcbiAqIGNoYXJhY3RlciBvciAleDgwLUZGXG4gKi9cbmV4cG9ydHMuSEVBREVSX0NIQVJTID0gWydcXHQnXTtcbmZvciAobGV0IGkgPSAzMjsgaSA8PSAyNTU7IGkrKykge1xuICAgIGlmIChpICE9PSAxMjcpIHtcbiAgICAgICAgZXhwb3J0cy5IRUFERVJfQ0hBUlMucHVzaChpKTtcbiAgICB9XG59XG4vLyAnLCcgPSBcXHg0NFxuZXhwb3J0cy5DT05ORUNUSU9OX1RPS0VOX0NIQVJTID0gZXhwb3J0cy5IRUFERVJfQ0hBUlMuZmlsdGVyKChjKSA9PiBjICE9PSA0NCk7XG5leHBvcnRzLk1BSk9SID0gZXhwb3J0cy5OVU1fTUFQO1xuZXhwb3J0cy5NSU5PUiA9IGV4cG9ydHMuTUFKT1I7XG52YXIgSEVBREVSX1NUQVRFO1xuKGZ1bmN0aW9uIChIRUFERVJfU1RBVEUpIHtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiR0VORVJBTFwiXSA9IDBdID0gXCJHRU5FUkFMXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkNPTk5FQ1RJT05cIl0gPSAxXSA9IFwiQ09OTkVDVElPTlwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05URU5UX0xFTkdUSFwiXSA9IDJdID0gXCJDT05URU5UX0xFTkdUSFwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJUUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDNdID0gXCJUUkFOU0ZFUl9FTkNPRElOR1wiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJVUEdSQURFXCJdID0gNF0gPSBcIlVQR1JBREVcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCJdID0gNV0gPSBcIkNPTk5FQ1RJT05fS0VFUF9BTElWRVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05ORUNUSU9OX0NMT1NFXCJdID0gNl0gPSBcIkNPTk5FQ1RJT05fQ0xPU0VcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OTkVDVElPTl9VUEdSQURFXCJdID0gN10gPSBcIkNPTk5FQ1RJT05fVVBHUkFERVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJUUkFOU0ZFUl9FTkNPRElOR19DSFVOS0VEXCJdID0gOF0gPSBcIlRSQU5TRkVSX0VOQ09ESU5HX0NIVU5LRURcIjtcbn0pKEhFQURFUl9TVEFURSA9IGV4cG9ydHMuSEVBREVSX1NUQVRFIHx8IChleHBvcnRzLkhFQURFUl9TVEFURSA9IHt9KSk7XG5leHBvcnRzLlNQRUNJQUxfSEVBREVSUyA9IHtcbiAgICAnY29ubmVjdGlvbic6IEhFQURFUl9TVEFURS5DT05ORUNUSU9OLFxuICAgICdjb250ZW50LWxlbmd0aCc6IEhFQURFUl9TVEFURS5DT05URU5UX0xFTkdUSCxcbiAgICAncHJveHktY29ubmVjdGlvbic6IEhFQURFUl9TVEFURS5DT05ORUNUSU9OLFxuICAgICd0cmFuc2Zlci1lbmNvZGluZyc6IEhFQURFUl9TVEFURS5UUkFOU0ZFUl9FTkNPRElORyxcbiAgICAndXBncmFkZSc6IEhFQURFUl9TVEFURS5VUEdSQURFLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTUEVDSUFMX0hFQURFUlMiLCJIRUFERVJfU1RBVEUiLCJNSU5PUiIsIk1BSk9SIiwiQ09OTkVDVElPTl9UT0tFTl9DSEFSUyIsIkhFQURFUl9DSEFSUyIsIlRPS0VOIiwiU1RSSUNUX1RPS0VOIiwiSEVYIiwiVVJMX0NIQVIiLCJTVFJJQ1RfVVJMX0NIQVIiLCJVU0VSSU5GT19DSEFSUyIsIk1BUksiLCJBTFBIQU5VTSIsIk5VTSIsIkhFWF9NQVAiLCJOVU1fTUFQIiwiQUxQSEEiLCJGSU5JU0giLCJIX01FVEhPRF9NQVAiLCJNRVRIT0RfTUFQIiwiTUVUSE9EU19SVFNQIiwiTUVUSE9EU19JQ0UiLCJNRVRIT0RTX0hUVFAiLCJNRVRIT0RTIiwiTEVOSUVOVF9GTEFHUyIsIkZMQUdTIiwiVFlQRSIsIkVSUk9SIiwidXRpbHNfMSIsInJlcXVpcmUiLCJERUxFVEUiLCJHRVQiLCJIRUFEIiwiUE9TVCIsIlBVVCIsIkNPTk5FQ1QiLCJPUFRJT05TIiwiVFJBQ0UiLCJDT1BZIiwiTE9DSyIsIk1LQ09MIiwiTU9WRSIsIlBST1BGSU5EIiwiUFJPUFBBVENIIiwiU0VBUkNIIiwiVU5MT0NLIiwiQklORCIsIlJFQklORCIsIlVOQklORCIsIkFDTCIsIlJFUE9SVCIsIk1LQUNUSVZJVFkiLCJDSEVDS09VVCIsIk1FUkdFIiwiTk9USUZZIiwiU1VCU0NSSUJFIiwiVU5TVUJTQ1JJQkUiLCJQQVRDSCIsIlBVUkdFIiwiTUtDQUxFTkRBUiIsIkxJTksiLCJVTkxJTksiLCJQUkkiLCJTT1VSQ0UiLCJERVNDUklCRSIsIkFOTk9VTkNFIiwiU0VUVVAiLCJQTEFZIiwiUEFVU0UiLCJURUFSRE9XTiIsIkdFVF9QQVJBTUVURVIiLCJTRVRfUEFSQU1FVEVSIiwiUkVESVJFQ1QiLCJSRUNPUkQiLCJGTFVTSCIsImVudW1Ub01hcCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwidGVzdCIsImkiLCJjaGFyQ29kZUF0IiwicHVzaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImNvbmNhdCIsImZpbHRlciIsIkNPTk5FQ1RJT04iLCJDT05URU5UX0xFTkdUSCIsIlRSQU5TRkVSX0VOQ09ESU5HIiwiVVBHUkFERSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/llhttp/constants.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/llhttp/llhttp-wasm.js":
/*!***********************************************************!*\
  !*** ../../node_modules/undici/lib/llhttp/llhttp-wasm.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("module.exports = \"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9sbGh0dHAtd2FzbS5qcz82YmUxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gJ0FHRnpiUUVBQUFBQk1BaGdBWDhCZjJBRGYzOS9BWDlnQkg5L2YzOEJmMkFBQUdBRGYzOS9BR0FCZndCZ0FuOS9BR0FHZjM5L2YzOS9BQUxMQVFnRFpXNTJHSGRoYzIxZmIyNWZhR1ZoWkdWeWMxOWpiMjF3YkdWMFpRQUNBMlZ1ZGhWM1lYTnRYMjl1WDIxbGMzTmhaMlZmWW1WbmFXNEFBQU5sYm5ZTGQyRnpiVjl2Ymw5MWNtd0FBUU5sYm5ZT2QyRnpiVjl2Ymw5emRHRjBkWE1BQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZlptbGxiR1FBQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZmRtRnNkV1VBQVFObGJuWU1kMkZ6YlY5dmJsOWliMlI1QUFFRFpXNTJHSGRoYzIxZmIyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpRQUFBMFpGQXdNRUFBQUZBQUFBQUFBQUJRRUZBQVVGQlFBQUJnQUFBQUFHQmdZR0FRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFBQUJBUWNBQUFVRkF3QUJCQVVCY0FFU0VnVURBUUFDQmdnQmZ3RkJnTlFFQ3dmUkJTSUdiV1Z0YjNKNUFnQUxYMmx1YVhScFlXeHBlbVVBQ1JsZlgybHVaR2x5WldOMFgyWjFibU4wYVc5dVgzUmhZbXhsQVFBTGJHeG9kSFJ3WDJsdWFYUUFDaGhzYkdoMGRIQmZjMmh2ZFd4a1gydGxaWEJmWVd4cGRtVUFRUXhzYkdoMGRIQmZZV3hzYjJNQURBWnRZV3hzYjJNQVJndHNiR2gwZEhCZlpuSmxaUUFOQkdaeVpXVUFTQTlzYkdoMGRIQmZaMlYwWDNSNWNHVUFEaFZzYkdoMGRIQmZaMlYwWDJoMGRIQmZiV0ZxYjNJQUR4VnNiR2gwZEhCZloyVjBYMmgwZEhCZmJXbHViM0lBRUJGc2JHaDBkSEJmWjJWMFgyMWxkR2h2WkFBUkZteHNhSFIwY0Y5blpYUmZjM1JoZEhWelgyTnZaR1VBRWhKc2JHaDBkSEJmWjJWMFgzVndaM0poWkdVQUV3eHNiR2gwZEhCZmNtVnpaWFFBRkE1c2JHaDBkSEJmWlhobFkzVjBaUUFWRkd4c2FIUjBjRjl6WlhSMGFXNW5jMTlwYm1sMEFCWU5iR3hvZEhSd1gyWnBibWx6YUFBWERHeHNhSFIwY0Y5d1lYVnpaUUFZRFd4c2FIUjBjRjl5WlhOMWJXVUFHUnRzYkdoMGRIQmZjbVZ6ZFcxbFgyRm1kR1Z5WDNWd1ozSmhaR1VBR2hCc2JHaDBkSEJmWjJWMFgyVnljbTV2QUJzWGJHeG9kSFJ3WDJkbGRGOWxjbkp2Y2w5eVpXRnpiMjRBSEJkc2JHaDBkSEJmYzJWMFgyVnljbTl5WDNKbFlYTnZiZ0FkRkd4c2FIUjBjRjluWlhSZlpYSnliM0pmY0c5ekFCNFJiR3hvZEhSd1gyVnljbTV2WDI1aGJXVUFIeEpzYkdoMGRIQmZiV1YwYUc5a1gyNWhiV1VBSUJKc2JHaDBkSEJmYzNSaGRIVnpYMjVoYldVQUlScHNiR2gwZEhCZmMyVjBYMnhsYm1sbGJuUmZhR1ZoWkdWeWN3QWlJV3hzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjlqYUhWdWEyVmtYMnhsYm1kMGFBQWpIV3hzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjlyWldWd1gyRnNhWFpsQUNRa2JHeG9kSFJ3WDNObGRGOXNaVzVwWlc1MFgzUnlZVzV6Wm1WeVgyVnVZMjlrYVc1bkFDVVliR3hvZEhSd1gyMWxjM05oWjJWZmJtVmxaSE5mWlc5bUFEOEpGd0VBUVFFTEVRRUNBd1FGQ3dZSE5UazNNUzh0SnlzcENzTGdBa1VDQUFzSUFCQ0lnSUNBQUFzWkFDQUFFTUtBZ0lBQUdpQUFJQUkyQWpnZ0FDQUJPZ0FvQ3h3QUlBQWdBQzhCTWlBQUxRQXVJQUFRd1lDQWdBQVFnSUNBZ0FBTEtnRUJmMEhBQUJER2dJQ0FBQ0lCRU1LQWdJQUFHaUFCUVlDSWdJQUFOZ0k0SUFFZ0FEb0FLQ0FCQ3dvQUlBQVF5SUNBZ0FBTEJ3QWdBQzBBS0FzSEFDQUFMUUFxQ3djQUlBQXRBQ3NMQndBZ0FDMEFLUXNIQUNBQUx3RXlDd2NBSUFBdEFDNExSUUVFZnlBQUtBSVlJUUVnQUMwQUxTRUNJQUF0QUNnaEF5QUFLQUk0SVFRZ0FCRENnSUNBQUJvZ0FDQUVOZ0k0SUFBZ0F6b0FLQ0FBSUFJNkFDMGdBQ0FCTmdJWUN4RUFJQUFnQVNBQklBSnFFTU9BZ0lBQUN4QUFJQUJCQUVIY0FCRE1nSUNBQUJvTFp3RUJmMEVBSVFFQ1FDQUFLQUlNRFFBQ1FBSkFBa0FDUUNBQUxRQXZEZ01CQUFNQ0N5QUFLQUk0SWdGRkRRQWdBU2dDTENJQlJRMEFJQUFnQVJHQWdJQ0FBQUFpQVEwREMwRUFEd3NReW9DQWdBQUFDeUFBUWNPV2dJQUFOZ0lRUVE0aEFRc2dBUXNlQUFKQUlBQW9BZ3dOQUNBQVFkR2JnSUFBTmdJUUlBQkJGVFlDREFzTEZnQUNRQ0FBS0FJTVFSVkhEUUFnQUVFQU5nSU1Dd3NXQUFKQUlBQW9BZ3hCRmtjTkFDQUFRUUEyQWd3TEN3Y0FJQUFvQWd3TEJ3QWdBQ2dDRUFzSkFDQUFJQUUyQWhBTEJ3QWdBQ2dDRkFzaUFBSkFJQUJCSkVrTkFCREtnSUNBQUFBTElBQkJBblJCb0xPQWdBQnFLQUlBQ3lJQUFrQWdBRUV1U1EwQUVNcUFnSUFBQUFzZ0FFRUNkRUd3dElDQUFHb29BZ0FMN2dzQkFYOUI2NmlBZ0FBaEFRSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCbkg5cUR2UURZMklBQVdGaFlXRmhZUUlEQkFWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhCZ2NJQ1FvTERBME9EMkZoWVdGaEVHRmhZV0ZoWVdGaFlXRmhFV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZUklURkJVV0Z4Z1pHaHRoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoSEIwZUh5QWhJaU1rSlNZbktDa3FLeXd0TGk4d01USXpORFUyWVRjNE9UcGhZV0ZoWVdGaFlUdGhZV0U4WVdGaFlUMCtQMkZoWVdGaFlXRmhRR0ZoUVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlVSkRSRVZHUjBoSlNrdE1UVTVQVUZGU1UyRmhZV0ZoWVdGaFZGVldWMWhaV2x0aFhGMWhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZlWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWDJCaEMwSGhwNENBQUE4TFFhU2hnSUFBRHd0Qnk2eUFnQUFQQzBIK3NZQ0FBQThMUWNDa2dJQUFEd3RCcTZTQWdBQVBDMEdOcUlDQUFBOExRZUttZ0lBQUR3dEJnTENBZ0FBUEMwRzVyNENBQUE4TFFkZWtnSUFBRHd0Qjc1K0FnQUFQQzBIaG40Q0FBQThMUWZxZmdJQUFEd3RCOHFDQWdBQVBDMEdvcjRDQUFBOExRYTZ5Z0lBQUR3dEJpTENBZ0FBUEMwSHNwNENBQUE4TFFZS2lnSUFBRHd0QmpwMkFnQUFQQzBIUXJvQ0FBQThMUWNxamdJQUFEd3RCeGJLQWdBQVBDMEhmbklDQUFBOExRZEtjZ0lBQUR3dEJ4S0NBZ0FBUEMwSFhvSUNBQUE4TFFhS2ZnSUFBRHd0QjdhNkFnQUFQQzBHcnNJQ0FBQThMUWRTbGdJQUFEd3RCeks2QWdBQVBDMEg2cm9DQUFBOExRZnlyZ0lBQUR3dEIwckNBZ0FBUEMwSHhuWUNBQUE4TFFidWdnSUFBRHd0Qjk2dUFnQUFQQzBHUXNZQ0FBQThMUWRleGdJQUFEd3RCb3EyQWdBQVBDMEhVcDRDQUFBOExRZUNyZ0lBQUR3dEJuNnlBZ0FBUEMwSHJzWUNBQUE4TFFkV2ZnSUFBRHd0QnlyR0FnQUFQQzBIZXBZQ0FBQThMUWRTZWdJQUFEd3RCOUp5QWdBQVBDMEduc29DQUFBOExRYkdkZ0lBQUR3dEJvSjJBZ0FBUEMwRzVzWUNBQUE4TFFieXdnSUFBRHd0QmtxR0FnQUFQQzBHenBvQ0FBQThMUWVtc2dJQUFEd3RCcko2QWdBQVBDMEhVcTRDQUFBOExRZmVtZ0lBQUR3dEJnS2FBZ0FBUEMwR3dvWUNBQUE4TFFmNmVnSUFBRHd0QmphT0FnQUFQQzBHSnJZQ0FBQThMUWZlaWdJQUFEd3RCb0xHQWdBQVBDMEd1bjRDQUFBOExRY2FsZ0lBQUR3dEI2SjZBZ0FBUEMwR1Rvb0NBQUE4TFFjS3ZnSUFBRHd0Qnc1MkFnQUFQQzBHTHJJQ0FBQThMUWVHZGdJQUFEd3RCamErQWdBQVBDMEhxb1lDQUFBOExRYlN0Z0lBQUR3dEIwcStBZ0FBUEMwSGZzb0NBQUE4TFFkS3lnSUFBRHd0QjhMQ0FnQUFQQzBHcG9vQ0FBQThMUWZtamdJQUFEd3RCbVo2QWdBQVBDMEcxcklDQUFBOExRWnV3Z0lBQUR3dEJrcktBZ0FBUEMwRzJxNENBQUE4TFFjS2lnSUFBRHd0QitMS0FnQUFQQzBHZXBZQ0FBQThMUWRDaWdJQUFEd3RCdXA2QWdBQVBDMEdCbm9DQUFBOExFTXFBZ0lBQUFBdEIxcUdBZ0FBaEFRc2dBUXNXQUNBQUlBQXRBQzFCL2dGeElBRkJBRWR5T2dBdEN4a0FJQUFnQUMwQUxVSDlBWEVnQVVFQVIwRUJkSEk2QUMwTEdRQWdBQ0FBTFFBdFFmc0JjU0FCUVFCSFFRSjBjam9BTFFzWkFDQUFJQUF0QUMxQjl3RnhJQUZCQUVkQkEzUnlPZ0F0Q3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BZ0FpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDQkNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRY2FSZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJd0lnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMGtCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FnZ2lCRVVOQUNBQUlBRWdBaUFCYXlBRUVZR0FnSUFBQUNJRFFYOUhEUUFnQUVIMmlvQ0FBRFlDRUVFWUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NOQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0SkFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUlNSWdSRkRRQWdBQ0FCSUFJZ0FXc2dCQkdCZ0lDQUFBQWlBMEYvUncwQUlBQkI3WnFBZ0FBMkFoQkJHQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWpnaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxTUUVDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ0VDSUVSUTBBSUFBZ0FTQUNJQUZySUFRUmdZQ0FnQUFBSWdOQmYwY05BQ0FBUVpXUWdJQUFOZ0lRUVJnaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSThJZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQzBrQkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BaFFpQkVVTkFDQUFJQUVnQWlBQmF5QUVFWUdBZ0lBQUFDSURRWDlIRFFBZ0FFR3FtNENBQURZQ0VFRVlJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDUUNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEpBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJWUlnUkZEUUFnQUNBQklBSWdBV3NnQkJHQmdJQ0FBQUFpQTBGL1J3MEFJQUJCN1pPQWdBQTJBaEJCR0NFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FrUWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NKQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUlzSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwa0JBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWlnaUJFVU5BQ0FBSUFFZ0FpQUJheUFFRVlHQWdJQUFBQ0lEUVg5SERRQWdBRUgyaUlDQUFEWUNFRUVZSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ1VDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSWNJZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQndwbUFnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9Ba2dpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDSUNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRWlNVZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FKTUlnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FsUWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NXQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0RkFRRi9Ba0FDUUNBQUx3RXdRUlJ4UVJSSERRQkJBU0VESUFBdEFDaEJBVVlOQVNBQUx3RXlRZVVBUmlFRERBRUxJQUF0QUNsQkJVWWhBd3NnQUNBRE9nQXVRUUFML2dFQkEzOUJBU0VEQWtBZ0FDOEJNQ0lFUVFoeERRQWdBQ2tESUVJQVVpRURDd0pBQWtBZ0FDMEFMa1VOQUVFQklRVWdBQzBBS1VFRlJnMEJRUUVoQlNBRVFjQUFjVVVnQTNGQkFVY05BUXRCQUNFRklBUkJ3QUJ4RFFCQkFpRUZJQVJCLy84RGNTSURRUWh4RFFBQ1FDQURRWUFFY1VVTkFBSkFJQUF0QUNoQkFVY05BQ0FBTFFBdFFRcHhEUUJCQlE4TFFRUVBDd0pBSUFOQklIRU5BQUpBSUFBdEFDaEJBVVlOQUNBQUx3RXlRZi8vQTNFaUFFR2NmMnBCNUFCSkRRQWdBRUhNQVVZTkFDQUFRYkFDUmcwQVFRUWhCU0FFUVNoeFJRMENJQU5CaUFSeFFZQUVSZzBDQzBFQUR3dEJBRUVESUFBcEF5QlFHeUVGQ3lBRkMySUJBbjlCQUNFQkFrQWdBQzBBS0VFQlJnMEFJQUF2QVRKQi8vOERjU0lDUVp4L2FrSGtBRWtOQUNBQ1Fjd0JSZzBBSUFKQnNBSkdEUUFnQUM4Qk1DSUFRY0FBY1EwQVFRRWhBU0FBUVlnRWNVR0FCRVlOQUNBQVFTaHhSU0VCQ3lBQkM2Y0JBUU4vQWtBQ1FBSkFJQUF0QUNwRkRRQWdBQzBBSzBVTkFFRUFJUU1nQUM4Qk1DSUVRUUp4UlEwQkRBSUxRUUFoQXlBQUx3RXdJZ1JCQVhGRkRRRUxRUUVoQXlBQUxRQW9RUUZHRFFBZ0FDOEJNa0gvL3dOeElnVkJuSDlxUWVRQVNRMEFJQVZCekFGR0RRQWdCVUd3QWtZTkFDQUVRY0FBY1EwQVFRQWhBeUFFUVlnRWNVR0FCRVlOQUNBRVFTaHhRUUJISVFNTElBQkJBRHNCTUNBQVFRQTZBQzhnQXd1WkFRRUNmd0pBQWtBQ1FDQUFMUUFxUlEwQUlBQXRBQ3RGRFFCQkFDRUJJQUF2QVRBaUFrRUNjVVVOQVF3Q0MwRUFJUUVnQUM4Qk1DSUNRUUZ4UlEwQkMwRUJJUUVnQUMwQUtFRUJSZzBBSUFBdkFUSkIvLzhEY1NJQVFaeC9ha0hrQUVrTkFDQUFRY3dCUmcwQUlBQkJzQUpHRFFBZ0FrSEFBSEVOQUVFQUlRRWdBa0dJQkhGQmdBUkdEUUFnQWtFb2NVRUFSeUVCQ3lBQkMxa0FJQUJCR0dwQ0FEY0RBQ0FBUWdBM0F3QWdBRUU0YWtJQU53TUFJQUJCTUdwQ0FEY0RBQ0FBUVNocVFnQTNBd0FnQUVFZ2FrSUFOd01BSUFCQkVHcENBRGNEQUNBQVFRaHFRZ0EzQXdBZ0FFSGRBVFlDSEVFQUMzc0JBWDhDUUNBQUtBSU1JZ01OQUFKQUlBQW9BZ1JGRFFBZ0FDQUJOZ0lFQ3dKQUlBQWdBU0FDRU1TQWdJQUFJZ01OQUNBQUtBSU1Ed3NnQUNBRE5nSWNRUUFoQXlBQUtBSUVJZ0ZGRFFBZ0FDQUJJQUlnQUNnQ0NCR0JnSUNBQUFBaUFVVU5BQ0FBSUFJMkFoUWdBQ0FCTmdJTUlBRWhBd3NnQXd2azh3RUREbjhEZmdSL0k0Q0FnSUFBUVJCcklnTWtnSUNBZ0FBZ0FTRUVJQUVoQlNBQklRWWdBU0VISUFFaENDQUJJUWtnQVNFS0lBRWhDeUFCSVF3Z0FTRU5JQUVoRGlBQklROENRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBQ2dDSENJUVFYOXFEdDBCMmdFQjJRRUNBd1FGQmdjSUNRb0xEQTBPMkFFUEVOY0JFUkxXQVJNVUZSWVhHQmthRytBQjN3RWNIUjdWQVI4Z0lTSWpKQ1hVQVNZbktDa3FLeXpUQWRJQkxTN1JBZEFCTHpBeE1qTTBOVFkzT0RrNk96dzlQajlBUVVKRFJFVkcyd0ZIU0VsS3p3SE9BVXZOQVV6TUFVMU9UMUJSVWxOVVZWWlhXRmxhVzF4ZFhsOWdZV0pqWkdWbVoyaHBhbXRzYlc1dmNIRnljM1IxZG5kNGVYcDdmSDErZjRBQmdRR0NBWU1CaEFHRkFZWUJod0dJQVlrQmlnR0xBWXdCalFHT0FZOEJrQUdSQVpJQmt3R1VBWlVCbGdHWEFaZ0JtUUdhQVpzQm5BR2RBWjRCbndHZ0FhRUJvZ0dqQWFRQnBRR21BYWNCcUFHcEFhb0Jxd0dzQWEwQnJnR3ZBYkFCc1FHeUFiTUJ0QUcxQWJZQnR3SExBY29CdUFISkFia0J5QUc2QWJzQnZBRzlBYjRCdndIQUFjRUJ3Z0hEQWNRQnhRSEdBUURjQVF0QkFDRVFETVlCQzBFT0lSQU14UUVMUVEwaEVBekVBUXRCRHlFUURNTUJDMEVRSVJBTXdnRUxRUk1oRUF6QkFRdEJGQ0VRRE1BQkMwRVZJUkFNdndFTFFSWWhFQXkrQVF0QkZ5RVFETDBCQzBFWUlSQU12QUVMUVJraEVBeTdBUXRCR2lFUURMb0JDMEViSVJBTXVRRUxRUndoRUF5NEFRdEJDQ0VRRExjQkMwRWRJUkFNdGdFTFFTQWhFQXkxQVF0Qkh5RVFETFFCQzBFSElSQU1zd0VMUVNFaEVBeXlBUXRCSWlFUURMRUJDMEVlSVJBTXNBRUxRU01oRUF5dkFRdEJFaUVRREs0QkMwRVJJUkFNclFFTFFTUWhFQXlzQVF0QkpTRVFES3NCQzBFbUlSQU1xZ0VMUVNjaEVBeXBBUXRCd3dFaEVBeW9BUXRCS1NFUURLY0JDMEVySVJBTXBnRUxRU3doRUF5bEFRdEJMU0VRREtRQkMwRXVJUkFNb3dFTFFTOGhFQXlpQVF0QnhBRWhFQXloQVF0Qk1DRVFES0FCQzBFMElSQU1ud0VMUVF3aEVBeWVBUXRCTVNFUURKMEJDMEV5SVJBTW5BRUxRVE1oRUF5YkFRdEJPU0VRREpvQkMwRTFJUkFNbVFFTFFjVUJJUkFNbUFFTFFRc2hFQXlYQVF0Qk9pRVFESllCQzBFMklSQU1sUUVMUVFvaEVBeVVBUXRCTnlFUURKTUJDMEU0SVJBTWtnRUxRVHdoRUF5UkFRdEJPeUVRREpBQkMwRTlJUkFNandFTFFRa2hFQXlPQVF0QktDRVFESTBCQzBFK0lSQU1qQUVMUVQ4aEVBeUxBUXRCd0FBaEVBeUtBUXRCd1FBaEVBeUpBUXRCd2dBaEVBeUlBUXRCd3dBaEVBeUhBUXRCeEFBaEVBeUdBUXRCeFFBaEVBeUZBUXRCeGdBaEVBeUVBUXRCS2lFUURJTUJDMEhIQUNFUURJSUJDMEhJQUNFUURJRUJDMEhKQUNFUURJQUJDMEhLQUNFUURIOExRY3NBSVJBTWZndEJ6UUFoRUF4OUMwSE1BQ0VRREh3TFFjNEFJUkFNZXd0Qnp3QWhFQXg2QzBIUUFDRVFESGtMUWRFQUlSQU1lQXRCMGdBaEVBeDNDMEhUQUNFUURIWUxRZFFBSVJBTWRRdEIxZ0FoRUF4MEMwSFZBQ0VRREhNTFFRWWhFQXh5QzBIWEFDRVFESEVMUVFVaEVBeHdDMEhZQUNFUURHOExRUVFoRUF4dUMwSFpBQ0VRREcwTFFkb0FJUkFNYkF0QjJ3QWhFQXhyQzBIY0FDRVFER29MUVFNaEVBeHBDMEhkQUNFUURHZ0xRZDRBSVJBTVp3dEIzd0FoRUF4bUMwSGhBQ0VRREdVTFFlQUFJUkFNWkF0QjRnQWhFQXhqQzBIakFDRVFER0lMUVFJaEVBeGhDMEhrQUNFUURHQUxRZVVBSVJBTVh3dEI1Z0FoRUF4ZUMwSG5BQ0VRREYwTFFlZ0FJUkFNWEF0QjZRQWhFQXhiQzBIcUFDRVFERm9MUWVzQUlSQU1XUXRCN0FBaEVBeFlDMEh0QUNFUURGY0xRZTRBSVJBTVZndEI3d0FoRUF4VkMwSHdBQ0VRREZRTFFmRUFJUkFNVXd0QjhnQWhFQXhTQzBIekFDRVFERkVMUWZRQUlSQU1VQXRCOVFBaEVBeFBDMEgyQUNFUURFNExRZmNBSVJBTVRRdEIrQUFoRUF4TUMwSDVBQ0VRREVzTFFmb0FJUkFNU2d0Qit3QWhFQXhKQzBIOEFDRVFERWdMUWYwQUlSQU1Sd3RCL2dBaEVBeEdDMEgvQUNFUURFVUxRWUFCSVJBTVJBdEJnUUVoRUF4REMwR0NBU0VRREVJTFFZTUJJUkFNUVF0QmhBRWhFQXhBQzBHRkFTRVFERDhMUVlZQklSQU1QZ3RCaHdFaEVBdzlDMEdJQVNFUUREd0xRWWtCSVJBTU93dEJpZ0VoRUF3NkMwR0xBU0VRRERrTFFZd0JJUkFNT0F0QmpRRWhFQXczQzBHT0FTRVFERFlMUVk4QklSQU1OUXRCa0FFaEVBdzBDMEdSQVNFUURETUxRWklCSVJBTU1ndEJrd0VoRUF3eEMwR1VBU0VRRERBTFFaVUJJUkFNTHd0QmxnRWhFQXd1QzBHWEFTRVFEQzBMUVpnQklSQU1MQXRCbVFFaEVBd3JDMEdhQVNFUURDb0xRWnNCSVJBTUtRdEJuQUVoRUF3b0MwR2RBU0VRRENjTFFaNEJJUkFNSmd0Qm53RWhFQXdsQzBHZ0FTRVFEQ1FMUWFFQklSQU1Jd3RCb2dFaEVBd2lDMEdqQVNFUURDRUxRYVFCSVJBTUlBdEJwUUVoRUF3ZkMwR21BU0VRREI0TFFhY0JJUkFNSFF0QnFBRWhFQXdjQzBHcEFTRVFEQnNMUWFvQklSQU1HZ3RCcXdFaEVBd1pDMEdzQVNFUURCZ0xRYTBCSVJBTUZ3dEJyZ0VoRUF3V0MwRUJJUkFNRlF0QnJ3RWhFQXdVQzBHd0FTRVFEQk1MUWJFQklSQU1FZ3RCc3dFaEVBd1JDMEd5QVNFUURCQUxRYlFCSVJBTUR3dEJ0UUVoRUF3T0MwRzJBU0VRREEwTFFiY0JJUkFNREF0QnVBRWhFQXdMQzBHNUFTRVFEQW9MUWJvQklSQU1DUXRCdXdFaEVBd0lDMEhHQVNFUURBY0xRYndCSVJBTUJndEJ2UUVoRUF3RkMwRytBU0VRREFRTFFiOEJJUkFNQXd0QndBRWhFQXdDQzBIQ0FTRVFEQUVMUWNFQklSQUxBMEFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBUURzY0JBQUVDQXdRRkJnY0lDUW9MREEwT0R4QVJFaE1VRlJZWEdCa2FHeHdlSHlBaEl5VW9QMEJCUkVWR1IwaEpTa3RNVFU5UVVWSlQzZ05YV1Z0Y1hXQmlaV1puYUdscWEyeHRiM0J4Y25OMGRYWjNlSGw2ZTN4OWZvQUJnZ0dGQVlZQmh3R0pBWXNCakFHTkFZNEJqd0dRQVpFQmxBR1ZBWllCbHdHWUFaa0JtZ0diQVp3Qm5RR2VBWjhCb0FHaEFhSUJvd0drQWFVQnBnR25BYWdCcVFHcUFhc0JyQUd0QWE0QnJ3R3dBYkVCc2dHekFiUUJ0UUcyQWJjQnVBRzVBYm9CdXdHOEFiMEJ2Z0cvQWNBQndRSENBY01CeEFIRkFjWUJ4d0hJQWNrQnlnSExBY3dCelFIT0FjOEIwQUhSQWRJQjB3SFVBZFVCMWdIWEFkZ0IyUUhhQWRzQjNBSGRBZDRCNEFIaEFlSUI0d0hrQWVVQjVnSG5BZWdCNlFIcUFlc0I3QUh0QWU0Qjd3SHdBZkVCOGdIekFaa0NwQUt3QXY0Qy9nSUxJQUVpQkNBQ1J3M3pBVUhkQVNFUURQOERDeUFCSWhBZ0FrY04zUUZCd3dFaEVBeitBd3NnQVNJQklBSkhEWkFCUWZjQUlSQU0vUU1MSUFFaUFTQUNSdzJHQVVIdkFDRVFEUHdEQ3lBQklnRWdBa2NOZjBIcUFDRVFEUHNEQ3lBQklnRWdBa2NOZTBIb0FDRVFEUG9EQ3lBQklnRWdBa2NOZUVIbUFDRVFEUGtEQ3lBQklnRWdBa2NOR2tFWUlSQU0rQU1MSUFFaUFTQUNSdzBVUVJJaEVBejNBd3NnQVNJQklBSkhEVmxCeFFBaEVBejJBd3NnQVNJQklBSkhEVXBCUHlFUURQVURDeUFCSWdFZ0FrY05TRUU4SVJBTTlBTUxJQUVpQVNBQ1J3MUJRVEVoRUF6ekF3c2dBQzBBTGtFQlJnM3JBd3lIQWdzZ0FDQUJJZ0VnQWhEQWdJQ0FBRUVCUnczbUFTQUFRZ0EzQXlBTTV3RUxJQUFnQVNJQklBSVF0SUNBZ0FBaUVBM25BU0FCSVFFTTlRSUxBa0FnQVNJQklBSkhEUUJCQmlFUURQQURDeUFBSUFGQkFXb2lBU0FDRUx1QWdJQUFJaEFONkFFZ0FTRUJEREVMSUFCQ0FEY0RJRUVTSVJBTTFRTUxJQUVpRUNBQ1J3MHJRUjBoRUF6dEF3c0NRQ0FCSWdFZ0FrWU5BQ0FCUVFGcUlRRkJFQ0VRRE5RREMwRUhJUkFNN0FNTElBQkNBQ0FBS1FNZ0loRWdBaUFCSWhCcnJTSVNmU0lUSUJNZ0VWWWJOd01nSUJFZ0VsWWlGRVVONVFGQkNDRVFET3NEQ3dKQUlBRWlBU0FDUmcwQUlBQkJpWUNBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUVVSVJBTTBnTUxRUWtoRUF6cUF3c2dBU0VCSUFBcEF5QlFEZVFCSUFFaEFRenlBZ3NDUUNBQklnRWdBa2NOQUVFTElSQU02UU1MSUFBZ0FVRUJhaUlCSUFJUXRvQ0FnQUFpRUEzbEFTQUJJUUVNOGdJTElBQWdBU0lCSUFJUXVJQ0FnQUFpRUEzbEFTQUJJUUVNOGdJTElBQWdBU0lCSUFJUXVJQ0FnQUFpRUEzbUFTQUJJUUVNRFFzZ0FDQUJJZ0VnQWhDNmdJQ0FBQ0lRRGVjQklBRWhBUXp3QWdzQ1FDQUJJZ0VnQWtjTkFFRVBJUkFNNVFNTElBRXRBQUFpRUVFN1JnMElJQkJCRFVjTjZBRWdBVUVCYWlFQkRPOENDeUFBSUFFaUFTQUNFTHFBZ0lBQUloQU42QUVnQVNFQkRQSUNDd05BQWtBZ0FTMEFBRUh3dFlDQUFHb3RBQUFpRUVFQlJnMEFJQkJCQWtjTjZ3RWdBQ2dDQkNFUUlBQkJBRFlDQkNBQUlCQWdBVUVCYWlJQkVMbUFnSUFBSWhBTjZnRWdBU0VCRFBRQ0N5QUJRUUZxSWdFZ0FrY05BQXRCRWlFUURPSURDeUFBSUFFaUFTQUNFTHFBZ0lBQUloQU42UUVnQVNFQkRBb0xJQUVpQVNBQ1J3MEdRUnNoRUF6Z0F3c0NRQ0FCSWdFZ0FrY05BRUVXSVJBTTRBTUxJQUJCaW9DQWdBQTJBZ2dnQUNBQk5nSUVJQUFnQVNBQ0VMaUFnSUFBSWhBTjZnRWdBU0VCUVNBaEVBekdBd3NDUUNBQklnRWdBa1lOQUFOQUFrQWdBUzBBQUVId3Q0Q0FBR290QUFBaUVFRUNSZzBBQWtBZ0VFRi9hZzRFNVFIc0FRRHJBZXdCQ3lBQlFRRnFJUUZCQ0NFUURNZ0RDeUFCUVFGcUlnRWdBa2NOQUF0QkZTRVFETjhEQzBFVklSQU0zZ01MQTBBQ1FDQUJMUUFBUWZDNWdJQUFhaTBBQUNJUVFRSkdEUUFnRUVGL2FnNEUzZ0hzQWVBQjZ3SHNBUXNnQVVFQmFpSUJJQUpIRFFBTFFSZ2hFQXpkQXdzQ1FDQUJJZ0VnQWtZTkFDQUFRWXVBZ0lBQU5nSUlJQUFnQVRZQ0JDQUJJUUZCQnlFUURNUURDMEVaSVJBTTNBTUxJQUZCQVdvaEFRd0NDd0pBSUFFaUZDQUNSdzBBUVJvaEVBemJBd3NnRkNFQkFrQWdGQzBBQUVGemFnNFUzUUx1QXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0lBN2dJTFFRQWhFQ0FBUVFBMkFod2dBRUd2aTRDQUFEWUNFQ0FBUVFJMkFnd2dBQ0FVUVFGcU5nSVVETm9EQ3dKQUlBRXRBQUFpRUVFN1JnMEFJQkJCRFVjTjZBRWdBVUVCYWlFQkRPVUNDeUFCUVFGcUlRRUxRU0loRUF5L0F3c0NRQ0FCSWhBZ0FrY05BRUVjSVJBTTJBTUxRZ0FoRVNBUUlRRWdFQzBBQUVGUWFnNDM1d0htQVFFQ0F3UUZCZ2NJQUFBQUFBQUFBQWtLQ3d3TkRnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUR4QVJFaE1VQUF0QkhpRVFETDBEQzBJQ0lSRU01UUVMUWdNaEVRemtBUXRDQkNFUkRPTUJDMElGSVJFTTRnRUxRZ1loRVF6aEFRdENCeUVSRE9BQkMwSUlJUkVNM3dFTFFna2hFUXplQVF0Q0NpRVJETjBCQzBJTElSRU0zQUVMUWd3aEVRemJBUXRDRFNFUkROb0JDMElPSVJFTTJRRUxRZzhoRVF6WUFRdENDaUVSRE5jQkMwSUxJUkVNMWdFTFFnd2hFUXpWQVF0Q0RTRVJETlFCQzBJT0lSRU0wd0VMUWc4aEVRelNBUXRDQUNFUkFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FRTFFBQVFWQnFEamZsQWVRQkFBRUNBd1FGQmdmbUFlWUI1Z0htQWVZQjVnSG1BUWdKQ2dzTURlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdFT0R4QVJFaFBtQVF0Q0FpRVJET1FCQzBJRElSRU00d0VMUWdRaEVRemlBUXRDQlNFUkRPRUJDMElHSVJFTTRBRUxRZ2NoRVF6ZkFRdENDQ0VSRE40QkMwSUpJUkVNM1FFTFFnb2hFUXpjQVF0Q0N5RVJETnNCQzBJTUlSRU0yZ0VMUWcwaEVRelpBUXRDRGlFUkROZ0JDMElQSVJFTTF3RUxRZ29oRVF6V0FRdENDeUVSRE5VQkMwSU1JUkVNMUFFTFFnMGhFUXpUQVF0Q0RpRVJETklCQzBJUElSRU0wUUVMSUFCQ0FDQUFLUU1nSWhFZ0FpQUJJaEJyclNJU2ZTSVRJQk1nRVZZYk53TWdJQkVnRWxZaUZFVU4wZ0ZCSHlFUURNQURDd0pBSUFFaUFTQUNSZzBBSUFCQmlZQ0FnQUEyQWdnZ0FDQUJOZ0lFSUFFaEFVRWtJUkFNcHdNTFFTQWhFQXkvQXdzZ0FDQUJJaEFnQWhDK2dJQ0FBRUYvYWc0RnRnRUF4UUlCMFFIU0FRdEJFU0VRREtRREN5QUFRUUU2QUM4Z0VDRUJETHNEQ3lBQklnRWdBa2NOMGdGQkpDRVFETHNEQ3lBQklnMGdBa2NOSGtIR0FDRVFETG9EQ3lBQUlBRWlBU0FDRUxLQWdJQUFJaEFOMUFFZ0FTRUJETFVCQ3lBQkloQWdBa2NOSmtIUUFDRVFETGdEQ3dKQUlBRWlBU0FDUncwQVFTZ2hFQXk0QXdzZ0FFRUFOZ0lFSUFCQmpJQ0FnQUEyQWdnZ0FDQUJJQUVRc1lDQWdBQWlFQTNUQVNBQklRRU0yQUVMQWtBZ0FTSVFJQUpIRFFCQktTRVFETGNEQ3lBUUxRQUFJZ0ZCSUVZTkZDQUJRUWxIRGRNQklCQkJBV29oQVF3VkN3SkFJQUVpQVNBQ1JnMEFJQUZCQVdvaEFRd1hDMEVxSVJBTXRRTUxBa0FnQVNJUUlBSkhEUUJCS3lFUURMVURDd0pBSUJBdEFBQWlBVUVKUmcwQUlBRkJJRWNOMVFFTElBQXRBQ3hCQ0VZTjB3RWdFQ0VCREpFREN3SkFJQUVpQVNBQ1J3MEFRU3doRUF5MEF3c2dBUzBBQUVFS1J3M1ZBU0FCUVFGcUlRRU15UUlMSUFFaURpQUNSdzNWQVVFdklSQU1zZ01MQTBBQ1FDQUJMUUFBSWhCQklFWU5BQUpBSUJCQmRtb09CQURjQWR3QkFOb0JDeUFCSVFFTTRBRUxJQUZCQVdvaUFTQUNSdzBBQzBFeElSQU1zUU1MUVRJaEVDQUJJaFFnQWtZTnNBTWdBaUFVYXlBQUtBSUFJZ0ZxSVJVZ0ZDQUJhMEVEYWlFV0FrQURRQ0FVTFFBQUloZEJJSElnRnlBWFFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFmQzdnSUFBYWkwQUFFY05BUUpBSUFGQkEwY05BRUVHSVFFTWxnTUxJQUZCQVdvaEFTQVVRUUZxSWhRZ0FrY05BQXNnQUNBVk5nSUFETEVEQ3lBQVFRQTJBZ0FnRkNFQkROa0JDMEV6SVJBZ0FTSVVJQUpHRGE4RElBSWdGR3NnQUNnQ0FDSUJhaUVWSUJRZ0FXdEJDR29oRmdKQUEwQWdGQzBBQUNJWFFTQnlJQmNnRjBHL2YycEIvd0Z4UVJwSkcwSC9BWEVnQVVIMHU0Q0FBR290QUFCSERRRUNRQ0FCUVFoSERRQkJCU0VCREpVREN5QUJRUUZxSVFFZ0ZFRUJhaUlVSUFKSERRQUxJQUFnRlRZQ0FBeXdBd3NnQUVFQU5nSUFJQlFoQVF6WUFRdEJOQ0VRSUFFaUZDQUNSZzJ1QXlBQ0lCUnJJQUFvQWdBaUFXb2hGU0FVSUFGclFRVnFJUllDUUFOQUlCUXRBQUFpRjBFZ2NpQVhJQmRCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCME1LQWdBQnFMUUFBUncwQkFrQWdBVUVGUncwQVFRY2hBUXlVQXdzZ0FVRUJhaUVCSUJSQkFXb2lGQ0FDUncwQUN5QUFJQlUyQWdBTXJ3TUxJQUJCQURZQ0FDQVVJUUVNMXdFTEFrQWdBU0lCSUFKR0RRQURRQUpBSUFFdEFBQkJnTDZBZ0FCcUxRQUFJaEJCQVVZTkFDQVFRUUpHRFFvZ0FTRUJETjBCQ3lBQlFRRnFJZ0VnQWtjTkFBdEJNQ0VRREs0REMwRXdJUkFNclFNTEFrQWdBU0lCSUFKR0RRQURRQUpBSUFFdEFBQWlFRUVnUmcwQUlCQkJkbW9PQk5rQjJnSGFBZGtCMmdFTElBRkJBV29pQVNBQ1J3MEFDMEU0SVJBTXJRTUxRVGdoRUF5c0F3c0RRQUpBSUFFdEFBQWlFRUVnUmcwQUlCQkJDVWNOQXdzZ0FVRUJhaUlCSUFKSERRQUxRVHdoRUF5ckF3c0RRQUpBSUFFdEFBQWlFRUVnUmcwQUFrQUNRQ0FRUVhacURnVGFBUUVCMmdFQUN5QVFRU3hHRGRzQkN5QUJJUUVNQkFzZ0FVRUJhaUlCSUFKSERRQUxRVDhoRUF5cUF3c2dBU0VCRE5zQkMwSEFBQ0VRSUFFaUZDQUNSZzJvQXlBQ0lCUnJJQUFvQWdBaUFXb2hGaUFVSUFGclFRWnFJUmNDUUFOQUlCUXRBQUJCSUhJZ0FVR0F3SUNBQUdvdEFBQkhEUUVnQVVFR1JnMk9BeUFCUVFGcUlRRWdGRUVCYWlJVUlBSkhEUUFMSUFBZ0ZqWUNBQXlwQXdzZ0FFRUFOZ0lBSUJRaEFRdEJOaUVRREk0REN3SkFJQUVpRHlBQ1J3MEFRY0VBSVJBTXB3TUxJQUJCaklDQWdBQTJBZ2dnQUNBUE5nSUVJQThoQVNBQUxRQXNRWDlxRGdUTkFkVUIxd0haQVljREN5QUJRUUZxSVFFTXpBRUxBa0FnQVNJQklBSkdEUUFEUUFKQUlBRXRBQUFpRUVFZ2NpQVFJQkJCdjM5cVFmOEJjVUVhU1J0Qi93RnhJaEJCQ1VZTkFDQVFRU0JHRFFBQ1FBSkFBa0FDUUNBUVFaMS9hZzRUQUFNREF3TURBd01CQXdNREF3TURBd01EQWdNTElBRkJBV29oQVVFeElSQU1rUU1MSUFGQkFXb2hBVUV5SVJBTWtBTUxJQUZCQVdvaEFVRXpJUkFNandNTElBRWhBUXpRQVFzZ0FVRUJhaUlCSUFKSERRQUxRVFVoRUF5bEF3dEJOU0VRREtRREN3SkFJQUVpQVNBQ1JnMEFBMEFDUUNBQkxRQUFRWUM4Z0lBQWFpMEFBRUVCUmcwQUlBRWhBUXpUQVFzZ0FVRUJhaUlCSUFKSERRQUxRVDBoRUF5a0F3dEJQU0VRREtNREN5QUFJQUVpQVNBQ0VMQ0FnSUFBSWhBTjFnRWdBU0VCREFFTElCQkJBV29oQVF0QlBDRVFESWNEQ3dKQUlBRWlBU0FDUncwQVFjSUFJUkFNb0FNTEFrQURRQUpBSUFFdEFBQkJkMm9PR0FBQy9nTCtBb1FEL2dMK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDQVA0Q0N5QUJRUUZxSWdFZ0FrY05BQXRCd2dBaEVBeWdBd3NnQVVFQmFpRUJJQUF0QUMxQkFYRkZEYjBCSUFFaEFRdEJMQ0VRRElVREN5QUJJZ0VnQWtjTjB3RkJ4QUFoRUF5ZEF3c0RRQUpBSUFFdEFBQkJrTUNBZ0FCcUxRQUFRUUZHRFFBZ0FTRUJETGNDQ3lBQlFRRnFJZ0VnQWtjTkFBdEJ4UUFoRUF5Y0F3c2dEUzBBQUNJUVFTQkdEYk1CSUJCQk9rY05nUU1nQUNnQ0JDRUJJQUJCQURZQ0JDQUFJQUVnRFJDdmdJQ0FBQ0lCRGRBQklBMUJBV29oQVF5ekFndEJ4d0FoRUNBQklnMGdBa1lObWdNZ0FpQU5heUFBS0FJQUlnRnFJUllnRFNBQmEwRUZhaUVYQTBBZ0RTMEFBQ0lVUVNCeUlCUWdGRUcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUdRd29DQUFHb3RBQUJIRFlBRElBRkJCVVlOOUFJZ0FVRUJhaUVCSUExQkFXb2lEU0FDUncwQUN5QUFJQlkyQWdBTW1nTUxRY2dBSVJBZ0FTSU5JQUpHRFprRElBSWdEV3NnQUNnQ0FDSUJhaUVXSUEwZ0FXdEJDV29oRndOQUlBMHRBQUFpRkVFZ2NpQVVJQlJCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCbHNLQWdBQnFMUUFBUnczL0FnSkFJQUZCQ1VjTkFFRUNJUUVNOVFJTElBRkJBV29oQVNBTlFRRnFJZzBnQWtjTkFBc2dBQ0FXTmdJQURKa0RDd0pBSUFFaURTQUNSdzBBUWNrQUlSQU1tUU1MQWtBQ1FDQU5MUUFBSWdGQklISWdBU0FCUWI5L2FrSC9BWEZCR2trYlFmOEJjVUdTZjJvT0J3Q0FBNEFEZ0FPQUE0QURBWUFEQ3lBTlFRRnFJUUZCUGlFUURJQURDeUFOUVFGcUlRRkJQeUVRRFA4Q0MwSEtBQ0VRSUFFaURTQUNSZzJYQXlBQ0lBMXJJQUFvQWdBaUFXb2hGaUFOSUFGclFRRnFJUmNEUUNBTkxRQUFJaFJCSUhJZ0ZDQVVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRYURDZ0lBQWFpMEFBRWNOL1FJZ0FVRUJSZzN3QWlBQlFRRnFJUUVnRFVFQmFpSU5JQUpIRFFBTElBQWdGallDQUF5WEF3dEJ5d0FoRUNBQklnMGdBa1lObGdNZ0FpQU5heUFBS0FJQUlnRnFJUllnRFNBQmEwRU9haUVYQTBBZ0RTMEFBQ0lVUVNCeUlCUWdGRUcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUdpd29DQUFHb3RBQUJIRGZ3Q0lBRkJEa1lOOEFJZ0FVRUJhaUVCSUExQkFXb2lEU0FDUncwQUN5QUFJQlkyQWdBTWxnTUxRY3dBSVJBZ0FTSU5JQUpHRFpVRElBSWdEV3NnQUNnQ0FDSUJhaUVXSUEwZ0FXdEJEMm9oRndOQUlBMHRBQUFpRkVFZ2NpQVVJQlJCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCd01LQWdBQnFMUUFBUnczN0FnSkFJQUZCRDBjTkFFRURJUUVNOFFJTElBRkJBV29oQVNBTlFRRnFJZzBnQWtjTkFBc2dBQ0FXTmdJQURKVURDMEhOQUNFUUlBRWlEU0FDUmcyVUF5QUNJQTFySUFBb0FnQWlBV29oRmlBTklBRnJRUVZxSVJjRFFDQU5MUUFBSWhSQklISWdGQ0FVUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUWREQ2dJQUFhaTBBQUVjTitnSUNRQ0FCUVFWSERRQkJCQ0VCRFBBQ0N5QUJRUUZxSVFFZ0RVRUJhaUlOSUFKSERRQUxJQUFnRmpZQ0FBeVVBd3NDUUNBQklnMGdBa2NOQUVIT0FDRVFESlFEQ3dKQUFrQUNRQUpBSUEwdEFBQWlBVUVnY2lBQklBRkJ2MzlxUWY4QmNVRWFTUnRCL3dGeFFaMS9hZzRUQVAwQy9RTDlBdjBDL1FMOUF2MEMvUUw5QXYwQy9RTDlBZ0g5QXYwQy9RSUNBLzBDQ3lBTlFRRnFJUUZCd1FBaEVBejlBZ3NnRFVFQmFpRUJRY0lBSVJBTS9BSUxJQTFCQVdvaEFVSERBQ0VRRFBzQ0N5QU5RUUZxSVFGQnhBQWhFQXo2QWdzQ1FDQUJJZ0VnQWtZTkFDQUFRWTJBZ0lBQU5nSUlJQUFnQVRZQ0JDQUJJUUZCeFFBaEVBejZBZ3RCendBaEVBeVNBd3NnRUNFQkFrQUNRQ0FRTFFBQVFYWnFEZ1FCcUFLb0FnQ29BZ3NnRUVFQmFpRUJDMEVuSVJBTStBSUxBa0FnQVNJQklBSkhEUUJCMFFBaEVBeVJBd3NDUUNBQkxRQUFRU0JHRFFBZ0FTRUJESTBCQ3lBQlFRRnFJUUVnQUMwQUxVRUJjVVVOeHdFZ0FTRUJESXdCQ3lBQkloY2dBa2NOeUFGQjBnQWhFQXlQQXd0QjB3QWhFQ0FCSWhRZ0FrWU5qZ01nQWlBVWF5QUFLQUlBSWdGcUlSWWdGQ0FCYTBFQmFpRVhBMEFnRkMwQUFDQUJRZGJDZ0lBQWFpMEFBRWNOekFFZ0FVRUJSZzNIQVNBQlFRRnFJUUVnRkVFQmFpSVVJQUpIRFFBTElBQWdGallDQUF5T0F3c0NRQ0FCSWdFZ0FrY05BRUhWQUNFUURJNERDeUFCTFFBQVFRcEhEY3dCSUFGQkFXb2hBUXpIQVFzQ1FDQUJJZ0VnQWtjTkFFSFdBQ0VRREkwREN3SkFBa0FnQVMwQUFFRjJhZzRFQU0wQnpRRUJ6UUVMSUFGQkFXb2hBUXpIQVFzZ0FVRUJhaUVCUWNvQUlSQU04d0lMSUFBZ0FTSUJJQUlRcm9DQWdBQWlFQTNMQVNBQklRRkJ6UUFoRUF6eUFnc2dBQzBBS1VFaVJnMkZBd3ltQWdzQ1FDQUJJZ0VnQWtjTkFFSGJBQ0VRRElvREMwRUFJUlJCQVNFWFFRRWhGa0VBSVJBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FTMEFBRUZRYWc0SzFBSFRBUUFCQWdNRUJRWUkxUUVMUVFJaEVBd0dDMEVESVJBTUJRdEJCQ0VRREFRTFFRVWhFQXdEQzBFR0lSQU1BZ3RCQnlFUURBRUxRUWdoRUF0QkFDRVhRUUFoRmtFQUlSUU16QUVMUVFraEVFRUJJUlJCQUNFWFFRQWhGZ3pMQVFzQ1FDQUJJZ0VnQWtjTkFFSGRBQ0VRRElrREN5QUJMUUFBUVM1SERjd0JJQUZCQVdvaEFReW1BZ3NnQVNJQklBSkhEY3dCUWQ4QUlSQU1od01MQWtBZ0FTSUJJQUpHRFFBZ0FFR09nSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJRZEFBSVJBTTdnSUxRZUFBSVJBTWhnTUxRZUVBSVJBZ0FTSUJJQUpHRFlVRElBSWdBV3NnQUNnQ0FDSVVhaUVXSUFFZ0ZHdEJBMm9oRndOQUlBRXRBQUFnRkVIaXdvQ0FBR290QUFCSERjMEJJQlJCQTBZTnpBRWdGRUVCYWlFVUlBRkJBV29pQVNBQ1J3MEFDeUFBSUJZMkFnQU1oUU1MUWVJQUlSQWdBU0lCSUFKR0RZUURJQUlnQVdzZ0FDZ0NBQ0lVYWlFV0lBRWdGR3RCQW1vaEZ3TkFJQUV0QUFBZ0ZFSG13b0NBQUdvdEFBQkhEY3dCSUJSQkFrWU56Z0VnRkVFQmFpRVVJQUZCQVdvaUFTQUNSdzBBQ3lBQUlCWTJBZ0FNaEFNTFFlTUFJUkFnQVNJQklBSkdEWU1ESUFJZ0FXc2dBQ2dDQUNJVWFpRVdJQUVnRkd0QkEyb2hGd05BSUFFdEFBQWdGRUhwd29DQUFHb3RBQUJIRGNzQklCUkJBMFlOemdFZ0ZFRUJhaUVVSUFGQkFXb2lBU0FDUncwQUN5QUFJQlkyQWdBTWd3TUxBa0FnQVNJQklBSkhEUUJCNVFBaEVBeURBd3NnQUNBQlFRRnFJZ0VnQWhDb2dJQ0FBQ0lRRGMwQklBRWhBVUhXQUNFUURPa0NDd0pBSUFFaUFTQUNSZzBBQTBBQ1FDQUJMUUFBSWhCQklFWU5BQUpBQWtBQ1FDQVFRYmgvYWc0TEFBSFBBYzhCendIUEFjOEJ6d0hQQWM4QkFzOEJDeUFCUVFGcUlRRkIwZ0FoRUF6dEFnc2dBVUVCYWlFQlFkTUFJUkFNN0FJTElBRkJBV29oQVVIVUFDRVFET3NDQ3lBQlFRRnFJZ0VnQWtjTkFBdEI1QUFoRUF5Q0F3dEI1QUFoRUF5QkF3c0RRQUpBSUFFdEFBQkI4TUtBZ0FCcUxRQUFJaEJCQVVZTkFDQVFRWDVxRGdQUEFkQUIwUUhTQVFzZ0FVRUJhaUlCSUFKSERRQUxRZVlBSVJBTWdBTUxBa0FnQVNJQklBSkdEUUFnQVVFQmFpRUJEQU1MUWVjQUlSQU0vd0lMQTBBQ1FDQUJMUUFBUWZERWdJQUFhaTBBQUNJUVFRRkdEUUFDUUNBUVFYNXFEZ1RTQWRNQjFBRUExUUVMSUFFaEFVSFhBQ0VRRE9jQ0N5QUJRUUZxSWdFZ0FrY05BQXRCNkFBaEVBeitBZ3NDUUNBQklnRWdBa2NOQUVIcEFDRVFEUDRDQ3dKQUlBRXRBQUFpRUVGMmFnNGF1Z0hWQWRVQnZBSFZBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSEtBZFVCMVFFQTB3RUxJQUZCQVdvaEFRdEJCaUVRRE9NQ0N3TkFBa0FnQVMwQUFFSHd4b0NBQUdvdEFBQkJBVVlOQUNBQklRRU1uZ0lMSUFGQkFXb2lBU0FDUncwQUMwSHFBQ0VRRFBzQ0N3SkFJQUVpQVNBQ1JnMEFJQUZCQVdvaEFRd0RDMEhyQUNFUURQb0NDd0pBSUFFaUFTQUNSdzBBUWV3QUlSQU0rZ0lMSUFGQkFXb2hBUXdCQ3dKQUlBRWlBU0FDUncwQVFlMEFJUkFNK1FJTElBRkJBV29oQVF0QkJDRVFETjRDQ3dKQUlBRWlGQ0FDUncwQVFlNEFJUkFNOXdJTElCUWhBUUpBQWtBQ1FDQVVMUUFBUWZESWdJQUFhaTBBQUVGL2FnNEgxQUhWQWRZQkFKd0NBUUxYQVFzZ0ZFRUJhaUVCREFvTElCUkJBV29oQVF6TkFRdEJBQ0VRSUFCQkFEWUNIQ0FBUVp1U2dJQUFOZ0lRSUFCQkJ6WUNEQ0FBSUJSQkFXbzJBaFFNOWdJTEFrQURRQUpBSUFFdEFBQkI4TWlBZ0FCcUxRQUFJaEJCQkVZTkFBSkFBa0FnRUVGL2FnNEgwZ0hUQWRRQjJRRUFCQUhaQVFzZ0FTRUJRZG9BSVJBTTRBSUxJQUZCQVdvaEFVSGNBQ0VRRE44Q0N5QUJRUUZxSWdFZ0FrY05BQXRCN3dBaEVBejJBZ3NnQVVFQmFpRUJETXNCQ3dKQUlBRWlGQ0FDUncwQVFmQUFJUkFNOVFJTElCUXRBQUJCTDBjTjFBRWdGRUVCYWlFQkRBWUxBa0FnQVNJVUlBSkhEUUJCOFFBaEVBejBBZ3NDUUNBVUxRQUFJZ0ZCTDBjTkFDQVVRUUZxSVFGQjNRQWhFQXpiQWdzZ0FVRjJhaUlFUVJaTERkTUJRUUVnQkhSQmlZQ0FBbkZGRGRNQkRNb0NDd0pBSUFFaUFTQUNSZzBBSUFGQkFXb2hBVUhlQUNFUUROb0NDMEh5QUNFUURQSUNDd0pBSUFFaUZDQUNSdzBBUWZRQUlSQU04Z0lMSUJRaEFRSkFJQlF0QUFCQjhNeUFnQUJxTFFBQVFYOXFEZ1BKQXBRQ0FOUUJDMEhoQUNFUUROZ0NDd0pBSUFFaUZDQUNSZzBBQTBBQ1FDQVVMUUFBUWZES2dJQUFhaTBBQUNJQlFRTkdEUUFDUUNBQlFYOXFEZ0xMQWdEVkFRc2dGQ0VCUWQ4QUlSQU0yZ0lMSUJSQkFXb2lGQ0FDUncwQUMwSHpBQ0VRRFBFQ0MwSHpBQ0VRRFBBQ0N3SkFJQUVpQVNBQ1JnMEFJQUJCajRDQWdBQTJBZ2dnQUNBQk5nSUVJQUVoQVVIZ0FDRVFETmNDQzBIMUFDRVFETzhDQ3dKQUlBRWlBU0FDUncwQVFmWUFJUkFNN3dJTElBQkJqNENBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBUXRCQXlFUUROUUNDd05BSUFFdEFBQkJJRWNOd3dJZ0FVRUJhaUlCSUFKSERRQUxRZmNBSVJBTTdBSUxBa0FnQVNJQklBSkhEUUJCK0FBaEVBenNBZ3NnQVMwQUFFRWdSdzNPQVNBQlFRRnFJUUVNN3dFTElBQWdBU0lCSUFJUXJJQ0FnQUFpRUEzT0FTQUJJUUVNamdJTEFrQWdBU0lFSUFKSERRQkIrZ0FoRUF6cUFnc2dCQzBBQUVITUFFY04wUUVnQkVFQmFpRUJRUk1oRUF6UEFRc0NRQ0FCSWdRZ0FrY05BRUg3QUNFUURPa0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFWcUlSQURRQ0FFTFFBQUlBRkI4TTZBZ0FCcUxRQUFSdzNRQVNBQlFRVkdEYzRCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWZzQUlSQU02QUlMQWtBZ0FTSUVJQUpIRFFCQi9BQWhFQXpvQWdzQ1FBSkFJQVF0QUFCQnZYOXFEZ3dBMFFIUkFkRUIwUUhSQWRFQjBRSFJBZEVCMFFFQjBRRUxJQVJCQVdvaEFVSG1BQ0VRRE04Q0N5QUVRUUZxSVFGQjV3QWhFQXpPQWdzQ1FDQUJJZ1FnQWtjTkFFSDlBQ0VRRE9jQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSHR6NENBQUdvdEFBQkhEYzhCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUg5QUNFUURPY0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFSQWhFQXpNQVFzQ1FDQUJJZ1FnQWtjTkFFSCtBQ0VRRE9ZQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVZxSVJBQ1FBTkFJQVF0QUFBZ0FVSDJ6b0NBQUdvdEFBQkhEYzRCSUFGQkJVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUgrQUNFUURPWUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFSWWhFQXpMQVFzQ1FDQUJJZ1FnQWtjTkFFSC9BQ0VRRE9VQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUU5xSVJBQ1FBTkFJQVF0QUFBZ0FVSDh6b0NBQUdvdEFBQkhEYzBCSUFGQkEwWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUgvQUNFUURPVUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFRVWhFQXpLQVFzQ1FDQUJJZ1FnQWtjTkFFR0FBU0VRRE9RQ0N5QUVMUUFBUWRrQVJ3M0xBU0FFUVFGcUlRRkJDQ0VRRE1rQkN3SkFJQUVpQkNBQ1J3MEFRWUVCSVJBTTR3SUxBa0FDUUNBRUxRQUFRYkovYWc0REFNd0JBY3dCQ3lBRVFRRnFJUUZCNndBaEVBektBZ3NnQkVFQmFpRUJRZXdBSVJBTXlRSUxBa0FnQVNJRUlBSkhEUUJCZ2dFaEVBemlBZ3NDUUFKQUlBUXRBQUJCdUg5cURnZ0F5d0hMQWNzQnl3SExBY3NCQWNzQkN5QUVRUUZxSVFGQjZnQWhFQXpKQWdzZ0JFRUJhaUVCUWUwQUlSQU15QUlMQWtBZ0FTSUVJQUpIRFFCQmd3RWhFQXpoQWdzZ0FpQUVheUFBS0FJQUlnRnFJUkFnQkNBQmEwRUNhaUVVQWtBRFFDQUVMUUFBSUFGQmdNK0FnQUJxTFFBQVJ3M0pBU0FCUVFKR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJBMkFnQkJnd0VoRUF6aEFndEJBQ0VRSUFCQkFEWUNBQ0FVUVFGcUlRRU14Z0VMQWtBZ0FTSUVJQUpIRFFCQmhBRWhFQXpnQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUVhaUVRQWtBRFFDQUVMUUFBSUFGQmc4K0FnQUJxTFFBQVJ3M0lBU0FCUVFSR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJoQUVoRUF6Z0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFaklSQU14UUVMQWtBZ0FTSUVJQUpIRFFCQmhRRWhFQXpmQWdzQ1FBSkFJQVF0QUFCQnRIOXFEZ2dBeUFISUFjZ0J5QUhJQWNnQkFjZ0JDeUFFUVFGcUlRRkI3d0FoRUF6R0Fnc2dCRUVCYWlFQlFmQUFJUkFNeFFJTEFrQWdBU0lFSUFKSERRQkJoZ0VoRUF6ZUFnc2dCQzBBQUVIRkFFY054UUVnQkVFQmFpRUJESU1DQ3dKQUlBRWlCQ0FDUncwQVFZY0JJUkFNM1FJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBMm9oRUFKQUEwQWdCQzBBQUNBQlFZalBnSUFBYWkwQUFFY054UUVnQVVFRFJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWWNCSVJBTTNRSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkxTRVFETUlCQ3dKQUlBRWlCQ0FDUncwQVFZZ0JJUkFNM0FJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJDR29oRUFKQUEwQWdCQzBBQUNBQlFkRFBnSUFBYWkwQUFFY054QUVnQVVFSVJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWWdCSVJBTTNBSUxJQUJCQURZQ0FDQVFRUUZxSVFGQktTRVFETUVCQ3dKQUlBRWlBU0FDUncwQVFZa0JJUkFNMndJTFFRRWhFQ0FCTFFBQVFkOEFSdzNBQVNBQlFRRnFJUUVNZ1FJTEFrQWdBU0lFSUFKSERRQkJpZ0VoRUF6YUFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVCYWlFUUEwQWdCQzBBQUNBQlFZelBnSUFBYWkwQUFFY053UUVnQVVFQlJnMnZBaUFCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdLQVNFUUROa0NDd0pBSUFFaUJDQUNSdzBBUVlzQklSQU0yUUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUVk3UGdJQUFhaTBBQUVjTndRRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZc0JJUkFNMlFJTElBQkJBRFlDQUNBUVFRRnFJUUZCQWlFUURMNEJDd0pBSUFFaUJDQUNSdzBBUVl3QklSQU0yQUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWZEUGdJQUFhaTBBQUVjTndBRWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZd0JJUkFNMkFJTElBQkJBRFlDQUNBUVFRRnFJUUZCSHlFUURMMEJDd0pBSUFFaUJDQUNSdzBBUVkwQklSQU0xd0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWZMUGdJQUFhaTBBQUVjTnZ3RWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZMEJJUkFNMXdJTElBQkJBRFlDQUNBUVFRRnFJUUZCQ1NFUURMd0JDd0pBSUFFaUJDQUNSdzBBUVk0QklSQU0xZ0lMQWtBQ1FDQUVMUUFBUWJkL2FnNEhBTDhCdndHL0FiOEJ2d0VCdndFTElBUkJBV29oQVVINEFDRVFETDBDQ3lBRVFRRnFJUUZCK1FBaEVBeThBZ3NDUUNBQklnUWdBa2NOQUVHUEFTRVFETlVDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRVnFJUkFDUUFOQUlBUXRBQUFnQVVHUno0Q0FBR290QUFCSERiMEJJQUZCQlVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR1BBU0VRRE5VQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJnaEVBeTZBUXNDUUNBQklnUWdBa2NOQUVHUUFTRVFETlFDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRSnFJUkFDUUFOQUlBUXRBQUFnQVVHWHo0Q0FBR290QUFCSERid0JJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR1FBU0VRRE5RQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJjaEVBeTVBUXNDUUNBQklnUWdBa2NOQUVHUkFTRVFETk1DQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRWnFJUkFDUUFOQUlBUXRBQUFnQVVHYXo0Q0FBR290QUFCSERic0JJQUZCQmtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR1JBU0VRRE5NQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJVaEVBeTRBUXNDUUNBQklnUWdBa2NOQUVHU0FTRVFETklDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRVnFJUkFDUUFOQUlBUXRBQUFnQVVHaHo0Q0FBR290QUFCSERib0JJQUZCQlVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR1NBU0VRRE5JQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVI0aEVBeTNBUXNDUUNBQklnUWdBa2NOQUVHVEFTRVFETkVDQ3lBRUxRQUFRY3dBUncyNEFTQUVRUUZxSVFGQkNpRVFETFlCQ3dKQUlBUWdBa2NOQUVHVUFTRVFETkFDQ3dKQUFrQWdCQzBBQUVHL2Yyb09Ed0M1QWJrQnVRRzVBYmtCdVFHNUFia0J1UUc1QWJrQnVRRzVBUUc1QVFzZ0JFRUJhaUVCUWY0QUlSQU10d0lMSUFSQkFXb2hBVUgvQUNFUURMWUNDd0pBSUFRZ0FrY05BRUdWQVNFUURNOENDd0pBQWtBZ0JDMEFBRUcvZjJvT0F3QzRBUUc0QVFzZ0JFRUJhaUVCUWYwQUlSQU10Z0lMSUFSQkFXb2hCRUdBQVNFUURMVUNDd0pBSUFRZ0FrY05BRUdXQVNFUURNNENDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFGcUlSQUNRQU5BSUFRdEFBQWdBVUduejRDQUFHb3RBQUJIRGJZQklBRkJBVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHV0FTRVFETTRDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUXNoRUF5ekFRc0NRQ0FFSUFKSERRQkJsd0VoRUF6TkFnc0NRQUpBQWtBQ1FDQUVMUUFBUVZOcURpTUF1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBUUc0QWJnQnVBRzRBYmdCQXJnQnVBRzRBUU80QVFzZ0JFRUJhaUVCUWZzQUlSQU10Z0lMSUFSQkFXb2hBVUg4QUNFUURMVUNDeUFFUVFGcUlRUkJnUUVoRUF5MEFnc2dCRUVCYWlFRVFZSUJJUkFNc3dJTEFrQWdCQ0FDUncwQVFaZ0JJUkFNekFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJCR29oRUFKQUEwQWdCQzBBQUNBQlFhblBnSUFBYWkwQUFFY050QUVnQVVFRVJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWmdCSVJBTXpBSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkdTRVFETEVCQ3dKQUlBUWdBa2NOQUVHWkFTRVFETXNDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRVnFJUkFDUUFOQUlBUXRBQUFnQVVHdXo0Q0FBR290QUFCSERiTUJJQUZCQlVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR1pBU0VRRE1zQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVFZaEVBeXdBUXNDUUNBRUlBSkhEUUJCbWdFaEVBektBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCdE0rQWdBQnFMUUFBUncyeUFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQm1nRWhFQXpLQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVjSVJBTXJ3RUxBa0FnQkNBQ1J3MEFRWnNCSVJBTXlRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRYmJQZ0lBQWFpMEFBRWNOc1FFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVpzQklSQU15UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJKeUVRREs0QkN3SkFJQVFnQWtjTkFFR2NBU0VRRE1nQ0N3SkFBa0FnQkMwQUFFR3NmMm9PQWdBQnNRRUxJQVJCQVdvaEJFR0dBU0VRREs4Q0N5QUVRUUZxSVFSQmh3RWhFQXl1QWdzQ1FDQUVJQUpIRFFCQm5RRWhFQXpIQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUJhaUVRQWtBRFFDQUVMUUFBSUFGQnVNK0FnQUJxTFFBQVJ3MnZBU0FCUVFGR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJuUUVoRUF6SEFnc2dBRUVBTmdJQUlCQkJBV29oQVVFbUlSQU1yQUVMQWtBZ0JDQUNSdzBBUVo0QklSQU14Z0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWJyUGdJQUFhaTBBQUVjTnJnRWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaNEJJUkFNeGdJTElBQkJBRFlDQUNBUVFRRnFJUUZCQXlFUURLc0JDd0pBSUFRZ0FrY05BRUdmQVNFUURNVUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUh0ejRDQUFHb3RBQUJIRGEwQklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHZkFTRVFETVVDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUXdoRUF5cUFRc0NRQ0FFSUFKSERRQkJvQUVoRUF6RUFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVEYWlFUUFrQURRQ0FFTFFBQUlBRkJ2TStBZ0FCcUxRQUFSdzJzQVNBQlFRTkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCb0FFaEVBekVBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRU5JUkFNcVFFTEFrQWdCQ0FDUncwQVFhRUJJUkFNd3dJTEFrQUNRQ0FFTFFBQVFicC9hZzRMQUt3QnJBR3NBYXdCckFHc0Fhd0JyQUdzQVFHc0FRc2dCRUVCYWlFRVFZc0JJUkFNcWdJTElBUkJBV29oQkVHTUFTRVFES2tDQ3dKQUlBUWdBa2NOQUVHaUFTRVFETUlDQ3lBRUxRQUFRZEFBUncycEFTQUVRUUZxSVFRTTZRRUxBa0FnQkNBQ1J3MEFRYU1CSVJBTXdRSUxBa0FDUUNBRUxRQUFRYmQvYWc0SEFhb0JxZ0dxQWFvQnFnRUFxZ0VMSUFSQkFXb2hCRUdPQVNFUURLZ0NDeUFFUVFGcUlRRkJJaUVRREtZQkN3SkFJQVFnQWtjTkFFR2tBU0VRRE1BQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUZxSVJBQ1FBTkFJQVF0QUFBZ0FVSEF6NENBQUdvdEFBQkhEYWdCSUFGQkFVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdrQVNFUURNQUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFSMGhFQXlsQVFzQ1FDQUVJQUpIRFFCQnBRRWhFQXkvQWdzQ1FBSkFJQVF0QUFCQnJuOXFEZ01BcUFFQnFBRUxJQVJCQVdvaEJFR1FBU0VRREtZQ0N5QUVRUUZxSVFGQkJDRVFES1FCQ3dKQUlBUWdBa2NOQUVHbUFTRVFETDRDQ3dKQUFrQUNRQUpBQWtBZ0JDMEFBRUcvZjJvT0ZRQ3FBYW9CcWdHcUFhb0JxZ0dxQWFvQnFnR3FBUUdxQWFvQkFxb0JxZ0VEcWdHcUFRU3FBUXNnQkVFQmFpRUVRWWdCSVJBTXFBSUxJQVJCQVdvaEJFR0pBU0VRREtjQ0N5QUVRUUZxSVFSQmlnRWhFQXltQWdzZ0JFRUJhaUVFUVk4QklSQU1wUUlMSUFSQkFXb2hCRUdSQVNFUURLUUNDd0pBSUFRZ0FrY05BRUduQVNFUURMMENDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUh0ejRDQUFHb3RBQUJIRGFVQklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHbkFTRVFETDBDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUkVoRUF5aUFRc0NRQ0FFSUFKSERRQkJxQUVoRUF5OEFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVDYWlFUUFrQURRQ0FFTFFBQUlBRkJ3cytBZ0FCcUxRQUFSdzJrQVNBQlFRSkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCcUFFaEVBeThBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRXNJUkFNb1FFTEFrQWdCQ0FDUncwQVFha0JJUkFNdXdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJCR29oRUFKQUEwQWdCQzBBQUNBQlFjWFBnSUFBYWkwQUFFY05vd0VnQVVFRVJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYWtCSVJBTXV3SUxJQUJCQURZQ0FDQVFRUUZxSVFGQkt5RVFES0FCQ3dKQUlBUWdBa2NOQUVHcUFTRVFETG9DQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRSnFJUkFDUUFOQUlBUXRBQUFnQVVIS3o0Q0FBR290QUFCSERhSUJJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR3FBU0VRRExvQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJRaEVBeWZBUXNDUUNBRUlBSkhEUUJCcXdFaEVBeTVBZ3NDUUFKQUFrQUNRQ0FFTFFBQVFiNS9hZzRQQUFFQ3BBR2tBYVFCcEFHa0FhUUJwQUdrQWFRQnBBR2tBUU9rQVFzZ0JFRUJhaUVFUVpNQklSQU1vZ0lMSUFSQkFXb2hCRUdVQVNFUURLRUNDeUFFUVFGcUlRUkJsUUVoRUF5Z0Fnc2dCRUVCYWlFRVFaWUJJUkFNbndJTEFrQWdCQ0FDUncwQVFhd0JJUkFNdUFJTElBUXRBQUJCeFFCSERaOEJJQVJCQVdvaEJBemdBUXNDUUNBRUlBSkhEUUJCclFFaEVBeTNBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQ2FpRVFBa0FEUUNBRUxRQUFJQUZCemMrQWdBQnFMUUFBUncyZkFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQnJRRWhFQXkzQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVPSVJBTW5BRUxBa0FnQkNBQ1J3MEFRYTRCSVJBTXRnSUxJQVF0QUFCQjBBQkhEWjBCSUFSQkFXb2hBVUVsSVJBTW13RUxBa0FnQkNBQ1J3MEFRYThCSVJBTXRRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQ0dvaEVBSkFBMEFnQkMwQUFDQUJRZERQZ0lBQWFpMEFBRWNOblFFZ0FVRUlSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWE4QklSQU10UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJLaUVRREpvQkN3SkFJQVFnQWtjTkFFR3dBU0VRRExRQ0N3SkFBa0FnQkMwQUFFR3JmMm9PQ3dDZEFaMEJuUUdkQVowQm5RR2RBWjBCblFFQm5RRUxJQVJCQVdvaEJFR2FBU0VRREpzQ0N5QUVRUUZxSVFSQm13RWhFQXlhQWdzQ1FDQUVJQUpIRFFCQnNRRWhFQXl6QWdzQ1FBSkFJQVF0QUFCQnYzOXFEaFFBbkFHY0Fad0JuQUdjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUdjQVp3Qm5BR2NBWndCQVp3QkN5QUVRUUZxSVFSQm1RRWhFQXlhQWdzZ0JFRUJhaUVFUVp3QklSQU1tUUlMQWtBZ0JDQUNSdzBBUWJJQklSQU1zZ0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkEyb2hFQUpBQTBBZ0JDMEFBQ0FCUWRuUGdJQUFhaTBBQUVjTm1nRWdBVUVEUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFiSUJJUkFNc2dJTElBQkJBRFlDQUNBUVFRRnFJUUZCSVNFUURKY0JDd0pBSUFRZ0FrY05BRUd6QVNFUURMRUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFacUlSQUNRQU5BSUFRdEFBQWdBVUhkejRDQUFHb3RBQUJIRFprQklBRkJCa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHekFTRVFETEVDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUm9oRUF5V0FRc0NRQ0FFSUFKSERRQkJ0QUVoRUF5d0Fnc0NRQUpBQWtBZ0JDMEFBRUc3ZjJvT0VRQ2FBWm9CbWdHYUFab0JtZ0dhQVpvQm1nRUJtZ0dhQVpvQm1nR2FBUUthQVFzZ0JFRUJhaUVFUVowQklSQU1tQUlMSUFSQkFXb2hCRUdlQVNFUURKY0NDeUFFUVFGcUlRUkJud0VoRUF5V0Fnc0NRQ0FFSUFKSERRQkJ0UUVoRUF5dkFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVGYWlFUUFrQURRQ0FFTFFBQUlBRkI1TStBZ0FCcUxRQUFSdzJYQVNBQlFRVkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCdFFFaEVBeXZBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRW9JUkFNbEFFTEFrQWdCQ0FDUncwQVFiWUJJUkFNcmdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBbW9oRUFKQUEwQWdCQzBBQUNBQlFlclBnSUFBYWkwQUFFY05sZ0VnQVVFQ1JnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYllCSVJBTXJnSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkJ5RVFESk1CQ3dKQUlBUWdBa2NOQUVHM0FTRVFESzBDQ3dKQUFrQWdCQzBBQUVHN2Yyb09EZ0NXQVpZQmxnR1dBWllCbGdHV0FaWUJsZ0dXQVpZQmxnRUJsZ0VMSUFSQkFXb2hCRUdoQVNFUURKUUNDeUFFUVFGcUlRUkJvZ0VoRUF5VEFnc0NRQ0FFSUFKSERRQkJ1QUVoRUF5c0Fnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVDYWlFUUFrQURRQ0FFTFFBQUlBRkI3YytBZ0FCcUxRQUFSdzJVQVNBQlFRSkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCdUFFaEVBeXNBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRVNJUkFNa1FFTEFrQWdCQ0FDUncwQVFia0JJUkFNcXdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBV29oRUFKQUEwQWdCQzBBQUNBQlFmRFBnSUFBYWkwQUFFY05rd0VnQVVFQlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYmtCSVJBTXF3SUxJQUJCQURZQ0FDQVFRUUZxSVFGQklDRVFESkFCQ3dKQUlBUWdBa2NOQUVHNkFTRVFES29DQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRRnFJUkFDUUFOQUlBUXRBQUFnQVVIeXo0Q0FBR290QUFCSERaSUJJQUZCQVVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFRzZBU0VRREtvQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVE4aEVBeVBBUXNDUUNBRUlBSkhEUUJCdXdFaEVBeXBBZ3NDUUFKQUlBUXRBQUJCdDM5cURnY0FrZ0dTQVpJQmtnR1NBUUdTQVFzZ0JFRUJhaUVFUWFVQklSQU1rQUlMSUFSQkFXb2hCRUdtQVNFUURJOENDd0pBSUFRZ0FrY05BRUc4QVNFUURLZ0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFkcUlSQUNRQU5BSUFRdEFBQWdBVUgwejRDQUFHb3RBQUJIRFpBQklBRkJCMFlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHOEFTRVFES2dDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUnNoRUF5TkFRc0NRQ0FFSUFKSERRQkJ2UUVoRUF5bkFnc0NRQUpBQWtBZ0JDMEFBRUcrZjJvT0VnQ1JBWkVCa1FHUkFaRUJrUUdSQVpFQmtRRUJrUUdSQVpFQmtRR1JBWkVCQXBFQkN5QUVRUUZxSVFSQnBBRWhFQXlQQWdzZ0JFRUJhaUVFUWFjQklSQU1qZ0lMSUFSQkFXb2hCRUdvQVNFUURJMENDd0pBSUFRZ0FrY05BRUcrQVNFUURLWUNDeUFFTFFBQVFjNEFSdzJOQVNBRVFRRnFJUVFNendFTEFrQWdCQ0FDUncwQVFiOEJJUkFNcFFJTEFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQkMwQUFFRy9mMm9PRlFBQkFnT2NBUVFGQnB3Qm5BR2NBUWNJQ1FvTG5BRU1EUTRQbkFFTElBUkJBV29oQVVIb0FDRVFESm9DQ3lBRVFRRnFJUUZCNlFBaEVBeVpBZ3NnQkVFQmFpRUJRZTRBSVJBTW1BSUxJQVJCQVdvaEFVSHlBQ0VRREpjQ0N5QUVRUUZxSVFGQjh3QWhFQXlXQWdzZ0JFRUJhaUVCUWZZQUlSQU1sUUlMSUFSQkFXb2hBVUgzQUNFUURKUUNDeUFFUVFGcUlRRkIrZ0FoRUF5VEFnc2dCRUVCYWlFRVFZTUJJUkFNa2dJTElBUkJBV29oQkVHRUFTRVFESkVDQ3lBRVFRRnFJUVJCaFFFaEVBeVFBZ3NnQkVFQmFpRUVRWklCSVJBTWp3SUxJQVJCQVdvaEJFR1lBU0VRREk0Q0N5QUVRUUZxSVFSQm9BRWhFQXlOQWdzZ0JFRUJhaUVFUWFNQklSQU1qQUlMSUFSQkFXb2hCRUdxQVNFUURJc0NDd0pBSUFRZ0FrWU5BQ0FBUVpDQWdJQUFOZ0lJSUFBZ0JEWUNCRUdyQVNFUURJc0NDMEhBQVNFUURLTUNDeUFBSUFVZ0FoQ3FnSUNBQUNJQkRZc0JJQVVoQVF4Y0N3SkFJQVlnQWtZTkFDQUdRUUZxSVFVTWpRRUxRY0lCSVJBTW9RSUxBMEFDUUNBUUxRQUFRWFpxRGdTTUFRQUFqd0VBQ3lBUVFRRnFJaEFnQWtjTkFBdEJ3d0VoRUF5Z0Fnc0NRQ0FISUFKR0RRQWdBRUdSZ0lDQUFEWUNDQ0FBSUFjMkFnUWdCeUVCUVFFaEVBeUhBZ3RCeEFFaEVBeWZBZ3NDUUNBSElBSkhEUUJCeFFFaEVBeWZBZ3NDUUFKQUlBY3RBQUJCZG1vT0JBSE9BYzRCQU00QkN5QUhRUUZxSVFZTWpRRUxJQWRCQVdvaEJReUpBUXNDUUNBSElBSkhEUUJCeGdFaEVBeWVBZ3NDUUFKQUlBY3RBQUJCZG1vT0Z3R1BBWThCQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVFDUEFRc2dCMEVCYWlFSEMwR3dBU0VRRElRQ0N3SkFJQWdnQWtjTkFFSElBU0VRREowQ0N5QUlMUUFBUVNCSERZMEJJQUJCQURzQk1pQUlRUUZxSVFGQnN3RWhFQXlEQWdzZ0FTRVhBa0FEUUNBWElnY2dBa1lOQVNBSExRQUFRVkJxUWY4QmNTSVFRUXBQRGN3QkFrQWdBQzhCTWlJVVFaa3pTdzBBSUFBZ0ZFRUtiQ0lVT3dFeUlCQkIvLzhEY3lBVVFmNy9BM0ZKRFFBZ0IwRUJhaUVYSUFBZ0ZDQVFhaUlRT3dFeUlCQkIvLzhEY1VIb0Iwa05BUXNMUVFBaEVDQUFRUUEyQWh3Z0FFSEJpWUNBQURZQ0VDQUFRUTAyQWd3Z0FDQUhRUUZxTmdJVURKd0NDMEhIQVNFUURKc0NDeUFBSUFnZ0FoQ3VnSUNBQUNJUVJRM0tBU0FRUVJWSERZd0JJQUJCeUFFMkFod2dBQ0FJTmdJVUlBQkJ5WmVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXlhQWdzQ1FDQUpJQUpIRFFCQnpBRWhFQXlhQWd0QkFDRVVRUUVoRjBFQklSWkJBQ0VRQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFrdEFBQkJVR29PQ3BZQmxRRUFBUUlEQkFVR0NKY0JDMEVDSVJBTUJndEJBeUVRREFVTFFRUWhFQXdFQzBFRklSQU1Bd3RCQmlFUURBSUxRUWNoRUF3QkMwRUlJUkFMUVFBaEYwRUFJUlpCQUNFVURJNEJDMEVKSVJCQkFTRVVRUUFoRjBFQUlSWU1qUUVMQWtBZ0NpQUNSdzBBUWM0QklSQU1tUUlMSUFvdEFBQkJMa2NOamdFZ0NrRUJhaUVKRE1vQkN5QUxJQUpIRFk0QlFkQUJJUkFNbHdJTEFrQWdDeUFDUmcwQUlBQkJqb0NBZ0FBMkFnZ2dBQ0FMTmdJRVFiY0JJUkFNL2dFTFFkRUJJUkFNbGdJTEFrQWdCQ0FDUncwQVFkSUJJUkFNbGdJTElBSWdCR3NnQUNnQ0FDSVFhaUVVSUFRZ0VHdEJCR29oQ3dOQUlBUXRBQUFnRUVIOHo0Q0FBR290QUFCSERZNEJJQkJCQkVZTjZRRWdFRUVCYWlFUUlBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkIwZ0VoRUF5VkFnc2dBQ0FNSUFJUXJJQ0FnQUFpQVEyTkFTQU1JUUVNdUFFTEFrQWdCQ0FDUncwQVFkUUJJUkFNbEFJTElBSWdCR3NnQUNnQ0FDSVFhaUVVSUFRZ0VHdEJBV29oREFOQUlBUXRBQUFnRUVHQjBJQ0FBR290QUFCSERZOEJJQkJCQVVZTmpnRWdFRUVCYWlFUUlBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkIxQUVoRUF5VEFnc0NRQ0FFSUFKSERRQkIxZ0VoRUF5VEFnc2dBaUFFYXlBQUtBSUFJaEJxSVJRZ0JDQVFhMEVDYWlFTEEwQWdCQzBBQUNBUVFZUFFnSUFBYWkwQUFFY05qZ0VnRUVFQ1JnMlFBU0FRUVFGcUlSQWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUhXQVNFUURKSUNDd0pBSUFRZ0FrY05BRUhYQVNFUURKSUNDd0pBQWtBZ0JDMEFBRUc3ZjJvT0VBQ1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJBWThCQ3lBRVFRRnFJUVJCdXdFaEVBejVBUXNnQkVFQmFpRUVRYndCSVJBTStBRUxBa0FnQkNBQ1J3MEFRZGdCSVJBTWtRSUxJQVF0QUFCQnlBQkhEWXdCSUFSQkFXb2hCQXpFQVFzQ1FDQUVJQUpHRFFBZ0FFR1FnSUNBQURZQ0NDQUFJQVEyQWdSQnZnRWhFQXozQVF0QjJRRWhFQXlQQWdzQ1FDQUVJQUpIRFFCQjJnRWhFQXlQQWdzZ0JDMEFBRUhJQUVZTnd3RWdBRUVCT2dBb0RMa0JDeUFBUVFJNkFDOGdBQ0FFSUFJUXBvQ0FnQUFpRUEyTkFVSENBU0VRRFBRQkN5QUFMUUFvUVg5cURnSzNBYmtCdUFFTEEwQUNRQ0FFTFFBQVFYWnFEZ1FBamdHT0FRQ09BUXNnQkVFQmFpSUVJQUpIRFFBTFFkMEJJUkFNaXdJTElBQkJBRG9BTHlBQUxRQXRRUVJ4UlEyRUFnc2dBRUVBT2dBdklBQkJBVG9BTkNBQklRRU1qQUVMSUJCQkZVWU4yZ0VnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYWVPZ0lBQU5nSVFJQUJCRWpZQ0RFRUFJUkFNaUFJTEFrQWdBQ0FRSUFJUXRJQ0FnQUFpQkEwQUlCQWhBUXlCQWdzQ1FDQUVRUlZIRFFBZ0FFRUROZ0ljSUFBZ0VEWUNGQ0FBUWJDWWdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTWlBSUxJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFR25qb0NBQURZQ0VDQUFRUkkyQWd4QkFDRVFESWNDQ3lBUVFSVkdEZFlCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUhhallDQUFEWUNFQ0FBUVJRMkFneEJBQ0VRRElZQ0N5QUFLQUlFSVJjZ0FFRUFOZ0lFSUJBZ0VhZHFJaFloQVNBQUlCY2dFQ0FXSUJRYkloQVF0WUNBZ0FBaUZFVU5qUUVnQUVFSE5nSWNJQUFnRURZQ0ZDQUFJQlEyQWd4QkFDRVFESVVDQ3lBQUlBQXZBVEJCZ0FGeU93RXdJQUVoQVF0QktpRVFET29CQ3lBUVFSVkdEZEVCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdEaklDQUFEWUNFQ0FBUVJNMkFneEJBQ0VRRElJQ0N5QVFRUlZHRGM4QklBQkJBRFlDSENBQUlBRTJBaFFnQUVHYWo0Q0FBRFlDRUNBQVFTSTJBZ3hCQUNFUURJRUNDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXQ0Q0FnQUFpRUEwQUlBRkJBV29oQVF5TkFRc2dBRUVNTmdJY0lBQWdFRFlDRENBQUlBRkJBV28yQWhSQkFDRVFESUFDQ3lBUVFSVkdEY3dCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdhajRDQUFEWUNFQ0FBUVNJMkFneEJBQ0VRRFA4QkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRdDRDQWdBQWlFQTBBSUFGQkFXb2hBUXlNQVFzZ0FFRU5OZ0ljSUFBZ0VEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURQNEJDeUFRUVJWR0Rja0JJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEdqSUNBQURZQ0VDQUFRU00yQWd4QkFDRVFEUDBCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVF1WUNBZ0FBaUVBMEFJQUZCQVdvaEFReUxBUXNnQUVFT05nSWNJQUFnRURZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFB3QkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQndKV0FnQUEyQWhBZ0FFRUNOZ0lNUVFBaEVBejdBUXNnRUVFVlJnM0ZBU0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJ4b3lBZ0FBMkFoQWdBRUVqTmdJTVFRQWhFQXo2QVFzZ0FFRVFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRFBrQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRdVlDQWdBQWlCQTBBSUFGQkFXb2hBUXp4QVFzZ0FFRVJOZ0ljSUFBZ0JEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURQZ0JDeUFRUVJWR0RjRUJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEdqSUNBQURZQ0VDQUFRU00yQWd4QkFDRVFEUGNCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVF1WUNBZ0FBaUVBMEFJQUZCQVdvaEFReUlBUXNnQUVFVE5nSWNJQUFnRURZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFBZQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRdVlDQWdBQWlCQTBBSUFGQkFXb2hBUXp0QVFzZ0FFRVVOZ0ljSUFBZ0JEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURQVUJDeUFRUVJWR0RiMEJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR2FqNENBQURZQ0VDQUFRU0kyQWd4QkFDRVFEUFFCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVF0NENBZ0FBaUVBMEFJQUZCQVdvaEFReUdBUXNnQUVFV05nSWNJQUFnRURZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFBNQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRdDRDQWdBQWlCQTBBSUFGQkFXb2hBUXpwQVFzZ0FFRVhOZ0ljSUFBZ0JEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURQSUJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ6Wk9BZ0FBMkFoQWdBRUVNTmdJTVFRQWhFQXp4QVF0Q0FTRVJDeUFRUVFGcUlRRUNRQ0FBS1FNZ0loSkMvLy8vLy8vLy8vOFBWZzBBSUFBZ0VrSUVoaUFSaERjRElDQUJJUUVNaEFFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVHdGlZQ0FBRFlDRUNBQVFRdzJBZ3hCQUNFUURPOEJDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkJ6Wk9BZ0FBMkFoQWdBRUVNTmdJTVFRQWhFQXp1QVFzZ0FDZ0NCQ0VYSUFCQkFEWUNCQ0FRSUJHbmFpSVdJUUVnQUNBWElCQWdGaUFVR3lJUUVMV0FnSUFBSWhSRkRYTWdBRUVGTmdJY0lBQWdFRFlDRkNBQUlCUTJBZ3hCQUNFUURPMEJDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkJxcHlBZ0FBMkFoQWdBRUVQTmdJTVFRQWhFQXpzQVFzZ0FDQVFJQUlRdElDQWdBQWlBUTBCSUJBaEFRdEJEaUVRRE5FQkN3SkFJQUZCRlVjTkFDQUFRUUkyQWh3Z0FDQVFOZ0lVSUFCQnNKaUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBenFBUXNnQUVFQU5nSWNJQUFnRURZQ0ZDQUFRYWVPZ0lBQU5nSVFJQUJCRWpZQ0RFRUFJUkFNNlFFTElBRkJBV29oRUFKQUlBQXZBVEFpQVVHQUFYRkZEUUFDUUNBQUlCQWdBaEM3Z0lDQUFDSUJEUUFnRUNFQkRIQUxJQUZCRlVjTnVnRWdBRUVGTmdJY0lBQWdFRFlDRkNBQVFmbVhnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU02UUVMQWtBZ0FVR2dCSEZCb0FSSERRQWdBQzBBTFVFQ2NRMEFJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFR1drNENBQURZQ0VDQUFRUVEyQWd4QkFDRVFET2tCQ3lBQUlCQWdBaEM5Z0lDQUFCb2dFQ0VCQWtBQ1FBSkFBa0FDUUNBQUlCQWdBaEN6Z0lDQUFBNFdBZ0VBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQXdRTElBQkJBVG9BTGdzZ0FDQUFMd0V3UWNBQWNqc0JNQ0FRSVFFTFFTWWhFQXpSQVFzZ0FFRWpOZ0ljSUFBZ0VEWUNGQ0FBUWFXV2dJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTTZRRUxJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFSFZpNENBQURZQ0VDQUFRUkUyQWd4QkFDRVFET2dCQ3lBQUxRQXRRUUZ4UlEwQlFjTUJJUkFNemdFTEFrQWdEU0FDUmcwQUEwQUNRQ0FOTFFBQVFTQkdEUUFnRFNFQkRNUUJDeUFOUVFGcUlnMGdBa2NOQUF0QkpTRVFET2NCQzBFbElSQU01Z0VMSUFBb0FnUWhCQ0FBUVFBMkFnUWdBQ0FFSUEwUXI0Q0FnQUFpQkVVTnJRRWdBRUVtTmdJY0lBQWdCRFlDRENBQUlBMUJBV28yQWhSQkFDRVFET1VCQ3lBUVFSVkdEYXNCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUg5allDQUFEWUNFQ0FBUVIwMkFneEJBQ0VRRE9RQkN5QUFRU2MyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTTR3RUxJQkFoQVVFQklSUUNRQUpBQWtBQ1FBSkFBa0FDUUNBQUxRQXNRWDVxRGdjR0JRVURBUUlBQlFzZ0FDQUFMd0V3UVFoeU93RXdEQU1MUVFJaEZBd0JDMEVFSVJRTElBQkJBVG9BTENBQUlBQXZBVEFnRkhJN0FUQUxJQkFoQVF0Qkt5RVFETW9CQ3lBQVFRQTJBaHdnQUNBUU5nSVVJQUJCcTVLQWdBQTJBaEFnQUVFTE5nSU1RUUFoRUF6aUFRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFlR1BnSUFBTmdJUUlBQkJDallDREVFQUlSQU00UUVMSUFCQkFEb0FMQ0FRSVFFTXZRRUxJQkFoQVVFQklSUUNRQUpBQWtBQ1FBSkFJQUF0QUN4QmUyb09CQU1CQWdBRkN5QUFJQUF2QVRCQkNISTdBVEFNQXd0QkFpRVVEQUVMUVFRaEZBc2dBRUVCT2dBc0lBQWdBQzhCTUNBVWNqc0JNQXNnRUNFQkMwRXBJUkFNeFFFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVId2xJQ0FBRFlDRUNBQVFRTTJBZ3hCQUNFUUROMEJDd0pBSUE0dEFBQkJEVWNOQUNBQUtBSUVJUUVnQUVFQU5nSUVBa0FnQUNBQklBNFFzWUNBZ0FBaUFRMEFJQTVCQVdvaEFReDFDeUFBUVN3MkFod2dBQ0FCTmdJTUlBQWdEa0VCYWpZQ0ZFRUFJUkFNM1FFTElBQXRBQzFCQVhGRkRRRkJ4QUVoRUF6REFRc0NRQ0FPSUFKSERRQkJMU0VRRE53QkN3SkFBa0FEUUFKQUlBNHRBQUJCZG1vT0JBSUFBQU1BQ3lBT1FRRnFJZzRnQWtjTkFBdEJMU0VRRE4wQkN5QUFLQUlFSVFFZ0FFRUFOZ0lFQWtBZ0FDQUJJQTRRc1lDQWdBQWlBUTBBSUE0aEFReDBDeUFBUVN3MkFod2dBQ0FPTmdJVUlBQWdBVFlDREVFQUlSQU0zQUVMSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0RoQ3hnSUNBQUNJQkRRQWdEa0VCYWlFQkRITUxJQUJCTERZQ0hDQUFJQUUyQWd3Z0FDQU9RUUZxTmdJVVFRQWhFQXpiQVFzZ0FDZ0NCQ0VFSUFCQkFEWUNCQ0FBSUFRZ0RoQ3hnSUNBQUNJRURhQUJJQTRoQVF6T0FRc2dFRUVzUncwQklBRkJBV29oRUVFQklRRUNRQUpBQWtBQ1FBSkFJQUF0QUN4QmUyb09CQU1CQWdRQUN5QVFJUUVNQkF0QkFpRUJEQUVMUVFRaEFRc2dBRUVCT2dBc0lBQWdBQzhCTUNBQmNqc0JNQ0FRSVFFTUFRc2dBQ0FBTHdFd1FRaHlPd0V3SUJBaEFRdEJPU0VRREw4QkN5QUFRUUE2QUN3Z0FTRUJDMEUwSVJBTXZRRUxJQUFnQUM4Qk1FRWdjanNCTUNBQklRRU1BZ3NnQUNnQ0JDRUVJQUJCQURZQ0JBSkFJQUFnQkNBQkVMR0FnSUFBSWdRTkFDQUJJUUVNeHdFTElBQkJOellDSENBQUlBRTJBaFFnQUNBRU5nSU1RUUFoRUF6VUFRc2dBRUVJT2dBc0lBRWhBUXRCTUNFUURMa0JDd0pBSUFBdEFDaEJBVVlOQUNBQklRRU1CQXNnQUMwQUxVRUljVVVOa3dFZ0FTRUJEQU1MSUFBdEFEQkJJSEVObEFGQnhRRWhFQXkzQVFzQ1FDQVBJQUpHRFFBQ1FBTkFBa0FnRHkwQUFFRlFhaUlCUWY4QmNVRUtTUTBBSUE4aEFVRTFJUkFNdWdFTElBQXBBeUFpRVVLWnMrYk1tYlBtekJsV0RRRWdBQ0FSUWdwK0loRTNBeUFnRVNBQnJVTC9BWU1pRWtKL2hWWU5BU0FBSUJFZ0VudzNBeUFnRDBFQmFpSVBJQUpIRFFBTFFUa2hFQXpSQVFzZ0FDZ0NCQ0VDSUFCQkFEWUNCQ0FBSUFJZ0QwRUJhaUlFRUxHQWdJQUFJZ0lObFFFZ0JDRUJETU1CQzBFNUlSQU16d0VMQWtBZ0FDOEJNQ0lCUVFoeFJRMEFJQUF0QUNoQkFVY05BQ0FBTFFBdFFRaHhSUTJRQVFzZ0FDQUJRZmY3QTNGQmdBUnlPd0V3SUE4aEFRdEJOeUVRRExRQkN5QUFJQUF2QVRCQkVISTdBVEFNcXdFTElCQkJGVVlOaXdFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZDT2dJQUFOZ0lRSUFCQkhEWUNERUVBSVJBTXl3RUxJQUJCd3dBMkFod2dBQ0FCTmdJTUlBQWdEVUVCYWpZQ0ZFRUFJUkFNeWdFTEFrQWdBUzBBQUVFNlJ3MEFJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDdmdJQ0FBQ0lRRFFBZ0FVRUJhaUVCREdNTElBQkJ3d0EyQWh3Z0FDQVFOZ0lNSUFBZ0FVRUJhallDRkVFQUlSQU15Z0VMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUd4a1lDQUFEWUNFQ0FBUVFvMkFneEJBQ0VRRE1rQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQm9KbUFnQUEyQWhBZ0FFRWVOZ0lNUVFBaEVBeklBUXNnQUVFQU5nSUFDeUFBUVlBU093RXFJQUFnRjBFQmFpSUJJQUlRcUlDQWdBQWlFQTBCSUFFaEFRdEJ4d0FoRUF5c0FRc2dFRUVWUncyREFTQUFRZEVBTmdJY0lBQWdBVFlDRkNBQVFlT1hnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU14QUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREY0TElBQkIwZ0EyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXd3RUxJQUJCQURZQ0hDQUFJQlEyQWhRZ0FFSEJxSUNBQURZQ0VDQUFRUWMyQWd3Z0FFRUFOZ0lBUVFBaEVBekNBUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNWFFzZ0FFSFRBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF6QkFRdEJBQ0VRSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdBa1lDQUFEWUNFQ0FBUVFrMkFnd013QUVMSUJCQkZVWU5mU0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJsSTJBZ0FBMkFoQWdBRUVoTmdJTVFRQWhFQXkvQVF0QkFTRVdRUUFoRjBFQUlSUkJBU0VRQ3lBQUlCQTZBQ3NnQVVFQmFpRUJBa0FDUUNBQUxRQXRRUkJ4RFFBQ1FBSkFBa0FnQUMwQUtnNERBUUFDQkFzZ0ZrVU5Bd3dDQ3lBVURRRU1BZ3NnRjBVTkFRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUsyQWdJQUFJaEFOQUNBQklRRU1YQXNnQUVIWUFEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXkrQVFzZ0FDZ0NCQ0VFSUFCQkFEWUNCQUpBSUFBZ0JDQUJFSzJBZ0lBQUlnUU5BQ0FCSVFFTXJRRUxJQUJCMlFBMkFod2dBQ0FCTmdJVUlBQWdCRFlDREVFQUlSQU12UUVMSUFBb0FnUWhCQ0FBUVFBMkFnUUNRQ0FBSUFRZ0FSQ3RnSUNBQUNJRURRQWdBU0VCREtzQkN5QUFRZG9BTmdJY0lBQWdBVFlDRkNBQUlBUTJBZ3hCQUNFUURMd0JDeUFBS0FJRUlRUWdBRUVBTmdJRUFrQWdBQ0FFSUFFUXJZQ0FnQUFpQkEwQUlBRWhBUXlwQVFzZ0FFSGNBRFlDSENBQUlBRTJBaFFnQUNBRU5nSU1RUUFoRUF5N0FRc0NRQ0FCTFFBQVFWQnFJaEJCL3dGeFFRcFBEUUFnQUNBUU9nQXFJQUZCQVdvaEFVSFBBQ0VRREtJQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRcllDQWdBQWlCQTBBSUFFaEFReW5BUXNnQUVIZUFEWUNIQ0FBSUFFMkFoUWdBQ0FFTmdJTVFRQWhFQXk2QVFzZ0FFRUFOZ0lBSUJkQkFXb2hBUUpBSUFBdEFDbEJJMDhOQUNBQklRRU1XUXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZE9KZ0lBQU5nSVFJQUJCQ0RZQ0RFRUFJUkFNdVFFTElBQkJBRFlDQUF0QkFDRVFJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR1FzNENBQURZQ0VDQUFRUWcyQWd3TXR3RUxJQUJCQURZQ0FDQVhRUUZxSVFFQ1FDQUFMUUFwUVNGSERRQWdBU0VCREZZTElBQkJBRFlDSENBQUlBRTJBaFFnQUVHYmlvQ0FBRFlDRUNBQVFRZzJBZ3hCQUNFUURMWUJDeUFBUVFBMkFnQWdGMEVCYWlFQkFrQWdBQzBBS1NJUVFWMXFRUXRQRFFBZ0FTRUJERlVMQWtBZ0VFRUdTdzBBUVFFZ0VIUkJ5Z0J4UlEwQUlBRWhBUXhWQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFmZUpnSUFBTmdJUUlBQkJDRFlDREF5MUFRc2dFRUVWUmcxeElBQkJBRFlDSENBQUlBRTJBaFFnQUVHNWpZQ0FBRFlDRUNBQVFSbzJBZ3hCQUNFUURMUUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhVQ3lBQVFlVUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRExNQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcDRDQWdBQWlFQTBBSUFFaEFReE5DeUFBUWRJQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFETElCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVFwNENBZ0FBaUVBMEFJQUVoQVF4TkN5QUFRZE1BTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURMRUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhSQ3lBQVFlVUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRExBQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnhvcUFnQUEyQWhBZ0FFRUhOZ0lNUVFBaEVBeXZBUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNU1FzZ0FFSFNBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF5dUFRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUtlQWdJQUFJaEFOQUNBQklRRU1TUXNnQUVIVEFEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXl0QVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFS2VBZ0lBQUloQU5BQ0FCSVFFTVRRc2dBRUhsQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeXNBUXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZHlJZ0lBQU5nSVFJQUJCQnpZQ0RFRUFJUkFNcXdFTElCQkJQMGNOQVNBQlFRRnFJUUVMUVFVaEVBeVFBUXRCQUNFUUlBQkJBRFlDSENBQUlBRTJBaFFnQUVIOWtvQ0FBRFlDRUNBQVFRYzJBZ3dNcUFFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkNuZ0lDQUFDSVFEUUFnQVNFQkRFSUxJQUJCMGdBMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU1wd0VMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREVJTElBQkIwd0EyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXBnRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERVlMSUFCQjVRQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNcFFFTElBQW9BZ1FoQVNBQVFRQTJBZ1FDUUNBQUlBRWdGQkNuZ0lDQUFDSUJEUUFnRkNFQkREOExJQUJCMGdBMkFod2dBQ0FVTmdJVUlBQWdBVFlDREVFQUlSQU1wQUVMSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0ZCQ25nSUNBQUNJQkRRQWdGQ0VCREQ4TElBQkIwd0EyQWh3Z0FDQVVOZ0lVSUFBZ0FUWUNERUVBSVJBTW93RUxJQUFvQWdRaEFTQUFRUUEyQWdRQ1FDQUFJQUVnRkJDbmdJQ0FBQ0lCRFFBZ0ZDRUJERU1MSUFCQjVRQTJBaHdnQUNBVU5nSVVJQUFnQVRZQ0RFRUFJUkFNb2dFTElBQkJBRFlDSENBQUlCUTJBaFFnQUVIRGo0Q0FBRFlDRUNBQVFRYzJBZ3hCQUNFUURLRUJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ3NCtBZ0FBMkFoQWdBRUVITmdJTVFRQWhFQXlnQVF0QkFDRVFJQUJCQURZQ0hDQUFJQlEyQWhRZ0FFR01uSUNBQURZQ0VDQUFRUWMyQWd3TW53RUxJQUJCQURZQ0hDQUFJQlEyQWhRZ0FFR01uSUNBQURZQ0VDQUFRUWMyQWd4QkFDRVFESjRCQ3lBQVFRQTJBaHdnQUNBVU5nSVVJQUJCL3BHQWdBQTJBaEFnQUVFSE5nSU1RUUFoRUF5ZEFRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFZNmJnSUFBTmdJUUlBQkJCallDREVFQUlSQU1uQUVMSUJCQkZVWU5WeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ6STZBZ0FBMkFoQWdBRUVnTmdJTVFRQWhFQXliQVFzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVrSVJBTElBQWdFRG9BS1NBQUtBSUVJUkFnQUVFQU5nSUVJQUFnRUNBQkVLdUFnSUFBSWhBTlZDQUJJUUVNUGdzZ0FFRUFOZ0lBQzBFQUlSQWdBRUVBTmdJY0lBQWdCRFlDRkNBQVFmR2JnSUFBTmdJUUlBQkJCallDREF5WEFRc2dBVUVWUmcxUUlBQkJBRFlDSENBQUlBVTJBaFFnQUVId2pJQ0FBRFlDRUNBQVFSczJBZ3hCQUNFUURKWUJDeUFBS0FJRUlRVWdBRUVBTmdJRUlBQWdCU0FRRUttQWdJQUFJZ1VOQVNBUVFRRnFJUVVMUWEwQklSQU1ld3NnQUVIQkFUWUNIQ0FBSUFVMkFnd2dBQ0FRUVFGcU5nSVVRUUFoRUF5VEFRc2dBQ2dDQkNFR0lBQkJBRFlDQkNBQUlBWWdFQkNwZ0lDQUFDSUdEUUVnRUVFQmFpRUdDMEd1QVNFUURIZ0xJQUJCd2dFMkFod2dBQ0FHTmdJTUlBQWdFRUVCYWpZQ0ZFRUFJUkFNa0FFTElBQkJBRFlDSENBQUlBYzJBaFFnQUVHWGk0Q0FBRFlDRUNBQVFRMDJBZ3hCQUNFUURJOEJDeUFBUVFBMkFod2dBQ0FJTmdJVUlBQkI0NUNBZ0FBMkFoQWdBRUVKTmdJTVFRQWhFQXlPQVFzZ0FFRUFOZ0ljSUFBZ0NEWUNGQ0FBUVpTTmdJQUFOZ0lRSUFCQklUWUNERUVBSVJBTWpRRUxRUUVoRmtFQUlSZEJBQ0VVUVFFaEVBc2dBQ0FRT2dBcklBbEJBV29oQ0FKQUFrQWdBQzBBTFVFUWNRMEFBa0FDUUFKQUlBQXRBQ29PQXdFQUFnUUxJQlpGRFFNTUFnc2dGQTBCREFJTElCZEZEUUVMSUFBb0FnUWhFQ0FBUVFBMkFnUWdBQ0FRSUFnUXJZQ0FnQUFpRUVVTlBTQUFRY2tCTmdJY0lBQWdDRFlDRkNBQUlCQTJBZ3hCQUNFUURJd0JDeUFBS0FJRUlRUWdBRUVBTmdJRUlBQWdCQ0FJRUsyQWdJQUFJZ1JGRFhZZ0FFSEtBVFlDSENBQUlBZzJBaFFnQUNBRU5nSU1RUUFoRUF5TEFRc2dBQ2dDQkNFRUlBQkJBRFlDQkNBQUlBUWdDUkN0Z0lDQUFDSUVSUTEwSUFCQnl3RTJBaHdnQUNBSk5nSVVJQUFnQkRZQ0RFRUFJUkFNaWdFTElBQW9BZ1FoQkNBQVFRQTJBZ1FnQUNBRUlBb1FyWUNBZ0FBaUJFVU5jaUFBUWMwQk5nSWNJQUFnQ2pZQ0ZDQUFJQVEyQWd4QkFDRVFESWtCQ3dKQUlBc3RBQUJCVUdvaUVFSC9BWEZCQ2s4TkFDQUFJQkE2QUNvZ0MwRUJhaUVLUWJZQklSQU1jQXNnQUNnQ0JDRUVJQUJCQURZQ0JDQUFJQVFnQ3hDdGdJQ0FBQ0lFUlExd0lBQkJ6d0UyQWh3Z0FDQUxOZ0lVSUFBZ0JEWUNERUVBSVJBTWlBRUxJQUJCQURZQ0hDQUFJQVEyQWhRZ0FFR1FzNENBQURZQ0VDQUFRUWcyQWd3Z0FFRUFOZ0lBUVFBaEVBeUhBUXNnQVVFVlJnMC9JQUJCQURZQ0hDQUFJQXcyQWhRZ0FFSE1qb0NBQURZQ0VDQUFRU0EyQWd4QkFDRVFESVlCQ3lBQVFZRUVPd0VvSUFBb0FnUWhFQ0FBUWdBM0F3QWdBQ0FRSUF4QkFXb2lEQkNyZ0lDQUFDSVFSUTA0SUFCQjB3RTJBaHdnQUNBTU5nSVVJQUFnRURZQ0RFRUFJUkFNaFFFTElBQkJBRFlDQUF0QkFDRVFJQUJCQURZQ0hDQUFJQVEyQWhRZ0FFSFltNENBQURZQ0VDQUFRUWcyQWd3TWd3RUxJQUFvQWdRaEVDQUFRZ0EzQXdBZ0FDQVFJQXRCQVdvaUN4Q3JnSUNBQUNJUURRRkJ4Z0VoRUF4cEN5QUFRUUk2QUNnTVZRc2dBRUhWQVRZQ0hDQUFJQXMyQWhRZ0FDQVFOZ0lNUVFBaEVBeUFBUXNnRUVFVlJnMDNJQUJCQURZQ0hDQUFJQVEyQWhRZ0FFR2tqSUNBQURZQ0VDQUFRUkEyQWd4QkFDRVFESDhMSUFBdEFEUkJBVWNOTkNBQUlBUWdBaEM4Z0lDQUFDSVFSUTAwSUJCQkZVY05OU0FBUWR3Qk5nSWNJQUFnQkRZQ0ZDQUFRZFdXZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNZmd0QkFDRVFJQUJCQURZQ0hDQUFRYStMZ0lBQU5nSVFJQUJCQWpZQ0RDQUFJQlJCQVdvMkFoUU1mUXRCQUNFUURHTUxRUUloRUF4aUMwRU5JUkFNWVF0QkR5RVFER0FMUVNVaEVBeGZDMEVUSVJBTVhndEJGU0VRREYwTFFSWWhFQXhjQzBFWElSQU1Xd3RCR0NFUURGb0xRUmtoRUF4WkMwRWFJUkFNV0F0Qkd5RVFERmNMUVJ3aEVBeFdDMEVkSVJBTVZRdEJIeUVRREZRTFFTRWhFQXhUQzBFaklSQU1VZ3RCeGdBaEVBeFJDMEV1SVJBTVVBdEJMeUVRREU4TFFUc2hFQXhPQzBFOUlSQU1UUXRCeUFBaEVBeE1DMEhKQUNFUURFc0xRY3NBSVJBTVNndEJ6QUFoRUF4SkMwSE9BQ0VRREVnTFFkRUFJUkFNUnd0QjFRQWhFQXhHQzBIWUFDRVFERVVMUWRrQUlSQU1SQXRCMndBaEVBeERDMEhrQUNFUURFSUxRZVVBSVJBTVFRdEI4UUFoRUF4QUMwSDBBQ0VRREQ4TFFZMEJJUkFNUGd0Qmx3RWhFQXc5QzBHcEFTRVFERHdMUWF3QklSQU1Pd3RCd0FFaEVBdzZDMEc1QVNFUUREa0xRYThCSVJBTU9BdEJzUUVoRUF3M0MwR3lBU0VRRERZTFFiUUJJUkFNTlF0QnRRRWhFQXcwQzBHNkFTRVFERE1MUWIwQklSQU1NZ3RCdndFaEVBd3hDMEhCQVNFUUREQUxJQUJCQURZQ0hDQUFJQVEyQWhRZ0FFSHBpNENBQURZQ0VDQUFRUjgyQWd4QkFDRVFERWdMSUFCQjJ3RTJBaHdnQUNBRU5nSVVJQUJCK3BhQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF4SEN5QUFRZmdBTmdJY0lBQWdERFlDRkNBQVFjcVlnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1SZ3NnQUVIUkFEWUNIQ0FBSUFVMkFoUWdBRUd3bDRDQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREVVTElBQkIrUUEyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTVJBc2dBRUg0QURZQ0hDQUFJQUUyQWhRZ0FFSEttSUNBQURZQ0VDQUFRUlUyQWd4QkFDRVFERU1MSUFCQjVBQTJBaHdnQUNBQk5nSVVJQUJCNDVlQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF4Q0N5QUFRZGNBTmdJY0lBQWdBVFlDRkNBQVFjbVhnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1RUXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYm1OZ0lBQU5nSVFJQUJCR2pZQ0RFRUFJUkFNUUFzZ0FFSENBRFlDSENBQUlBRTJBaFFnQUVIam1JQ0FBRFlDRUNBQVFSVTJBZ3hCQUNFUUREOExJQUJCQURZQ0JDQUFJQThnRHhDeGdJQ0FBQ0lFUlEwQklBQkJPallDSENBQUlBUTJBZ3dnQUNBUFFRRnFOZ0lVUVFBaEVBdytDeUFBS0FJRUlRUWdBRUVBTmdJRUFrQWdBQ0FFSUFFUXNZQ0FnQUFpQkVVTkFDQUFRVHMyQWh3Z0FDQUVOZ0lNSUFBZ0FVRUJhallDRkVFQUlSQU1QZ3NnQVVFQmFpRUJEQzBMSUE5QkFXb2hBUXd0Q3lBQVFRQTJBaHdnQUNBUE5nSVVJQUJCNUpLQWdBQTJBaEFnQUVFRU5nSU1RUUFoRUF3N0N5QUFRVFkyQWh3Z0FDQUVOZ0lVSUFBZ0FqWUNERUVBSVJBTU9nc2dBRUV1TmdJY0lBQWdEallDRkNBQUlBUTJBZ3hCQUNFUUREa0xJQUJCMEFBMkFod2dBQ0FCTmdJVUlBQkJrWmlBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXc0Q3lBTlFRRnFJUUVNTEFzZ0FFRVZOZ0ljSUFBZ0FUWUNGQ0FBUVlLWmdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTU5nc2dBRUViTmdJY0lBQWdBVFlDRkNBQVFaR1hnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1OUXNnQUVFUE5nSWNJQUFnQVRZQ0ZDQUFRWkdYZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTkFzZ0FFRUxOZ0ljSUFBZ0FUWUNGQ0FBUVpHWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTU13c2dBRUVhTmdJY0lBQWdBVFlDRkNBQVFZS1pnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1NZ3NnQUVFTE5nSWNJQUFnQVRZQ0ZDQUFRWUtaZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTVFzZ0FFRUtOZ0ljSUFBZ0FUWUNGQ0FBUWVTV2dJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTU1Bc2dBRUVlTmdJY0lBQWdBVFlDRkNBQVFmbVhnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1Md3NnQUVFQU5nSWNJQUFnRURZQ0ZDQUFRZHFOZ0lBQU5nSVFJQUJCRkRZQ0RFRUFJUkFNTGdzZ0FFRUVOZ0ljSUFBZ0FUWUNGQ0FBUWJDWWdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTUxRc2dBRUVBTmdJQUlBdEJBV29oQ3d0QnVBRWhFQXdTQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRZlVBSVJBTUVRc2dBU0VCQWtBZ0FDMEFLVUVGUncwQVFlTUFJUkFNRVF0QjRnQWhFQXdRQzBFQUlSQWdBRUVBTmdJY0lBQkI1SkdBZ0FBMkFoQWdBRUVITmdJTUlBQWdGRUVCYWpZQ0ZBd29DeUFBUVFBMkFnQWdGMEVCYWlFQlFjQUFJUkFNRGd0QkFTRUJDeUFBSUFFNkFDd2dBRUVBTmdJQUlCZEJBV29oQVF0QktDRVFEQXNMSUFFaEFRdEJPQ0VRREFrTEFrQWdBU0lQSUFKR0RRQURRQUpBSUE4dEFBQkJnTDZBZ0FCcUxRQUFJZ0ZCQVVZTkFDQUJRUUpIRFFNZ0QwRUJhaUVCREFRTElBOUJBV29pRHlBQ1J3MEFDMEUrSVJBTUlndEJQaUVRRENFTElBQkJBRG9BTENBUElRRU1BUXRCQ3lFUURBWUxRVG9oRUF3RkN5QUJRUUZxSVFGQkxTRVFEQVFMSUFBZ0FUb0FMQ0FBUVFBMkFnQWdGa0VCYWlFQlFRd2hFQXdEQ3lBQVFRQTJBZ0FnRjBFQmFpRUJRUW9oRUF3Q0N5QUFRUUEyQWdBTElBQkJBRG9BTENBTklRRkJDU0VRREFBTEMwRUFJUkFnQUVFQU5nSWNJQUFnQ3pZQ0ZDQUFRYzJRZ0lBQU5nSVFJQUJCQ1RZQ0RBd1hDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0NqWUNGQ0FBUWVtS2dJQUFOZ0lRSUFCQkNUWUNEQXdXQzBFQUlSQWdBRUVBTmdJY0lBQWdDVFlDRkNBQVFiZVFnSUFBTmdJUUlBQkJDVFlDREF3VkMwRUFJUkFnQUVFQU5nSWNJQUFnQ0RZQ0ZDQUFRWnlSZ0lBQU5nSVFJQUJCQ1RZQ0RBd1VDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWMyUWdJQUFOZ0lRSUFCQkNUWUNEQXdUQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFlbUtnSUFBTmdJUUlBQkJDVFlDREF3U0MwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYmVRZ0lBQU5nSVFJQUJCQ1RZQ0RBd1JDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVp5UmdJQUFOZ0lRSUFCQkNUWUNEQXdRQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFaZVZnSUFBTmdJUUlBQkJEellDREF3UEMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWmVWZ0lBQU5nSVFJQUJCRHpZQ0RBd09DMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWNDU2dJQUFOZ0lRSUFCQkN6WUNEQXdOQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFaV0pnSUFBTmdJUUlBQkJDellDREF3TUMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZUdQZ0lBQU5nSVFJQUJCQ2pZQ0RBd0xDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZ1UGdJQUFOZ0lRSUFCQkNqWUNEQXdLQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFmR1pnSUFBTmdJUUlBQkJBallDREF3SkMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRY1NVZ0lBQU5nSVFJQUJCQWpZQ0RBd0lDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZLVmdJQUFOZ0lRSUFCQkFqWUNEQXdIQ3lBQVFRSTJBaHdnQUNBQk5nSVVJQUJCbkpxQWdBQTJBaEFnQUVFV05nSU1RUUFoRUF3R0MwRUJJUkFNQlF0QjFBQWhFQ0FCSWdRZ0FrWU5CQ0FEUVFocUlBQWdCQ0FDUWRqQ2dJQUFRUW9ReFlDQWdBQWdBeWdDRENFRUlBTW9BZ2dPQXdFRUFnQUxFTXFBZ0lBQUFBc2dBRUVBTmdJY0lBQkJ0WnFBZ0FBMkFoQWdBRUVYTmdJTUlBQWdCRUVCYWpZQ0ZFRUFJUkFNQWdzZ0FFRUFOZ0ljSUFBZ0JEWUNGQ0FBUWNxYWdJQUFOZ0lRSUFCQkNUWUNERUVBSVJBTUFRc0NRQ0FCSWdRZ0FrY05BRUVpSVJBTUFRc2dBRUdKZ0lDQUFEWUNDQ0FBSUFRMkFnUkJJU0VRQ3lBRFFSQnFKSUNBZ0lBQUlCQUxyd0VCQW44Z0FTZ0NBQ0VHQWtBQ1FDQUNJQU5HRFFBZ0JDQUdhaUVFSUFZZ0Eyb2dBbXNoQnlBQ0lBWkJmM01nQldvaUJtb2hCUU5BQWtBZ0FpMEFBQ0FFTFFBQVJnMEFRUUloQkF3REN3SkFJQVlOQUVFQUlRUWdCU0VDREFNTElBWkJmMm9oQmlBRVFRRnFJUVFnQWtFQmFpSUNJQU5IRFFBTElBY2hCaUFESVFJTElBQkJBVFlDQUNBQklBWTJBZ0FnQUNBQ05nSUVEd3NnQVVFQU5nSUFJQUFnQkRZQ0FDQUFJQUkyQWdRTENnQWdBQkRIZ0lDQUFBdnlOZ0VMZnlPQWdJQ0FBRUVRYXlJQkpJQ0FnSUFBQWtCQkFDZ0NvTkNBZ0FBTkFFRUFFTXVBZ0lBQVFZRFVoSUFBYXlJQ1Fka0FTUTBBUVFBaEF3SkFRUUFvQXVEVGdJQUFJZ1FOQUVFQVFuODNBdXpUZ0lBQVFRQkNnSUNFZ0lDQXdBQTNBdVRUZ0lBQVFRQWdBVUVJYWtGd2NVSFlxdFdxQlhNaUJEWUM0Tk9BZ0FCQkFFRUFOZ0wwMDRDQUFFRUFRUUEyQXNUVGdJQUFDMEVBSUFJMkFzelRnSUFBUVFCQmdOU0VnQUEyQXNqVGdJQUFRUUJCZ05TRWdBQTJBcGpRZ0lBQVFRQWdCRFlDck5DQWdBQkJBRUYvTmdLbzBJQ0FBQU5BSUFOQnhOQ0FnQUJxSUFOQnVOQ0FnQUJxSWdRMkFnQWdCQ0FEUWJEUWdJQUFhaUlGTmdJQUlBTkJ2TkNBZ0FCcUlBVTJBZ0FnQTBITTBJQ0FBR29nQTBIQTBJQ0FBR29pQlRZQ0FDQUZJQVEyQWdBZ0EwSFUwSUNBQUdvZ0EwSEkwSUNBQUdvaUJEWUNBQ0FFSUFVMkFnQWdBMEhRMElDQUFHb2dCRFlDQUNBRFFTQnFJZ05CZ0FKSERRQUxRWURVaElBQVFYaEJnTlNFZ0FCclFROXhRUUJCZ05TRWdBQkJDR3BCRDNFYklnTnFJZ1JCQkdvZ0FrRklhaUlGSUFOcklnTkJBWEkyQWdCQkFFRUFLQUx3MDRDQUFEWUNwTkNBZ0FCQkFDQUROZ0tVMElDQUFFRUFJQVEyQXFEUWdJQUFRWURVaElBQUlBVnFRVGcyQWdRTEFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQjdBRkxEUUFDUUVFQUtBS0kwSUNBQUNJR1FSQWdBRUVUYWtGd2NTQUFRUXRKR3lJQ1FRTjJJZ1IySWdOQkEzRkZEUUFDUUFKQUlBTkJBWEVnQkhKQkFYTWlCVUVEZENJRVFiRFFnSUFBYWlJRElBUkJ1TkNBZ0FCcUtBSUFJZ1FvQWdnaUFrY05BRUVBSUFaQmZpQUZkM0UyQW9qUWdJQUFEQUVMSUFNZ0FqWUNDQ0FDSUFNMkFnd0xJQVJCQ0dvaEF5QUVJQVZCQTNRaUJVRURjallDQkNBRUlBVnFJZ1FnQkNnQ0JFRUJjallDQkF3TUN5QUNRUUFvQXBEUWdJQUFJZ2RORFFFQ1FDQURSUTBBQWtBQ1FDQURJQVIwUVFJZ0JIUWlBMEVBSUFOcmNuRWlBMEVBSUFOcmNVRi9haUlESUFOQkRIWkJFSEVpQTNZaUJFRUZka0VJY1NJRklBTnlJQVFnQlhZaUEwRUNka0VFY1NJRWNpQURJQVIySWdOQkFYWkJBbkVpQkhJZ0F5QUVkaUlEUVFGMlFRRnhJZ1J5SUFNZ0JIWnFJZ1JCQTNRaUEwR3cwSUNBQUdvaUJTQURRYmpRZ0lBQWFpZ0NBQ0lES0FJSUlnQkhEUUJCQUNBR1FYNGdCSGR4SWdZMkFvalFnSUFBREFFTElBVWdBRFlDQ0NBQUlBVTJBZ3dMSUFNZ0FrRURjallDQkNBRElBUkJBM1FpQkdvZ0JDQUNheUlGTmdJQUlBTWdBbW9pQUNBRlFRRnlOZ0lFQWtBZ0IwVU5BQ0FIUVhoeFFiRFFnSUFBYWlFQ1FRQW9BcHpRZ0lBQUlRUUNRQUpBSUFaQkFTQUhRUU4yZENJSWNRMEFRUUFnQmlBSWNqWUNpTkNBZ0FBZ0FpRUlEQUVMSUFJb0FnZ2hDQXNnQ0NBRU5nSU1JQUlnQkRZQ0NDQUVJQUkyQWd3Z0JDQUlOZ0lJQ3lBRFFRaHFJUU5CQUNBQU5nS2MwSUNBQUVFQUlBVTJBcERRZ0lBQURBd0xRUUFvQW96UWdJQUFJZ2xGRFFFZ0NVRUFJQWxyY1VGL2FpSURJQU5CREhaQkVIRWlBM1lpQkVFRmRrRUljU0lGSUFOeUlBUWdCWFlpQTBFQ2RrRUVjU0lFY2lBRElBUjJJZ05CQVhaQkFuRWlCSElnQXlBRWRpSURRUUYyUVFGeElnUnlJQU1nQkhacVFRSjBRYmpTZ0lBQWFpZ0NBQ0lBS0FJRVFYaHhJQUpySVFRZ0FDRUZBa0FEUUFKQUlBVW9BaEFpQXcwQUlBVkJGR29vQWdBaUEwVU5BZ3NnQXlnQ0JFRjRjU0FDYXlJRklBUWdCU0FFU1NJRkd5RUVJQU1nQUNBRkd5RUFJQU1oQlF3QUN3c2dBQ2dDR0NFS0FrQWdBQ2dDRENJSUlBQkdEUUFnQUNnQ0NDSURRUUFvQXBqUWdJQUFTUm9nQ0NBRE5nSUlJQU1nQ0RZQ0RBd0xDd0pBSUFCQkZHb2lCU2dDQUNJRERRQWdBQ2dDRUNJRFJRMERJQUJCRUdvaEJRc0RRQ0FGSVFzZ0F5SUlRUlJxSWdVb0FnQWlBdzBBSUFoQkVHb2hCU0FJS0FJUUlnTU5BQXNnQzBFQU5nSUFEQW9MUVg4aEFpQUFRYjkvU3cwQUlBQkJFMm9pQTBGd2NTRUNRUUFvQW96UWdJQUFJZ2RGRFFCQkFDRUxBa0FnQWtHQUFra05BRUVmSVFzZ0FrSC8vLzhIU3cwQUlBTkJDSFlpQXlBRFFZRCtQMnBCRUhaQkNIRWlBM1FpQkNBRVFZRGdIMnBCRUhaQkJIRWlCSFFpQlNBRlFZQ0FEMnBCRUhaQkFuRWlCWFJCRDNZZ0F5QUVjaUFGY21zaUEwRUJkQ0FDSUFOQkZXcDJRUUZ4Y2tFY2FpRUxDMEVBSUFKcklRUUNRQUpBQWtBQ1FDQUxRUUowUWJqU2dJQUFhaWdDQUNJRkRRQkJBQ0VEUVFBaENBd0JDMEVBSVFNZ0FrRUFRUmtnQzBFQmRtc2dDMEVmUmh0MElRQkJBQ0VJQTBBQ1FDQUZLQUlFUVhoeElBSnJJZ1lnQkU4TkFDQUdJUVFnQlNFSUlBWU5BRUVBSVFRZ0JTRUlJQVVoQXd3REN5QURJQVZCRkdvb0FnQWlCaUFHSUFVZ0FFRWRka0VFY1dwQkVHb29BZ0FpQlVZYklBTWdCaHNoQXlBQVFRRjBJUUFnQlEwQUN3c0NRQ0FESUFoeURRQkJBQ0VJUVFJZ0MzUWlBMEVBSUFOcmNpQUhjU0lEUlEwRElBTkJBQ0FEYTNGQmYyb2lBeUFEUVF4MlFSQnhJZ04ySWdWQkJYWkJDSEVpQUNBRGNpQUZJQUIySWdOQkFuWkJCSEVpQlhJZ0F5QUZkaUlEUVFGMlFRSnhJZ1Z5SUFNZ0JYWWlBMEVCZGtFQmNTSUZjaUFESUFWMmFrRUNkRUc0MG9DQUFHb29BZ0FoQXdzZ0EwVU5BUXNEUUNBREtBSUVRWGh4SUFKcklnWWdCRWtoQUFKQUlBTW9BaEFpQlEwQUlBTkJGR29vQWdBaEJRc2dCaUFFSUFBYklRUWdBeUFJSUFBYklRZ2dCU0VESUFVTkFBc0xJQWhGRFFBZ0JFRUFLQUtRMElDQUFDQUNhMDhOQUNBSUtBSVlJUXNDUUNBSUtBSU1JZ0FnQ0VZTkFDQUlLQUlJSWdOQkFDZ0NtTkNBZ0FCSkdpQUFJQU0yQWdnZ0F5QUFOZ0lNREFrTEFrQWdDRUVVYWlJRktBSUFJZ01OQUNBSUtBSVFJZ05GRFFNZ0NFRVFhaUVGQ3dOQUlBVWhCaUFESWdCQkZHb2lCU2dDQUNJRERRQWdBRUVRYWlFRklBQW9BaEFpQXcwQUN5QUdRUUEyQWdBTUNBc0NRRUVBS0FLUTBJQ0FBQ0lESUFKSkRRQkJBQ2dDbk5DQWdBQWhCQUpBQWtBZ0F5QUNheUlGUVJCSkRRQWdCQ0FDYWlJQUlBVkJBWEkyQWdSQkFDQUZOZ0tRMElDQUFFRUFJQUEyQXB6UWdJQUFJQVFnQTJvZ0JUWUNBQ0FFSUFKQkEzSTJBZ1FNQVFzZ0JDQURRUU55TmdJRUlBUWdBMm9pQXlBREtBSUVRUUZ5TmdJRVFRQkJBRFlDbk5DQWdBQkJBRUVBTmdLUTBJQ0FBQXNnQkVFSWFpRUREQW9MQWtCQkFDZ0NsTkNBZ0FBaUFDQUNUUTBBUVFBb0FxRFFnSUFBSWdNZ0Ftb2lCQ0FBSUFKcklnVkJBWEkyQWdSQkFDQUZOZ0tVMElDQUFFRUFJQVEyQXFEUWdJQUFJQU1nQWtFRGNqWUNCQ0FEUVFocUlRTU1DZ3NDUUFKQVFRQW9BdURUZ0lBQVJRMEFRUUFvQXVqVGdJQUFJUVFNQVF0QkFFSi9Od0xzMDRDQUFFRUFRb0NBaElDQWdNQUFOd0xrMDRDQUFFRUFJQUZCREdwQmNIRkIyS3JWcWdWek5nTGcwNENBQUVFQVFRQTJBdlRUZ0lBQVFRQkJBRFlDeE5PQWdBQkJnSUFFSVFRTFFRQWhBd0pBSUFRZ0FrSEhBR29pQjJvaUJrRUFJQVJySWd0eElnZ2dBa3NOQUVFQVFUQTJBdmpUZ0lBQURBb0xBa0JCQUNnQ3dOT0FnQUFpQTBVTkFBSkFRUUFvQXJqVGdJQUFJZ1FnQ0dvaUJTQUVUUTBBSUFVZ0EwME5BUXRCQUNFRFFRQkJNRFlDK05PQWdBQU1DZ3RCQUMwQXhOT0FnQUJCQkhFTkJBSkFBa0FDUUVFQUtBS2cwSUNBQUNJRVJRMEFRY2pUZ0lBQUlRTURRQUpBSUFNb0FnQWlCU0FFU3cwQUlBVWdBeWdDQkdvZ0JFc05Bd3NnQXlnQ0NDSUREUUFMQzBFQUVNdUFnSUFBSWdCQmYwWU5CU0FJSVFZQ1FFRUFLQUxrMDRDQUFDSURRWDlxSWdRZ0FIRkZEUUFnQ0NBQWF5QUVJQUJxUVFBZ0EydHhhaUVHQ3lBR0lBSk5EUVVnQmtIKy8vLy9CMHNOQlFKQVFRQW9Bc0RUZ0lBQUlnTkZEUUJCQUNnQ3VOT0FnQUFpQkNBR2FpSUZJQVJORFFZZ0JTQURTdzBHQ3lBR0VNdUFnSUFBSWdNZ0FFY05BUXdIQ3lBR0lBQnJJQXR4SWdaQi92Ly8vd2RMRFFRZ0JoRExnSUNBQUNJQUlBTW9BZ0FnQXlnQ0JHcEdEUU1nQUNFREN3SkFJQU5CZjBZTkFDQUNRY2dBYWlBR1RRMEFBa0FnQnlBR2EwRUFLQUxvMDRDQUFDSUVha0VBSUFScmNTSUVRZjcvLy84SFRRMEFJQU1oQUF3SEN3SkFJQVFReTRDQWdBQkJmMFlOQUNBRUlBWnFJUVlnQXlFQURBY0xRUUFnQm1zUXk0Q0FnQUFhREFRTElBTWhBQ0FEUVg5SERRVU1Bd3RCQUNFSURBY0xRUUFoQUF3RkN5QUFRWDlIRFFJTFFRQkJBQ2dDeE5PQWdBQkJCSEkyQXNUVGdJQUFDeUFJUWY3Ly8vOEhTdzBCSUFnUXk0Q0FnQUFoQUVFQUVNdUFnSUFBSVFNZ0FFRi9SZzBCSUFOQmYwWU5BU0FBSUFOUERRRWdBeUFBYXlJR0lBSkJPR3BORFFFTFFRQkJBQ2dDdU5PQWdBQWdCbW9pQXpZQ3VOT0FnQUFDUUNBRFFRQW9BcnpUZ0lBQVRRMEFRUUFnQXpZQ3ZOT0FnQUFMQWtBQ1FBSkFBa0JCQUNnQ29OQ0FnQUFpQkVVTkFFSEkwNENBQUNFREEwQWdBQ0FES0FJQUlnVWdBeWdDQkNJSWFrWU5BaUFES0FJSUlnTU5BQXdEQ3dzQ1FBSkFRUUFvQXBqUWdJQUFJZ05GRFFBZ0FDQURUdzBCQzBFQUlBQTJBcGpRZ0lBQUMwRUFJUU5CQUNBR05nTE0wNENBQUVFQUlBQTJBc2pUZ0lBQVFRQkJmellDcU5DQWdBQkJBRUVBS0FMZzA0Q0FBRFlDck5DQWdBQkJBRUVBTmdMVTA0Q0FBQU5BSUFOQnhOQ0FnQUJxSUFOQnVOQ0FnQUJxSWdRMkFnQWdCQ0FEUWJEUWdJQUFhaUlGTmdJQUlBTkJ2TkNBZ0FCcUlBVTJBZ0FnQTBITTBJQ0FBR29nQTBIQTBJQ0FBR29pQlRZQ0FDQUZJQVEyQWdBZ0EwSFUwSUNBQUdvZ0EwSEkwSUNBQUdvaUJEWUNBQ0FFSUFVMkFnQWdBMEhRMElDQUFHb2dCRFlDQUNBRFFTQnFJZ05CZ0FKSERRQUxJQUJCZUNBQWEwRVBjVUVBSUFCQkNHcEJEM0ViSWdOcUlnUWdCa0ZJYWlJRklBTnJJZ05CQVhJMkFnUkJBRUVBS0FMdzA0Q0FBRFlDcE5DQWdBQkJBQ0FETmdLVTBJQ0FBRUVBSUFRMkFxRFFnSUFBSUFBZ0JXcEJPRFlDQkF3Q0N5QURMUUFNUVFoeERRQWdCQ0FGU1EwQUlBUWdBRThOQUNBRVFYZ2dCR3RCRDNGQkFDQUVRUWhxUVE5eEd5SUZhaUlBUVFBb0FwVFFnSUFBSUFacUlnc2dCV3NpQlVFQmNqWUNCQ0FESUFnZ0JtbzJBZ1JCQUVFQUtBTHcwNENBQURZQ3BOQ0FnQUJCQUNBRk5nS1UwSUNBQUVFQUlBQTJBcURRZ0lBQUlBUWdDMnBCT0RZQ0JBd0JDd0pBSUFCQkFDZ0NtTkNBZ0FBaUNFOE5BRUVBSUFBMkFwalFnSUFBSUFBaENBc2dBQ0FHYWlFRlFjalRnSUFBSVFNQ1FBSkFBa0FDUUFKQUFrQUNRQU5BSUFNb0FnQWdCVVlOQVNBREtBSUlJZ01OQUF3Q0N3c2dBeTBBREVFSWNVVU5BUXRCeU5PQWdBQWhBd05BQWtBZ0F5Z0NBQ0lGSUFSTERRQWdCU0FES0FJRWFpSUZJQVJMRFFNTElBTW9BZ2doQXd3QUN3c2dBeUFBTmdJQUlBTWdBeWdDQkNBR2FqWUNCQ0FBUVhnZ0FHdEJEM0ZCQUNBQVFRaHFRUTl4RzJvaUN5QUNRUU55TmdJRUlBVkJlQ0FGYTBFUGNVRUFJQVZCQ0dwQkQzRWJhaUlHSUFzZ0Ftb2lBbXNoQXdKQUlBWWdCRWNOQUVFQUlBSTJBcURRZ0lBQVFRQkJBQ2dDbE5DQWdBQWdBMm9pQXpZQ2xOQ0FnQUFnQWlBRFFRRnlOZ0lFREFNTEFrQWdCa0VBS0FLYzBJQ0FBRWNOQUVFQUlBSTJBcHpRZ0lBQVFRQkJBQ2dDa05DQWdBQWdBMm9pQXpZQ2tOQ0FnQUFnQWlBRFFRRnlOZ0lFSUFJZ0Eyb2dBellDQUF3REN3SkFJQVlvQWdRaUJFRURjVUVCUncwQUlBUkJlSEVoQndKQUFrQWdCRUgvQVVzTkFDQUdLQUlJSWdVZ0JFRURkaUlJUVFOMFFiRFFnSUFBYWlJQVJob0NRQ0FHS0FJTUlnUWdCVWNOQUVFQVFRQW9Bb2pRZ0lBQVFYNGdDSGR4TmdLSTBJQ0FBQXdDQ3lBRUlBQkdHaUFFSUFVMkFnZ2dCU0FFTmdJTURBRUxJQVlvQWhnaENRSkFBa0FnQmlnQ0RDSUFJQVpHRFFBZ0JpZ0NDQ0lFSUFoSkdpQUFJQVEyQWdnZ0JDQUFOZ0lNREFFTEFrQWdCa0VVYWlJRUtBSUFJZ1VOQUNBR1FSQnFJZ1FvQWdBaUJRMEFRUUFoQUF3QkN3TkFJQVFoQ0NBRklnQkJGR29pQkNnQ0FDSUZEUUFnQUVFUWFpRUVJQUFvQWhBaUJRMEFDeUFJUVFBMkFnQUxJQWxGRFFBQ1FBSkFJQVlnQmlnQ0hDSUZRUUowUWJqU2dJQUFhaUlFS0FJQVJ3MEFJQVFnQURZQ0FDQUFEUUZCQUVFQUtBS00wSUNBQUVGK0lBVjNjVFlDak5DQWdBQU1BZ3NnQ1VFUVFSUWdDU2dDRUNBR1JodHFJQUEyQWdBZ0FFVU5BUXNnQUNBSk5nSVlBa0FnQmlnQ0VDSUVSUTBBSUFBZ0JEWUNFQ0FFSUFBMkFoZ0xJQVlvQWhRaUJFVU5BQ0FBUVJScUlBUTJBZ0FnQkNBQU5nSVlDeUFISUFOcUlRTWdCaUFIYWlJR0tBSUVJUVFMSUFZZ0JFRitjVFlDQkNBQ0lBTnFJQU0yQWdBZ0FpQURRUUZ5TmdJRUFrQWdBMEgvQVVzTkFDQURRWGh4UWJEUWdJQUFhaUVFQWtBQ1FFRUFLQUtJMElDQUFDSUZRUUVnQTBFRGRuUWlBM0VOQUVFQUlBVWdBM0kyQW9qUWdJQUFJQVFoQXd3QkN5QUVLQUlJSVFNTElBTWdBallDRENBRUlBSTJBZ2dnQWlBRU5nSU1JQUlnQXpZQ0NBd0RDMEVmSVFRQ1FDQURRZi8vL3dkTERRQWdBMEVJZGlJRUlBUkJnUDQvYWtFUWRrRUljU0lFZENJRklBVkJnT0FmYWtFUWRrRUVjU0lGZENJQUlBQkJnSUFQYWtFUWRrRUNjU0lBZEVFUGRpQUVJQVZ5SUFCeWF5SUVRUUYwSUFNZ0JFRVZhblpCQVhGeVFSeHFJUVFMSUFJZ0JEWUNIQ0FDUWdBM0FoQWdCRUVDZEVHNDBvQ0FBR29oQlFKQVFRQW9Bb3pRZ0lBQUlnQkJBU0FFZENJSWNRMEFJQVVnQWpZQ0FFRUFJQUFnQ0hJMkFvelFnSUFBSUFJZ0JUWUNHQ0FDSUFJMkFnZ2dBaUFDTmdJTURBTUxJQU5CQUVFWklBUkJBWFpySUFSQkgwWWJkQ0VFSUFVb0FnQWhBQU5BSUFBaUJTZ0NCRUY0Y1NBRFJnMENJQVJCSFhZaEFDQUVRUUYwSVFRZ0JTQUFRUVJ4YWtFUWFpSUlLQUlBSWdBTkFBc2dDQ0FDTmdJQUlBSWdCVFlDR0NBQ0lBSTJBZ3dnQWlBQ05nSUlEQUlMSUFCQmVDQUFhMEVQY1VFQUlBQkJDR3BCRDNFYklnTnFJZ3NnQmtGSWFpSUlJQU5ySWdOQkFYSTJBZ1FnQUNBSWFrRTROZ0lFSUFRZ0JVRTNJQVZyUVE5eFFRQWdCVUZKYWtFUGNSdHFRVUZxSWdnZ0NDQUVRUkJxU1JzaUNFRWpOZ0lFUVFCQkFDZ0M4Tk9BZ0FBMkFxVFFnSUFBUVFBZ0F6WUNsTkNBZ0FCQkFDQUxOZ0tnMElDQUFDQUlRUkJxUVFBcEF0RFRnSUFBTndJQUlBaEJBQ2tDeU5PQWdBQTNBZ2hCQUNBSVFRaHFOZ0xRMDRDQUFFRUFJQVkyQXN6VGdJQUFRUUFnQURZQ3lOT0FnQUJCQUVFQU5nTFUwNENBQUNBSVFTUnFJUU1EUUNBRFFRYzJBZ0FnQTBFRWFpSURJQVZKRFFBTElBZ2dCRVlOQXlBSUlBZ29BZ1JCZm5FMkFnUWdDQ0FJSUFScklnQTJBZ0FnQkNBQVFRRnlOZ0lFQWtBZ0FFSC9BVXNOQUNBQVFYaHhRYkRRZ0lBQWFpRURBa0FDUUVFQUtBS0kwSUNBQUNJRlFRRWdBRUVEZG5RaUFIRU5BRUVBSUFVZ0FISTJBb2pRZ0lBQUlBTWhCUXdCQ3lBREtBSUlJUVVMSUFVZ0JEWUNEQ0FESUFRMkFnZ2dCQ0FETmdJTUlBUWdCVFlDQ0F3RUMwRWZJUU1DUUNBQVFmLy8vd2RMRFFBZ0FFRUlkaUlESUFOQmdQNC9ha0VRZGtFSWNTSURkQ0lGSUFWQmdPQWZha0VRZGtFRWNTSUZkQ0lJSUFoQmdJQVBha0VRZGtFQ2NTSUlkRUVQZGlBRElBVnlJQWh5YXlJRFFRRjBJQUFnQTBFVmFuWkJBWEZ5UVJ4cUlRTUxJQVFnQXpZQ0hDQUVRZ0EzQWhBZ0EwRUNkRUc0MG9DQUFHb2hCUUpBUVFBb0FvelFnSUFBSWdoQkFTQURkQ0lHY1EwQUlBVWdCRFlDQUVFQUlBZ2dCbkkyQW96UWdJQUFJQVFnQlRZQ0dDQUVJQVEyQWdnZ0JDQUVOZ0lNREFRTElBQkJBRUVaSUFOQkFYWnJJQU5CSDBZYmRDRURJQVVvQWdBaENBTkFJQWdpQlNnQ0JFRjRjU0FBUmcwRElBTkJIWFloQ0NBRFFRRjBJUU1nQlNBSVFRUnhha0VRYWlJR0tBSUFJZ2dOQUFzZ0JpQUVOZ0lBSUFRZ0JUWUNHQ0FFSUFRMkFnd2dCQ0FFTmdJSURBTUxJQVVvQWdnaUF5QUNOZ0lNSUFVZ0FqWUNDQ0FDUVFBMkFoZ2dBaUFGTmdJTUlBSWdBellDQ0FzZ0MwRUlhaUVEREFVTElBVW9BZ2dpQXlBRU5nSU1JQVVnQkRZQ0NDQUVRUUEyQWhnZ0JDQUZOZ0lNSUFRZ0F6WUNDQXRCQUNnQ2xOQ0FnQUFpQXlBQ1RRMEFRUUFvQXFEUWdJQUFJZ1FnQW1vaUJTQURJQUpySWdOQkFYSTJBZ1JCQUNBRE5nS1UwSUNBQUVFQUlBVTJBcURRZ0lBQUlBUWdBa0VEY2pZQ0JDQUVRUWhxSVFNTUF3dEJBQ0VEUVFCQk1EWUMrTk9BZ0FBTUFnc0NRQ0FMUlEwQUFrQUNRQ0FJSUFnb0Fod2lCVUVDZEVHNDBvQ0FBR29pQXlnQ0FFY05BQ0FESUFBMkFnQWdBQTBCUVFBZ0IwRitJQVYzY1NJSE5nS00wSUNBQUF3Q0N5QUxRUkJCRkNBTEtBSVFJQWhHRzJvZ0FEWUNBQ0FBUlEwQkN5QUFJQXMyQWhnQ1FDQUlLQUlRSWdORkRRQWdBQ0FETmdJUUlBTWdBRFlDR0FzZ0NFRVVhaWdDQUNJRFJRMEFJQUJCRkdvZ0F6WUNBQ0FESUFBMkFoZ0xBa0FDUUNBRVFROUxEUUFnQ0NBRUlBSnFJZ05CQTNJMkFnUWdDQ0FEYWlJRElBTW9BZ1JCQVhJMkFnUU1BUXNnQ0NBQ2FpSUFJQVJCQVhJMkFnUWdDQ0FDUVFOeU5nSUVJQUFnQkdvZ0JEWUNBQUpBSUFSQi93RkxEUUFnQkVGNGNVR3cwSUNBQUdvaEF3SkFBa0JCQUNnQ2lOQ0FnQUFpQlVFQklBUkJBM1owSWdSeERRQkJBQ0FGSUFSeU5nS0kwSUNBQUNBRElRUU1BUXNnQXlnQ0NDRUVDeUFFSUFBMkFnd2dBeUFBTmdJSUlBQWdBellDRENBQUlBUTJBZ2dNQVF0Qkh5RURBa0FnQkVILy8vOEhTdzBBSUFSQkNIWWlBeUFEUVlEK1AycEJFSFpCQ0hFaUEzUWlCU0FGUVlEZ0gycEJFSFpCQkhFaUJYUWlBaUFDUVlDQUQycEJFSFpCQW5FaUFuUkJEM1lnQXlBRmNpQUNjbXNpQTBFQmRDQUVJQU5CRldwMlFRRnhja0VjYWlFREN5QUFJQU0yQWh3Z0FFSUFOd0lRSUFOQkFuUkJ1TktBZ0FCcUlRVUNRQ0FIUVFFZ0EzUWlBbkVOQUNBRklBQTJBZ0JCQUNBSElBSnlOZ0tNMElDQUFDQUFJQVUyQWhnZ0FDQUFOZ0lJSUFBZ0FEWUNEQXdCQ3lBRVFRQkJHU0FEUVFGMmF5QURRUjlHRzNRaEF5QUZLQUlBSVFJQ1FBTkFJQUlpQlNnQ0JFRjRjU0FFUmcwQklBTkJIWFloQWlBRFFRRjBJUU1nQlNBQ1FRUnhha0VRYWlJR0tBSUFJZ0lOQUFzZ0JpQUFOZ0lBSUFBZ0JUWUNHQ0FBSUFBMkFnd2dBQ0FBTmdJSURBRUxJQVVvQWdnaUF5QUFOZ0lNSUFVZ0FEWUNDQ0FBUVFBMkFoZ2dBQ0FGTmdJTUlBQWdBellDQ0FzZ0NFRUlhaUVEREFFTEFrQWdDa1VOQUFKQUFrQWdBQ0FBS0FJY0lnVkJBblJCdU5LQWdBQnFJZ01vQWdCSERRQWdBeUFJTmdJQUlBZ05BVUVBSUFsQmZpQUZkM0UyQW96UWdJQUFEQUlMSUFwQkVFRVVJQW9vQWhBZ0FFWWJhaUFJTmdJQUlBaEZEUUVMSUFnZ0NqWUNHQUpBSUFBb0FoQWlBMFVOQUNBSUlBTTJBaEFnQXlBSU5nSVlDeUFBUVJScUtBSUFJZ05GRFFBZ0NFRVVhaUFETmdJQUlBTWdDRFlDR0FzQ1FBSkFJQVJCRDBzTkFDQUFJQVFnQW1vaUEwRURjallDQkNBQUlBTnFJZ01nQXlnQ0JFRUJjallDQkF3QkN5QUFJQUpxSWdVZ0JFRUJjallDQkNBQUlBSkJBM0kyQWdRZ0JTQUVhaUFFTmdJQUFrQWdCMFVOQUNBSFFYaHhRYkRRZ0lBQWFpRUNRUUFvQXB6UWdJQUFJUU1DUUFKQVFRRWdCMEVEZG5RaUNDQUdjUTBBUVFBZ0NDQUdjallDaU5DQWdBQWdBaUVJREFFTElBSW9BZ2doQ0FzZ0NDQUROZ0lNSUFJZ0F6WUNDQ0FESUFJMkFnd2dBeUFJTmdJSUMwRUFJQVUyQXB6UWdJQUFRUUFnQkRZQ2tOQ0FnQUFMSUFCQkNHb2hBd3NnQVVFUWFpU0FnSUNBQUNBREN3b0FJQUFReVlDQWdBQUw0ZzBCQjM4Q1FDQUFSUTBBSUFCQmVHb2lBU0FBUVh4cUtBSUFJZ0pCZUhFaUFHb2hBd0pBSUFKQkFYRU5BQ0FDUVFOeFJRMEJJQUVnQVNnQ0FDSUNheUlCUVFBb0FwalFnSUFBSWdSSkRRRWdBaUFBYWlFQUFrQWdBVUVBS0FLYzBJQ0FBRVlOQUFKQUlBSkIvd0ZMRFFBZ0FTZ0NDQ0lFSUFKQkEzWWlCVUVEZEVHdzBJQ0FBR29pQmtZYUFrQWdBU2dDRENJQ0lBUkhEUUJCQUVFQUtBS0kwSUNBQUVGK0lBVjNjVFlDaU5DQWdBQU1Bd3NnQWlBR1Job2dBaUFFTmdJSUlBUWdBallDREF3Q0N5QUJLQUlZSVFjQ1FBSkFJQUVvQWd3aUJpQUJSZzBBSUFFb0FnZ2lBaUFFU1JvZ0JpQUNOZ0lJSUFJZ0JqWUNEQXdCQ3dKQUlBRkJGR29pQWlnQ0FDSUVEUUFnQVVFUWFpSUNLQUlBSWdRTkFFRUFJUVlNQVFzRFFDQUNJUVVnQkNJR1FSUnFJZ0lvQWdBaUJBMEFJQVpCRUdvaEFpQUdLQUlRSWdRTkFBc2dCVUVBTmdJQUN5QUhSUTBCQWtBQ1FDQUJJQUVvQWh3aUJFRUNkRUc0MG9DQUFHb2lBaWdDQUVjTkFDQUNJQVkyQWdBZ0JnMEJRUUJCQUNnQ2pOQ0FnQUJCZmlBRWQzRTJBb3pRZ0lBQURBTUxJQWRCRUVFVUlBY29BaEFnQVVZYmFpQUdOZ0lBSUFaRkRRSUxJQVlnQnpZQ0dBSkFJQUVvQWhBaUFrVU5BQ0FHSUFJMkFoQWdBaUFHTmdJWUN5QUJLQUlVSWdKRkRRRWdCa0VVYWlBQ05nSUFJQUlnQmpZQ0dBd0JDeUFES0FJRUlnSkJBM0ZCQTBjTkFDQURJQUpCZm5FMkFnUkJBQ0FBTmdLUTBJQ0FBQ0FCSUFCcUlBQTJBZ0FnQVNBQVFRRnlOZ0lFRHdzZ0FTQURUdzBBSUFNb0FnUWlBa0VCY1VVTkFBSkFBa0FnQWtFQ2NRMEFBa0FnQTBFQUtBS2cwSUNBQUVjTkFFRUFJQUUyQXFEUWdJQUFRUUJCQUNnQ2xOQ0FnQUFnQUdvaUFEWUNsTkNBZ0FBZ0FTQUFRUUZ5TmdJRUlBRkJBQ2dDbk5DQWdBQkhEUU5CQUVFQU5nS1EwSUNBQUVFQVFRQTJBcHpRZ0lBQUR3c0NRQ0FEUVFBb0FwelFnSUFBUncwQVFRQWdBVFlDbk5DQWdBQkJBRUVBS0FLUTBJQ0FBQ0FBYWlJQU5nS1EwSUNBQUNBQklBQkJBWEkyQWdRZ0FTQUFhaUFBTmdJQUR3c2dBa0Y0Y1NBQWFpRUFBa0FDUUNBQ1FmOEJTdzBBSUFNb0FnZ2lCQ0FDUVFOMklnVkJBM1JCc05DQWdBQnFJZ1pHR2dKQUlBTW9BZ3dpQWlBRVJ3MEFRUUJCQUNnQ2lOQ0FnQUJCZmlBRmQzRTJBb2pRZ0lBQURBSUxJQUlnQmtZYUlBSWdCRFlDQ0NBRUlBSTJBZ3dNQVFzZ0F5Z0NHQ0VIQWtBQ1FDQURLQUlNSWdZZ0EwWU5BQ0FES0FJSUlnSkJBQ2dDbU5DQWdBQkpHaUFHSUFJMkFnZ2dBaUFHTmdJTURBRUxBa0FnQTBFVWFpSUNLQUlBSWdRTkFDQURRUkJxSWdJb0FnQWlCQTBBUVFBaEJnd0JDd05BSUFJaEJTQUVJZ1pCRkdvaUFpZ0NBQ0lFRFFBZ0JrRVFhaUVDSUFZb0FoQWlCQTBBQ3lBRlFRQTJBZ0FMSUFkRkRRQUNRQUpBSUFNZ0F5Z0NIQ0lFUVFKMFFialNnSUFBYWlJQ0tBSUFSdzBBSUFJZ0JqWUNBQ0FHRFFGQkFFRUFLQUtNMElDQUFFRitJQVIzY1RZQ2pOQ0FnQUFNQWdzZ0IwRVFRUlFnQnlnQ0VDQURSaHRxSUFZMkFnQWdCa1VOQVFzZ0JpQUhOZ0lZQWtBZ0F5Z0NFQ0lDUlEwQUlBWWdBallDRUNBQ0lBWTJBaGdMSUFNb0FoUWlBa1VOQUNBR1FSUnFJQUkyQWdBZ0FpQUdOZ0lZQ3lBQklBQnFJQUEyQWdBZ0FTQUFRUUZ5TmdJRUlBRkJBQ2dDbk5DQWdBQkhEUUZCQUNBQU5nS1EwSUNBQUE4TElBTWdBa0YrY1RZQ0JDQUJJQUJxSUFBMkFnQWdBU0FBUVFGeU5nSUVDd0pBSUFCQi93RkxEUUFnQUVGNGNVR3cwSUNBQUdvaEFnSkFBa0JCQUNnQ2lOQ0FnQUFpQkVFQklBQkJBM1owSWdCeERRQkJBQ0FFSUFCeU5nS0kwSUNBQUNBQ0lRQU1BUXNnQWlnQ0NDRUFDeUFBSUFFMkFnd2dBaUFCTmdJSUlBRWdBallDRENBQklBQTJBZ2dQQzBFZklRSUNRQ0FBUWYvLy93ZExEUUFnQUVFSWRpSUNJQUpCZ1A0L2FrRVFka0VJY1NJQ2RDSUVJQVJCZ09BZmFrRVFka0VFY1NJRWRDSUdJQVpCZ0lBUGFrRVFka0VDY1NJR2RFRVBkaUFDSUFSeUlBWnlheUlDUVFGMElBQWdBa0VWYW5aQkFYRnlRUnhxSVFJTElBRWdBallDSENBQlFnQTNBaEFnQWtFQ2RFRzQwb0NBQUdvaEJBSkFBa0JCQUNnQ2pOQ0FnQUFpQmtFQklBSjBJZ054RFFBZ0JDQUJOZ0lBUVFBZ0JpQURjallDak5DQWdBQWdBU0FFTmdJWUlBRWdBVFlDQ0NBQklBRTJBZ3dNQVFzZ0FFRUFRUmtnQWtFQmRtc2dBa0VmUmh0MElRSWdCQ2dDQUNFR0FrQURRQ0FHSWdRb0FnUkJlSEVnQUVZTkFTQUNRUjEySVFZZ0FrRUJkQ0VDSUFRZ0JrRUVjV3BCRUdvaUF5Z0NBQ0lHRFFBTElBTWdBVFlDQUNBQklBUTJBaGdnQVNBQk5nSU1JQUVnQVRZQ0NBd0JDeUFFS0FJSUlnQWdBVFlDRENBRUlBRTJBZ2dnQVVFQU5nSVlJQUVnQkRZQ0RDQUJJQUEyQWdnTFFRQkJBQ2dDcU5DQWdBQkJmMm9pQVVGL0lBRWJOZ0tvMElDQUFBc0xCQUFBQUF0T0FBSkFJQUFOQUQ4QVFSQjBEd3NDUUNBQVFmLy9BM0VOQUNBQVFYOU1EUUFDUUNBQVFSQjJRQUFpQUVGL1J3MEFRUUJCTURZQytOT0FnQUJCZnc4TElBQkJFSFFQQ3hES2dJQ0FBQUFMOGdJQ0EzOEJmZ0pBSUFKRkRRQWdBQ0FCT2dBQUlBSWdBR29pQTBGL2FpQUJPZ0FBSUFKQkEwa05BQ0FBSUFFNkFBSWdBQ0FCT2dBQklBTkJmV29nQVRvQUFDQURRWDVxSUFFNkFBQWdBa0VIU1EwQUlBQWdBVG9BQXlBRFFYeHFJQUU2QUFBZ0FrRUpTUTBBSUFCQkFDQUFhMEVEY1NJRWFpSURJQUZCL3dGeFFZR0NoQWhzSWdFMkFnQWdBeUFDSUFSclFYeHhJZ1JxSWdKQmZHb2dBVFlDQUNBRVFRbEpEUUFnQXlBQk5nSUlJQU1nQVRZQ0JDQUNRWGhxSUFFMkFnQWdBa0YwYWlBQk5nSUFJQVJCR1VrTkFDQURJQUUyQWhnZ0F5QUJOZ0lVSUFNZ0FUWUNFQ0FESUFFMkFnd2dBa0Z3YWlBQk5nSUFJQUpCYkdvZ0FUWUNBQ0FDUVdocUlBRTJBZ0FnQWtGa2FpQUJOZ0lBSUFRZ0EwRUVjVUVZY2lJRmF5SUNRU0JKRFFBZ0FhMUNnWUNBZ0JCK0lRWWdBeUFGYWlFQkEwQWdBU0FHTndNWUlBRWdCamNERUNBQklBWTNBd2dnQVNBR053TUFJQUZCSUdvaEFTQUNRV0JxSWdKQkgwc05BQXNMSUFBTEM0NUlBUUJCZ0FnTGhrZ0JBQUFBQWdBQUFBTUFBQUFBQUFBQUFBQUFBQVFBQUFBRkFBQUFBQUFBQUFBQUFBQUdBQUFBQndBQUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRWx1ZG1Gc2FXUWdZMmhoY2lCcGJpQjFjbXdnY1hWbGNua0FVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOWliMlI1QUVOdmJuUmxiblF0VEdWdVozUm9JRzkyWlhKbWJHOTNBRU5vZFc1cklITnBlbVVnYjNabGNtWnNiM2NBVW1WemNHOXVjMlVnYjNabGNtWnNiM2NBU1c1MllXeHBaQ0J0WlhSb2IyUWdabTl5SUVoVVZGQXZlQzU0SUhKbGNYVmxjM1FBU1c1MllXeHBaQ0J0WlhSb2IyUWdabTl5SUZKVVUxQXZlQzU0SUhKbGNYVmxjM1FBUlhod1pXTjBaV1FnVTA5VlVrTkZJRzFsZEdodlpDQm1iM0lnU1VORkwzZ3VlQ0J5WlhGMVpYTjBBRWx1ZG1Gc2FXUWdZMmhoY2lCcGJpQjFjbXdnWm5KaFoyMWxiblFnYzNSaGNuUUFSWGh3WldOMFpXUWdaRzkwQUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmYzNSaGRIVnpBRWx1ZG1Gc2FXUWdjbVZ6Y0c5dWMyVWdjM1JoZEhWekFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTUFWWE5sY2lCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmNtVnpaWFJnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5amFIVnVhMTlvWldGa1pYSmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDl0WlhOellXZGxYMkpsWjJsdVlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgzWmhiSFZsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmMzUmhkSFZ6WDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmRtVnljMmx2Ymw5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgzVnliRjlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJOb2RXNXJYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYUdWaFpHVnlYM1poYkhWbFgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMjFsZEdodlpGOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMmhsWVdSbGNsOW1hV1ZzWkY5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5dVlXMWxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQlZibVY0Y0dWamRHVmtJR05vWVhJZ2FXNGdkWEpzSUhObGNuWmxjZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQjJZV3gxWlNCamFHRnlBRWx1ZG1Gc2FXUWdhR1ZoWkdWeUlHWnBaV3hrSUdOb1lYSUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOTJaWEp6YVc5dUFFbHVkbUZzYVdRZ2JXbHViM0lnZG1WeWMybHZiZ0JKYm5aaGJHbGtJRzFoYW05eUlIWmxjbk5wYjI0QVJYaHdaV04wWldRZ2MzQmhZMlVnWVdaMFpYSWdkbVZ5YzJsdmJnQkZlSEJsWTNSbFpDQkRVa3hHSUdGbWRHVnlJSFpsY25OcGIyNEFTVzUyWVd4cFpDQklWRlJRSUhabGNuTnBiMjRBU1c1MllXeHBaQ0JvWldGa1pYSWdkRzlyWlc0QVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5MWNtd0FTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSnpJR2x1SUhWeWJBQlZibVY0Y0dWamRHVmtJSE4wWVhKMElHTm9ZWElnYVc0Z2RYSnNBRVJ2ZFdKc1pTQkFJR2x1SUhWeWJBQkZiWEIwZVNCRGIyNTBaVzUwTFV4bGJtZDBhQUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCRGIyNTBaVzUwTFV4bGJtZDBhQUJFZFhCc2FXTmhkR1VnUTI5dWRHVnVkQzFNWlc1bmRHZ0FTVzUyWVd4cFpDQmphR0Z5SUdsdUlIVnliQ0J3WVhSb0FFTnZiblJsYm5RdFRHVnVaM1JvSUdOaGJpZDBJR0psSUhCeVpYTmxiblFnZDJsMGFDQlVjbUZ1YzJabGNpMUZibU52WkdsdVp3QkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJqYUhWdWF5QnphWHBsQUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmYUdWaFpHVnlYM1poYkhWbEFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDNaaGJIVmxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nZG1Gc2RXVUFUV2x6YzJsdVp5QmxlSEJsWTNSbFpDQk1SaUJoWm5SbGNpQm9aV0ZrWlhJZ2RtRnNkV1VBU1c1MllXeHBaQ0JnVkhKaGJuTm1aWEl0Ulc1amIyUnBibWRnSUdobFlXUmxjaUIyWVd4MVpRQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJqYUhWdWF5QmxlSFJsYm5OcGIyNXpJSEYxYjNSbElIWmhiSFZsQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NZ2NYVnZkR1ZrSUhaaGJIVmxBRkJoZFhObFpDQmllU0J2Ymw5b1pXRmtaWEp6WDJOdmJYQnNaWFJsQUVsdWRtRnNhV1FnUlU5R0lITjBZWFJsQUc5dVgzSmxjMlYwSUhCaGRYTmxBRzl1WDJOb2RXNXJYMmhsWVdSbGNpQndZWFZ6WlFCdmJsOXRaWE56WVdkbFgySmxaMmx1SUhCaGRYTmxBRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDkyWVd4MVpTQndZWFZ6WlFCdmJsOXpkR0YwZFhOZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmRtVnljMmx2Ymw5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5MWNteGZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZZMmgxYm10ZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmFHVmhaR1Z5WDNaaGJIVmxYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMjFsYzNOaFoyVmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZiV1YwYUc5a1gyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyaGxZV1JsY2w5bWFXVnNaRjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZibUZ0WlNCd1lYVnpaUUJWYm1WNGNHVmpkR1ZrSUhOd1lXTmxJR0ZtZEdWeUlITjBZWEowSUd4cGJtVUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmJtRnRaUUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCamFIVnVheUJsZUhSbGJuTnBiMjV6SUc1aGJXVUFVR0YxYzJVZ2IyNGdRMDlPVGtWRFZDOVZjR2R5WVdSbEFGQmhkWE5sSUc5dUlGQlNTUzlWY0dkeVlXUmxBRVY0Y0dWamRHVmtJRWhVVkZBdk1pQkRiMjV1WldOMGFXOXVJRkJ5WldaaFkyVUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOXRaWFJvYjJRQVJYaHdaV04wWldRZ2MzQmhZMlVnWVdaMFpYSWdiV1YwYUc5a0FGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmFHVmhaR1Z5WDJacFpXeGtBRkJoZFhObFpBQkpiblpoYkdsa0lIZHZjbVFnWlc1amIzVnVkR1Z5WldRQVNXNTJZV3hwWkNCdFpYUm9iMlFnWlc1amIzVnVkR1Z5WldRQVZXNWxlSEJsWTNSbFpDQmphR0Z5SUdsdUlIVnliQ0J6WTJobGJXRUFVbVZ4ZFdWemRDQm9ZWE1nYVc1MllXeHBaQ0JnVkhKaGJuTm1aWEl0Ulc1amIyUnBibWRnQUZOWFNWUkRTRjlRVWs5WVdRQlZVMFZmVUZKUFdGa0FUVXRCUTFSSlZrbFVXUUJWVGxCU1QwTkZVMU5CUWt4RlgwVk9WRWxVV1FCRFQxQlpBRTFQVmtWRVgxQkZVazFCVGtWT1ZFeFpBRlJQVDE5RlFWSk1XUUJPVDFSSlJsa0FSa0ZKVEVWRVgwUkZVRVZPUkVWT1Exa0FRa0ZFWDBkQlZFVlhRVmtBVUV4QldRQlFWVlFBUTBoRlEwdFBWVlFBUjBGVVJWZEJXVjlVU1UxRlQxVlVBRkpGVVZWRlUxUmZWRWxOUlU5VlZBQk9SVlJYVDFKTFgwTlBUazVGUTFSZlZFbE5SVTlWVkFCRFQwNU9SVU5VU1U5T1gxUkpUVVZQVlZRQVRFOUhTVTVmVkVsTlJVOVZWQUJPUlZSWFQxSkxYMUpGUVVSZlZFbE5SVTlWVkFCUVQxTlVBRTFKVTBSSlVrVkRWRVZFWDFKRlVWVkZVMVFBUTB4SlJVNVVYME5NVDFORlJGOVNSVkZWUlZOVUFFTk1TVVZPVkY5RFRFOVRSVVJmVEU5QlJGOUNRVXhCVGtORlJGOVNSVkZWUlZOVUFFSkJSRjlTUlZGVlJWTlVBRWhVVkZCZlVrVlJWVVZUVkY5VFJVNVVYMVJQWDBoVVZGQlRYMUJQVWxRQVVrVlFUMUpVQUVsTlgwRmZWRVZCVUU5VUFGSkZVMFZVWDBOUFRsUkZUbFFBVGs5ZlEwOU9WRVZPVkFCUVFWSlVTVUZNWDBOUFRsUkZUbFFBU0ZCRlgwbE9Wa0ZNU1VSZlEwOU9VMVJCVGxRQVNGQkZYME5DWDFKRlUwVlVBRWRGVkFCSVVFVmZVMVJTU1VOVUFFTlBUa1pNU1VOVUFGUkZUVkJQVWtGU1dWOVNSVVJKVWtWRFZBQlFSVkpOUVU1RlRsUmZVa1ZFU1ZKRlExUUFRMDlPVGtWRFZBQk5WVXhVU1Y5VFZFRlVWVk1BU0ZCRlgwbE9Wa0ZNU1VSZlUxUkJWRlZUQUZSUFQxOU5RVTVaWDFKRlVWVkZVMVJUQUVWQlVreFpYMGhKVGxSVEFGVk9RVlpCU1V4QlFreEZYMFpQVWw5TVJVZEJURjlTUlVGVFQwNVRBRTlRVkVsUFRsTUFVMWRKVkVOSVNVNUhYMUJTVDFSUFEwOU1Vd0JXUVZKSlFVNVVYMEZNVTA5ZlRrVkhUMVJKUVZSRlV3Qk5WVXhVU1ZCTVJWOURTRTlKUTBWVEFFbE9WRVZTVGtGTVgxTkZVbFpGVWw5RlVsSlBVZ0JYUlVKZlUwVlNWa1ZTWDFWT1MwNVBWMDVmUlZKU1QxSUFVa0ZKVEVkVlRsOUZVbEpQVWdCSlJFVk9WRWxVV1Y5UVVrOVdTVVJGVWw5QlZWUklSVTVVU1VOQlZFbFBUbDlGVWxKUFVnQlRVMHhmUTBWU1ZFbEdTVU5CVkVWZlJWSlNUMUlBU1U1V1FVeEpSRjlZWDBaUFVsZEJVa1JGUkY5R1QxSUFVMFZVWDFCQlVrRk5SVlJGVWdCSFJWUmZVRUZTUVUxRlZFVlNBRWhRUlY5VlUwVlNBRk5GUlY5UFZFaEZVZ0JJVUVWZlEwSmZRMGhWVGt0ZlNFVkJSRVZTQUUxTFEwRk1SVTVFUVZJQVUwVlVWVkFBVjBWQ1gxTkZVbFpGVWw5SlUxOUVUMWRPQUZSRlFWSkVUMWRPQUVoUVJWOURURTlUUlVSZlEwOU9Ua1ZEVkVsUFRnQklSVlZTU1ZOVVNVTmZSVmhRU1ZKQlZFbFBUZ0JFU1ZORFQwNU9SVU5VUlVSZlQxQkZVa0ZVU1U5T0FFNVBUbDlCVlZSSVQxSkpWRUZVU1ZaRlgwbE9SazlTVFVGVVNVOU9BRWhRUlY5SlRsWkJURWxFWDFaRlVsTkpUMDRBU0ZCRlgwTkNYMDFGVTFOQlIwVmZRa1ZIU1U0QVUwbFVSVjlKVTE5R1VrOWFSVTRBU0ZCRlgwbE9Wa0ZNU1VSZlNFVkJSRVZTWDFSUFMwVk9BRWxPVmtGTVNVUmZWRTlMUlU0QVJrOVNRa2xFUkVWT0FFVk9TRUZPUTBWZldVOVZVbDlEUVV4TkFFaFFSVjlKVGxaQlRFbEVYMVZTVEFCQ1RFOURTMFZFWDBKWlgxQkJVa1ZPVkVGTVgwTlBUbFJTVDB3QVRVdERUMHdBUVVOTUFFaFFSVjlKVGxSRlVrNUJUQUJTUlZGVlJWTlVYMGhGUVVSRlVsOUdTVVZNUkZOZlZFOVBYMHhCVWtkRlgxVk9UMFpHU1VOSlFVd0FTRkJGWDA5TEFGVk9URWxPU3dCVlRreFBRMHNBVUZKSkFGSkZWRkpaWDFkSlZFZ0FTRkJGWDBsT1ZrRk1TVVJmUTA5T1ZFVk9WRjlNUlU1SFZFZ0FTRkJGWDFWT1JWaFFSVU5VUlVSZlEwOU9WRVZPVkY5TVJVNUhWRWdBUmt4VlUwZ0FVRkpQVUZCQlZFTklBRTB0VTBWQlVrTklBRlZTU1Y5VVQwOWZURTlPUndCUVVrOURSVk5UU1U1SEFFMUpVME5GVEV4QlRrVlBWVk5mVUVWU1UwbFRWRVZPVkY5WFFWSk9TVTVIQUUxSlUwTkZURXhCVGtWUFZWTmZWMEZTVGtsT1J3QklVRVZmU1U1V1FVeEpSRjlVVWtGT1UwWkZVbDlGVGtOUFJFbE9Sd0JGZUhCbFkzUmxaQ0JEVWt4R0FFaFFSVjlKVGxaQlRFbEVYME5JVlU1TFgxTkpXa1VBVFU5V1JRQkRUMDVVU1U1VlJRQklVRVZmUTBKZlUxUkJWRlZUWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlJUlVGRVJWSlRYME5QVFZCTVJWUkZBRWhRUlY5RFFsOVdSVkpUU1U5T1gwTlBUVkJNUlZSRkFFaFFSVjlEUWw5VlVreGZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwTklWVTVMWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlJUlVGRVJWSmZWa0ZNVlVWZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBOSVZVNUxYMFZZVkVWT1UwbFBUbDlXUVV4VlJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlEwaFZUa3RmUlZoVVJVNVRTVTlPWDA1QlRVVmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwMUZVMU5CUjBWZlEwOU5VRXhGVkVVQVNGQkZYME5DWDAxRlZFaFBSRjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZTRVZCUkVWU1gwWkpSVXhFWDBOUFRWQk1SVlJGQUVSRlRFVlVSUUJJVUVWZlNVNVdRVXhKUkY5RlQwWmZVMVJCVkVVQVNVNVdRVXhKUkY5VFUweGZRMFZTVkVsR1NVTkJWRVVBVUVGVlUwVUFUazlmVWtWVFVFOU9VMFVBVlU1VFZWQlFUMUpVUlVSZlRVVkVTVUZmVkZsUVJRQkhUMDVGQUU1UFZGOUJRME5GVUZSQlFreEZBRk5GVWxaSlEwVmZWVTVCVmtGSlRFRkNURVVBVWtGT1IwVmZUazlVWDFOQlZFbFRSa2xCUWt4RkFFOVNTVWRKVGw5SlUxOVZUbEpGUVVOSVFVSk1SUUJTUlZOUVQwNVRSVjlKVTE5VFZFRk1SUUJRVlZKSFJRQk5SVkpIUlFCU1JWRlZSVk5VWDBoRlFVUkZVbDlHU1VWTVJGTmZWRTlQWDB4QlVrZEZBRkpGVVZWRlUxUmZTRVZCUkVWU1gxUlBUMTlNUVZKSFJRQlFRVmxNVDBGRVgxUlBUMTlNUVZKSFJRQkpUbE5WUmtaSlEwbEZUbFJmVTFSUFVrRkhSUUJJVUVWZlVFRlZVMFZFWDFWUVIxSkJSRVVBU0ZCRlgxQkJWVk5GUkY5SU1sOVZVRWRTUVVSRkFGTlBWVkpEUlFCQlRrNVBWVTVEUlFCVVVrRkRSUUJJVUVWZlZVNUZXRkJGUTFSRlJGOVRVRUZEUlFCRVJWTkRVa2xDUlFCVlRsTlZRbE5EVWtsQ1JRQlNSVU5QVWtRQVNGQkZYMGxPVmtGTVNVUmZUVVZVU0U5RUFFNVBWRjlHVDFWT1JBQlFVazlRUmtsT1JBQlZUa0pKVGtRQVVrVkNTVTVFQUZWT1FWVlVTRTlTU1ZwRlJBQk5SVlJJVDBSZlRrOVVYMEZNVEU5WFJVUUFTRlJVVUY5V1JWSlRTVTlPWDA1UFZGOVRWVkJRVDFKVVJVUUFRVXhTUlVGRVdWOVNSVkJQVWxSRlJBQkJRME5GVUZSRlJBQk9UMVJmU1UxUVRFVk5SVTVVUlVRQVRFOVBVRjlFUlZSRlExUkZSQUJJVUVWZlExSmZSVmhRUlVOVVJVUUFTRkJGWDB4R1gwVllVRVZEVkVWRUFFTlNSVUZVUlVRQVNVMWZWVk5GUkFCSVVFVmZVRUZWVTBWRUFGUkpUVVZQVlZSZlQwTkRWVkpGUkFCUVFWbE5SVTVVWDFKRlVWVkpVa1ZFQUZCU1JVTlBUa1JKVkVsUFRsOVNSVkZWU1ZKRlJBQlFVazlZV1Y5QlZWUklSVTVVU1VOQlZFbFBUbDlTUlZGVlNWSkZSQUJPUlZSWFQxSkxYMEZWVkVoRlRsUkpRMEZVU1U5T1gxSkZVVlZKVWtWRUFFeEZUa2RVU0Y5U1JWRlZTVkpGUkFCVFUweGZRMFZTVkVsR1NVTkJWRVZmVWtWUlZVbFNSVVFBVlZCSFVrRkVSVjlTUlZGVlNWSkZSQUJRUVVkRlgwVllVRWxTUlVRQVVGSkZRMDlPUkVsVVNVOU9YMFpCU1V4RlJBQkZXRkJGUTFSQlZFbFBUbDlHUVVsTVJVUUFVa1ZXUVV4SlJFRlVTVTlPWDBaQlNVeEZSQUJUVTB4ZlNFRk9SRk5JUVV0RlgwWkJTVXhGUkFCTVQwTkxSVVFBVkZKQlRsTkdUMUpOUVZSSlQwNWZRVkJRVEVsRlJBQk9UMVJmVFU5RVNVWkpSVVFBVGs5VVgwVllWRVZPUkVWRUFFSkJUa1JYU1VSVVNGOU1TVTFKVkY5RldFTkZSVVJGUkFCVFNWUkZYMGxUWDA5V1JWSk1UMEZFUlVRQVNFVkJSQUJGZUhCbFkzUmxaQ0JJVkZSUUx3QUFYaE1BQUNZVEFBQXdFQUFBOEJjQUFKMFRBQUFWRWdBQU9SY0FBUEFTQUFBS0VBQUFkUklBQUswU0FBQ0NFd0FBVHhRQUFIOFFBQUNnRlFBQUl4UUFBSWtTQUFDTEZBQUFUUlVBQU5RUkFBRFBGQUFBRUJnQUFNa1dBQURjRmdBQXdSRUFBT0FYQUFDN0ZBQUFkQlFBQUh3VkFBRGxGQUFBQ0JjQUFCOFFBQUJsRlFBQW94UUFBQ2dWQUFBQ0ZRQUFtUlVBQUN3UUFBQ0xHUUFBVHc4QUFOUU9BQUJxRUFBQXpoQUFBQUlYQUFDSkRnQUFiaE1BQUJ3VEFBQm1GQUFBVmhjQUFNRVRBQURORXdBQWJCTUFBR2dYQUFCbUZ3QUFYeGNBQUNJVEFBRE9Ed0FBYVE0QUFOZ09BQUJqRmdBQXl4TUFBS29PQUFBb0Z3QUFKaGNBQU1VVEFBQmRGZ0FBNkJFQUFHY1RBQUJsRXdBQThoWUFBSE1UQUFBZEZ3QUErUllBQVBNUkFBRFBEZ0FBemhVQUFBd1NBQUN6RVFBQXBSRUFBR0VRQUFBeUZ3QUF1eE1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBUUlCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJREFnSUNBZ0lBQUFJQ0FBSUNBQUlDQWdJQ0FnSUNBZ0lBQkFBQUFBQUFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFBQUFDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdBQ0FBSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNBQUlDQWdJQ0FBQUNBZ0FDQWdBQ0FnSUNBZ0lDQWdJQ0FBTUFCQUFBQUFJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFBQUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFBZ0FDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWJHOXpaV1ZsY0MxaGJHbDJaUUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQkFRRUJBUUVCQVFFQkFRSUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCWTJoMWJtdGxaQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRRUFBUUVCQVFFQUFBRUJBQUVCQUFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQUFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCbFkzUnBiMjVsYm5RdGJHVnVaM1JvYjI1eWIzaDVMV052Ym01bFkzUnBiMjRBQUFBQUFBQUFBQUFBQUFBQUFBQnlZVzV6Wm1WeUxXVnVZMjlrYVc1bmNHZHlZV1JsRFFvTkNnMEtVMDBOQ2cwS1ZGUlFMME5GTDFSVFVDOEFBQUFBQUFBQUFBQUFBQUFCQWdBQkF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBQUFBQUFBQUFBQUFRSUFBUU1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQVFFRkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFBQUFBQUFBQUVBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQUFBQUFRQUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1FQUFBRUJBUUVCQVFFQkFRRUJBVUVCQVFFQkFRRUJBUUVCQVFBQkFBR0J3UUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVBQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0FBQUFBQUFBTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUlBQUFBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQk9UMVZPUTBWRlEwdFBWVlJPUlVOVVJWUkZRMUpKUWtWTVZWTklSVlJGUVVSVFJVRlNRMGhTUjBWRFZFbFdTVlJaVEVWT1JFRlNWa1ZQVkVsR1dWQlVTVTlPVTBOSVUwVkJXVk5VUVZSRFNFZEZUMUpFU1ZKRlExUlBVbFJTUTBoUVFWSkJUVVZVUlZKVlVrTkZRbE5EVWtsQ1JVRlNSRTlYVGtGRFJVbE9SRTVMUTB0VlFsTkRVa2xDUlVoVVZGQXZRVVJVVUM4PSdcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUFHIiwiZmlsZSI6Iihyc2MpLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9sbGh0dHAtd2FzbS5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/llhttp/llhttp-wasm.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/llhttp/llhttp_simd-wasm.js":
/*!****************************************************************!*\
  !*** ../../node_modules/undici/lib/llhttp/llhttp_simd-wasm.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("module.exports = \"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9sbGh0dHBfc2ltZC13YXNtLmpzP2ZjMDYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAnQUdGemJRRUFBQUFCTUFoZ0FYOEJmMkFEZjM5L0FYOWdCSDkvZjM4QmYyQUFBR0FEZjM5L0FHQUJmd0JnQW45L0FHQUdmMzkvZjM5L0FBTExBUWdEWlc1MkdIZGhjMjFmYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFBQ0EyVnVkaFYzWVhOdFgyOXVYMjFsYzNOaFoyVmZZbVZuYVc0QUFBTmxibllMZDJGemJWOXZibDkxY213QUFRTmxibllPZDJGemJWOXZibDl6ZEdGMGRYTUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmWm1sbGJHUUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFBUU5sYm5ZTWQyRnpiVjl2Ymw5aWIyUjVBQUVEWlc1MkdIZGhjMjFmYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlFBQUEwWkZBd01FQUFBRkFBQUFBQUFBQlFFRkFBVUZCUUFBQmdBQUFBQUdCZ1lHQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQUFBQkFRY0FBQVVGQXdBQkJBVUJjQUVTRWdVREFRQUNCZ2dCZndGQmdOUUVDd2ZSQlNJR2JXVnRiM0o1QWdBTFgybHVhWFJwWVd4cGVtVUFDUmxmWDJsdVpHbHlaV04wWDJaMWJtTjBhVzl1WDNSaFlteGxBUUFMYkd4b2RIUndYMmx1YVhRQUNoaHNiR2gwZEhCZmMyaHZkV3hrWDJ0bFpYQmZZV3hwZG1VQVFReHNiR2gwZEhCZllXeHNiMk1BREFadFlXeHNiMk1BUmd0c2JHaDBkSEJmWm5KbFpRQU5CR1p5WldVQVNBOXNiR2gwZEhCZloyVjBYM1I1Y0dVQURoVnNiR2gwZEhCZloyVjBYMmgwZEhCZmJXRnFiM0lBRHhWc2JHaDBkSEJmWjJWMFgyaDBkSEJmYldsdWIzSUFFQkZzYkdoMGRIQmZaMlYwWDIxbGRHaHZaQUFSRm14c2FIUjBjRjluWlhSZmMzUmhkSFZ6WDJOdlpHVUFFaEpzYkdoMGRIQmZaMlYwWDNWd1ozSmhaR1VBRXd4c2JHaDBkSEJmY21WelpYUUFGQTVzYkdoMGRIQmZaWGhsWTNWMFpRQVZGR3hzYUhSMGNGOXpaWFIwYVc1bmMxOXBibWwwQUJZTmJHeG9kSFJ3WDJacGJtbHphQUFYREd4c2FIUjBjRjl3WVhWelpRQVlEV3hzYUhSMGNGOXlaWE4xYldVQUdSdHNiR2gwZEhCZmNtVnpkVzFsWDJGbWRHVnlYM1Z3WjNKaFpHVUFHaEJzYkdoMGRIQmZaMlYwWDJWeWNtNXZBQnNYYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl5WldGemIyNEFIQmRzYkdoMGRIQmZjMlYwWDJWeWNtOXlYM0psWVhOdmJnQWRGR3hzYUhSMGNGOW5aWFJmWlhKeWIzSmZjRzl6QUI0UmJHeG9kSFJ3WDJWeWNtNXZYMjVoYldVQUh4SnNiR2gwZEhCZmJXVjBhRzlrWDI1aGJXVUFJQkpzYkdoMGRIQmZjM1JoZEhWelgyNWhiV1VBSVJwc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmFHVmhaR1Z5Y3dBaUlXeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOWphSFZ1YTJWa1gyeGxibWQwYUFBakhXeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOXJaV1Z3WDJGc2FYWmxBQ1FrYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDNSeVlXNXpabVZ5WDJWdVkyOWthVzVuQUNVWWJHeG9kSFJ3WDIxbGMzTmhaMlZmYm1WbFpITmZaVzltQUQ4SkZ3RUFRUUVMRVFFQ0F3UUZDd1lITlRrM01TOHRKeXNwQ3JMZ0FrVUNBQXNJQUJDSWdJQ0FBQXNaQUNBQUVNS0FnSUFBR2lBQUlBSTJBamdnQUNBQk9nQW9DeHdBSUFBZ0FDOEJNaUFBTFFBdUlBQVF3WUNBZ0FBUWdJQ0FnQUFMS2dFQmYwSEFBQkRHZ0lDQUFDSUJFTUtBZ0lBQUdpQUJRWUNJZ0lBQU5nSTRJQUVnQURvQUtDQUJDd29BSUFBUXlJQ0FnQUFMQndBZ0FDMEFLQXNIQUNBQUxRQXFDd2NBSUFBdEFDc0xCd0FnQUMwQUtRc0hBQ0FBTHdFeUN3Y0FJQUF0QUM0TFJRRUVmeUFBS0FJWUlRRWdBQzBBTFNFQ0lBQXRBQ2doQXlBQUtBSTRJUVFnQUJEQ2dJQ0FBQm9nQUNBRU5nSTRJQUFnQXpvQUtDQUFJQUk2QUMwZ0FDQUJOZ0lZQ3hFQUlBQWdBU0FCSUFKcUVNT0FnSUFBQ3hBQUlBQkJBRUhjQUJETWdJQ0FBQm9MWndFQmYwRUFJUUVDUUNBQUtBSU1EUUFDUUFKQUFrQUNRQ0FBTFFBdkRnTUJBQU1DQ3lBQUtBSTRJZ0ZGRFFBZ0FTZ0NMQ0lCUlEwQUlBQWdBUkdBZ0lDQUFBQWlBUTBEQzBFQUR3c1F5b0NBZ0FBQUN5QUFRY09XZ0lBQU5nSVFRUTRoQVFzZ0FRc2VBQUpBSUFBb0Fnd05BQ0FBUWRHYmdJQUFOZ0lRSUFCQkZUWUNEQXNMRmdBQ1FDQUFLQUlNUVJWSERRQWdBRUVBTmdJTUN3c1dBQUpBSUFBb0FneEJGa2NOQUNBQVFRQTJBZ3dMQ3djQUlBQW9BZ3dMQndBZ0FDZ0NFQXNKQUNBQUlBRTJBaEFMQndBZ0FDZ0NGQXNpQUFKQUlBQkJKRWtOQUJES2dJQ0FBQUFMSUFCQkFuUkJvTE9BZ0FCcUtBSUFDeUlBQWtBZ0FFRXVTUTBBRU1xQWdJQUFBQXNnQUVFQ2RFR3d0SUNBQUdvb0FnQUw3Z3NCQVg5QjY2aUFnQUFoQVFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkJuSDlxRHZRRFkySUFBV0ZoWVdGaFlRSURCQVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEJnY0lDUW9MREEwT0QyRmhZV0ZoRUdGaFlXRmhZV0ZoWVdGaEVXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlSSVRGQlVXRnhnWkdodGhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhIQjBlSHlBaElpTWtKU1luS0NrcUt5d3RMaTh3TVRJek5EVTJZVGM0T1RwaFlXRmhZV0ZoWVR0aFlXRThZV0ZoWVQwK1AyRmhZV0ZoWVdGaFFHRmhRV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVVKRFJFVkdSMGhKU2t0TVRVNVBVRkZTVTJGaFlXRmhZV0ZoVkZWV1YxaFpXbHRoWEYxaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmVZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhYMkJoQzBIaHA0Q0FBQThMUWFTaGdJQUFEd3RCeTZ5QWdBQVBDMEgrc1lDQUFBOExRY0NrZ0lBQUR3dEJxNlNBZ0FBUEMwR05xSUNBQUE4TFFlS21nSUFBRHd0QmdMQ0FnQUFQQzBHNXI0Q0FBQThMUWRla2dJQUFEd3RCNzUrQWdBQVBDMEhobjRDQUFBOExRZnFmZ0lBQUR3dEI4cUNBZ0FBUEMwR29yNENBQUE4TFFhNnlnSUFBRHd0QmlMQ0FnQUFQQzBIc3A0Q0FBQThMUVlLaWdJQUFEd3RCanAyQWdBQVBDMEhRcm9DQUFBOExRY3FqZ0lBQUR3dEJ4YktBZ0FBUEMwSGZuSUNBQUE4TFFkS2NnSUFBRHd0QnhLQ0FnQUFQQzBIWG9JQ0FBQThMUWFLZmdJQUFEd3RCN2E2QWdBQVBDMEdyc0lDQUFBOExRZFNsZ0lBQUR3dEJ6SzZBZ0FBUEMwSDZyb0NBQUE4TFFmeXJnSUFBRHd0QjByQ0FnQUFQQzBIeG5ZQ0FBQThMUWJ1Z2dJQUFEd3RCOTZ1QWdBQVBDMEdRc1lDQUFBOExRZGV4Z0lBQUR3dEJvcTJBZ0FBUEMwSFVwNENBQUE4TFFlQ3JnSUFBRHd0Qm42eUFnQUFQQzBIcnNZQ0FBQThMUWRXZmdJQUFEd3RCeXJHQWdBQVBDMEhlcFlDQUFBOExRZFNlZ0lBQUR3dEI5SnlBZ0FBUEMwR25zb0NBQUE4TFFiR2RnSUFBRHd0Qm9KMkFnQUFQQzBHNXNZQ0FBQThMUWJ5d2dJQUFEd3RCa3FHQWdBQVBDMEd6cG9DQUFBOExRZW1zZ0lBQUR3dEJySjZBZ0FBUEMwSFVxNENBQUE4TFFmZW1nSUFBRHd0QmdLYUFnQUFQQzBHd29ZQ0FBQThMUWY2ZWdJQUFEd3RCamFPQWdBQVBDMEdKcllDQUFBOExRZmVpZ0lBQUR3dEJvTEdBZ0FBUEMwR3VuNENBQUE4TFFjYWxnSUFBRHd0QjZKNkFnQUFQQzBHVG9vQ0FBQThMUWNLdmdJQUFEd3RCdzUyQWdBQVBDMEdMcklDQUFBOExRZUdkZ0lBQUR3dEJqYStBZ0FBUEMwSHFvWUNBQUE4TFFiU3RnSUFBRHd0QjBxK0FnQUFQQzBIZnNvQ0FBQThMUWRLeWdJQUFEd3RCOExDQWdBQVBDMEdwb29DQUFBOExRZm1qZ0lBQUR3dEJtWjZBZ0FBUEMwRzFySUNBQUE4TFFadXdnSUFBRHd0QmtyS0FnQUFQQzBHMnE0Q0FBQThMUWNLaWdJQUFEd3RCK0xLQWdBQVBDMEdlcFlDQUFBOExRZENpZ0lBQUR3dEJ1cDZBZ0FBUEMwR0Jub0NBQUE4TEVNcUFnSUFBQUF0QjFxR0FnQUFoQVFzZ0FRc1dBQ0FBSUFBdEFDMUIvZ0Z4SUFGQkFFZHlPZ0F0Q3hrQUlBQWdBQzBBTFVIOUFYRWdBVUVBUjBFQmRISTZBQzBMR1FBZ0FDQUFMUUF0UWZzQmNTQUJRUUJIUVFKMGNqb0FMUXNaQUNBQUlBQXRBQzFCOXdGeElBRkJBRWRCQTNSeU9nQXRDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FnQWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NCQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFjYVJnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUl3SWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwa0JBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWdnaUJFVU5BQ0FBSUFFZ0FpQUJheUFFRVlHQWdJQUFBQ0lEUVg5SERRQWdBRUgyaW9DQUFEWUNFRUVZSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ05DSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSU1JZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQjdacUFnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BamdpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDRUNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRWldRZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJOElnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMGtCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FoUWlCRVVOQUNBQUlBRWdBaUFCYXlBRUVZR0FnSUFBQUNJRFFYOUhEUUFnQUVHcW00Q0FBRFlDRUVFWUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NRQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0SkFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUlZSWdSRkRRQWdBQ0FCSUFJZ0FXc2dCQkdCZ0lDQUFBQWlBMEYvUncwQUlBQkI3Wk9BZ0FBMkFoQkJHQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWtRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ0pDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSXNJZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQzBrQkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BaWdpQkVVTkFDQUFJQUVnQWlBQmF5QUVFWUdBZ0lBQUFDSURRWDlIRFFBZ0FFSDJpSUNBQURZQ0VFRVlJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDVUNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEpBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJY0lnUkZEUUFnQUNBQklBSWdBV3NnQkJHQmdJQ0FBQUFpQTBGL1J3MEFJQUJCd3BtQWdBQTJBaEJCR0NFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FrZ2lCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NJQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFaU1VnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUpNSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWxRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ1dDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RGQVFGL0FrQUNRQ0FBTHdFd1FSUnhRUlJIRFFCQkFTRURJQUF0QUNoQkFVWU5BU0FBTHdFeVFlVUFSaUVEREFFTElBQXRBQ2xCQlVZaEF3c2dBQ0FET2dBdVFRQUwvZ0VCQTM5QkFTRURBa0FnQUM4Qk1DSUVRUWh4RFFBZ0FDa0RJRUlBVWlFREN3SkFBa0FnQUMwQUxrVU5BRUVCSVFVZ0FDMEFLVUVGUmcwQlFRRWhCU0FFUWNBQWNVVWdBM0ZCQVVjTkFRdEJBQ0VGSUFSQndBQnhEUUJCQWlFRklBUkIvLzhEY1NJRFFRaHhEUUFDUUNBRFFZQUVjVVVOQUFKQUlBQXRBQ2hCQVVjTkFDQUFMUUF0UVFweERRQkJCUThMUVFRUEN3SkFJQU5CSUhFTkFBSkFJQUF0QUNoQkFVWU5BQ0FBTHdFeVFmLy9BM0VpQUVHY2YycEI1QUJKRFFBZ0FFSE1BVVlOQUNBQVFiQUNSZzBBUVFRaEJTQUVRU2h4UlEwQ0lBTkJpQVJ4UVlBRVJnMENDMEVBRHd0QkFFRURJQUFwQXlCUUd5RUZDeUFGQzJJQkFuOUJBQ0VCQWtBZ0FDMEFLRUVCUmcwQUlBQXZBVEpCLy84RGNTSUNRWngvYWtIa0FFa05BQ0FDUWN3QlJnMEFJQUpCc0FKR0RRQWdBQzhCTUNJQVFjQUFjUTBBUVFFaEFTQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUJDeUFCQzZjQkFRTi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUVFQUlRTWdBQzhCTUNJRVFRSnhSUTBCREFJTFFRQWhBeUFBTHdFd0lnUkJBWEZGRFFFTFFRRWhBeUFBTFFBb1FRRkdEUUFnQUM4Qk1rSC8vd054SWdWQm5IOXFRZVFBU1EwQUlBVkJ6QUZHRFFBZ0JVR3dBa1lOQUNBRVFjQUFjUTBBUVFBaEF5QUVRWWdFY1VHQUJFWU5BQ0FFUVNoeFFRQkhJUU1MSUFCQkFEc0JNQ0FBUVFBNkFDOGdBd3VaQVFFQ2Z3SkFBa0FDUUNBQUxRQXFSUTBBSUFBdEFDdEZEUUJCQUNFQklBQXZBVEFpQWtFQ2NVVU5BUXdDQzBFQUlRRWdBQzhCTUNJQ1FRRnhSUTBCQzBFQklRRWdBQzBBS0VFQlJnMEFJQUF2QVRKQi8vOERjU0lBUVp4L2FrSGtBRWtOQUNBQVFjd0JSZzBBSUFCQnNBSkdEUUFnQWtIQUFIRU5BRUVBSVFFZ0FrR0lCSEZCZ0FSR0RRQWdBa0VvY1VFQVJ5RUJDeUFCQzBrQkFYc2dBRUVRYXYwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNJQi9Rc0RBQ0FBSUFIOUN3TUFJQUJCTUdvZ0FmMExBd0FnQUVFZ2FpQUIvUXNEQUNBQVFkMEJOZ0ljUVFBTGV3RUJmd0pBSUFBb0Fnd2lBdzBBQWtBZ0FDZ0NCRVVOQUNBQUlBRTJBZ1FMQWtBZ0FDQUJJQUlReElDQWdBQWlBdzBBSUFBb0Fnd1BDeUFBSUFNMkFoeEJBQ0VESUFBb0FnUWlBVVVOQUNBQUlBRWdBaUFBS0FJSUVZR0FnSUFBQUNJQlJRMEFJQUFnQWpZQ0ZDQUFJQUUyQWd3Z0FTRURDeUFEQytUekFRTU9md04rQkg4amdJQ0FnQUJCRUdzaUF5U0FnSUNBQUNBQklRUWdBU0VGSUFFaEJpQUJJUWNnQVNFSUlBRWhDU0FCSVFvZ0FTRUxJQUVoRENBQklRMGdBU0VPSUFFaER3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUFLQUljSWhCQmYyb08zUUhhQVFIWkFRSURCQVVHQndnSkNnc01EUTdZQVE4UTF3RVJFdFlCRXhRVkZoY1lHUm9iNEFIZkFSd2RIdFVCSHlBaElpTWtKZFFCSmljb0tTb3JMTk1CMGdFdEx0RUIwQUV2TURFeU16UTFOamM0T1RvN1BEMCtQMEJCUWtORVJVYmJBVWRJU1VyUEFjNEJTODBCVE13QlRVNVBVRkZTVTFSVlZsZFlXVnBiWEYxZVgyQmhZbU5rWldabmFHbHFhMnh0Ym05d2NYSnpkSFYyZDNoNWVudDhmWDUvZ0FHQkFZSUJnd0dFQVlVQmhnR0hBWWdCaVFHS0FZc0JqQUdOQVk0Qmp3R1FBWkVCa2dHVEFaUUJsUUdXQVpjQm1BR1pBWm9CbXdHY0FaMEJuZ0dmQWFBQm9RR2lBYU1CcEFHbEFhWUJwd0dvQWFrQnFnR3JBYXdCclFHdUFhOEJzQUd4QWJJQnN3RzBBYlVCdGdHM0Fjc0J5Z0c0QWNrQnVRSElBYm9CdXdHOEFiMEJ2Z0cvQWNBQndRSENBY01CeEFIRkFjWUJBTndCQzBFQUlSQU14Z0VMUVE0aEVBekZBUXRCRFNFUURNUUJDMEVQSVJBTXd3RUxRUkFoRUF6Q0FRdEJFeUVRRE1FQkMwRVVJUkFNd0FFTFFSVWhFQXkvQVF0QkZpRVFETDRCQzBFWElSQU12UUVMUVJnaEVBeThBUXRCR1NFUURMc0JDMEVhSVJBTXVnRUxRUnNoRUF5NUFRdEJIQ0VRRExnQkMwRUlJUkFNdHdFTFFSMGhFQXkyQVF0QklDRVFETFVCQzBFZklSQU10QUVMUVFjaEVBeXpBUXRCSVNFUURMSUJDMEVpSVJBTXNRRUxRUjRoRUF5d0FRdEJJeUVRREs4QkMwRVNJUkFNcmdFTFFSRWhFQXl0QVF0QkpDRVFES3dCQzBFbElSQU1xd0VMUVNZaEVBeXFBUXRCSnlFUURLa0JDMEhEQVNFUURLZ0JDMEVwSVJBTXB3RUxRU3NoRUF5bUFRdEJMQ0VRREtVQkMwRXRJUkFNcEFFTFFTNGhFQXlqQVF0Qkx5RVFES0lCQzBIRUFTRVFES0VCQzBFd0lSQU1vQUVMUVRRaEVBeWZBUXRCRENFUURKNEJDMEV4SVJBTW5RRUxRVEloRUF5Y0FRdEJNeUVRREpzQkMwRTVJUkFNbWdFTFFUVWhFQXlaQVF0QnhRRWhFQXlZQVF0QkN5RVFESmNCQzBFNklSQU1sZ0VMUVRZaEVBeVZBUXRCQ2lFUURKUUJDMEUzSVJBTWt3RUxRVGdoRUF5U0FRdEJQQ0VRREpFQkMwRTdJUkFNa0FFTFFUMGhFQXlQQVF0QkNTRVFESTRCQzBFb0lSQU1qUUVMUVQ0aEVBeU1BUXRCUHlFUURJc0JDMEhBQUNFUURJb0JDMEhCQUNFUURJa0JDMEhDQUNFUURJZ0JDMEhEQUNFUURJY0JDMEhFQUNFUURJWUJDMEhGQUNFUURJVUJDMEhHQUNFUURJUUJDMEVxSVJBTWd3RUxRY2NBSVJBTWdnRUxRY2dBSVJBTWdRRUxRY2tBSVJBTWdBRUxRY29BSVJBTWZ3dEJ5d0FoRUF4K0MwSE5BQ0VRREgwTFFjd0FJUkFNZkF0QnpnQWhFQXg3QzBIUEFDRVFESG9MUWRBQUlSQU1lUXRCMFFBaEVBeDRDMEhTQUNFUURIY0xRZE1BSVJBTWRndEIxQUFoRUF4MUMwSFdBQ0VRREhRTFFkVUFJUkFNY3d0QkJpRVFESElMUWRjQUlSQU1jUXRCQlNFUURIQUxRZGdBSVJBTWJ3dEJCQ0VRREc0TFFka0FJUkFNYlF0QjJnQWhFQXhzQzBIYkFDRVFER3NMUWR3QUlSQU1hZ3RCQXlFUURHa0xRZDBBSVJBTWFBdEIzZ0FoRUF4bkMwSGZBQ0VRREdZTFFlRUFJUkFNWlF0QjRBQWhFQXhrQzBIaUFDRVFER01MUWVNQUlSQU1ZZ3RCQWlFUURHRUxRZVFBSVJBTVlBdEI1UUFoRUF4ZkMwSG1BQ0VRREY0TFFlY0FJUkFNWFF0QjZBQWhFQXhjQzBIcEFDRVFERnNMUWVvQUlSQU1XZ3RCNndBaEVBeFpDMEhzQUNFUURGZ0xRZTBBSVJBTVZ3dEI3Z0FoRUF4V0MwSHZBQ0VRREZVTFFmQUFJUkFNVkF0QjhRQWhFQXhUQzBIeUFDRVFERklMUWZNQUlSQU1VUXRCOUFBaEVBeFFDMEgxQUNFUURFOExRZllBSVJBTVRndEI5d0FoRUF4TkMwSDRBQ0VRREV3TFFma0FJUkFNU3d0QitnQWhFQXhLQzBIN0FDRVFERWtMUWZ3QUlSQU1TQXRCL1FBaEVBeEhDMEgrQUNFUURFWUxRZjhBSVJBTVJRdEJnQUVoRUF4RUMwR0JBU0VRREVNTFFZSUJJUkFNUWd0Qmd3RWhFQXhCQzBHRUFTRVFERUFMUVlVQklSQU1Qd3RCaGdFaEVBdytDMEdIQVNFUUREMExRWWdCSVJBTVBBdEJpUUVoRUF3N0MwR0tBU0VRRERvTFFZc0JJUkFNT1F0QmpBRWhFQXc0QzBHTkFTRVFERGNMUVk0QklSQU1OZ3RCandFaEVBdzFDMEdRQVNFUUREUUxRWkVCSVJBTU13dEJrZ0VoRUF3eUMwR1RBU0VRRERFTFFaUUJJUkFNTUF0QmxRRWhFQXd2QzBHV0FTRVFEQzRMUVpjQklSQU1MUXRCbUFFaEVBd3NDMEdaQVNFUURDc0xRWm9CSVJBTUtndEJtd0VoRUF3cEMwR2NBU0VRRENnTFFaMEJJUkFNSnd0Qm5nRWhFQXdtQzBHZkFTRVFEQ1VMUWFBQklSQU1KQXRCb1FFaEVBd2pDMEdpQVNFUURDSUxRYU1CSVJBTUlRdEJwQUVoRUF3Z0MwR2xBU0VRREI4TFFhWUJJUkFNSGd0QnB3RWhFQXdkQzBHb0FTRVFEQndMUWFrQklSQU1Hd3RCcWdFaEVBd2FDMEdyQVNFUURCa0xRYXdCSVJBTUdBdEJyUUVoRUF3WEMwR3VBU0VRREJZTFFRRWhFQXdWQzBHdkFTRVFEQlFMUWJBQklSQU1Fd3RCc1FFaEVBd1NDMEd6QVNFUURCRUxRYklCSVJBTUVBdEJ0QUVoRUF3UEMwRzFBU0VRREE0TFFiWUJJUkFNRFF0QnR3RWhFQXdNQzBHNEFTRVFEQXNMUWJrQklSQU1DZ3RCdWdFaEVBd0pDMEc3QVNFUURBZ0xRY1lCSVJBTUJ3dEJ2QUVoRUF3R0MwRzlBU0VRREFVTFFiNEJJUkFNQkF0QnZ3RWhFQXdEQzBIQUFTRVFEQUlMUWNJQklSQU1BUXRCd1FFaEVBc0RRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUJBT3h3RUFBUUlEQkFVR0J3Z0pDZ3NNRFE0UEVCRVNFeFFWRmhjWUdSb2JIQjRmSUNFakpTZy9RRUZFUlVaSFNFbEtTMHhOVDFCUlVsUGVBMWRaVzF4ZFlHSmxabWRvYVdwcmJHMXZjSEZ5YzNSMWRuZDRlWHA3ZkgxK2dBR0NBWVVCaGdHSEFZa0Jpd0dNQVkwQmpnR1BBWkFCa1FHVUFaVUJsZ0dYQVpnQm1RR2FBWnNCbkFHZEFaNEJud0dnQWFFQm9nR2pBYVFCcFFHbUFhY0JxQUdwQWFvQnF3R3NBYTBCcmdHdkFiQUJzUUd5QWJNQnRBRzFBYllCdHdHNEFia0J1Z0c3QWJ3QnZRRytBYjhCd0FIQkFjSUJ3d0hFQWNVQnhnSEhBY2dCeVFIS0Fjc0J6QUhOQWM0Qnp3SFFBZEVCMGdIVEFkUUIxUUhXQWRjQjJBSFpBZG9CMndIY0FkMEIzZ0hnQWVFQjRnSGpBZVFCNVFIbUFlY0I2QUhwQWVvQjZ3SHNBZTBCN2dIdkFmQUI4UUh5QWZNQm1RS2tBckFDL2dMK0Fnc2dBU0lFSUFKSERmTUJRZDBCSVJBTS93TUxJQUVpRUNBQ1J3M2RBVUhEQVNFUURQNERDeUFCSWdFZ0FrY05rQUZCOXdBaEVBejlBd3NnQVNJQklBSkhEWVlCUWU4QUlSQU0vQU1MSUFFaUFTQUNSdzEvUWVvQUlSQU0rd01MSUFFaUFTQUNSdzE3UWVnQUlSQU0rZ01MSUFFaUFTQUNSdzE0UWVZQUlSQU0rUU1MSUFFaUFTQUNSdzBhUVJnaEVBejRBd3NnQVNJQklBSkhEUlJCRWlFUURQY0RDeUFCSWdFZ0FrY05XVUhGQUNFUURQWURDeUFCSWdFZ0FrY05Ta0UvSVJBTTlRTUxJQUVpQVNBQ1J3MUlRVHdoRUF6MEF3c2dBU0lCSUFKSERVRkJNU0VRRFBNREN5QUFMUUF1UVFGR0Rlc0RESWNDQ3lBQUlBRWlBU0FDRU1DQWdJQUFRUUZIRGVZQklBQkNBRGNESUF6bkFRc2dBQ0FCSWdFZ0FoQzBnSUNBQUNJUURlY0JJQUVoQVF6MUFnc0NRQ0FCSWdFZ0FrY05BRUVHSVJBTThBTUxJQUFnQVVFQmFpSUJJQUlRdTRDQWdBQWlFQTNvQVNBQklRRU1NUXNnQUVJQU53TWdRUkloRUF6VkF3c2dBU0lRSUFKSERTdEJIU0VRRE8wREN3SkFJQUVpQVNBQ1JnMEFJQUZCQVdvaEFVRVFJUkFNMUFNTFFRY2hFQXpzQXdzZ0FFSUFJQUFwQXlBaUVTQUNJQUVpRUd1dEloSjlJaE1nRXlBUlZoczNBeUFnRVNBU1ZpSVVSUTNsQVVFSUlSQU02d01MQWtBZ0FTSUJJQUpHRFFBZ0FFR0pnSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJRUlFoRUF6U0F3dEJDU0VRRE9vREN5QUJJUUVnQUNrRElGQU41QUVnQVNFQkRQSUNDd0pBSUFFaUFTQUNSdzBBUVFzaEVBenBBd3NnQUNBQlFRRnFJZ0VnQWhDMmdJQ0FBQ0lRRGVVQklBRWhBUXp5QWdzZ0FDQUJJZ0VnQWhDNGdJQ0FBQ0lRRGVVQklBRWhBUXp5QWdzZ0FDQUJJZ0VnQWhDNGdJQ0FBQ0lRRGVZQklBRWhBUXdOQ3lBQUlBRWlBU0FDRUxxQWdJQUFJaEFONXdFZ0FTRUJEUEFDQ3dKQUlBRWlBU0FDUncwQVFROGhFQXpsQXdzZ0FTMEFBQ0lRUVR0R0RRZ2dFRUVOUnczb0FTQUJRUUZxSVFFTTd3SUxJQUFnQVNJQklBSVF1b0NBZ0FBaUVBM29BU0FCSVFFTThnSUxBMEFDUUNBQkxRQUFRZkMxZ0lBQWFpMEFBQ0lRUVFGR0RRQWdFRUVDUnczckFTQUFLQUlFSVJBZ0FFRUFOZ0lFSUFBZ0VDQUJRUUZxSWdFUXVZQ0FnQUFpRUEzcUFTQUJJUUVNOUFJTElBRkJBV29pQVNBQ1J3MEFDMEVTSVJBTTRnTUxJQUFnQVNJQklBSVF1b0NBZ0FBaUVBM3BBU0FCSVFFTUNnc2dBU0lCSUFKSERRWkJHeUVRRE9BREN3SkFJQUVpQVNBQ1J3MEFRUlloRUF6Z0F3c2dBRUdLZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBQ0FCSUFJUXVJQ0FnQUFpRUEzcUFTQUJJUUZCSUNFUURNWURDd0pBSUFFaUFTQUNSZzBBQTBBQ1FDQUJMUUFBUWZDM2dJQUFhaTBBQUNJUVFRSkdEUUFDUUNBUVFYOXFEZ1RsQWV3QkFPc0I3QUVMSUFGQkFXb2hBVUVJSVJBTXlBTUxJQUZCQVdvaUFTQUNSdzBBQzBFVklSQU0zd01MUVJVaEVBemVBd3NEUUFKQUlBRXRBQUJCOExtQWdBQnFMUUFBSWhCQkFrWU5BQ0FRUVg5cURnVGVBZXdCNEFIckFld0JDeUFCUVFGcUlnRWdBa2NOQUF0QkdDRVFETjBEQ3dKQUlBRWlBU0FDUmcwQUlBQkJpNENBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUVISVJBTXhBTUxRUmtoRUF6Y0F3c2dBVUVCYWlFQkRBSUxBa0FnQVNJVUlBSkhEUUJCR2lFUUROc0RDeUFVSVFFQ1FDQVVMUUFBUVhOcURoVGRBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBZ0R1QWd0QkFDRVFJQUJCQURZQ0hDQUFRYStMZ0lBQU5nSVFJQUJCQWpZQ0RDQUFJQlJCQVdvMkFoUU0yZ01MQWtBZ0FTMEFBQ0lRUVR0R0RRQWdFRUVOUnczb0FTQUJRUUZxSVFFTTVRSUxJQUZCQVdvaEFRdEJJaUVRREw4REN3SkFJQUVpRUNBQ1J3MEFRUndoRUF6WUF3dENBQ0VSSUJBaEFTQVFMUUFBUVZCcURqZm5BZVlCQVFJREJBVUdCd2dBQUFBQUFBQUFDUW9MREEwT0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUEVCRVNFeFFBQzBFZUlSQU12UU1MUWdJaEVRemxBUXRDQXlFUkRPUUJDMElFSVJFTTR3RUxRZ1VoRVF6aUFRdENCaUVSRE9FQkMwSUhJUkVNNEFFTFFnZ2hFUXpmQVF0Q0NTRVJETjRCQzBJS0lSRU0zUUVMUWdzaEVRemNBUXRDRENFUkROc0JDMElOSVJFTTJnRUxRZzRoRVF6WkFRdENEeUVSRE5nQkMwSUtJUkVNMXdFTFFnc2hFUXpXQVF0Q0RDRVJETlVCQzBJTklSRU0xQUVMUWc0aEVRelRBUXRDRHlFUkROSUJDMElBSVJFQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQkF0QUFCQlVHb09OK1VCNUFFQUFRSURCQVVHQitZQjVnSG1BZVlCNWdIbUFlWUJDQWtLQ3d3TjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQVE0UEVCRVNFK1lCQzBJQ0lSRU01QUVMUWdNaEVRempBUXRDQkNFUkRPSUJDMElGSVJFTTRRRUxRZ1loRVF6Z0FRdENCeUVSRE44QkMwSUlJUkVNM2dFTFFna2hFUXpkQVF0Q0NpRVJETndCQzBJTElSRU0yd0VMUWd3aEVRemFBUXRDRFNFUkROa0JDMElPSVJFTTJBRUxRZzhoRVF6WEFRdENDaUVSRE5ZQkMwSUxJUkVNMVFFTFFnd2hFUXpVQVF0Q0RTRVJETk1CQzBJT0lSRU0wZ0VMUWc4aEVRelJBUXNnQUVJQUlBQXBBeUFpRVNBQ0lBRWlFR3V0SWhKOUloTWdFeUFSVmhzM0F5QWdFU0FTVmlJVVJRM1NBVUVmSVJBTXdBTUxBa0FnQVNJQklBSkdEUUFnQUVHSmdJQ0FBRFlDQ0NBQUlBRTJBZ1FnQVNFQlFTUWhFQXluQXd0QklDRVFETDhEQ3lBQUlBRWlFQ0FDRUw2QWdJQUFRWDlxRGdXMkFRREZBZ0hSQWRJQkMwRVJJUkFNcEFNTElBQkJBVG9BTHlBUUlRRU11d01MSUFFaUFTQUNSdzNTQVVFa0lSQU11d01MSUFFaURTQUNSdzBlUWNZQUlSQU11Z01MSUFBZ0FTSUJJQUlRc29DQWdBQWlFQTNVQVNBQklRRU10UUVMSUFFaUVDQUNSdzBtUWRBQUlSQU11QU1MQWtBZ0FTSUJJQUpIRFFCQktDRVFETGdEQ3lBQVFRQTJBZ1FnQUVHTWdJQ0FBRFlDQ0NBQUlBRWdBUkN4Z0lDQUFDSVFEZE1CSUFFaEFRellBUXNDUUNBQkloQWdBa2NOQUVFcElSQU10d01MSUJBdEFBQWlBVUVnUmcwVUlBRkJDVWNOMHdFZ0VFRUJhaUVCREJVTEFrQWdBU0lCSUFKR0RRQWdBVUVCYWlFQkRCY0xRU29oRUF5MUF3c0NRQ0FCSWhBZ0FrY05BRUVySVJBTXRRTUxBa0FnRUMwQUFDSUJRUWxHRFFBZ0FVRWdSdzNWQVFzZ0FDMEFMRUVJUmczVEFTQVFJUUVNa1FNTEFrQWdBU0lCSUFKSERRQkJMQ0VRRExRREN5QUJMUUFBUVFwSERkVUJJQUZCQVdvaEFRekpBZ3NnQVNJT0lBSkhEZFVCUVM4aEVBeXlBd3NEUUFKQUlBRXRBQUFpRUVFZ1JnMEFBa0FnRUVGMmFnNEVBTndCM0FFQTJnRUxJQUVoQVF6Z0FRc2dBVUVCYWlJQklBSkhEUUFMUVRFaEVBeXhBd3RCTWlFUUlBRWlGQ0FDUmcyd0F5QUNJQlJySUFBb0FnQWlBV29oRlNBVUlBRnJRUU5xSVJZQ1FBTkFJQlF0QUFBaUYwRWdjaUFYSUJkQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQjhMdUFnQUJxTFFBQVJ3MEJBa0FnQVVFRFJ3MEFRUVloQVF5V0F3c2dBVUVCYWlFQklCUkJBV29pRkNBQ1J3MEFDeUFBSUJVMkFnQU1zUU1MSUFCQkFEWUNBQ0FVSVFFTTJRRUxRVE1oRUNBQkloUWdBa1lOcndNZ0FpQVVheUFBS0FJQUlnRnFJUlVnRkNBQmEwRUlhaUVXQWtBRFFDQVVMUUFBSWhkQklISWdGeUFYUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUWZTN2dJQUFhaTBBQUVjTkFRSkFJQUZCQ0VjTkFFRUZJUUVNbFFNTElBRkJBV29oQVNBVVFRRnFJaFFnQWtjTkFBc2dBQ0FWTmdJQURMQURDeUFBUVFBMkFnQWdGQ0VCRE5nQkMwRTBJUkFnQVNJVUlBSkdEYTRESUFJZ0ZHc2dBQ2dDQUNJQmFpRVZJQlFnQVd0QkJXb2hGZ0pBQTBBZ0ZDMEFBQ0lYUVNCeUlCY2dGMEcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUhRd29DQUFHb3RBQUJIRFFFQ1FDQUJRUVZIRFFCQkJ5RUJESlFEQ3lBQlFRRnFJUUVnRkVFQmFpSVVJQUpIRFFBTElBQWdGVFlDQUF5dkF3c2dBRUVBTmdJQUlCUWhBUXpYQVFzQ1FDQUJJZ0VnQWtZTkFBTkFBa0FnQVMwQUFFR0F2b0NBQUdvdEFBQWlFRUVCUmcwQUlCQkJBa1lOQ2lBQklRRU0zUUVMSUFGQkFXb2lBU0FDUncwQUMwRXdJUkFNcmdNTFFUQWhFQXl0QXdzQ1FDQUJJZ0VnQWtZTkFBTkFBa0FnQVMwQUFDSVFRU0JHRFFBZ0VFRjJhZzRFMlFIYUFkb0IyUUhhQVFzZ0FVRUJhaUlCSUFKSERRQUxRVGdoRUF5dEF3dEJPQ0VRREt3REN3TkFBa0FnQVMwQUFDSVFRU0JHRFFBZ0VFRUpSdzBEQ3lBQlFRRnFJZ0VnQWtjTkFBdEJQQ0VRREtzREN3TkFBa0FnQVMwQUFDSVFRU0JHRFFBQ1FBSkFJQkJCZG1vT0JOb0JBUUhhQVFBTElCQkJMRVlOMndFTElBRWhBUXdFQ3lBQlFRRnFJZ0VnQWtjTkFBdEJQeUVRREtvREN5QUJJUUVNMndFTFFjQUFJUkFnQVNJVUlBSkdEYWdESUFJZ0ZHc2dBQ2dDQUNJQmFpRVdJQlFnQVd0QkJtb2hGd0pBQTBBZ0ZDMEFBRUVnY2lBQlFZREFnSUFBYWkwQUFFY05BU0FCUVFaR0RZNERJQUZCQVdvaEFTQVVRUUZxSWhRZ0FrY05BQXNnQUNBV05nSUFES2tEQ3lBQVFRQTJBZ0FnRkNFQkMwRTJJUkFNamdNTEFrQWdBU0lQSUFKSERRQkJ3UUFoRUF5bkF3c2dBRUdNZ0lDQUFEWUNDQ0FBSUE4MkFnUWdEeUVCSUFBdEFDeEJmMm9PQk0wQjFRSFhBZGtCaHdNTElBRkJBV29oQVF6TUFRc0NRQ0FCSWdFZ0FrWU5BQU5BQWtBZ0FTMEFBQ0lRUVNCeUlCQWdFRUcvZjJwQi93RnhRUnBKRzBIL0FYRWlFRUVKUmcwQUlCQkJJRVlOQUFKQUFrQUNRQUpBSUJCQm5YOXFEaE1BQXdNREF3TURBd0VEQXdNREF3TURBd01DQXdzZ0FVRUJhaUVCUVRFaEVBeVJBd3NnQVVFQmFpRUJRVEloRUF5UUF3c2dBVUVCYWlFQlFUTWhFQXlQQXdzZ0FTRUJETkFCQ3lBQlFRRnFJZ0VnQWtjTkFBdEJOU0VRREtVREMwRTFJUkFNcEFNTEFrQWdBU0lCSUFKR0RRQURRQUpBSUFFdEFBQkJnTHlBZ0FCcUxRQUFRUUZHRFFBZ0FTRUJETk1CQ3lBQlFRRnFJZ0VnQWtjTkFBdEJQU0VRREtRREMwRTlJUkFNb3dNTElBQWdBU0lCSUFJUXNJQ0FnQUFpRUEzV0FTQUJJUUVNQVFzZ0VFRUJhaUVCQzBFOElSQU1od01MQWtBZ0FTSUJJQUpIRFFCQndnQWhFQXlnQXdzQ1FBTkFBa0FnQVMwQUFFRjNhZzRZQUFMK0F2NENoQVArQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0lBL2dJTElBRkJBV29pQVNBQ1J3MEFDMEhDQUNFUURLQURDeUFCUVFGcUlRRWdBQzBBTFVFQmNVVU52UUVnQVNFQkMwRXNJUkFNaFFNTElBRWlBU0FDUnczVEFVSEVBQ0VRREowREN3TkFBa0FnQVMwQUFFR1F3SUNBQUdvdEFBQkJBVVlOQUNBQklRRU10d0lMSUFGQkFXb2lBU0FDUncwQUMwSEZBQ0VRREp3REN5QU5MUUFBSWhCQklFWU5zd0VnRUVFNlJ3MkJBeUFBS0FJRUlRRWdBRUVBTmdJRUlBQWdBU0FORUsrQWdJQUFJZ0VOMEFFZ0RVRUJhaUVCRExNQ0MwSEhBQ0VRSUFFaURTQUNSZzJhQXlBQ0lBMXJJQUFvQWdBaUFXb2hGaUFOSUFGclFRVnFJUmNEUUNBTkxRQUFJaFJCSUhJZ0ZDQVVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRWkRDZ0lBQWFpMEFBRWNOZ0FNZ0FVRUZSZzMwQWlBQlFRRnFJUUVnRFVFQmFpSU5JQUpIRFFBTElBQWdGallDQUF5YUF3dEJ5QUFoRUNBQklnMGdBa1lObVFNZ0FpQU5heUFBS0FJQUlnRnFJUllnRFNBQmEwRUphaUVYQTBBZ0RTMEFBQ0lVUVNCeUlCUWdGRUcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUdXd29DQUFHb3RBQUJIRGY4Q0FrQWdBVUVKUncwQVFRSWhBUXoxQWdzZ0FVRUJhaUVCSUExQkFXb2lEU0FDUncwQUN5QUFJQlkyQWdBTW1RTUxBa0FnQVNJTklBSkhEUUJCeVFBaEVBeVpBd3NDUUFKQUlBMHRBQUFpQVVFZ2NpQUJJQUZCdjM5cVFmOEJjVUVhU1J0Qi93RnhRWkovYWc0SEFJQURnQU9BQTRBRGdBTUJnQU1MSUExQkFXb2hBVUUrSVJBTWdBTUxJQTFCQVdvaEFVRS9JUkFNL3dJTFFjb0FJUkFnQVNJTklBSkdEWmNESUFJZ0RXc2dBQ2dDQUNJQmFpRVdJQTBnQVd0QkFXb2hGd05BSUEwdEFBQWlGRUVnY2lBVUlCUkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkJvTUtBZ0FCcUxRQUFSdzM5QWlBQlFRRkdEZkFDSUFGQkFXb2hBU0FOUVFGcUlnMGdBa2NOQUFzZ0FDQVdOZ0lBREpjREMwSExBQ0VRSUFFaURTQUNSZzJXQXlBQ0lBMXJJQUFvQWdBaUFXb2hGaUFOSUFGclFRNXFJUmNEUUNBTkxRQUFJaFJCSUhJZ0ZDQVVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRYUxDZ0lBQWFpMEFBRWNOL0FJZ0FVRU9SZzN3QWlBQlFRRnFJUUVnRFVFQmFpSU5JQUpIRFFBTElBQWdGallDQUF5V0F3dEJ6QUFoRUNBQklnMGdBa1lObFFNZ0FpQU5heUFBS0FJQUlnRnFJUllnRFNBQmEwRVBhaUVYQTBBZ0RTMEFBQ0lVUVNCeUlCUWdGRUcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUhBd29DQUFHb3RBQUJIRGZzQ0FrQWdBVUVQUncwQVFRTWhBUXp4QWdzZ0FVRUJhaUVCSUExQkFXb2lEU0FDUncwQUN5QUFJQlkyQWdBTWxRTUxRYzBBSVJBZ0FTSU5JQUpHRFpRRElBSWdEV3NnQUNnQ0FDSUJhaUVXSUEwZ0FXdEJCV29oRndOQUlBMHRBQUFpRkVFZ2NpQVVJQlJCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCME1LQWdBQnFMUUFBUnczNkFnSkFJQUZCQlVjTkFFRUVJUUVNOEFJTElBRkJBV29oQVNBTlFRRnFJZzBnQWtjTkFBc2dBQ0FXTmdJQURKUURDd0pBSUFFaURTQUNSdzBBUWM0QUlSQU1sQU1MQWtBQ1FBSkFBa0FnRFMwQUFDSUJRU0J5SUFFZ0FVRy9mMnBCL3dGeFFScEpHMEgvQVhGQm5YOXFEaE1BL1FMOUF2MEMvUUw5QXYwQy9RTDlBdjBDL1FMOUF2MENBZjBDL1FMOUFnSUQvUUlMSUExQkFXb2hBVUhCQUNFUURQMENDeUFOUVFGcUlRRkJ3Z0FoRUF6OEFnc2dEVUVCYWlFQlFjTUFJUkFNK3dJTElBMUJBV29oQVVIRUFDRVFEUG9DQ3dKQUlBRWlBU0FDUmcwQUlBQkJqWUNBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUhGQUNFUURQb0NDMEhQQUNFUURKSURDeUFRSVFFQ1FBSkFJQkF0QUFCQmRtb09CQUdvQXFnQ0FLZ0NDeUFRUVFGcUlRRUxRU2NoRUF6NEFnc0NRQ0FCSWdFZ0FrY05BRUhSQUNFUURKRURDd0pBSUFFdEFBQkJJRVlOQUNBQklRRU1qUUVMSUFGQkFXb2hBU0FBTFFBdFFRRnhSUTNIQVNBQklRRU1qQUVMSUFFaUZ5QUNSdzNJQVVIU0FDRVFESThEQzBIVEFDRVFJQUVpRkNBQ1JnMk9BeUFDSUJScklBQW9BZ0FpQVdvaEZpQVVJQUZyUVFGcUlSY0RRQ0FVTFFBQUlBRkIxc0tBZ0FCcUxRQUFSdzNNQVNBQlFRRkdEY2NCSUFGQkFXb2hBU0FVUVFGcUloUWdBa2NOQUFzZ0FDQVdOZ0lBREk0REN3SkFJQUVpQVNBQ1J3MEFRZFVBSVJBTWpnTUxJQUV0QUFCQkNrY056QUVnQVVFQmFpRUJETWNCQ3dKQUlBRWlBU0FDUncwQVFkWUFJUkFNalFNTEFrQUNRQ0FCTFFBQVFYWnFEZ1FBelFITkFRSE5BUXNnQVVFQmFpRUJETWNCQ3lBQlFRRnFJUUZCeWdBaEVBenpBZ3NnQUNBQklnRWdBaEN1Z0lDQUFDSVFEY3NCSUFFaEFVSE5BQ0VRRFBJQ0N5QUFMUUFwUVNKR0RZVURES1lDQ3dKQUlBRWlBU0FDUncwQVFkc0FJUkFNaWdNTFFRQWhGRUVCSVJkQkFTRVdRUUFoRUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRVkJxRGdyVUFkTUJBQUVDQXdRRkJnalZBUXRCQWlFUURBWUxRUU1oRUF3RkMwRUVJUkFNQkF0QkJTRVFEQU1MUVFZaEVBd0NDMEVISVJBTUFRdEJDQ0VRQzBFQUlSZEJBQ0VXUVFBaEZBek1BUXRCQ1NFUVFRRWhGRUVBSVJkQkFDRVdETXNCQ3dKQUlBRWlBU0FDUncwQVFkMEFJUkFNaVFNTElBRXRBQUJCTGtjTnpBRWdBVUVCYWlFQkRLWUNDeUFCSWdFZ0FrY056QUZCM3dBaEVBeUhBd3NDUUNBQklnRWdBa1lOQUNBQVFZNkFnSUFBTmdJSUlBQWdBVFlDQkNBQklRRkIwQUFoRUF6dUFndEI0QUFoRUF5R0F3dEI0UUFoRUNBQklnRWdBa1lOaFFNZ0FpQUJheUFBS0FJQUloUnFJUllnQVNBVWEwRURhaUVYQTBBZ0FTMEFBQ0FVUWVMQ2dJQUFhaTBBQUVjTnpRRWdGRUVEUmczTUFTQVVRUUZxSVJRZ0FVRUJhaUlCSUFKSERRQUxJQUFnRmpZQ0FBeUZBd3RCNGdBaEVDQUJJZ0VnQWtZTmhBTWdBaUFCYXlBQUtBSUFJaFJxSVJZZ0FTQVVhMEVDYWlFWEEwQWdBUzBBQUNBVVFlYkNnSUFBYWkwQUFFY056QUVnRkVFQ1JnM09BU0FVUVFGcUlSUWdBVUVCYWlJQklBSkhEUUFMSUFBZ0ZqWUNBQXlFQXd0QjR3QWhFQ0FCSWdFZ0FrWU5nd01nQWlBQmF5QUFLQUlBSWhScUlSWWdBU0FVYTBFRGFpRVhBMEFnQVMwQUFDQVVRZW5DZ0lBQWFpMEFBRWNOeXdFZ0ZFRURSZzNPQVNBVVFRRnFJUlFnQVVFQmFpSUJJQUpIRFFBTElBQWdGallDQUF5REF3c0NRQ0FCSWdFZ0FrY05BRUhsQUNFUURJTURDeUFBSUFGQkFXb2lBU0FDRUtpQWdJQUFJaEFOelFFZ0FTRUJRZFlBSVJBTTZRSUxBa0FnQVNJQklBSkdEUUFEUUFKQUlBRXRBQUFpRUVFZ1JnMEFBa0FDUUFKQUlCQkJ1SDlxRGdzQUFjOEJ6d0hQQWM4Qnp3SFBBYzhCendFQ3p3RUxJQUZCQVdvaEFVSFNBQ0VRRE8wQ0N5QUJRUUZxSVFGQjB3QWhFQXpzQWdzZ0FVRUJhaUVCUWRRQUlSQU02d0lMSUFGQkFXb2lBU0FDUncwQUMwSGtBQ0VRRElJREMwSGtBQ0VRRElFREN3TkFBa0FnQVMwQUFFSHd3b0NBQUdvdEFBQWlFRUVCUmcwQUlCQkJmbW9PQTg4QjBBSFJBZElCQ3lBQlFRRnFJZ0VnQWtjTkFBdEI1Z0FoRUF5QUF3c0NRQ0FCSWdFZ0FrWU5BQ0FCUVFGcUlRRU1Bd3RCNXdBaEVBei9BZ3NEUUFKQUlBRXRBQUJCOE1TQWdBQnFMUUFBSWhCQkFVWU5BQUpBSUJCQmZtb09CTklCMHdIVUFRRFZBUXNnQVNFQlFkY0FJUkFNNXdJTElBRkJBV29pQVNBQ1J3MEFDMEhvQUNFUURQNENDd0pBSUFFaUFTQUNSdzBBUWVrQUlSQU0vZ0lMQWtBZ0FTMEFBQ0lRUVhacURocTZBZFVCMVFHOEFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFjb0IxUUhWQVFEVEFRc2dBVUVCYWlFQkMwRUdJUkFNNHdJTEEwQUNRQ0FCTFFBQVFmREdnSUFBYWkwQUFFRUJSZzBBSUFFaEFReWVBZ3NnQVVFQmFpSUJJQUpIRFFBTFFlb0FJUkFNK3dJTEFrQWdBU0lCSUFKR0RRQWdBVUVCYWlFQkRBTUxRZXNBSVJBTStnSUxBa0FnQVNJQklBSkhEUUJCN0FBaEVBejZBZ3NnQVVFQmFpRUJEQUVMQWtBZ0FTSUJJQUpIRFFCQjdRQWhFQXo1QWdzZ0FVRUJhaUVCQzBFRUlSQU0zZ0lMQWtBZ0FTSVVJQUpIRFFCQjdnQWhFQXozQWdzZ0ZDRUJBa0FDUUFKQUlCUXRBQUJCOE1pQWdBQnFMUUFBUVg5cURnZlVBZFVCMWdFQW5BSUJBdGNCQ3lBVVFRRnFJUUVNQ2dzZ0ZFRUJhaUVCRE0wQkMwRUFJUkFnQUVFQU5nSWNJQUJCbTVLQWdBQTJBaEFnQUVFSE5nSU1JQUFnRkVFQmFqWUNGQXoyQWdzQ1FBTkFBa0FnQVMwQUFFSHd5SUNBQUdvdEFBQWlFRUVFUmcwQUFrQUNRQ0FRUVg5cURnZlNBZE1CMUFIWkFRQUVBZGtCQ3lBQklRRkIyZ0FoRUF6Z0Fnc2dBVUVCYWlFQlFkd0FJUkFNM3dJTElBRkJBV29pQVNBQ1J3MEFDMEh2QUNFUURQWUNDeUFCUVFGcUlRRU15d0VMQWtBZ0FTSVVJQUpIRFFCQjhBQWhFQXoxQWdzZ0ZDMEFBRUV2UnczVUFTQVVRUUZxSVFFTUJnc0NRQ0FCSWhRZ0FrY05BRUh4QUNFUURQUUNDd0pBSUJRdEFBQWlBVUV2UncwQUlCUkJBV29oQVVIZEFDRVFETnNDQ3lBQlFYWnFJZ1JCRmtzTjB3RkJBU0FFZEVHSmdJQUNjVVVOMHdFTXlnSUxBa0FnQVNJQklBSkdEUUFnQVVFQmFpRUJRZDRBSVJBTTJnSUxRZklBSVJBTThnSUxBa0FnQVNJVUlBSkhEUUJCOUFBaEVBenlBZ3NnRkNFQkFrQWdGQzBBQUVId3pJQ0FBR290QUFCQmYyb09BOGtDbEFJQTFBRUxRZUVBSVJBTTJBSUxBa0FnQVNJVUlBSkdEUUFEUUFKQUlCUXRBQUJCOE1xQWdBQnFMUUFBSWdGQkEwWU5BQUpBSUFGQmYyb09Bc3NDQU5VQkN5QVVJUUZCM3dBaEVBemFBZ3NnRkVFQmFpSVVJQUpIRFFBTFFmTUFJUkFNOFFJTFFmTUFJUkFNOEFJTEFrQWdBU0lCSUFKR0RRQWdBRUdQZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBU0VCUWVBQUlSQU0xd0lMUWZVQUlSQU03d0lMQWtBZ0FTSUJJQUpIRFFCQjlnQWhFQXp2QWdzZ0FFR1BnSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJDMEVESVJBTTFBSUxBMEFnQVMwQUFFRWdSdzNEQWlBQlFRRnFJZ0VnQWtjTkFBdEI5d0FoRUF6c0Fnc0NRQ0FCSWdFZ0FrY05BRUg0QUNFUURPd0NDeUFCTFFBQVFTQkhEYzRCSUFGQkFXb2hBUXp2QVFzZ0FDQUJJZ0VnQWhDc2dJQ0FBQ0lRRGM0QklBRWhBUXlPQWdzQ1FDQUJJZ1FnQWtjTkFFSDZBQ0VRRE9vQ0N5QUVMUUFBUWN3QVJ3M1JBU0FFUVFGcUlRRkJFeUVRRE04QkN3SkFJQUVpQkNBQ1J3MEFRZnNBSVJBTTZRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQldvaEVBTkFJQVF0QUFBZ0FVSHd6b0NBQUdvdEFBQkhEZEFCSUFGQkJVWU56Z0VnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCK3dBaEVBem9BZ3NDUUNBQklnUWdBa2NOQUVIOEFDRVFET2dDQ3dKQUFrQWdCQzBBQUVHOWYyb09EQURSQWRFQjBRSFJBZEVCMFFIUkFkRUIwUUhSQVFIUkFRc2dCRUVCYWlFQlFlWUFJUkFNendJTElBUkJBV29oQVVIbkFDRVFETTRDQ3dKQUlBRWlCQ0FDUncwQVFmMEFJUkFNNXdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBbW9oRUFKQUEwQWdCQzBBQUNBQlFlM1BnSUFBYWkwQUFFY056d0VnQVVFQ1JnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZjBBSVJBTTV3SUxJQUJCQURZQ0FDQVFRUUZxSVFGQkVDRVFETXdCQ3dKQUlBRWlCQ0FDUncwQVFmNEFJUkFNNWdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJCV29oRUFKQUEwQWdCQzBBQUNBQlFmYk9nSUFBYWkwQUFFY056Z0VnQVVFRlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZjRBSVJBTTVnSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkZpRVFETXNCQ3dKQUlBRWlCQ0FDUncwQVFmOEFJUkFNNVFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBMm9oRUFKQUEwQWdCQzBBQUNBQlFmek9nSUFBYWkwQUFFY056UUVnQVVFRFJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZjhBSVJBTTVRSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkJTRVFETW9CQ3dKQUlBRWlCQ0FDUncwQVFZQUJJUkFNNUFJTElBUXRBQUJCMlFCSERjc0JJQVJCQVdvaEFVRUlJUkFNeVFFTEFrQWdBU0lFSUFKSERRQkJnUUVoRUF6akFnc0NRQUpBSUFRdEFBQkJzbjlxRGdNQXpBRUJ6QUVMSUFSQkFXb2hBVUhyQUNFUURNb0NDeUFFUVFGcUlRRkI3QUFoRUF6SkFnc0NRQ0FCSWdRZ0FrY05BRUdDQVNFUURPSUNDd0pBQWtBZ0JDMEFBRUc0ZjJvT0NBRExBY3NCeXdITEFjc0J5d0VCeXdFTElBUkJBV29oQVVIcUFDRVFETWtDQ3lBRVFRRnFJUUZCN1FBaEVBeklBZ3NDUUNBQklnUWdBa2NOQUVHREFTRVFET0VDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hFQ0FFSUFGclFRSnFJUlFDUUFOQUlBUXRBQUFnQVVHQXo0Q0FBR290QUFCSERja0JJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRURZQ0FFR0RBU0VRRE9FQ0MwRUFJUkFnQUVFQU5nSUFJQlJCQVdvaEFRekdBUXNDUUNBQklnUWdBa2NOQUVHRUFTRVFET0FDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRUnFJUkFDUUFOQUlBUXRBQUFnQVVHRHo0Q0FBR290QUFCSERjZ0JJQUZCQkVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR0VBU0VRRE9BQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVNNaEVBekZBUXNDUUNBQklnUWdBa2NOQUVHRkFTRVFETjhDQ3dKQUFrQWdCQzBBQUVHMGYyb09DQURJQWNnQnlBSElBY2dCeUFFQnlBRUxJQVJCQVdvaEFVSHZBQ0VRRE1ZQ0N5QUVRUUZxSVFGQjhBQWhFQXpGQWdzQ1FDQUJJZ1FnQWtjTkFFR0dBU0VRRE40Q0N5QUVMUUFBUWNVQVJ3M0ZBU0FFUVFGcUlRRU1nd0lMQWtBZ0FTSUVJQUpIRFFCQmh3RWhFQXpkQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRURhaUVRQWtBRFFDQUVMUUFBSUFGQmlNK0FnQUJxTFFBQVJ3M0ZBU0FCUVFOR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJod0VoRUF6ZEFnc2dBRUVBTmdJQUlCQkJBV29oQVVFdElSQU13Z0VMQWtBZ0FTSUVJQUpIRFFCQmlBRWhFQXpjQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUlhaUVRQWtBRFFDQUVMUUFBSUFGQjBNK0FnQUJxTFFBQVJ3M0VBU0FCUVFoR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJpQUVoRUF6Y0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFcElSQU13UUVMQWtBZ0FTSUJJQUpIRFFCQmlRRWhFQXpiQWd0QkFTRVFJQUV0QUFCQjN3QkhEY0FCSUFGQkFXb2hBUXlCQWdzQ1FDQUJJZ1FnQWtjTkFFR0tBU0VRRE5vQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUZxSVJBRFFDQUVMUUFBSUFGQmpNK0FnQUJxTFFBQVJ3M0JBU0FCUVFGR0RhOENJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWW9CSVJBTTJRSUxBa0FnQVNJRUlBSkhEUUJCaXdFaEVBelpBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQ2FpRVFBa0FEUUNBRUxRQUFJQUZCanMrQWdBQnFMUUFBUnczQkFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQml3RWhFQXpaQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVDSVJBTXZnRUxBa0FnQVNJRUlBSkhEUUJCakFFaEVBellBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCOE0rQWdBQnFMUUFBUnczQUFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQmpBRWhFQXpZQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVmSVJBTXZRRUxBa0FnQVNJRUlBSkhEUUJCalFFaEVBelhBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCOHMrQWdBQnFMUUFBUncyL0FTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQmpRRWhFQXpYQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVKSVJBTXZBRUxBa0FnQVNJRUlBSkhEUUJCamdFaEVBeldBZ3NDUUFKQUlBUXRBQUJCdDM5cURnY0F2d0cvQWI4QnZ3Ry9BUUcvQVFzZ0JFRUJhaUVCUWZnQUlSQU12UUlMSUFSQkFXb2hBVUg1QUNFUURMd0NDd0pBSUFFaUJDQUNSdzBBUVk4QklSQU0xUUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQUpBQTBBZ0JDMEFBQ0FCUVpIUGdJQUFhaTBBQUVjTnZRRWdBVUVGUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZOEJJUkFNMVFJTElBQkJBRFlDQUNBUVFRRnFJUUZCR0NFUURMb0JDd0pBSUFFaUJDQUNSdzBBUVpBQklSQU0xQUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUVpmUGdJQUFhaTBBQUVjTnZBRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaQUJJUkFNMUFJTElBQkJBRFlDQUNBUVFRRnFJUUZCRnlFUURMa0JDd0pBSUFFaUJDQUNSdzBBUVpFQklSQU0wd0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJtb2hFQUpBQTBBZ0JDMEFBQ0FCUVpyUGdJQUFhaTBBQUVjTnV3RWdBVUVHUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaRUJJUkFNMHdJTElBQkJBRFlDQUNBUVFRRnFJUUZCRlNFUURMZ0JDd0pBSUFFaUJDQUNSdzBBUVpJQklSQU0wZ0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQUpBQTBBZ0JDMEFBQ0FCUWFIUGdJQUFhaTBBQUVjTnVnRWdBVUVGUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaSUJJUkFNMGdJTElBQkJBRFlDQUNBUVFRRnFJUUZCSGlFUURMY0JDd0pBSUFFaUJDQUNSdzBBUVpNQklSQU0wUUlMSUFRdEFBQkJ6QUJIRGJnQklBUkJBV29oQVVFS0lSQU10Z0VMQWtBZ0JDQUNSdzBBUVpRQklSQU0wQUlMQWtBQ1FDQUVMUUFBUWI5L2FnNFBBTGtCdVFHNUFia0J1UUc1QWJrQnVRRzVBYmtCdVFHNUFia0JBYmtCQ3lBRVFRRnFJUUZCL2dBaEVBeTNBZ3NnQkVFQmFpRUJRZjhBSVJBTXRnSUxBa0FnQkNBQ1J3MEFRWlVCSVJBTXp3SUxBa0FDUUNBRUxRQUFRYjkvYWc0REFMZ0JBYmdCQ3lBRVFRRnFJUUZCL1FBaEVBeTJBZ3NnQkVFQmFpRUVRWUFCSVJBTXRRSUxBa0FnQkNBQ1J3MEFRWllCSVJBTXpnSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRYWZQZ0lBQWFpMEFBRWNOdGdFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVpZQklSQU16Z0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJDeUVRRExNQkN3SkFJQVFnQWtjTkFFR1hBU0VRRE0wQ0N3SkFBa0FDUUFKQUlBUXRBQUJCVTJvT0l3QzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0JBYmdCdUFHNEFiZ0J1QUVDdUFHNEFiZ0JBN2dCQ3lBRVFRRnFJUUZCK3dBaEVBeTJBZ3NnQkVFQmFpRUJRZndBSVJBTXRRSUxJQVJCQVdvaEJFR0JBU0VRRExRQ0N5QUVRUUZxSVFSQmdnRWhFQXl6QWdzQ1FDQUVJQUpIRFFCQm1BRWhFQXpNQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUVhaUVRQWtBRFFDQUVMUUFBSUFGQnFjK0FnQUJxTFFBQVJ3MjBBU0FCUVFSR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJtQUVoRUF6TUFnc2dBRUVBTmdJQUlCQkJBV29oQVVFWklSQU1zUUVMQWtBZ0JDQUNSdzBBUVprQklSQU15d0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQUpBQTBBZ0JDMEFBQ0FCUWE3UGdJQUFhaTBBQUVjTnN3RWdBVUVGUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaa0JJUkFNeXdJTElBQkJBRFlDQUNBUVFRRnFJUUZCQmlFUURMQUJDd0pBSUFRZ0FrY05BRUdhQVNFUURNb0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFGcUlSQUNRQU5BSUFRdEFBQWdBVUcwejRDQUFHb3RBQUJIRGJJQklBRkJBVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHYUFTRVFETW9DQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUndoRUF5dkFRc0NRQ0FFSUFKSERRQkJtd0VoRUF6SkFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVCYWlFUUFrQURRQ0FFTFFBQUlBRkJ0cytBZ0FCcUxRQUFSdzJ4QVNBQlFRRkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCbXdFaEVBekpBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRW5JUkFNcmdFTEFrQWdCQ0FDUncwQVFad0JJUkFNeUFJTEFrQUNRQ0FFTFFBQVFheC9hZzRDQUFHeEFRc2dCRUVCYWlFRVFZWUJJUkFNcndJTElBUkJBV29oQkVHSEFTRVFESzRDQ3dKQUlBUWdBa2NOQUVHZEFTRVFETWNDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRRnFJUkFDUUFOQUlBUXRBQUFnQVVHNHo0Q0FBR290QUFCSERhOEJJQUZCQVVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR2RBU0VRRE1jQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVNZaEVBeXNBUXNDUUNBRUlBSkhEUUJCbmdFaEVBekdBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCdXMrQWdBQnFMUUFBUncydUFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQm5nRWhFQXpHQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVESVJBTXF3RUxBa0FnQkNBQ1J3MEFRWjhCSVJBTXhRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQW1vaEVBSkFBMEFnQkMwQUFDQUJRZTNQZ0lBQWFpMEFBRWNOclFFZ0FVRUNSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVo4QklSQU14UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJEQ0VRREtvQkN3SkFJQVFnQWtjTkFFR2dBU0VRRE1RQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUU5xSVJBQ1FBTkFJQVF0QUFBZ0FVRzh6NENBQUdvdEFBQkhEYXdCSUFGQkEwWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdnQVNFUURNUUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFRMGhFQXlwQVFzQ1FDQUVJQUpIRFFCQm9RRWhFQXpEQWdzQ1FBSkFJQVF0QUFCQnVuOXFEZ3NBckFHc0Fhd0JyQUdzQWF3QnJBR3NBYXdCQWF3QkN5QUVRUUZxSVFSQml3RWhFQXlxQWdzZ0JFRUJhaUVFUVl3QklSQU1xUUlMQWtBZ0JDQUNSdzBBUWFJQklSQU13Z0lMSUFRdEFBQkIwQUJIRGFrQklBUkJBV29oQkF6cEFRc0NRQ0FFSUFKSERRQkJvd0VoRUF6QkFnc0NRQUpBSUFRdEFBQkJ0MzlxRGdjQnFnR3FBYW9CcWdHcUFRQ3FBUXNnQkVFQmFpRUVRWTRCSVJBTXFBSUxJQVJCQVdvaEFVRWlJUkFNcGdFTEFrQWdCQ0FDUncwQVFhUUJJUkFNd0FJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBV29oRUFKQUEwQWdCQzBBQUNBQlFjRFBnSUFBYWkwQUFFY05xQUVnQVVFQlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYVFCSVJBTXdBSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkhTRVFES1VCQ3dKQUlBUWdBa2NOQUVHbEFTRVFETDhDQ3dKQUFrQWdCQzBBQUVHdWYyb09Bd0NvQVFHb0FRc2dCRUVCYWlFRVFaQUJJUkFNcGdJTElBUkJBV29oQVVFRUlSQU1wQUVMQWtBZ0JDQUNSdzBBUWFZQklSQU12Z0lMQWtBQ1FBSkFBa0FDUUNBRUxRQUFRYjkvYWc0VkFLb0JxZ0dxQWFvQnFnR3FBYW9CcWdHcUFhb0JBYW9CcWdFQ3FnR3FBUU9xQWFvQkJLb0JDeUFFUVFGcUlRUkJpQUVoRUF5b0Fnc2dCRUVCYWlFRVFZa0JJUkFNcHdJTElBUkJBV29oQkVHS0FTRVFES1lDQ3lBRVFRRnFJUVJCandFaEVBeWxBZ3NnQkVFQmFpRUVRWkVCSVJBTXBBSUxBa0FnQkNBQ1J3MEFRYWNCSVJBTXZRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQW1vaEVBSkFBMEFnQkMwQUFDQUJRZTNQZ0lBQWFpMEFBRWNOcFFFZ0FVRUNSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWFjQklSQU12UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJFU0VRREtJQkN3SkFJQVFnQWtjTkFFR29BU0VRREx3Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSEN6NENBQUdvdEFBQkhEYVFCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdvQVNFUURMd0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFTd2hFQXloQVFzQ1FDQUVJQUpIRFFCQnFRRWhFQXk3QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUVhaUVRQWtBRFFDQUVMUUFBSUFGQnhjK0FnQUJxTFFBQVJ3MmpBU0FCUVFSR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJxUUVoRUF5N0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFcklSQU1vQUVMQWtBZ0JDQUNSdzBBUWFvQklSQU11Z0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUWNyUGdJQUFhaTBBQUVjTm9nRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFhb0JJUkFNdWdJTElBQkJBRFlDQUNBUVFRRnFJUUZCRkNFUURKOEJDd0pBSUFRZ0FrY05BRUdyQVNFUURMa0NDd0pBQWtBQ1FBSkFJQVF0QUFCQnZuOXFEZzhBQVFLa0FhUUJwQUdrQWFRQnBBR2tBYVFCcEFHa0FhUUJBNlFCQ3lBRVFRRnFJUVJCa3dFaEVBeWlBZ3NnQkVFQmFpRUVRWlFCSVJBTW9RSUxJQVJCQVdvaEJFR1ZBU0VRREtBQ0N5QUVRUUZxSVFSQmxnRWhFQXlmQWdzQ1FDQUVJQUpIRFFCQnJBRWhFQXk0QWdzZ0JDMEFBRUhGQUVjTm53RWdCRUVCYWlFRURPQUJDd0pBSUFRZ0FrY05BRUd0QVNFUURMY0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUhOejRDQUFHb3RBQUJIRFo4QklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHdEFTRVFETGNDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUTRoRUF5Y0FRc0NRQ0FFSUFKSERRQkJyZ0VoRUF5MkFnc2dCQzBBQUVIUUFFY05uUUVnQkVFQmFpRUJRU1VoRUF5YkFRc0NRQ0FFSUFKSERRQkJyd0VoRUF5MUFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVJYWlFUUFrQURRQ0FFTFFBQUlBRkIwTStBZ0FCcUxRQUFSdzJkQVNBQlFRaEdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCcndFaEVBeTFBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRXFJUkFNbWdFTEFrQWdCQ0FDUncwQVFiQUJJUkFNdEFJTEFrQUNRQ0FFTFFBQVFhdC9hZzRMQUowQm5RR2RBWjBCblFHZEFaMEJuUUdkQVFHZEFRc2dCRUVCYWlFRVFab0JJUkFNbXdJTElBUkJBV29oQkVHYkFTRVFESm9DQ3dKQUlBUWdBa2NOQUVHeEFTRVFETE1DQ3dKQUFrQWdCQzBBQUVHL2Yyb09GQUNjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUdjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUVCbkFFTElBUkJBV29oQkVHWkFTRVFESm9DQ3lBRVFRRnFJUVJCbkFFaEVBeVpBZ3NDUUNBRUlBSkhEUUJCc2dFaEVBeXlBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFRGFpRVFBa0FEUUNBRUxRQUFJQUZCMmMrQWdBQnFMUUFBUncyYUFTQUJRUU5HRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQnNnRWhFQXl5QWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVoSVJBTWx3RUxBa0FnQkNBQ1J3MEFRYk1CSVJBTXNRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQm1vaEVBSkFBMEFnQkMwQUFDQUJRZDNQZ0lBQWFpMEFBRWNObVFFZ0FVRUdSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWJNQklSQU1zUUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJHaUVRREpZQkN3SkFJQVFnQWtjTkFFRzBBU0VRRExBQ0N3SkFBa0FDUUNBRUxRQUFRYnQvYWc0UkFKb0JtZ0dhQVpvQm1nR2FBWm9CbWdHYUFRR2FBWm9CbWdHYUFab0JBcG9CQ3lBRVFRRnFJUVJCblFFaEVBeVlBZ3NnQkVFQmFpRUVRWjRCSVJBTWx3SUxJQVJCQVdvaEJFR2ZBU0VRREpZQ0N3SkFJQVFnQWtjTkFFRzFBU0VRREs4Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVZxSVJBQ1FBTkFJQVF0QUFBZ0FVSGt6NENBQUdvdEFBQkhEWmNCSUFGQkJVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUcxQVNFUURLOENDeUFBUVFBMkFnQWdFRUVCYWlFQlFTZ2hFQXlVQVFzQ1FDQUVJQUpIRFFCQnRnRWhFQXl1QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUNhaUVRQWtBRFFDQUVMUUFBSUFGQjZzK0FnQUJxTFFBQVJ3MldBU0FCUVFKR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJ0Z0VoRUF5dUFnc2dBRUVBTmdJQUlCQkJBV29oQVVFSElSQU1rd0VMQWtBZ0JDQUNSdzBBUWJjQklSQU1yUUlMQWtBQ1FDQUVMUUFBUWJ0L2FnNE9BSllCbGdHV0FaWUJsZ0dXQVpZQmxnR1dBWllCbGdHV0FRR1dBUXNnQkVFQmFpRUVRYUVCSVJBTWxBSUxJQVJCQVdvaEJFR2lBU0VRREpNQ0N3SkFJQVFnQWtjTkFFRzRBU0VRREt3Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSHR6NENBQUdvdEFBQkhEWlFCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUc0QVNFUURLd0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFSSWhFQXlSQVFzQ1FDQUVJQUpIRFFCQnVRRWhFQXlyQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUJhaUVRQWtBRFFDQUVMUUFBSUFGQjhNK0FnQUJxTFFBQVJ3MlRBU0FCUVFGR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJ1UUVoRUF5ckFnc2dBRUVBTmdJQUlCQkJBV29oQVVFZ0lSQU1rQUVMQWtBZ0JDQUNSdzBBUWJvQklSQU1xZ0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWZMUGdJQUFhaTBBQUVjTmtnRWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFib0JJUkFNcWdJTElBQkJBRFlDQUNBUVFRRnFJUUZCRHlFUURJOEJDd0pBSUFRZ0FrY05BRUc3QVNFUURLa0NDd0pBQWtBZ0JDMEFBRUczZjJvT0J3Q1NBWklCa2dHU0FaSUJBWklCQ3lBRVFRRnFJUVJCcFFFaEVBeVFBZ3NnQkVFQmFpRUVRYVlCSVJBTWp3SUxBa0FnQkNBQ1J3MEFRYndCSVJBTXFBSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQjJvaEVBSkFBMEFnQkMwQUFDQUJRZlRQZ0lBQWFpMEFBRWNOa0FFZ0FVRUhSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWJ3QklSQU1xQUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJHeUVRREkwQkN3SkFJQVFnQWtjTkFFRzlBU0VRREtjQ0N3SkFBa0FDUUNBRUxRQUFRYjUvYWc0U0FKRUJrUUdSQVpFQmtRR1JBWkVCa1FHUkFRR1JBWkVCa1FHUkFaRUJrUUVDa1FFTElBUkJBV29oQkVHa0FTRVFESThDQ3lBRVFRRnFJUVJCcHdFaEVBeU9BZ3NnQkVFQmFpRUVRYWdCSVJBTWpRSUxBa0FnQkNBQ1J3MEFRYjRCSVJBTXBnSUxJQVF0QUFCQnpnQkhEWTBCSUFSQkFXb2hCQXpQQVFzQ1FDQUVJQUpIRFFCQnZ3RWhFQXlsQWdzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FFTFFBQVFiOS9hZzRWQUFFQ0E1d0JCQVVHbkFHY0Fad0JCd2dKQ2d1Y0FRd05EZytjQVFzZ0JFRUJhaUVCUWVnQUlSQU1tZ0lMSUFSQkFXb2hBVUhwQUNFUURKa0NDeUFFUVFGcUlRRkI3Z0FoRUF5WUFnc2dCRUVCYWlFQlFmSUFJUkFNbHdJTElBUkJBV29oQVVIekFDRVFESllDQ3lBRVFRRnFJUUZCOWdBaEVBeVZBZ3NnQkVFQmFpRUJRZmNBSVJBTWxBSUxJQVJCQVdvaEFVSDZBQ0VRREpNQ0N5QUVRUUZxSVFSQmd3RWhFQXlTQWdzZ0JFRUJhaUVFUVlRQklSQU1rUUlMSUFSQkFXb2hCRUdGQVNFUURKQUNDeUFFUVFGcUlRUkJrZ0VoRUF5UEFnc2dCRUVCYWlFRVFaZ0JJUkFNamdJTElBUkJBV29oQkVHZ0FTRVFESTBDQ3lBRVFRRnFJUVJCb3dFaEVBeU1BZ3NnQkVFQmFpRUVRYW9CSVJBTWl3SUxBa0FnQkNBQ1JnMEFJQUJCa0lDQWdBQTJBZ2dnQUNBRU5nSUVRYXNCSVJBTWl3SUxRY0FCSVJBTW93SUxJQUFnQlNBQ0VLcUFnSUFBSWdFTml3RWdCU0VCREZ3TEFrQWdCaUFDUmcwQUlBWkJBV29oQlF5TkFRdEJ3Z0VoRUF5aEFnc0RRQUpBSUJBdEFBQkJkbW9PQkl3QkFBQ1BBUUFMSUJCQkFXb2lFQ0FDUncwQUMwSERBU0VRREtBQ0N3SkFJQWNnQWtZTkFDQUFRWkdBZ0lBQU5nSUlJQUFnQnpZQ0JDQUhJUUZCQVNFUURJY0NDMEhFQVNFUURKOENDd0pBSUFjZ0FrY05BRUhGQVNFUURKOENDd0pBQWtBZ0J5MEFBRUYyYWc0RUFjNEJ6Z0VBemdFTElBZEJBV29oQmd5TkFRc2dCMEVCYWlFRkRJa0JDd0pBSUFjZ0FrY05BRUhHQVNFUURKNENDd0pBQWtBZ0J5MEFBRUYyYWc0WEFZOEJqd0VCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCQUk4QkN5QUhRUUZxSVFjTFFiQUJJUkFNaEFJTEFrQWdDQ0FDUncwQVFjZ0JJUkFNblFJTElBZ3RBQUJCSUVjTmpRRWdBRUVBT3dFeUlBaEJBV29oQVVHekFTRVFESU1DQ3lBQklSY0NRQU5BSUJjaUJ5QUNSZzBCSUFjdEFBQkJVR3BCL3dGeEloQkJDazhOekFFQ1FDQUFMd0V5SWhSQm1UTkxEUUFnQUNBVVFRcHNJaFE3QVRJZ0VFSC8vd056SUJSQi92OERjVWtOQUNBSFFRRnFJUmNnQUNBVUlCQnFJaEE3QVRJZ0VFSC8vd054UWVnSFNRMEJDd3RCQUNFUUlBQkJBRFlDSENBQVFjR0pnSUFBTmdJUUlBQkJEVFlDRENBQUlBZEJBV28yQWhRTW5BSUxRY2NCSVJBTW13SUxJQUFnQ0NBQ0VLNkFnSUFBSWhCRkRjb0JJQkJCRlVjTmpBRWdBRUhJQVRZQ0hDQUFJQWcyQWhRZ0FFSEpsNENBQURZQ0VDQUFRUlUyQWd4QkFDRVFESm9DQ3dKQUlBa2dBa2NOQUVITUFTRVFESm9DQzBFQUlSUkJBU0VYUVFFaEZrRUFJUkFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQ1MwQUFFRlFhZzRLbGdHVkFRQUJBZ01FQlFZSWx3RUxRUUloRUF3R0MwRURJUkFNQlF0QkJDRVFEQVFMUVFVaEVBd0RDMEVHSVJBTUFndEJCeUVRREFFTFFRZ2hFQXRCQUNFWFFRQWhGa0VBSVJRTWpnRUxRUWtoRUVFQklSUkJBQ0VYUVFBaEZneU5BUXNDUUNBS0lBSkhEUUJCemdFaEVBeVpBZ3NnQ2kwQUFFRXVSdzJPQVNBS1FRRnFJUWtNeWdFTElBc2dBa2NOamdGQjBBRWhFQXlYQWdzQ1FDQUxJQUpHRFFBZ0FFR09nSUNBQURZQ0NDQUFJQXMyQWdSQnR3RWhFQXorQVF0QjBRRWhFQXlXQWdzQ1FDQUVJQUpIRFFCQjBnRWhFQXlXQWdzZ0FpQUVheUFBS0FJQUloQnFJUlFnQkNBUWEwRUVhaUVMQTBBZ0JDMEFBQ0FRUWZ6UGdJQUFhaTBBQUVjTmpnRWdFRUVFUmczcEFTQVFRUUZxSVJBZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSFNBU0VRREpVQ0N5QUFJQXdnQWhDc2dJQ0FBQ0lCRFkwQklBd2hBUXk0QVFzQ1FDQUVJQUpIRFFCQjFBRWhFQXlVQWdzZ0FpQUVheUFBS0FJQUloQnFJUlFnQkNBUWEwRUJhaUVNQTBBZ0JDMEFBQ0FRUVlIUWdJQUFhaTBBQUVjTmp3RWdFRUVCUmcyT0FTQVFRUUZxSVJBZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSFVBU0VRREpNQ0N3SkFJQVFnQWtjTkFFSFdBU0VRREpNQ0N5QUNJQVJySUFBb0FnQWlFR29oRkNBRUlCQnJRUUpxSVFzRFFDQUVMUUFBSUJCQmc5Q0FnQUJxTFFBQVJ3Mk9BU0FRUVFKR0RaQUJJQkJCQVdvaEVDQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZFlCSVJBTWtnSUxBa0FnQkNBQ1J3MEFRZGNCSVJBTWtnSUxBa0FDUUNBRUxRQUFRYnQvYWc0UUFJOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3RUJqd0VMSUFSQkFXb2hCRUc3QVNFUURQa0JDeUFFUVFGcUlRUkJ2QUVoRUF6NEFRc0NRQ0FFSUFKSERRQkIyQUVoRUF5UkFnc2dCQzBBQUVISUFFY05qQUVnQkVFQmFpRUVETVFCQ3dKQUlBUWdBa1lOQUNBQVFaQ0FnSUFBTmdJSUlBQWdCRFlDQkVHK0FTRVFEUGNCQzBIWkFTRVFESThDQ3dKQUlBUWdBa2NOQUVIYUFTRVFESThDQ3lBRUxRQUFRY2dBUmczREFTQUFRUUU2QUNnTXVRRUxJQUJCQWpvQUx5QUFJQVFnQWhDbWdJQ0FBQ0lRRFkwQlFjSUJJUkFNOUFFTElBQXRBQ2hCZjJvT0FyY0J1UUc0QVFzRFFBSkFJQVF0QUFCQmRtb09CQUNPQVk0QkFJNEJDeUFFUVFGcUlnUWdBa2NOQUF0QjNRRWhFQXlMQWdzZ0FFRUFPZ0F2SUFBdEFDMUJCSEZGRFlRQ0N5QUFRUUE2QUM4Z0FFRUJPZ0EwSUFFaEFReU1BUXNnRUVFVlJnM2FBU0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJwNDZBZ0FBMkFoQWdBRUVTTmdJTVFRQWhFQXlJQWdzQ1FDQUFJQkFnQWhDMGdJQ0FBQ0lFRFFBZ0VDRUJESUVDQ3dKQUlBUkJGVWNOQUNBQVFRTTJBaHdnQUNBUU5nSVVJQUJCc0ppQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF5SUFnc2dBRUVBTmdJY0lBQWdFRFlDRkNBQVFhZU9nSUFBTmdJUUlBQkJFallDREVFQUlSQU1od0lMSUJCQkZVWU4xZ0VnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZHFOZ0lBQU5nSVFJQUJCRkRZQ0RFRUFJUkFNaGdJTElBQW9BZ1FoRnlBQVFRQTJBZ1FnRUNBUnAyb2lGaUVCSUFBZ0Z5QVFJQllnRkJzaUVCQzFnSUNBQUNJVVJRMk5BU0FBUVFjMkFod2dBQ0FRTmdJVUlBQWdGRFlDREVFQUlSQU1oUUlMSUFBZ0FDOEJNRUdBQVhJN0FUQWdBU0VCQzBFcUlSQU02Z0VMSUJCQkZVWU4wUUVnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWU9NZ0lBQU5nSVFJQUJCRXpZQ0RFRUFJUkFNZ2dJTElCQkJGVVlOendFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVpxUGdJQUFOZ0lRSUFCQklqWUNERUVBSVJBTWdRSUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDM2dJQ0FBQ0lRRFFBZ0FVRUJhaUVCREkwQkN5QUFRUXcyQWh3Z0FDQVFOZ0lNSUFBZ0FVRUJhallDRkVFQUlSQU1nQUlMSUJCQkZVWU56QUVnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWnFQZ0lBQU5nSVFJQUJCSWpZQ0RFRUFJUkFNL3dFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkMzZ0lDQUFDSVFEUUFnQVVFQmFpRUJESXdCQ3lBQVFRMDJBaHdnQUNBUU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTS9nRUxJQkJCRlVZTnlRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFjYU1nSUFBTmdJUUlBQkJJellDREVFQUlSQU0vUUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzVnSUNBQUNJUURRQWdBVUVCYWlFQkRJc0JDeUFBUVE0MkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNL0FFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVIQWxZQ0FBRFlDRUNBQVFRSTJBZ3hCQUNFUURQc0JDeUFRUVJWR0RjVUJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEdqSUNBQURZQ0VDQUFRU00yQWd4QkFDRVFEUG9CQ3lBQVFSQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNK1FFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkM1Z0lDQUFDSUVEUUFnQVVFQmFpRUJEUEVCQ3lBQVFSRTJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTStBRUxJQkJCRlVZTndRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFjYU1nSUFBTmdJUUlBQkJJellDREVFQUlSQU05d0VMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzVnSUNBQUNJUURRQWdBVUVCYWlFQkRJZ0JDeUFBUVJNMkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNOWdFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkM1Z0lDQUFDSUVEUUFnQVVFQmFpRUJETzBCQ3lBQVFSUTJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTTlRRUxJQkJCRlVZTnZRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFacVBnSUFBTmdJUUlBQkJJallDREVFQUlSQU05QUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzNnSUNBQUNJUURRQWdBVUVCYWlFQkRJWUJDeUFBUVJZMkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNOHdFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkMzZ0lDQUFDSUVEUUFnQVVFQmFpRUJET2tCQ3lBQVFSYzJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTThnRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSE5rNENBQURZQ0VDQUFRUXcyQWd4QkFDRVFEUEVCQzBJQklSRUxJQkJCQVdvaEFRSkFJQUFwQXlBaUVrTC8vLy8vLy8vLy93OVdEUUFnQUNBU1FnU0dJQkdFTndNZ0lBRWhBUXlFQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWEySmdJQUFOZ0lRSUFCQkREWUNERUVBSVJBTTd3RUxJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFSE5rNENBQURZQ0VDQUFRUXcyQWd4QkFDRVFETzRCQ3lBQUtBSUVJUmNnQUVFQU5nSUVJQkFnRWFkcUloWWhBU0FBSUJjZ0VDQVdJQlFiSWhBUXRZQ0FnQUFpRkVVTmN5QUFRUVUyQWh3Z0FDQVFOZ0lVSUFBZ0ZEWUNERUVBSVJBTTdRRUxJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFR3FuSUNBQURZQ0VDQUFRUTgyQWd4QkFDRVFET3dCQ3lBQUlCQWdBaEMwZ0lDQUFDSUJEUUVnRUNFQkMwRU9JUkFNMFFFTEFrQWdBVUVWUncwQUlBQkJBallDSENBQUlCQTJBaFFnQUVHd21JQ0FBRFlDRUNBQVFSVTJBZ3hCQUNFUURPb0JDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkJwNDZBZ0FBMkFoQWdBRUVTTmdJTVFRQWhFQXpwQVFzZ0FVRUJhaUVRQWtBZ0FDOEJNQ0lCUVlBQmNVVU5BQUpBSUFBZ0VDQUNFTHVBZ0lBQUlnRU5BQ0FRSVFFTWNBc2dBVUVWUncyNkFTQUFRUVUyQWh3Z0FDQVFOZ0lVSUFCQitaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBenBBUXNDUUNBQlFhQUVjVUdnQkVjTkFDQUFMUUF0UVFKeERRQWdBRUVBTmdJY0lBQWdFRFlDRkNBQVFaYVRnSUFBTmdJUUlBQkJCRFlDREVFQUlSQU02UUVMSUFBZ0VDQUNFTDJBZ0lBQUdpQVFJUUVDUUFKQUFrQUNRQUpBSUFBZ0VDQUNFTE9BZ0lBQURoWUNBUUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFEQkFzZ0FFRUJPZ0F1Q3lBQUlBQXZBVEJCd0FCeU93RXdJQkFoQVF0QkppRVFETkVCQ3lBQVFTTTJBaHdnQUNBUU5nSVVJQUJCcFphQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF6cEFRc2dBRUVBTmdJY0lBQWdFRFlDRkNBQVFkV0xnSUFBTmdJUUlBQkJFVFlDREVFQUlSQU02QUVMSUFBdEFDMUJBWEZGRFFGQnd3RWhFQXpPQVFzQ1FDQU5JQUpHRFFBRFFBSkFJQTB0QUFCQklFWU5BQ0FOSVFFTXhBRUxJQTFCQVdvaURTQUNSdzBBQzBFbElSQU01d0VMUVNVaEVBem1BUXNnQUNnQ0JDRUVJQUJCQURZQ0JDQUFJQVFnRFJDdmdJQ0FBQ0lFUlEydEFTQUFRU1kyQWh3Z0FDQUVOZ0lNSUFBZ0RVRUJhallDRkVFQUlSQU01UUVMSUJCQkZVWU5xd0VnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZjJOZ0lBQU5nSVFJQUJCSFRZQ0RFRUFJUkFNNUFFTElBQkJKellDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF6akFRc2dFQ0VCUVFFaEZBSkFBa0FDUUFKQUFrQUNRQUpBSUFBdEFDeEJmbW9PQndZRkJRTUJBZ0FGQ3lBQUlBQXZBVEJCQ0hJN0FUQU1Bd3RCQWlFVURBRUxRUVFoRkFzZ0FFRUJPZ0FzSUFBZ0FDOEJNQ0FVY2pzQk1Bc2dFQ0VCQzBFcklSQU15Z0VMSUFCQkFEWUNIQ0FBSUJBMkFoUWdBRUdya29DQUFEWUNFQ0FBUVFzMkFneEJBQ0VRRE9JQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjRZK0FnQUEyQWhBZ0FFRUtOZ0lNUVFBaEVBemhBUXNnQUVFQU9nQXNJQkFoQVF5OUFRc2dFQ0VCUVFFaEZBSkFBa0FDUUFKQUFrQWdBQzBBTEVGN2FnNEVBd0VDQUFVTElBQWdBQzhCTUVFSWNqc0JNQXdEQzBFQ0lSUU1BUXRCQkNFVUN5QUFRUUU2QUN3Z0FDQUFMd0V3SUJSeU93RXdDeUFRSVFFTFFTa2hFQXpGQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZDVWdJQUFOZ0lRSUFCQkF6WUNERUVBSVJBTTNRRUxBa0FnRGkwQUFFRU5SdzBBSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0RoQ3hnSUNBQUNJQkRRQWdEa0VCYWlFQkRIVUxJQUJCTERZQ0hDQUFJQUUyQWd3Z0FDQU9RUUZxTmdJVVFRQWhFQXpkQVFzZ0FDMEFMVUVCY1VVTkFVSEVBU0VRRE1NQkN3SkFJQTRnQWtjTkFFRXRJUkFNM0FFTEFrQUNRQU5BQWtBZ0RpMEFBRUYyYWc0RUFnQUFBd0FMSUE1QkFXb2lEaUFDUncwQUMwRXRJUkFNM1FFTElBQW9BZ1FoQVNBQVFRQTJBZ1FDUUNBQUlBRWdEaEN4Z0lDQUFDSUJEUUFnRGlFQkRIUUxJQUJCTERZQ0hDQUFJQTQyQWhRZ0FDQUJOZ0lNUVFBaEVBemNBUXNnQUNnQ0JDRUJJQUJCQURZQ0JBSkFJQUFnQVNBT0VMR0FnSUFBSWdFTkFDQU9RUUZxSVFFTWN3c2dBRUVzTmdJY0lBQWdBVFlDRENBQUlBNUJBV28yQWhSQkFDRVFETnNCQ3lBQUtBSUVJUVFnQUVFQU5nSUVJQUFnQkNBT0VMR0FnSUFBSWdRTm9BRWdEaUVCRE00QkN5QVFRU3hIRFFFZ0FVRUJhaUVRUVFFaEFRSkFBa0FDUUFKQUFrQWdBQzBBTEVGN2FnNEVBd0VDQkFBTElCQWhBUXdFQzBFQ0lRRU1BUXRCQkNFQkN5QUFRUUU2QUN3Z0FDQUFMd0V3SUFGeU93RXdJQkFoQVF3QkN5QUFJQUF2QVRCQkNISTdBVEFnRUNFQkMwRTVJUkFNdndFTElBQkJBRG9BTENBQklRRUxRVFFoRUF5OUFRc2dBQ0FBTHdFd1FTQnlPd0V3SUFFaEFRd0NDeUFBS0FJRUlRUWdBRUVBTmdJRUFrQWdBQ0FFSUFFUXNZQ0FnQUFpQkEwQUlBRWhBUXpIQVFzZ0FFRTNOZ0ljSUFBZ0FUWUNGQ0FBSUFRMkFneEJBQ0VRRE5RQkN5QUFRUWc2QUN3Z0FTRUJDMEV3SVJBTXVRRUxBa0FnQUMwQUtFRUJSZzBBSUFFaEFRd0VDeUFBTFFBdFFRaHhSUTJUQVNBQklRRU1Bd3NnQUMwQU1FRWdjUTJVQVVIRkFTRVFETGNCQ3dKQUlBOGdBa1lOQUFKQUEwQUNRQ0FQTFFBQVFWQnFJZ0ZCL3dGeFFRcEpEUUFnRHlFQlFUVWhFQXk2QVFzZ0FDa0RJQ0lSUXBtejVzeVpzK2JNR1ZZTkFTQUFJQkZDQ240aUVUY0RJQ0FSSUFHdFF2OEJneUlTUW4rRlZnMEJJQUFnRVNBU2ZEY0RJQ0FQUVFGcUlnOGdBa2NOQUF0Qk9TRVFETkVCQ3lBQUtBSUVJUUlnQUVFQU5nSUVJQUFnQWlBUFFRRnFJZ1FRc1lDQWdBQWlBZzJWQVNBRUlRRU13d0VMUVRraEVBelBBUXNDUUNBQUx3RXdJZ0ZCQ0hGRkRRQWdBQzBBS0VFQlJ3MEFJQUF0QUMxQkNIRkZEWkFCQ3lBQUlBRkI5L3NEY1VHQUJISTdBVEFnRHlFQkMwRTNJUkFNdEFFTElBQWdBQzhCTUVFUWNqc0JNQXlyQVFzZ0VFRVZSZzJMQVNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCOEk2QWdBQTJBaEFnQUVFY05nSU1RUUFoRUF6TEFRc2dBRUhEQURZQ0hDQUFJQUUyQWd3Z0FDQU5RUUZxTmdJVVFRQWhFQXpLQVFzQ1FDQUJMUUFBUVRwSERRQWdBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUsrQWdJQUFJaEFOQUNBQlFRRnFJUUVNWXdzZ0FFSERBRFlDSENBQUlCQTJBZ3dnQUNBQlFRRnFOZ0lVUVFBaEVBektBUXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYkdSZ0lBQU5nSVFJQUJCQ2pZQ0RFRUFJUkFNeVFFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVHZ21ZQ0FBRFlDRUNBQVFSNDJBZ3hCQUNFUURNZ0JDeUFBUVFBMkFnQUxJQUJCZ0JJN0FTb2dBQ0FYUVFGcUlnRWdBaENvZ0lDQUFDSVFEUUVnQVNFQkMwSEhBQ0VRREt3QkN5QVFRUlZIRFlNQklBQkIwUUEyQWh3Z0FDQUJOZ0lVSUFCQjQ1ZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBekVBUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNWGdzZ0FFSFNBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF6REFRc2dBRUVBTmdJY0lBQWdGRFlDRkNBQVFjR29nSUFBTmdJUUlBQkJCellDRENBQVFRQTJBZ0JCQUNFUURNSUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhkQ3lBQVFkTUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRE1FQkMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWUNSZ0lBQU5nSVFJQUJCQ1RZQ0RBekFBUXNnRUVFVlJnMTlJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR1VqWUNBQURZQ0VDQUFRU0UyQWd4QkFDRVFETDhCQzBFQklSWkJBQ0VYUVFBaEZFRUJJUkFMSUFBZ0VEb0FLeUFCUVFGcUlRRUNRQUpBSUFBdEFDMUJFSEVOQUFKQUFrQUNRQ0FBTFFBcURnTUJBQUlFQ3lBV1JRMEREQUlMSUJRTkFRd0NDeUFYUlEwQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcllDQWdBQWlFQTBBSUFFaEFReGNDeUFBUWRnQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFETDRCQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVFyWUNBZ0FBaUJBMEFJQUVoQVF5dEFRc2dBRUhaQURZQ0hDQUFJQUUyQWhRZ0FDQUVOZ0lNUVFBaEVBeTlBUXNnQUNnQ0JDRUVJQUJCQURZQ0JBSkFJQUFnQkNBQkVLMkFnSUFBSWdRTkFDQUJJUUVNcXdFTElBQkIyZ0EyQWh3Z0FDQUJOZ0lVSUFBZ0JEWUNERUVBSVJBTXZBRUxJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDdGdJQ0FBQ0lFRFFBZ0FTRUJES2tCQ3lBQVFkd0FOZ0ljSUFBZ0FUWUNGQ0FBSUFRMkFneEJBQ0VRRExzQkN3SkFJQUV0QUFCQlVHb2lFRUgvQVhGQkNrOE5BQ0FBSUJBNkFDb2dBVUVCYWlFQlFjOEFJUkFNb2dFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkN0Z0lDQUFDSUVEUUFnQVNFQkRLY0JDeUFBUWQ0QU5nSWNJQUFnQVRZQ0ZDQUFJQVEyQWd4QkFDRVFETG9CQ3lBQVFRQTJBZ0FnRjBFQmFpRUJBa0FnQUMwQUtVRWpUdzBBSUFFaEFReFpDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkIwNG1BZ0FBMkFoQWdBRUVJTmdJTVFRQWhFQXk1QVFzZ0FFRUFOZ0lBQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFaQ3pnSUFBTmdJUUlBQkJDRFlDREF5M0FRc2dBRUVBTmdJQUlCZEJBV29oQVFKQUlBQXRBQ2xCSVVjTkFDQUJJUUVNVmdzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVp1S2dJQUFOZ0lRSUFCQkNEWUNERUVBSVJBTXRnRUxJQUJCQURZQ0FDQVhRUUZxSVFFQ1FDQUFMUUFwSWhCQlhXcEJDMDhOQUNBQklRRU1WUXNDUUNBUVFRWkxEUUJCQVNBUWRFSEtBSEZGRFFBZ0FTRUJERlVMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjk0bUFnQUEyQWhBZ0FFRUlOZ0lNRExVQkN5QVFRUlZHRFhFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWJtTmdJQUFOZ0lRSUFCQkdqWUNERUVBSVJBTXRBRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERlFMSUFCQjVRQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNc3dFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkNuZ0lDQUFDSVFEUUFnQVNFQkRFMExJQUJCMGdBMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU1zZ0VMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREUwTElBQkIwd0EyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXNRRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERkVMSUFCQjVRQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNc0FFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVIR2lvQ0FBRFlDRUNBQVFRYzJBZ3hCQUNFUURLOEJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhKQ3lBQVFkSUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRREs0QkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcDRDQWdBQWlFQTBBSUFFaEFReEpDeUFBUWRNQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFESzBCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVFwNENBZ0FBaUVBMEFJQUVoQVF4TkN5QUFRZVVBTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURLd0JDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkIzSWlBZ0FBMkFoQWdBRUVITmdJTVFRQWhFQXlyQVFzZ0VFRS9SdzBCSUFGQkFXb2hBUXRCQlNFUURKQUJDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWYyU2dJQUFOZ0lRSUFCQkJ6WUNEQXlvQVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFS2VBZ0lBQUloQU5BQ0FCSVFFTVFnc2dBRUhTQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeW5BUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNUWdzZ0FFSFRBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF5bUFRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUtlQWdJQUFJaEFOQUNBQklRRU1SZ3NnQUVIbEFEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXlsQVFzZ0FDZ0NCQ0VCSUFCQkFEWUNCQUpBSUFBZ0FTQVVFS2VBZ0lBQUlnRU5BQ0FVSVFFTVB3c2dBRUhTQURZQ0hDQUFJQlEyQWhRZ0FDQUJOZ0lNUVFBaEVBeWtBUXNnQUNnQ0JDRUJJQUJCQURZQ0JBSkFJQUFnQVNBVUVLZUFnSUFBSWdFTkFDQVVJUUVNUHdzZ0FFSFRBRFlDSENBQUlCUTJBaFFnQUNBQk5nSU1RUUFoRUF5akFRc2dBQ2dDQkNFQklBQkJBRFlDQkFKQUlBQWdBU0FVRUtlQWdJQUFJZ0VOQUNBVUlRRU1Rd3NnQUVIbEFEWUNIQ0FBSUJRMkFoUWdBQ0FCTmdJTVFRQWhFQXlpQVFzZ0FFRUFOZ0ljSUFBZ0ZEWUNGQ0FBUWNPUGdJQUFOZ0lRSUFCQkJ6WUNERUVBSVJBTW9RRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSERqNENBQURZQ0VDQUFRUWMyQWd4QkFDRVFES0FCQzBFQUlSQWdBRUVBTmdJY0lBQWdGRFlDRkNBQVFZeWNnSUFBTmdJUUlBQkJCellDREF5ZkFRc2dBRUVBTmdJY0lBQWdGRFlDRkNBQVFZeWNnSUFBTmdJUUlBQkJCellDREVFQUlSQU1uZ0VMSUFCQkFEWUNIQ0FBSUJRMkFoUWdBRUgra1lDQUFEWUNFQ0FBUVFjMkFneEJBQ0VRREowQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmpwdUFnQUEyQWhBZ0FFRUdOZ0lNUVFBaEVBeWNBUXNnRUVFVlJnMVhJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSE1qb0NBQURZQ0VDQUFRU0EyQWd4QkFDRVFESnNCQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRU1FoRUFzZ0FDQVFPZ0FwSUFBb0FnUWhFQ0FBUVFBMkFnUWdBQ0FRSUFFUXE0Q0FnQUFpRUExVUlBRWhBUXcrQ3lBQVFRQTJBZ0FMUVFBaEVDQUFRUUEyQWh3Z0FDQUVOZ0lVSUFCQjhadUFnQUEyQWhBZ0FFRUdOZ0lNREpjQkN5QUJRUlZHRFZBZ0FFRUFOZ0ljSUFBZ0JUWUNGQ0FBUWZDTWdJQUFOZ0lRSUFCQkd6WUNERUVBSVJBTWxnRUxJQUFvQWdRaEJTQUFRUUEyQWdRZ0FDQUZJQkFRcVlDQWdBQWlCUTBCSUJCQkFXb2hCUXRCclFFaEVBeDdDeUFBUWNFQk5nSWNJQUFnQlRZQ0RDQUFJQkJCQVdvMkFoUkJBQ0VRREpNQkN5QUFLQUlFSVFZZ0FFRUFOZ0lFSUFBZ0JpQVFFS21BZ0lBQUlnWU5BU0FRUVFGcUlRWUxRYTRCSVJBTWVBc2dBRUhDQVRZQ0hDQUFJQVkyQWd3Z0FDQVFRUUZxTmdJVVFRQWhFQXlRQVFzZ0FFRUFOZ0ljSUFBZ0J6WUNGQ0FBUVplTGdJQUFOZ0lRSUFCQkRUWUNERUVBSVJBTWp3RUxJQUJCQURZQ0hDQUFJQWcyQWhRZ0FFSGprSUNBQURZQ0VDQUFRUWsyQWd4QkFDRVFESTRCQ3lBQVFRQTJBaHdnQUNBSU5nSVVJQUJCbEkyQWdBQTJBaEFnQUVFaE5nSU1RUUFoRUF5TkFRdEJBU0VXUVFBaEYwRUFJUlJCQVNFUUN5QUFJQkE2QUNzZ0NVRUJhaUVJQWtBQ1FDQUFMUUF0UVJCeERRQUNRQUpBQWtBZ0FDMEFLZzREQVFBQ0JBc2dGa1VOQXd3Q0N5QVVEUUVNQWdzZ0YwVU5BUXNnQUNnQ0JDRVFJQUJCQURZQ0JDQUFJQkFnQ0JDdGdJQ0FBQ0lRUlEwOUlBQkJ5UUUyQWh3Z0FDQUlOZ0lVSUFBZ0VEWUNERUVBSVJBTWpBRUxJQUFvQWdRaEJDQUFRUUEyQWdRZ0FDQUVJQWdRcllDQWdBQWlCRVVOZGlBQVFjb0JOZ0ljSUFBZ0NEWUNGQ0FBSUFRMkFneEJBQ0VRRElzQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFSUFBZ0JDQUpFSzJBZ0lBQUlnUkZEWFFnQUVITEFUWUNIQ0FBSUFrMkFoUWdBQ0FFTmdJTVFRQWhFQXlLQVFzZ0FDZ0NCQ0VFSUFCQkFEWUNCQ0FBSUFRZ0NoQ3RnSUNBQUNJRVJRMXlJQUJCelFFMkFod2dBQ0FLTmdJVUlBQWdCRFlDREVFQUlSQU1pUUVMQWtBZ0N5MEFBRUZRYWlJUVFmOEJjVUVLVHcwQUlBQWdFRG9BS2lBTFFRRnFJUXBCdGdFaEVBeHdDeUFBS0FJRUlRUWdBRUVBTmdJRUlBQWdCQ0FMRUsyQWdJQUFJZ1JGRFhBZ0FFSFBBVFlDSENBQUlBczJBaFFnQUNBRU5nSU1RUUFoRUF5SUFRc2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFaQ3pnSUFBTmdJUUlBQkJDRFlDRENBQVFRQTJBZ0JCQUNFUURJY0JDeUFCUVJWR0RUOGdBRUVBTmdJY0lBQWdERFlDRkNBQVFjeU9nSUFBTmdJUUlBQkJJRFlDREVFQUlSQU1oZ0VMSUFCQmdRUTdBU2dnQUNnQ0JDRVFJQUJDQURjREFDQUFJQkFnREVFQmFpSU1FS3VBZ0lBQUloQkZEVGdnQUVIVEFUWUNIQ0FBSUF3MkFoUWdBQ0FRTmdJTVFRQWhFQXlGQVFzZ0FFRUFOZ0lBQzBFQUlSQWdBRUVBTmdJY0lBQWdCRFlDRkNBQVFkaWJnSUFBTmdJUUlBQkJDRFlDREF5REFRc2dBQ2dDQkNFUUlBQkNBRGNEQUNBQUlCQWdDMEVCYWlJTEVLdUFnSUFBSWhBTkFVSEdBU0VRREdrTElBQkJBam9BS0F4VkN5QUFRZFVCTmdJY0lBQWdDellDRkNBQUlCQTJBZ3hCQUNFUURJQUJDeUFRUVJWR0RUY2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFhU01nSUFBTmdJUUlBQkJFRFlDREVFQUlSQU1md3NnQUMwQU5FRUJSdzAwSUFBZ0JDQUNFTHlBZ0lBQUloQkZEVFFnRUVFVlJ3MDFJQUJCM0FFMkFod2dBQ0FFTmdJVUlBQkIxWmFBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXgrQzBFQUlSQWdBRUVBTmdJY0lBQkJyNHVBZ0FBMkFoQWdBRUVDTmdJTUlBQWdGRUVCYWpZQ0ZBeDlDMEVBSVJBTVl3dEJBaUVRREdJTFFRMGhFQXhoQzBFUElSQU1ZQXRCSlNFUURGOExRUk1oRUF4ZUMwRVZJUkFNWFF0QkZpRVFERndMUVJjaEVBeGJDMEVZSVJBTVdndEJHU0VRREZrTFFSb2hFQXhZQzBFYklSQU1Wd3RCSENFUURGWUxRUjBoRUF4VkMwRWZJUkFNVkF0QklTRVFERk1MUVNNaEVBeFNDMEhHQUNFUURGRUxRUzRoRUF4UUMwRXZJUkFNVHd0Qk95RVFERTRMUVQwaEVBeE5DMEhJQUNFUURFd0xRY2tBSVJBTVN3dEJ5d0FoRUF4S0MwSE1BQ0VRREVrTFFjNEFJUkFNU0F0QjBRQWhFQXhIQzBIVkFDRVFERVlMUWRnQUlSQU1SUXRCMlFBaEVBeEVDMEhiQUNFUURFTUxRZVFBSVJBTVFndEI1UUFoRUF4QkMwSHhBQ0VRREVBTFFmUUFJUkFNUHd0QmpRRWhFQXcrQzBHWEFTRVFERDBMUWFrQklSQU1QQXRCckFFaEVBdzdDMEhBQVNFUUREb0xRYmtCSVJBTU9RdEJyd0VoRUF3NEMwR3hBU0VRRERjTFFiSUJJUkFNTmd0QnRBRWhFQXcxQzBHMUFTRVFERFFMUWJvQklSQU1Nd3RCdlFFaEVBd3lDMEcvQVNFUURERUxRY0VCSVJBTU1Bc2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFlbUxnSUFBTmdJUUlBQkJIellDREVFQUlSQU1TQXNnQUVIYkFUWUNIQ0FBSUFRMkFoUWdBRUg2bG9DQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREVjTElBQkIrQUEyQWh3Z0FDQU1OZ0lVSUFCQnlwaUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeEdDeUFBUWRFQU5nSWNJQUFnQlRZQ0ZDQUFRYkNYZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNUlFzZ0FFSDVBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF4RUN5QUFRZmdBTmdJY0lBQWdBVFlDRkNBQVFjcVlnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1Rd3NnQUVIa0FEWUNIQ0FBSUFFMkFoUWdBRUhqbDRDQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREVJTElBQkIxd0EyQWh3Z0FDQUJOZ0lVSUFCQnlaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeEJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ1WTJBZ0FBMkFoQWdBRUVhTmdJTVFRQWhFQXhBQ3lBQVFjSUFOZ0ljSUFBZ0FUWUNGQ0FBUWVPWWdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTVB3c2dBRUVBTmdJRUlBQWdEeUFQRUxHQWdJQUFJZ1JGRFFFZ0FFRTZOZ0ljSUFBZ0JEWUNEQ0FBSUE5QkFXbzJBaFJCQUNFUURENExJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDeGdJQ0FBQ0lFUlEwQUlBQkJPellDSENBQUlBUTJBZ3dnQUNBQlFRRnFOZ0lVUVFBaEVBdytDeUFCUVFGcUlRRU1MUXNnRDBFQmFpRUJEQzBMSUFCQkFEWUNIQ0FBSUE4MkFoUWdBRUhra29DQUFEWUNFQ0FBUVFRMkFneEJBQ0VRRERzTElBQkJOallDSENBQUlBUTJBaFFnQUNBQ05nSU1RUUFoRUF3NkN5QUFRUzQyQWh3Z0FDQU9OZ0lVSUFBZ0JEWUNERUVBSVJBTU9Rc2dBRUhRQURZQ0hDQUFJQUUyQWhRZ0FFR1JtSUNBQURZQ0VDQUFRUlUyQWd4QkFDRVFERGdMSUExQkFXb2hBUXdzQ3lBQVFSVTJBaHdnQUNBQk5nSVVJQUJCZ3BtQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3MkN5QUFRUnMyQWh3Z0FDQUJOZ0lVSUFCQmtaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBdzFDeUFBUVE4MkFod2dBQ0FCTmdJVUlBQkJrWmVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXcwQ3lBQVFRczJBaHdnQUNBQk5nSVVJQUJCa1plQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3ekN5QUFRUm8yQWh3Z0FDQUJOZ0lVSUFCQmdwbUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBd3lDeUFBUVFzMkFod2dBQ0FCTmdJVUlBQkJncG1BZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXd4Q3lBQVFRbzJBaHdnQUNBQk5nSVVJQUJCNUphQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3d0N5QUFRUjQyQWh3Z0FDQUJOZ0lVSUFCQitaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBd3ZDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkIybzJBZ0FBMkFoQWdBRUVVTmdJTVFRQWhFQXd1Q3lBQVFRUTJBaHdnQUNBQk5nSVVJQUJCc0ppQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3dEN5QUFRUUEyQWdBZ0MwRUJhaUVMQzBHNEFTRVFEQklMSUFCQkFEWUNBQ0FRUVFGcUlRRkI5UUFoRUF3UkN5QUJJUUVDUUNBQUxRQXBRUVZIRFFCQjR3QWhFQXdSQzBIaUFDRVFEQkFMUVFBaEVDQUFRUUEyQWh3Z0FFSGtrWUNBQURZQ0VDQUFRUWMyQWd3Z0FDQVVRUUZxTmdJVURDZ0xJQUJCQURZQ0FDQVhRUUZxSVFGQndBQWhFQXdPQzBFQklRRUxJQUFnQVRvQUxDQUFRUUEyQWdBZ0YwRUJhaUVCQzBFb0lSQU1Dd3NnQVNFQkMwRTRJUkFNQ1FzQ1FDQUJJZzhnQWtZTkFBTkFBa0FnRHkwQUFFR0F2b0NBQUdvdEFBQWlBVUVCUmcwQUlBRkJBa2NOQXlBUFFRRnFJUUVNQkFzZ0QwRUJhaUlQSUFKSERRQUxRVDRoRUF3aUMwRStJUkFNSVFzZ0FFRUFPZ0FzSUE4aEFRd0JDMEVMSVJBTUJndEJPaUVRREFVTElBRkJBV29oQVVFdElSQU1CQXNnQUNBQk9nQXNJQUJCQURZQ0FDQVdRUUZxSVFGQkRDRVFEQU1MSUFCQkFEWUNBQ0FYUVFGcUlRRkJDaUVRREFJTElBQkJBRFlDQUFzZ0FFRUFPZ0FzSUEwaEFVRUpJUkFNQUFzTFFRQWhFQ0FBUVFBMkFod2dBQ0FMTmdJVUlBQkJ6WkNBZ0FBMkFoQWdBRUVKTmdJTURCY0xRUUFoRUNBQVFRQTJBaHdnQUNBS05nSVVJQUJCNllxQWdBQTJBaEFnQUVFSk5nSU1EQllMUVFBaEVDQUFRUUEyQWh3Z0FDQUpOZ0lVSUFCQnQ1Q0FnQUEyQWhBZ0FFRUpOZ0lNREJVTFFRQWhFQ0FBUVFBMkFod2dBQ0FJTmdJVUlBQkJuSkdBZ0FBMkFoQWdBRUVKTmdJTURCUUxRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCelpDQWdBQTJBaEFnQUVFSk5nSU1EQk1MUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjZZcUFnQUEyQWhBZ0FFRUpOZ0lNREJJTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJ0NUNBZ0FBMkFoQWdBRUVKTmdJTURCRUxRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCbkpHQWdBQTJBaEFnQUVFSk5nSU1EQkFMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmw1V0FnQUEyQWhBZ0FFRVBOZ0lNREE4TFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJsNVdBZ0FBMkFoQWdBRUVQTmdJTURBNExRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCd0pLQWdBQTJBaEFnQUVFTE5nSU1EQTBMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmxZbUFnQUEyQWhBZ0FFRUxOZ0lNREF3TFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkI0WStBZ0FBMkFoQWdBRUVLTmdJTURBc0xRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCKzQrQWdBQTJBaEFnQUVFS05nSU1EQW9MUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjhabUFnQUEyQWhBZ0FFRUNOZ0lNREFrTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJ4SlNBZ0FBMkFoQWdBRUVDTmdJTURBZ0xRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCOHBXQWdBQTJBaEFnQUVFQ05nSU1EQWNMSUFCQkFqWUNIQ0FBSUFFMkFoUWdBRUdjbW9DQUFEWUNFQ0FBUVJZMkFneEJBQ0VRREFZTFFRRWhFQXdGQzBIVUFDRVFJQUVpQkNBQ1JnMEVJQU5CQ0dvZ0FDQUVJQUpCMk1LQWdBQkJDaERGZ0lDQUFDQURLQUlNSVFRZ0F5Z0NDQTREQVFRQ0FBc1F5b0NBZ0FBQUN5QUFRUUEyQWh3Z0FFRzFtb0NBQURZQ0VDQUFRUmMyQWd3Z0FDQUVRUUZxTmdJVVFRQWhFQXdDQ3lBQVFRQTJBaHdnQUNBRU5nSVVJQUJCeXBxQWdBQTJBaEFnQUVFSk5nSU1RUUFoRUF3QkN3SkFJQUVpQkNBQ1J3MEFRU0loRUF3QkN5QUFRWW1BZ0lBQU5nSUlJQUFnQkRZQ0JFRWhJUkFMSUFOQkVHb2tnSUNBZ0FBZ0VBdXZBUUVDZnlBQktBSUFJUVlDUUFKQUlBSWdBMFlOQUNBRUlBWnFJUVFnQmlBRGFpQUNheUVISUFJZ0JrRi9jeUFGYWlJR2FpRUZBMEFDUUNBQ0xRQUFJQVF0QUFCR0RRQkJBaUVFREFNTEFrQWdCZzBBUVFBaEJDQUZJUUlNQXdzZ0JrRi9haUVHSUFSQkFXb2hCQ0FDUVFGcUlnSWdBMGNOQUFzZ0J5RUdJQU1oQWdzZ0FFRUJOZ0lBSUFFZ0JqWUNBQ0FBSUFJMkFnUVBDeUFCUVFBMkFnQWdBQ0FFTmdJQUlBQWdBallDQkFzS0FDQUFFTWVBZ0lBQUMvSTJBUXQvSTRDQWdJQUFRUkJySWdFa2dJQ0FnQUFDUUVFQUtBS2cwSUNBQUEwQVFRQVF5NENBZ0FCQmdOU0VnQUJySWdKQjJRQkpEUUJCQUNFREFrQkJBQ2dDNE5PQWdBQWlCQTBBUVFCQ2Z6Y0M3Tk9BZ0FCQkFFS0FnSVNBZ0lEQUFEY0M1Tk9BZ0FCQkFDQUJRUWhxUVhCeFFkaXExYW9GY3lJRU5nTGcwNENBQUVFQVFRQTJBdlRUZ0lBQVFRQkJBRFlDeE5PQWdBQUxRUUFnQWpZQ3pOT0FnQUJCQUVHQTFJU0FBRFlDeU5PQWdBQkJBRUdBMUlTQUFEWUNtTkNBZ0FCQkFDQUVOZ0tzMElDQUFFRUFRWDgyQXFqUWdJQUFBMEFnQTBIRTBJQ0FBR29nQTBHNDBJQ0FBR29pQkRZQ0FDQUVJQU5Cc05DQWdBQnFJZ1UyQWdBZ0EwRzgwSUNBQUdvZ0JUWUNBQ0FEUWN6UWdJQUFhaUFEUWNEUWdJQUFhaUlGTmdJQUlBVWdCRFlDQUNBRFFkVFFnSUFBYWlBRFFjalFnSUFBYWlJRU5nSUFJQVFnQlRZQ0FDQURRZERRZ0lBQWFpQUVOZ0lBSUFOQklHb2lBMEdBQWtjTkFBdEJnTlNFZ0FCQmVFR0ExSVNBQUd0QkQzRkJBRUdBMUlTQUFFRUlha0VQY1JzaUEyb2lCRUVFYWlBQ1FVaHFJZ1VnQTJzaUEwRUJjallDQUVFQVFRQW9BdkRUZ0lBQU5nS2swSUNBQUVFQUlBTTJBcFRRZ0lBQVFRQWdCRFlDb05DQWdBQkJnTlNFZ0FBZ0JXcEJPRFlDQkFzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQUVIc0FVc05BQUpBUVFBb0FvalFnSUFBSWdaQkVDQUFRUk5xUVhCeElBQkJDMGtiSWdKQkEzWWlCSFlpQTBFRGNVVU5BQUpBQWtBZ0EwRUJjU0FFY2tFQmN5SUZRUU4wSWdSQnNOQ0FnQUJxSWdNZ0JFRzQwSUNBQUdvb0FnQWlCQ2dDQ0NJQ1J3MEFRUUFnQmtGK0lBVjNjVFlDaU5DQWdBQU1BUXNnQXlBQ05nSUlJQUlnQXpZQ0RBc2dCRUVJYWlFRElBUWdCVUVEZENJRlFRTnlOZ0lFSUFRZ0JXb2lCQ0FFS0FJRVFRRnlOZ0lFREF3TElBSkJBQ2dDa05DQWdBQWlCMDBOQVFKQUlBTkZEUUFDUUFKQUlBTWdCSFJCQWlBRWRDSURRUUFnQTJ0eWNTSURRUUFnQTJ0eFFYOXFJZ01nQTBFTWRrRVFjU0lEZGlJRVFRVjJRUWh4SWdVZ0EzSWdCQ0FGZGlJRFFRSjJRUVJ4SWdSeUlBTWdCSFlpQTBFQmRrRUNjU0lFY2lBRElBUjJJZ05CQVhaQkFYRWlCSElnQXlBRWRtb2lCRUVEZENJRFFiRFFnSUFBYWlJRklBTkJ1TkNBZ0FCcUtBSUFJZ01vQWdnaUFFY05BRUVBSUFaQmZpQUVkM0VpQmpZQ2lOQ0FnQUFNQVFzZ0JTQUFOZ0lJSUFBZ0JUWUNEQXNnQXlBQ1FRTnlOZ0lFSUFNZ0JFRURkQ0lFYWlBRUlBSnJJZ1UyQWdBZ0F5QUNhaUlBSUFWQkFYSTJBZ1FDUUNBSFJRMEFJQWRCZUhGQnNOQ0FnQUJxSVFKQkFDZ0NuTkNBZ0FBaEJBSkFBa0FnQmtFQklBZEJBM1owSWdoeERRQkJBQ0FHSUFoeU5nS0kwSUNBQUNBQ0lRZ01BUXNnQWlnQ0NDRUlDeUFJSUFRMkFnd2dBaUFFTmdJSUlBUWdBallDRENBRUlBZzJBZ2dMSUFOQkNHb2hBMEVBSUFBMkFwelFnSUFBUVFBZ0JUWUNrTkNBZ0FBTURBdEJBQ2dDak5DQWdBQWlDVVVOQVNBSlFRQWdDV3R4UVg5cUlnTWdBMEVNZGtFUWNTSURkaUlFUVFWMlFRaHhJZ1VnQTNJZ0JDQUZkaUlEUVFKMlFRUnhJZ1J5SUFNZ0JIWWlBMEVCZGtFQ2NTSUVjaUFESUFSMklnTkJBWFpCQVhFaUJISWdBeUFFZG1wQkFuUkJ1TktBZ0FCcUtBSUFJZ0FvQWdSQmVIRWdBbXNoQkNBQUlRVUNRQU5BQWtBZ0JTZ0NFQ0lERFFBZ0JVRVVhaWdDQUNJRFJRMENDeUFES0FJRVFYaHhJQUpySWdVZ0JDQUZJQVJKSWdVYklRUWdBeUFBSUFVYklRQWdBeUVGREFBTEN5QUFLQUlZSVFvQ1FDQUFLQUlNSWdnZ0FFWU5BQ0FBS0FJSUlnTkJBQ2dDbU5DQWdBQkpHaUFJSUFNMkFnZ2dBeUFJTmdJTURBc0xBa0FnQUVFVWFpSUZLQUlBSWdNTkFDQUFLQUlRSWdORkRRTWdBRUVRYWlFRkN3TkFJQVVoQ3lBRElnaEJGR29pQlNnQ0FDSUREUUFnQ0VFUWFpRUZJQWdvQWhBaUF3MEFDeUFMUVFBMkFnQU1DZ3RCZnlFQ0lBQkJ2MzlMRFFBZ0FFRVRhaUlEUVhCeElRSkJBQ2dDak5DQWdBQWlCMFVOQUVFQUlRc0NRQ0FDUVlBQ1NRMEFRUjhoQ3lBQ1FmLy8vd2RMRFFBZ0EwRUlkaUlESUFOQmdQNC9ha0VRZGtFSWNTSURkQ0lFSUFSQmdPQWZha0VRZGtFRWNTSUVkQ0lGSUFWQmdJQVBha0VRZGtFQ2NTSUZkRUVQZGlBRElBUnlJQVZ5YXlJRFFRRjBJQUlnQTBFVmFuWkJBWEZ5UVJ4cUlRc0xRUUFnQW1zaEJBSkFBa0FDUUFKQUlBdEJBblJCdU5LQWdBQnFLQUlBSWdVTkFFRUFJUU5CQUNFSURBRUxRUUFoQXlBQ1FRQkJHU0FMUVFGMmF5QUxRUjlHRzNRaEFFRUFJUWdEUUFKQUlBVW9BZ1JCZUhFZ0Ftc2lCaUFFVHcwQUlBWWhCQ0FGSVFnZ0JnMEFRUUFoQkNBRklRZ2dCU0VEREFNTElBTWdCVUVVYWlnQ0FDSUdJQVlnQlNBQVFSMTJRUVJ4YWtFUWFpZ0NBQ0lGUmhzZ0F5QUdHeUVESUFCQkFYUWhBQ0FGRFFBTEN3SkFJQU1nQ0hJTkFFRUFJUWhCQWlBTGRDSURRUUFnQTJ0eUlBZHhJZ05GRFFNZ0EwRUFJQU5yY1VGL2FpSURJQU5CREhaQkVIRWlBM1lpQlVFRmRrRUljU0lBSUFOeUlBVWdBSFlpQTBFQ2RrRUVjU0lGY2lBRElBVjJJZ05CQVhaQkFuRWlCWElnQXlBRmRpSURRUUYyUVFGeElnVnlJQU1nQlhacVFRSjBRYmpTZ0lBQWFpZ0NBQ0VEQ3lBRFJRMEJDd05BSUFNb0FnUkJlSEVnQW1zaUJpQUVTU0VBQWtBZ0F5Z0NFQ0lGRFFBZ0EwRVVhaWdDQUNFRkN5QUdJQVFnQUJzaEJDQURJQWdnQUJzaENDQUZJUU1nQlEwQUN3c2dDRVVOQUNBRVFRQW9BcERRZ0lBQUlBSnJUdzBBSUFnb0FoZ2hDd0pBSUFnb0Fnd2lBQ0FJUmcwQUlBZ29BZ2dpQTBFQUtBS1kwSUNBQUVrYUlBQWdBellDQ0NBRElBQTJBZ3dNQ1FzQ1FDQUlRUlJxSWdVb0FnQWlBdzBBSUFnb0FoQWlBMFVOQXlBSVFSQnFJUVVMQTBBZ0JTRUdJQU1pQUVFVWFpSUZLQUlBSWdNTkFDQUFRUkJxSVFVZ0FDZ0NFQ0lERFFBTElBWkJBRFlDQUF3SUN3SkFRUUFvQXBEUWdJQUFJZ01nQWtrTkFFRUFLQUtjMElDQUFDRUVBa0FDUUNBRElBSnJJZ1ZCRUVrTkFDQUVJQUpxSWdBZ0JVRUJjallDQkVFQUlBVTJBcERRZ0lBQVFRQWdBRFlDbk5DQWdBQWdCQ0FEYWlBRk5nSUFJQVFnQWtFRGNqWUNCQXdCQ3lBRUlBTkJBM0kyQWdRZ0JDQURhaUlESUFNb0FnUkJBWEkyQWdSQkFFRUFOZ0tjMElDQUFFRUFRUUEyQXBEUWdJQUFDeUFFUVFocUlRTU1DZ3NDUUVFQUtBS1UwSUNBQUNJQUlBSk5EUUJCQUNnQ29OQ0FnQUFpQXlBQ2FpSUVJQUFnQW1zaUJVRUJjallDQkVFQUlBVTJBcFRRZ0lBQVFRQWdCRFlDb05DQWdBQWdBeUFDUVFOeU5nSUVJQU5CQ0dvaEF3d0tDd0pBQWtCQkFDZ0M0Tk9BZ0FCRkRRQkJBQ2dDNk5PQWdBQWhCQXdCQzBFQVFuODNBdXpUZ0lBQVFRQkNnSUNFZ0lDQXdBQTNBdVRUZ0lBQVFRQWdBVUVNYWtGd2NVSFlxdFdxQlhNMkF1RFRnSUFBUVFCQkFEWUM5Tk9BZ0FCQkFFRUFOZ0xFMDRDQUFFR0FnQVFoQkF0QkFDRURBa0FnQkNBQ1FjY0FhaUlIYWlJR1FRQWdCR3NpQzNFaUNDQUNTdzBBUVFCQk1EWUMrTk9BZ0FBTUNnc0NRRUVBS0FMQTA0Q0FBQ0lEUlEwQUFrQkJBQ2dDdU5PQWdBQWlCQ0FJYWlJRklBUk5EUUFnQlNBRFRRMEJDMEVBSVFOQkFFRXdOZ0w0MDRDQUFBd0tDMEVBTFFERTA0Q0FBRUVFY1EwRUFrQUNRQUpBUVFBb0FxRFFnSUFBSWdSRkRRQkJ5Tk9BZ0FBaEF3TkFBa0FnQXlnQ0FDSUZJQVJMRFFBZ0JTQURLQUlFYWlBRVN3MERDeUFES0FJSUlnTU5BQXNMUVFBUXk0Q0FnQUFpQUVGL1JnMEZJQWdoQmdKQVFRQW9BdVRUZ0lBQUlnTkJmMm9pQkNBQWNVVU5BQ0FJSUFCcklBUWdBR3BCQUNBRGEzRnFJUVlMSUFZZ0FrME5CU0FHUWY3Ly8vOEhTdzBGQWtCQkFDZ0N3Tk9BZ0FBaUEwVU5BRUVBS0FLNDA0Q0FBQ0lFSUFacUlnVWdCRTBOQmlBRklBTkxEUVlMSUFZUXk0Q0FnQUFpQXlBQVJ3MEJEQWNMSUFZZ0FHc2dDM0VpQmtIKy8vLy9CMHNOQkNBR0VNdUFnSUFBSWdBZ0F5Z0NBQ0FES0FJRWFrWU5BeUFBSVFNTEFrQWdBMEYvUmcwQUlBSkJ5QUJxSUFaTkRRQUNRQ0FISUFaclFRQW9BdWpUZ0lBQUlnUnFRUUFnQkd0eElnUkIvdi8vL3dkTkRRQWdBeUVBREFjTEFrQWdCQkRMZ0lDQUFFRi9SZzBBSUFRZ0Jtb2hCaUFESVFBTUJ3dEJBQ0FHYXhETGdJQ0FBQm9NQkFzZ0F5RUFJQU5CZjBjTkJRd0RDMEVBSVFnTUJ3dEJBQ0VBREFVTElBQkJmMGNOQWd0QkFFRUFLQUxFMDRDQUFFRUVjallDeE5PQWdBQUxJQWhCL3YvLy93ZExEUUVnQ0JETGdJQ0FBQ0VBUVFBUXk0Q0FnQUFoQXlBQVFYOUdEUUVnQTBGL1JnMEJJQUFnQTA4TkFTQURJQUJySWdZZ0FrRTRhazBOQVF0QkFFRUFLQUs0MDRDQUFDQUdhaUlETmdLNDA0Q0FBQUpBSUFOQkFDZ0N2Tk9BZ0FCTkRRQkJBQ0FETmdLODA0Q0FBQXNDUUFKQUFrQUNRRUVBS0FLZzBJQ0FBQ0lFUlEwQVFjalRnSUFBSVFNRFFDQUFJQU1vQWdBaUJTQURLQUlFSWdocVJnMENJQU1vQWdnaUF3MEFEQU1MQ3dKQUFrQkJBQ2dDbU5DQWdBQWlBMFVOQUNBQUlBTlBEUUVMUVFBZ0FEWUNtTkNBZ0FBTFFRQWhBMEVBSUFZMkFzelRnSUFBUVFBZ0FEWUN5Tk9BZ0FCQkFFRi9OZ0tvMElDQUFFRUFRUUFvQXVEVGdJQUFOZ0tzMElDQUFFRUFRUUEyQXRUVGdJQUFBMEFnQTBIRTBJQ0FBR29nQTBHNDBJQ0FBR29pQkRZQ0FDQUVJQU5Cc05DQWdBQnFJZ1UyQWdBZ0EwRzgwSUNBQUdvZ0JUWUNBQ0FEUWN6UWdJQUFhaUFEUWNEUWdJQUFhaUlGTmdJQUlBVWdCRFlDQUNBRFFkVFFnSUFBYWlBRFFjalFnSUFBYWlJRU5nSUFJQVFnQlRZQ0FDQURRZERRZ0lBQWFpQUVOZ0lBSUFOQklHb2lBMEdBQWtjTkFBc2dBRUY0SUFCclFROXhRUUFnQUVFSWFrRVBjUnNpQTJvaUJDQUdRVWhxSWdVZ0Eyc2lBMEVCY2pZQ0JFRUFRUUFvQXZEVGdJQUFOZ0trMElDQUFFRUFJQU0yQXBUUWdJQUFRUUFnQkRZQ29OQ0FnQUFnQUNBRmFrRTROZ0lFREFJTElBTXRBQXhCQ0hFTkFDQUVJQVZKRFFBZ0JDQUFUdzBBSUFSQmVDQUVhMEVQY1VFQUlBUkJDR3BCRDNFYklnVnFJZ0JCQUNnQ2xOQ0FnQUFnQm1vaUN5QUZheUlGUVFGeU5nSUVJQU1nQ0NBR2FqWUNCRUVBUVFBb0F2RFRnSUFBTmdLazBJQ0FBRUVBSUFVMkFwVFFnSUFBUVFBZ0FEWUNvTkNBZ0FBZ0JDQUxha0U0TmdJRURBRUxBa0FnQUVFQUtBS1kwSUNBQUNJSVR3MEFRUUFnQURZQ21OQ0FnQUFnQUNFSUN5QUFJQVpxSVFWQnlOT0FnQUFoQXdKQUFrQUNRQUpBQWtBQ1FBSkFBMEFnQXlnQ0FDQUZSZzBCSUFNb0FnZ2lBdzBBREFJTEN5QURMUUFNUVFoeFJRMEJDMEhJMDRDQUFDRURBMEFDUUNBREtBSUFJZ1VnQkVzTkFDQUZJQU1vQWdScUlnVWdCRXNOQXdzZ0F5Z0NDQ0VEREFBTEN5QURJQUEyQWdBZ0F5QURLQUlFSUFacU5nSUVJQUJCZUNBQWEwRVBjVUVBSUFCQkNHcEJEM0ViYWlJTElBSkJBM0kyQWdRZ0JVRjRJQVZyUVE5eFFRQWdCVUVJYWtFUGNSdHFJZ1lnQ3lBQ2FpSUNheUVEQWtBZ0JpQUVSdzBBUVFBZ0FqWUNvTkNBZ0FCQkFFRUFLQUtVMElDQUFDQURhaUlETmdLVTBJQ0FBQ0FDSUFOQkFYSTJBZ1FNQXdzQ1FDQUdRUUFvQXB6UWdJQUFSdzBBUVFBZ0FqWUNuTkNBZ0FCQkFFRUFLQUtRMElDQUFDQURhaUlETmdLUTBJQ0FBQ0FDSUFOQkFYSTJBZ1FnQWlBRGFpQUROZ0lBREFNTEFrQWdCaWdDQkNJRVFRTnhRUUZIRFFBZ0JFRjRjU0VIQWtBQ1FDQUVRZjhCU3cwQUlBWW9BZ2dpQlNBRVFRTjJJZ2hCQTNSQnNOQ0FnQUJxSWdCR0dnSkFJQVlvQWd3aUJDQUZSdzBBUVFCQkFDZ0NpTkNBZ0FCQmZpQUlkM0UyQW9qUWdJQUFEQUlMSUFRZ0FFWWFJQVFnQlRZQ0NDQUZJQVEyQWd3TUFRc2dCaWdDR0NFSkFrQUNRQ0FHS0FJTUlnQWdCa1lOQUNBR0tBSUlJZ1FnQ0VrYUlBQWdCRFlDQ0NBRUlBQTJBZ3dNQVFzQ1FDQUdRUlJxSWdRb0FnQWlCUTBBSUFaQkVHb2lCQ2dDQUNJRkRRQkJBQ0VBREFFTEEwQWdCQ0VJSUFVaUFFRVVhaUlFS0FJQUlnVU5BQ0FBUVJCcUlRUWdBQ2dDRUNJRkRRQUxJQWhCQURZQ0FBc2dDVVVOQUFKQUFrQWdCaUFHS0FJY0lnVkJBblJCdU5LQWdBQnFJZ1FvQWdCSERRQWdCQ0FBTmdJQUlBQU5BVUVBUVFBb0FvelFnSUFBUVg0Z0JYZHhOZ0tNMElDQUFBd0NDeUFKUVJCQkZDQUpLQUlRSUFaR0cyb2dBRFlDQUNBQVJRMEJDeUFBSUFrMkFoZ0NRQ0FHS0FJUUlnUkZEUUFnQUNBRU5nSVFJQVFnQURZQ0dBc2dCaWdDRkNJRVJRMEFJQUJCRkdvZ0JEWUNBQ0FFSUFBMkFoZ0xJQWNnQTJvaEF5QUdJQWRxSWdZb0FnUWhCQXNnQmlBRVFYNXhOZ0lFSUFJZ0Eyb2dBellDQUNBQ0lBTkJBWEkyQWdRQ1FDQURRZjhCU3cwQUlBTkJlSEZCc05DQWdBQnFJUVFDUUFKQVFRQW9Bb2pRZ0lBQUlnVkJBU0FEUVFOMmRDSURjUTBBUVFBZ0JTQURjallDaU5DQWdBQWdCQ0VEREFFTElBUW9BZ2doQXdzZ0F5QUNOZ0lNSUFRZ0FqWUNDQ0FDSUFRMkFnd2dBaUFETmdJSURBTUxRUjhoQkFKQUlBTkIvLy8vQjBzTkFDQURRUWgySWdRZ0JFR0EvajlxUVJCMlFRaHhJZ1IwSWdVZ0JVR0E0QjlxUVJCMlFRUnhJZ1YwSWdBZ0FFR0FnQTlxUVJCMlFRSnhJZ0IwUVE5MklBUWdCWElnQUhKcklnUkJBWFFnQXlBRVFSVnFka0VCY1hKQkhHb2hCQXNnQWlBRU5nSWNJQUpDQURjQ0VDQUVRUUowUWJqU2dJQUFhaUVGQWtCQkFDZ0NqTkNBZ0FBaUFFRUJJQVIwSWdoeERRQWdCU0FDTmdJQVFRQWdBQ0FJY2pZQ2pOQ0FnQUFnQWlBRk5nSVlJQUlnQWpZQ0NDQUNJQUkyQWd3TUF3c2dBMEVBUVJrZ0JFRUJkbXNnQkVFZlJodDBJUVFnQlNnQ0FDRUFBMEFnQUNJRktBSUVRWGh4SUFOR0RRSWdCRUVkZGlFQUlBUkJBWFFoQkNBRklBQkJCSEZxUVJCcUlnZ29BZ0FpQUEwQUN5QUlJQUkyQWdBZ0FpQUZOZ0lZSUFJZ0FqWUNEQ0FDSUFJMkFnZ01BZ3NnQUVGNElBQnJRUTl4UVFBZ0FFRUlha0VQY1JzaUEyb2lDeUFHUVVocUlnZ2dBMnNpQTBFQmNqWUNCQ0FBSUFocVFUZzJBZ1FnQkNBRlFUY2dCV3RCRDNGQkFDQUZRVWxxUVE5eEcycEJRV29pQ0NBSUlBUkJFR3BKR3lJSVFTTTJBZ1JCQUVFQUtBTHcwNENBQURZQ3BOQ0FnQUJCQUNBRE5nS1UwSUNBQUVFQUlBczJBcURRZ0lBQUlBaEJFR3BCQUNrQzBOT0FnQUEzQWdBZ0NFRUFLUUxJMDRDQUFEY0NDRUVBSUFoQkNHbzJBdERUZ0lBQVFRQWdCallDek5PQWdBQkJBQ0FBTmdMSTA0Q0FBRUVBUVFBMkF0VFRnSUFBSUFoQkpHb2hBd05BSUFOQkJ6WUNBQ0FEUVFScUlnTWdCVWtOQUFzZ0NDQUVSZzBESUFnZ0NDZ0NCRUYrY1RZQ0JDQUlJQWdnQkdzaUFEWUNBQ0FFSUFCQkFYSTJBZ1FDUUNBQVFmOEJTdzBBSUFCQmVIRkJzTkNBZ0FCcUlRTUNRQUpBUVFBb0FvalFnSUFBSWdWQkFTQUFRUU4yZENJQWNRMEFRUUFnQlNBQWNqWUNpTkNBZ0FBZ0F5RUZEQUVMSUFNb0FnZ2hCUXNnQlNBRU5nSU1JQU1nQkRZQ0NDQUVJQU0yQWd3Z0JDQUZOZ0lJREFRTFFSOGhBd0pBSUFCQi8vLy9CMHNOQUNBQVFRaDJJZ01nQTBHQS9qOXFRUkIyUVFoeElnTjBJZ1VnQlVHQTRCOXFRUkIyUVFSeElnVjBJZ2dnQ0VHQWdBOXFRUkIyUVFKeElnaDBRUTkySUFNZ0JYSWdDSEpySWdOQkFYUWdBQ0FEUVJWcWRrRUJjWEpCSEdvaEF3c2dCQ0FETmdJY0lBUkNBRGNDRUNBRFFRSjBRYmpTZ0lBQWFpRUZBa0JCQUNnQ2pOQ0FnQUFpQ0VFQklBTjBJZ1p4RFFBZ0JTQUVOZ0lBUVFBZ0NDQUdjallDak5DQWdBQWdCQ0FGTmdJWUlBUWdCRFlDQ0NBRUlBUTJBZ3dNQkFzZ0FFRUFRUmtnQTBFQmRtc2dBMEVmUmh0MElRTWdCU2dDQUNFSUEwQWdDQ0lGS0FJRVFYaHhJQUJHRFFNZ0EwRWRkaUVJSUFOQkFYUWhBeUFGSUFoQkJIRnFRUkJxSWdZb0FnQWlDQTBBQ3lBR0lBUTJBZ0FnQkNBRk5nSVlJQVFnQkRZQ0RDQUVJQVEyQWdnTUF3c2dCU2dDQ0NJRElBSTJBZ3dnQlNBQ05nSUlJQUpCQURZQ0dDQUNJQVUyQWd3Z0FpQUROZ0lJQ3lBTFFRaHFJUU1NQlFzZ0JTZ0NDQ0lESUFRMkFnd2dCU0FFTmdJSUlBUkJBRFlDR0NBRUlBVTJBZ3dnQkNBRE5nSUlDMEVBS0FLVTBJQ0FBQ0lESUFKTkRRQkJBQ2dDb05DQWdBQWlCQ0FDYWlJRklBTWdBbXNpQTBFQmNqWUNCRUVBSUFNMkFwVFFnSUFBUVFBZ0JUWUNvTkNBZ0FBZ0JDQUNRUU55TmdJRUlBUkJDR29oQXd3REMwRUFJUU5CQUVFd05nTDQwNENBQUF3Q0N3SkFJQXRGRFFBQ1FBSkFJQWdnQ0NnQ0hDSUZRUUowUWJqU2dJQUFhaUlES0FJQVJ3MEFJQU1nQURZQ0FDQUFEUUZCQUNBSFFYNGdCWGR4SWdjMkFvelFnSUFBREFJTElBdEJFRUVVSUFzb0FoQWdDRVliYWlBQU5nSUFJQUJGRFFFTElBQWdDellDR0FKQUlBZ29BaEFpQTBVTkFDQUFJQU0yQWhBZ0F5QUFOZ0lZQ3lBSVFSUnFLQUlBSWdORkRRQWdBRUVVYWlBRE5nSUFJQU1nQURZQ0dBc0NRQUpBSUFSQkQwc05BQ0FJSUFRZ0Ftb2lBMEVEY2pZQ0JDQUlJQU5xSWdNZ0F5Z0NCRUVCY2pZQ0JBd0JDeUFJSUFKcUlnQWdCRUVCY2pZQ0JDQUlJQUpCQTNJMkFnUWdBQ0FFYWlBRU5nSUFBa0FnQkVIL0FVc05BQ0FFUVhoeFFiRFFnSUFBYWlFREFrQUNRRUVBS0FLSTBJQ0FBQ0lGUVFFZ0JFRURkblFpQkhFTkFFRUFJQVVnQkhJMkFvalFnSUFBSUFNaEJBd0JDeUFES0FJSUlRUUxJQVFnQURZQ0RDQURJQUEyQWdnZ0FDQUROZ0lNSUFBZ0JEWUNDQXdCQzBFZklRTUNRQ0FFUWYvLy93ZExEUUFnQkVFSWRpSURJQU5CZ1A0L2FrRVFka0VJY1NJRGRDSUZJQVZCZ09BZmFrRVFka0VFY1NJRmRDSUNJQUpCZ0lBUGFrRVFka0VDY1NJQ2RFRVBkaUFESUFWeUlBSnlheUlEUVFGMElBUWdBMEVWYW5aQkFYRnlRUnhxSVFNTElBQWdBellDSENBQVFnQTNBaEFnQTBFQ2RFRzQwb0NBQUdvaEJRSkFJQWRCQVNBRGRDSUNjUTBBSUFVZ0FEWUNBRUVBSUFjZ0FuSTJBb3pRZ0lBQUlBQWdCVFlDR0NBQUlBQTJBZ2dnQUNBQU5nSU1EQUVMSUFSQkFFRVpJQU5CQVhacklBTkJIMFliZENFRElBVW9BZ0FoQWdKQUEwQWdBaUlGS0FJRVFYaHhJQVJHRFFFZ0EwRWRkaUVDSUFOQkFYUWhBeUFGSUFKQkJIRnFRUkJxSWdZb0FnQWlBZzBBQ3lBR0lBQTJBZ0FnQUNBRk5nSVlJQUFnQURZQ0RDQUFJQUEyQWdnTUFRc2dCU2dDQ0NJRElBQTJBZ3dnQlNBQU5nSUlJQUJCQURZQ0dDQUFJQVUyQWd3Z0FDQUROZ0lJQ3lBSVFRaHFJUU1NQVFzQ1FDQUtSUTBBQWtBQ1FDQUFJQUFvQWh3aUJVRUNkRUc0MG9DQUFHb2lBeWdDQUVjTkFDQURJQWcyQWdBZ0NBMEJRUUFnQ1VGK0lBVjNjVFlDak5DQWdBQU1BZ3NnQ2tFUVFSUWdDaWdDRUNBQVJodHFJQWcyQWdBZ0NFVU5BUXNnQ0NBS05nSVlBa0FnQUNnQ0VDSURSUTBBSUFnZ0F6WUNFQ0FESUFnMkFoZ0xJQUJCRkdvb0FnQWlBMFVOQUNBSVFSUnFJQU0yQWdBZ0F5QUlOZ0lZQ3dKQUFrQWdCRUVQU3cwQUlBQWdCQ0FDYWlJRFFRTnlOZ0lFSUFBZ0Eyb2lBeUFES0FJRVFRRnlOZ0lFREFFTElBQWdBbW9pQlNBRVFRRnlOZ0lFSUFBZ0FrRURjallDQkNBRklBUnFJQVEyQWdBQ1FDQUhSUTBBSUFkQmVIRkJzTkNBZ0FCcUlRSkJBQ2dDbk5DQWdBQWhBd0pBQWtCQkFTQUhRUU4yZENJSUlBWnhEUUJCQUNBSUlBWnlOZ0tJMElDQUFDQUNJUWdNQVFzZ0FpZ0NDQ0VJQ3lBSUlBTTJBZ3dnQWlBRE5nSUlJQU1nQWpZQ0RDQURJQWcyQWdnTFFRQWdCVFlDbk5DQWdBQkJBQ0FFTmdLUTBJQ0FBQXNnQUVFSWFpRURDeUFCUVJCcUpJQ0FnSUFBSUFNTENnQWdBQkRKZ0lDQUFBdmlEUUVIZndKQUlBQkZEUUFnQUVGNGFpSUJJQUJCZkdvb0FnQWlBa0Y0Y1NJQWFpRURBa0FnQWtFQmNRMEFJQUpCQTNGRkRRRWdBU0FCS0FJQUlnSnJJZ0ZCQUNnQ21OQ0FnQUFpQkVrTkFTQUNJQUJxSVFBQ1FDQUJRUUFvQXB6UWdJQUFSZzBBQWtBZ0FrSC9BVXNOQUNBQktBSUlJZ1FnQWtFRGRpSUZRUU4wUWJEUWdJQUFhaUlHUmhvQ1FDQUJLQUlNSWdJZ0JFY05BRUVBUVFBb0FvalFnSUFBUVg0Z0JYZHhOZ0tJMElDQUFBd0RDeUFDSUFaR0dpQUNJQVEyQWdnZ0JDQUNOZ0lNREFJTElBRW9BaGdoQndKQUFrQWdBU2dDRENJR0lBRkdEUUFnQVNnQ0NDSUNJQVJKR2lBR0lBSTJBZ2dnQWlBR05nSU1EQUVMQWtBZ0FVRVVhaUlDS0FJQUlnUU5BQ0FCUVJCcUlnSW9BZ0FpQkEwQVFRQWhCZ3dCQ3dOQUlBSWhCU0FFSWdaQkZHb2lBaWdDQUNJRURRQWdCa0VRYWlFQ0lBWW9BaEFpQkEwQUN5QUZRUUEyQWdBTElBZEZEUUVDUUFKQUlBRWdBU2dDSENJRVFRSjBRYmpTZ0lBQWFpSUNLQUlBUncwQUlBSWdCallDQUNBR0RRRkJBRUVBS0FLTTBJQ0FBRUYrSUFSM2NUWUNqTkNBZ0FBTUF3c2dCMEVRUVJRZ0J5Z0NFQ0FCUmh0cUlBWTJBZ0FnQmtVTkFnc2dCaUFITmdJWUFrQWdBU2dDRUNJQ1JRMEFJQVlnQWpZQ0VDQUNJQVkyQWhnTElBRW9BaFFpQWtVTkFTQUdRUlJxSUFJMkFnQWdBaUFHTmdJWURBRUxJQU1vQWdRaUFrRURjVUVEUncwQUlBTWdBa0YrY1RZQ0JFRUFJQUEyQXBEUWdJQUFJQUVnQUdvZ0FEWUNBQ0FCSUFCQkFYSTJBZ1FQQ3lBQklBTlBEUUFnQXlnQ0JDSUNRUUZ4UlEwQUFrQUNRQ0FDUVFKeERRQUNRQ0FEUVFBb0FxRFFnSUFBUncwQVFRQWdBVFlDb05DQWdBQkJBRUVBS0FLVTBJQ0FBQ0FBYWlJQU5nS1UwSUNBQUNBQklBQkJBWEkyQWdRZ0FVRUFLQUtjMElDQUFFY05BMEVBUVFBMkFwRFFnSUFBUVFCQkFEWUNuTkNBZ0FBUEN3SkFJQU5CQUNnQ25OQ0FnQUJIRFFCQkFDQUJOZ0tjMElDQUFFRUFRUUFvQXBEUWdJQUFJQUJxSWdBMkFwRFFnSUFBSUFFZ0FFRUJjallDQkNBQklBQnFJQUEyQWdBUEN5QUNRWGh4SUFCcUlRQUNRQUpBSUFKQi93RkxEUUFnQXlnQ0NDSUVJQUpCQTNZaUJVRURkRUd3MElDQUFHb2lCa1lhQWtBZ0F5Z0NEQ0lDSUFSSERRQkJBRUVBS0FLSTBJQ0FBRUYrSUFWM2NUWUNpTkNBZ0FBTUFnc2dBaUFHUmhvZ0FpQUVOZ0lJSUFRZ0FqWUNEQXdCQ3lBREtBSVlJUWNDUUFKQUlBTW9BZ3dpQmlBRFJnMEFJQU1vQWdnaUFrRUFLQUtZMElDQUFFa2FJQVlnQWpZQ0NDQUNJQVkyQWd3TUFRc0NRQ0FEUVJScUlnSW9BZ0FpQkEwQUlBTkJFR29pQWlnQ0FDSUVEUUJCQUNFR0RBRUxBMEFnQWlFRklBUWlCa0VVYWlJQ0tBSUFJZ1FOQUNBR1FSQnFJUUlnQmlnQ0VDSUVEUUFMSUFWQkFEWUNBQXNnQjBVTkFBSkFBa0FnQXlBREtBSWNJZ1JCQW5SQnVOS0FnQUJxSWdJb0FnQkhEUUFnQWlBR05nSUFJQVlOQVVFQVFRQW9Bb3pRZ0lBQVFYNGdCSGR4TmdLTTBJQ0FBQXdDQ3lBSFFSQkJGQ0FIS0FJUUlBTkdHMm9nQmpZQ0FDQUdSUTBCQ3lBR0lBYzJBaGdDUUNBREtBSVFJZ0pGRFFBZ0JpQUNOZ0lRSUFJZ0JqWUNHQXNnQXlnQ0ZDSUNSUTBBSUFaQkZHb2dBallDQUNBQ0lBWTJBaGdMSUFFZ0FHb2dBRFlDQUNBQklBQkJBWEkyQWdRZ0FVRUFLQUtjMElDQUFFY05BVUVBSUFBMkFwRFFnSUFBRHdzZ0F5QUNRWDV4TmdJRUlBRWdBR29nQURZQ0FDQUJJQUJCQVhJMkFnUUxBa0FnQUVIL0FVc05BQ0FBUVhoeFFiRFFnSUFBYWlFQ0FrQUNRRUVBS0FLSTBJQ0FBQ0lFUVFFZ0FFRURkblFpQUhFTkFFRUFJQVFnQUhJMkFvalFnSUFBSUFJaEFBd0JDeUFDS0FJSUlRQUxJQUFnQVRZQ0RDQUNJQUUyQWdnZ0FTQUNOZ0lNSUFFZ0FEWUNDQThMUVI4aEFnSkFJQUJCLy8vL0Iwc05BQ0FBUVFoMklnSWdBa0dBL2o5cVFSQjJRUWh4SWdKMElnUWdCRUdBNEI5cVFSQjJRUVJ4SWdSMElnWWdCa0dBZ0E5cVFSQjJRUUp4SWdaMFFROTJJQUlnQkhJZ0JuSnJJZ0pCQVhRZ0FDQUNRUlZxZGtFQmNYSkJIR29oQWdzZ0FTQUNOZ0ljSUFGQ0FEY0NFQ0FDUVFKMFFialNnSUFBYWlFRUFrQUNRRUVBS0FLTTBJQ0FBQ0lHUVFFZ0FuUWlBM0VOQUNBRUlBRTJBZ0JCQUNBR0lBTnlOZ0tNMElDQUFDQUJJQVEyQWhnZ0FTQUJOZ0lJSUFFZ0FUWUNEQXdCQ3lBQVFRQkJHU0FDUVFGMmF5QUNRUjlHRzNRaEFpQUVLQUlBSVFZQ1FBTkFJQVlpQkNnQ0JFRjRjU0FBUmcwQklBSkJIWFloQmlBQ1FRRjBJUUlnQkNBR1FRUnhha0VRYWlJREtBSUFJZ1lOQUFzZ0F5QUJOZ0lBSUFFZ0JEWUNHQ0FCSUFFMkFnd2dBU0FCTmdJSURBRUxJQVFvQWdnaUFDQUJOZ0lNSUFRZ0FUWUNDQ0FCUVFBMkFoZ2dBU0FFTmdJTUlBRWdBRFlDQ0F0QkFFRUFLQUtvMElDQUFFRi9haUlCUVg4Z0FSczJBcWpRZ0lBQUN3c0VBQUFBQzA0QUFrQWdBQTBBUHdCQkVIUVBDd0pBSUFCQi8vOERjUTBBSUFCQmYwd05BQUpBSUFCQkVIWkFBQ0lBUVg5SERRQkJBRUV3TmdMNDA0Q0FBRUYvRHdzZ0FFRVFkQThMRU1xQWdJQUFBQXZ5QWdJRGZ3RitBa0FnQWtVTkFDQUFJQUU2QUFBZ0FpQUFhaUlEUVg5cUlBRTZBQUFnQWtFRFNRMEFJQUFnQVRvQUFpQUFJQUU2QUFFZ0EwRjlhaUFCT2dBQUlBTkJmbW9nQVRvQUFDQUNRUWRKRFFBZ0FDQUJPZ0FESUFOQmZHb2dBVG9BQUNBQ1FRbEpEUUFnQUVFQUlBQnJRUU54SWdScUlnTWdBVUgvQVhGQmdZS0VDR3dpQVRZQ0FDQURJQUlnQkd0QmZIRWlCR29pQWtGOGFpQUJOZ0lBSUFSQkNVa05BQ0FESUFFMkFnZ2dBeUFCTmdJRUlBSkJlR29nQVRZQ0FDQUNRWFJxSUFFMkFnQWdCRUVaU1EwQUlBTWdBVFlDR0NBRElBRTJBaFFnQXlBQk5nSVFJQU1nQVRZQ0RDQUNRWEJxSUFFMkFnQWdBa0ZzYWlBQk5nSUFJQUpCYUdvZ0FUWUNBQ0FDUVdScUlBRTJBZ0FnQkNBRFFRUnhRUmh5SWdWcklnSkJJRWtOQUNBQnJVS0JnSUNBRUg0aEJpQURJQVZxSVFFRFFDQUJJQVkzQXhnZ0FTQUdOd01RSUFFZ0JqY0RDQ0FCSUFZM0F3QWdBVUVnYWlFQklBSkJZR29pQWtFZlN3MEFDd3NnQUFzTGprZ0JBRUdBQ0F1R1NBRUFBQUFDQUFBQUF3QUFBQUFBQUFBQUFBQUFCQUFBQUFVQUFBQUFBQUFBQUFBQUFBWUFBQUFIQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFTVzUyWVd4cFpDQmphR0Z5SUdsdUlIVnliQ0J4ZFdWeWVRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgySnZaSGtBUTI5dWRHVnVkQzFNWlc1bmRHZ2diM1psY21ac2IzY0FRMmgxYm1zZ2MybDZaU0J2ZG1WeVpteHZkd0JTWlhOd2IyNXpaU0J2ZG1WeVpteHZkd0JKYm5aaGJHbGtJRzFsZEdodlpDQm1iM0lnU0ZSVVVDOTRMbmdnY21WeGRXVnpkQUJKYm5aaGJHbGtJRzFsZEdodlpDQm1iM0lnVWxSVFVDOTRMbmdnY21WeGRXVnpkQUJGZUhCbFkzUmxaQ0JUVDFWU1EwVWdiV1YwYUc5a0lHWnZjaUJKUTBVdmVDNTRJSEpsY1hWbGMzUUFTVzUyWVd4cFpDQmphR0Z5SUdsdUlIVnliQ0JtY21GbmJXVnVkQ0J6ZEdGeWRBQkZlSEJsWTNSbFpDQmtiM1FBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDl6ZEdGMGRYTUFTVzUyWVd4cFpDQnlaWE53YjI1elpTQnpkR0YwZFhNQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN3QlZjMlZ5SUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5eVpYTmxkR0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJOb2RXNXJYMmhsWVdSbGNtQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMjFsYzNOaFoyVmZZbVZuYVc1Z0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmRtRnNkV1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5emRHRjBkWE5mWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5MlpYSnphVzl1WDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmRYSnNYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlvWldGa1pYSmZkbUZzZFdWZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXRaWE56WVdkbFgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZiV1YwYUc5a1gyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZhR1ZoWkdWeVgyWnBaV3hrWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDI1aGJXVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFGVnVaWGh3WldOMFpXUWdZMmhoY2lCcGJpQjFjbXdnYzJWeWRtVnlBRWx1ZG1Gc2FXUWdhR1ZoWkdWeUlIWmhiSFZsSUdOb1lYSUFTVzUyWVd4cFpDQm9aV0ZrWlhJZ1ptbGxiR1FnWTJoaGNnQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgzWmxjbk5wYjI0QVNXNTJZV3hwWkNCdGFXNXZjaUIyWlhKemFXOXVBRWx1ZG1Gc2FXUWdiV0ZxYjNJZ2RtVnljMmx2YmdCRmVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQjJaWEp6YVc5dUFFVjRjR1ZqZEdWa0lFTlNURVlnWVdaMFpYSWdkbVZ5YzJsdmJnQkpiblpoYkdsa0lFaFVWRkFnZG1WeWMybHZiZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQjBiMnRsYmdCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDNWeWJBQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNuTWdhVzRnZFhKc0FGVnVaWGh3WldOMFpXUWdjM1JoY25RZ1kyaGhjaUJwYmlCMWNtd0FSRzkxWW14bElFQWdhVzRnZFhKc0FFVnRjSFI1SUVOdmJuUmxiblF0VEdWdVozUm9BRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUVOdmJuUmxiblF0VEdWdVozUm9BRVIxY0d4cFkyRjBaU0JEYjI1MFpXNTBMVXhsYm1kMGFBQkpiblpoYkdsa0lHTm9ZWElnYVc0Z2RYSnNJSEJoZEdnQVEyOXVkR1Z1ZEMxTVpXNW5kR2dnWTJGdUozUWdZbVVnY0hKbGMyVnVkQ0IzYVhSb0lGUnlZVzV6Wm1WeUxVVnVZMjlrYVc1bkFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklITnBlbVVBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlvWldGa1pYSmZkbUZzZFdVQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmZG1Gc2RXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUIyWVd4MVpRQk5hWE56YVc1bklHVjRjR1ZqZEdWa0lFeEdJR0ZtZEdWeUlHaGxZV1JsY2lCMllXeDFaUUJKYm5aaGJHbGtJR0JVY21GdWMyWmxjaTFGYm1OdlpHbHVaMkFnYUdWaFpHVnlJSFpoYkhWbEFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTWdjWFZ2ZEdVZ2RtRnNkV1VBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3lCeGRXOTBaV1FnZG1Gc2RXVUFVR0YxYzJWa0lHSjVJRzl1WDJobFlXUmxjbk5mWTI5dGNHeGxkR1VBU1c1MllXeHBaQ0JGVDBZZ2MzUmhkR1VBYjI1ZmNtVnpaWFFnY0dGMWMyVUFiMjVmWTJoMWJtdGZhR1ZoWkdWeUlIQmhkWE5sQUc5dVgyMWxjM05oWjJWZlltVm5hVzRnY0dGMWMyVUFiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYM1poYkhWbElIQmhkWE5sQUc5dVgzTjBZWFIxYzE5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5MlpYSnphVzl1WDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDNWeWJGOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOWphSFZ1YTE5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5b1pXRmtaWEpmZG1Gc2RXVmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOXRaWFJvYjJSZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmFHVmhaR1Z5WDJacFpXeGtYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOXVZVzFsSUhCaGRYTmxBRlZ1Wlhod1pXTjBaV1FnYzNCaFkyVWdZV1owWlhJZ2MzUmhjblFnYkdsdVpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5dVlXMWxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nYm1GdFpRQlFZWFZ6WlNCdmJpQkRUMDVPUlVOVUwxVndaM0poWkdVQVVHRjFjMlVnYjI0Z1VGSkpMMVZ3WjNKaFpHVUFSWGh3WldOMFpXUWdTRlJVVUM4eUlFTnZibTVsWTNScGIyNGdVSEpsWm1GalpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyMWxkR2h2WkFCRmVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQnRaWFJvYjJRQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5b1pXRmtaWEpmWm1sbGJHUUFVR0YxYzJWa0FFbHVkbUZzYVdRZ2QyOXlaQ0JsYm1OdmRXNTBaWEpsWkFCSmJuWmhiR2xrSUcxbGRHaHZaQ0JsYm1OdmRXNTBaWEpsWkFCVmJtVjRjR1ZqZEdWa0lHTm9ZWElnYVc0Z2RYSnNJSE5qYUdWdFlRQlNaWEYxWlhOMElHaGhjeUJwYm5aaGJHbGtJR0JVY21GdWMyWmxjaTFGYm1OdlpHbHVaMkFBVTFkSlZFTklYMUJTVDFoWkFGVlRSVjlRVWs5WVdRQk5TMEZEVkVsV1NWUlpBRlZPVUZKUFEwVlRVMEZDVEVWZlJVNVVTVlJaQUVOUFVGa0FUVTlXUlVSZlVFVlNUVUZPUlU1VVRGa0FWRTlQWDBWQlVreFpBRTVQVkVsR1dRQkdRVWxNUlVSZlJFVlFSVTVFUlU1RFdRQkNRVVJmUjBGVVJWZEJXUUJRVEVGWkFGQlZWQUJEU0VWRFMwOVZWQUJIUVZSRlYwRlpYMVJKVFVWUFZWUUFVa1ZSVlVWVFZGOVVTVTFGVDFWVUFFNUZWRmRQVWt0ZlEwOU9Ua1ZEVkY5VVNVMUZUMVZVQUVOUFRrNUZRMVJKVDA1ZlZFbE5SVTlWVkFCTVQwZEpUbDlVU1UxRlQxVlVBRTVGVkZkUFVrdGZVa1ZCUkY5VVNVMUZUMVZVQUZCUFUxUUFUVWxUUkVsU1JVTlVSVVJmVWtWUlZVVlRWQUJEVEVsRlRsUmZRMHhQVTBWRVgxSkZVVlZGVTFRQVEweEpSVTVVWDBOTVQxTkZSRjlNVDBGRVgwSkJURUZPUTBWRVgxSkZVVlZGVTFRQVFrRkVYMUpGVVZWRlUxUUFTRlJVVUY5U1JWRlZSVk5VWDFORlRsUmZWRTlmU0ZSVVVGTmZVRTlTVkFCU1JWQlBVbFFBU1UxZlFWOVVSVUZRVDFRQVVrVlRSVlJmUTA5T1ZFVk9WQUJPVDE5RFQwNVVSVTVVQUZCQlVsUkpRVXhmUTA5T1ZFVk9WQUJJVUVWZlNVNVdRVXhKUkY5RFQwNVRWRUZPVkFCSVVFVmZRMEpmVWtWVFJWUUFSMFZVQUVoUVJWOVRWRkpKUTFRQVEwOU9Sa3hKUTFRQVZFVk5VRTlTUVZKWlgxSkZSRWxTUlVOVUFGQkZVazFCVGtWT1ZGOVNSVVJKVWtWRFZBQkRUMDVPUlVOVUFFMVZURlJKWDFOVVFWUlZVd0JJVUVWZlNVNVdRVXhKUkY5VFZFRlVWVk1BVkU5UFgwMUJUbGxmVWtWUlZVVlRWRk1BUlVGU1RGbGZTRWxPVkZNQVZVNUJWa0ZKVEVGQ1RFVmZSazlTWDB4RlIwRk1YMUpGUVZOUFRsTUFUMUJVU1U5T1V3QlRWMGxVUTBoSlRrZGZVRkpQVkU5RFQweFRBRlpCVWtsQlRsUmZRVXhUVDE5T1JVZFBWRWxCVkVWVEFFMVZURlJKVUV4RlgwTklUMGxEUlZNQVNVNVVSVkpPUVV4ZlUwVlNWa1ZTWDBWU1VrOVNBRmRGUWw5VFJWSldSVkpmVlU1TFRrOVhUbDlGVWxKUFVnQlNRVWxNUjFWT1gwVlNVazlTQUVsRVJVNVVTVlJaWDFCU1QxWkpSRVZTWDBGVlZFaEZUbFJKUTBGVVNVOU9YMFZTVWs5U0FGTlRURjlEUlZKVVNVWkpRMEZVUlY5RlVsSlBVZ0JKVGxaQlRFbEVYMWhmUms5U1YwRlNSRVZFWDBaUFVnQlRSVlJmVUVGU1FVMUZWRVZTQUVkRlZGOVFRVkpCVFVWVVJWSUFTRkJGWDFWVFJWSUFVMFZGWDA5VVNFVlNBRWhRUlY5RFFsOURTRlZPUzE5SVJVRkVSVklBVFV0RFFVeEZUa1JCVWdCVFJWUlZVQUJYUlVKZlUwVlNWa1ZTWDBsVFgwUlBWMDRBVkVWQlVrUlBWMDRBU0ZCRlgwTk1UMU5GUkY5RFQwNU9SVU5VU1U5T0FFaEZWVkpKVTFSSlExOUZXRkJKVWtGVVNVOU9BRVJKVTBOUFRrNUZRMVJGUkY5UFVFVlNRVlJKVDA0QVRrOU9YMEZWVkVoUFVrbFVRVlJKVmtWZlNVNUdUMUpOUVZSSlQwNEFTRkJGWDBsT1ZrRk1TVVJmVmtWU1UwbFBUZ0JJVUVWZlEwSmZUVVZUVTBGSFJWOUNSVWRKVGdCVFNWUkZYMGxUWDBaU1QxcEZUZ0JJVUVWZlNVNVdRVXhKUkY5SVJVRkVSVkpmVkU5TFJVNEFTVTVXUVV4SlJGOVVUMHRGVGdCR1QxSkNTVVJFUlU0QVJVNUlRVTVEUlY5WlQxVlNYME5CVEUwQVNGQkZYMGxPVmtGTVNVUmZWVkpNQUVKTVQwTkxSVVJmUWxsZlVFRlNSVTVVUVV4ZlEwOU9WRkpQVEFCTlMwTlBUQUJCUTB3QVNGQkZYMGxPVkVWU1RrRk1BRkpGVVZWRlUxUmZTRVZCUkVWU1gwWkpSVXhFVTE5VVQwOWZURUZTUjBWZlZVNVBSa1pKUTBsQlRBQklVRVZmVDBzQVZVNU1TVTVMQUZWT1RFOURTd0JRVWtrQVVrVlVVbGxmVjBsVVNBQklVRVZmU1U1V1FVeEpSRjlEVDA1VVJVNVVYMHhGVGtkVVNBQklVRVZmVlU1RldGQkZRMVJGUkY5RFQwNVVSVTVVWDB4RlRrZFVTQUJHVEZWVFNBQlFVazlRVUVGVVEwZ0FUUzFUUlVGU1EwZ0FWVkpKWDFSUFQxOU1UMDVIQUZCU1QwTkZVMU5KVGtjQVRVbFRRMFZNVEVGT1JVOVZVMTlRUlZKVFNWTlVSVTVVWDFkQlVrNUpUa2NBVFVsVFEwVk1URUZPUlU5VlUxOVhRVkpPU1U1SEFFaFFSVjlKVGxaQlRFbEVYMVJTUVU1VFJrVlNYMFZPUTA5RVNVNUhBRVY0Y0dWamRHVmtJRU5TVEVZQVNGQkZYMGxPVmtGTVNVUmZRMGhWVGt0ZlUwbGFSUUJOVDFaRkFFTlBUbFJKVGxWRkFFaFFSVjlEUWw5VFZFRlVWVk5mUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMGhGUVVSRlVsTmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gxWkZVbE5KVDA1ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDFWU1RGOURUMDFRVEVWVVJRQklVRVZmUTBKZlEwaFZUa3RmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMGhGUVVSRlVsOVdRVXhWUlY5RFQwMVFURVZVUlFCSVVFVmZRMEpmUTBoVlRrdGZSVmhVUlU1VFNVOU9YMVpCVEZWRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5RFNGVk9TMTlGV0ZSRlRsTkpUMDVmVGtGTlJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlRVVlRVMEZIUlY5RFQwMVFURVZVUlFCSVVFVmZRMEpmVFVWVVNFOUVYME5QVFZCTVJWUkZBRWhRUlY5RFFsOUlSVUZFUlZKZlJrbEZURVJmUTA5TlVFeEZWRVVBUkVWTVJWUkZBRWhRUlY5SlRsWkJURWxFWDBWUFJsOVRWRUZVUlFCSlRsWkJURWxFWDFOVFRGOURSVkpVU1VaSlEwRlVSUUJRUVZWVFJRQk9UMTlTUlZOUVQwNVRSUUJWVGxOVlVGQlBVbFJGUkY5TlJVUkpRVjlVV1ZCRkFFZFBUa1VBVGs5VVgwRkRRMFZRVkVGQ1RFVUFVMFZTVmtsRFJWOVZUa0ZXUVVsTVFVSk1SUUJTUVU1SFJWOU9UMVJmVTBGVVNWTkdTVUZDVEVVQVQxSkpSMGxPWDBsVFgxVk9Va1ZCUTBoQlFreEZBRkpGVTFCUFRsTkZYMGxUWDFOVVFVeEZBRkJWVWtkRkFFMUZVa2RGQUZKRlVWVkZVMVJmU0VWQlJFVlNYMFpKUlV4RVUxOVVUMDlmVEVGU1IwVUFVa1ZSVlVWVFZGOUlSVUZFUlZKZlZFOVBYMHhCVWtkRkFGQkJXVXhQUVVSZlZFOVBYMHhCVWtkRkFFbE9VMVZHUmtsRFNVVk9WRjlUVkU5U1FVZEZBRWhRUlY5UVFWVlRSVVJmVlZCSFVrRkVSUUJJVUVWZlVFRlZVMFZFWDBneVgxVlFSMUpCUkVVQVUwOVZVa05GQUVGT1RrOVZUa05GQUZSU1FVTkZBRWhRUlY5VlRrVllVRVZEVkVWRVgxTlFRVU5GQUVSRlUwTlNTVUpGQUZWT1UxVkNVME5TU1VKRkFGSkZRMDlTUkFCSVVFVmZTVTVXUVV4SlJGOU5SVlJJVDBRQVRrOVVYMFpQVlU1RUFGQlNUMUJHU1U1RUFGVk9Ra2xPUkFCU1JVSkpUa1FBVlU1QlZWUklUMUpKV2tWRUFFMUZWRWhQUkY5T1QxUmZRVXhNVDFkRlJBQklWRlJRWDFaRlVsTkpUMDVmVGs5VVgxTlZVRkJQVWxSRlJBQkJURkpGUVVSWlgxSkZVRTlTVkVWRUFFRkRRMFZRVkVWRUFFNVBWRjlKVFZCTVJVMUZUbFJGUkFCTVQwOVFYMFJGVkVWRFZFVkVBRWhRUlY5RFVsOUZXRkJGUTFSRlJBQklVRVZmVEVaZlJWaFFSVU5VUlVRQVExSkZRVlJGUkFCSlRWOVZVMFZFQUVoUVJWOVFRVlZUUlVRQVZFbE5SVTlWVkY5UFEwTlZVa1ZFQUZCQldVMUZUbFJmVWtWUlZVbFNSVVFBVUZKRlEwOU9SRWxVU1U5T1gxSkZVVlZKVWtWRUFGQlNUMWhaWDBGVlZFaEZUbFJKUTBGVVNVOU9YMUpGVVZWSlVrVkVBRTVGVkZkUFVrdGZRVlZVU0VWT1ZFbERRVlJKVDA1ZlVrVlJWVWxTUlVRQVRFVk9SMVJJWDFKRlVWVkpVa1ZFQUZOVFRGOURSVkpVU1VaSlEwRlVSVjlTUlZGVlNWSkZSQUJWVUVkU1FVUkZYMUpGVVZWSlVrVkVBRkJCUjBWZlJWaFFTVkpGUkFCUVVrVkRUMDVFU1ZSSlQwNWZSa0ZKVEVWRUFFVllVRVZEVkVGVVNVOU9YMFpCU1V4RlJBQlNSVlpCVEVsRVFWUkpUMDVmUmtGSlRFVkVBRk5UVEY5SVFVNUVVMGhCUzBWZlJrRkpURVZFQUV4UFEwdEZSQUJVVWtGT1UwWlBVazFCVkVsUFRsOUJVRkJNU1VWRUFFNVBWRjlOVDBSSlJrbEZSQUJPVDFSZlJWaFVSVTVFUlVRQVFrRk9SRmRKUkZSSVgweEpUVWxVWDBWWVEwVkZSRVZFQUZOSlZFVmZTVk5mVDFaRlVreFBRVVJGUkFCSVJVRkVBRVY0Y0dWamRHVmtJRWhVVkZBdkFBQmVFd0FBSmhNQUFEQVFBQUR3RndBQW5STUFBQlVTQUFBNUZ3QUE4QklBQUFvUUFBQjFFZ0FBclJJQUFJSVRBQUJQRkFBQWZ4QUFBS0FWQUFBakZBQUFpUklBQUlzVUFBQk5GUUFBMUJFQUFNOFVBQUFRR0FBQXlSWUFBTndXQUFEQkVRQUE0QmNBQUxzVUFBQjBGQUFBZkJVQUFPVVVBQUFJRndBQUh4QUFBR1VWQUFDakZBQUFLQlVBQUFJVkFBQ1pGUUFBTEJBQUFJc1pBQUJQRHdBQTFBNEFBR29RQUFET0VBQUFBaGNBQUlrT0FBQnVFd0FBSEJNQUFHWVVBQUJXRndBQXdSTUFBTTBUQUFCc0V3QUFhQmNBQUdZWEFBQmZGd0FBSWhNQUFNNFBBQUJwRGdBQTJBNEFBR01XQUFETEV3QUFxZzRBQUNnWEFBQW1Gd0FBeFJNQUFGMFdBQURvRVFBQVp4TUFBR1VUQUFEeUZnQUFjeE1BQUIwWEFBRDVGZ0FBOHhFQUFNOE9BQURPRlFBQURCSUFBTE1SQUFDbEVRQUFZUkFBQURJWEFBQzdFd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUJBZ0VCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWdNQ0FnSUNBZ0FBQWdJQUFnSUFBZ0lDQWdJQ0FnSUNBZ0FFQUFBQUFBQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUFBQUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFJQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSUFBZ0lDQWdJQUFBSUNBQUlDQUFJQ0FnSUNBZ0lDQWdJQUF3QUVBQUFBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQUFBQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUNBQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCc2IzTmxaV1Z3TFdGc2FYWmxBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFFQkFRRUJBUUVCQVFFQkFnRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUZqYUhWdWEyVmtBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFRQUJBUUVCQVFBQUFRRUFBUUVBQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdWamRHbHZibVZ1ZEMxc1pXNW5kR2h2Ym5KdmVIa3RZMjl1Ym1WamRHbHZiZ0FBQUFBQUFBQUFBQUFBQUFBQUFISmhibk5tWlhJdFpXNWpiMlJwYm1kd1ozSmhaR1VOQ2cwS0RRcFRUUTBLRFFwVVZGQXZRMFV2VkZOUUx3QUFBQUFBQUFBQUFBQUFBQUVDQUFFREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQUFBQkFnQUJBd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFCQVFVQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUFBQUFBQUFBQUFBUUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFBQUFBQkFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd1FBQUFRRUJBUUVCQVFFQkFRRUJRUUVCQVFFQkFRRUJBUUVCQUFFQUFZSEJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUFCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBZ0FBQUFBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdBQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFNVBWVTVEUlVWRFMwOVZWRTVGUTFSRlZFVkRVa2xDUlV4VlUwaEZWRVZCUkZORlFWSkRTRkpIUlVOVVNWWkpWRmxNUlU1RVFWSldSVTlVU1VaWlVGUkpUMDVUUTBoVFJVRlpVMVJCVkVOSVIwVlBVa1JKVWtWRFZFOVNWRkpEU0ZCQlVrRk5SVlJGVWxWU1EwVkNVME5TU1VKRlFWSkVUMWRPUVVORlNVNUVUa3REUzFWQ1UwTlNTVUpGU0ZSVVVDOUJSRlJRTHc9PSdcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUFHIiwiZmlsZSI6Iihyc2MpLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9sbGh0dHBfc2ltZC13YXNtLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/llhttp/utils.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/llhttp/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.enumToMap = void 0;\nfunction enumToMap(obj) {\n    const res = {};\n    Object.keys(obj).forEach((key)=>{\n        const value = obj[key];\n        if (typeof value === \"number\") {\n            res[key] = value;\n        }\n    });\n    return res;\n}\nexports.enumToMap = enumToMap; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLFNBQVNFLFVBQVVDLEdBQUc7SUFDbEIsTUFBTUMsTUFBTSxDQUFDO0lBQ2JOLE9BQU9PLElBQUksQ0FBQ0YsS0FBS0csT0FBTyxDQUFDLENBQUNDO1FBQ3RCLE1BQU1OLFFBQVFFLEdBQUcsQ0FBQ0ksSUFBSTtRQUN0QixJQUFJLE9BQU9OLFVBQVUsVUFBVTtZQUMzQkcsR0FBRyxDQUFDRyxJQUFJLEdBQUdOO1FBQ2Y7SUFDSjtJQUNBLE9BQU9HO0FBQ1g7QUFDQUosaUJBQWlCLEdBQUdFLFdBQ3BCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL3V0aWxzLmpzP2VhYWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVudW1Ub01hcCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGVudW1Ub01hcChvYmopIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmVudW1Ub01hcCA9IGVudW1Ub01hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1Ub01hcCIsIm9iaiIsInJlcyIsImtleXMiLCJmb3JFYWNoIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/llhttp/utils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/mock/mock-agent.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-agent.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kClients } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst Agent = __webpack_require__(/*! ../agent */ \"(rsc)/../../node_modules/undici/lib/agent.js\");\nconst { kAgent, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/../../node_modules/undici/lib/mock/mock-symbols.js\");\nconst MockClient = __webpack_require__(/*! ./mock-client */ \"(rsc)/../../node_modules/undici/lib/mock/mock-client.js\");\nconst MockPool = __webpack_require__(/*! ./mock-pool */ \"(rsc)/../../node_modules/undici/lib/mock/mock-pool.js\");\nconst { matchValue, buildMockOptions } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/../../node_modules/undici/lib/mock/mock-utils.js\");\nconst { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst Dispatcher = __webpack_require__(/*! ../dispatcher */ \"(rsc)/../../node_modules/undici/lib/dispatcher.js\");\nconst Pluralizer = __webpack_require__(/*! ./pluralizer */ \"(rsc)/../../node_modules/undici/lib/mock/pluralizer.js\");\nconst PendingInterceptorsFormatter = __webpack_require__(/*! ./pending-interceptors-formatter */ \"(rsc)/../../node_modules/undici/lib/mock/pending-interceptors-formatter.js\");\nclass FakeWeakRef {\n    constructor(value){\n        this.value = value;\n    }\n    deref() {\n        return this.value;\n    }\n}\nclass MockAgent extends Dispatcher {\n    constructor(opts){\n        super(opts);\n        this[kNetConnect] = true;\n        this[kIsMockActive] = true;\n        // Instantiate Agent and encapsulate\n        if (opts && opts.agent && typeof opts.agent.dispatch !== \"function\") {\n            throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        const agent = opts && opts.agent ? opts.agent : new Agent(opts);\n        this[kAgent] = agent;\n        this[kClients] = agent[kClients];\n        this[kOptions] = buildMockOptions(opts);\n    }\n    get(origin) {\n        let dispatcher = this[kMockAgentGet](origin);\n        if (!dispatcher) {\n            dispatcher = this[kFactory](origin);\n            this[kMockAgentSet](origin, dispatcher);\n        }\n        return dispatcher;\n    }\n    dispatch(opts, handler) {\n        // Call MockAgent.get to perform additional setup before dispatching as normal\n        this.get(opts.origin);\n        return this[kAgent].dispatch(opts, handler);\n    }\n    async close() {\n        await this[kAgent].close();\n        this[kClients].clear();\n    }\n    deactivate() {\n        this[kIsMockActive] = false;\n    }\n    activate() {\n        this[kIsMockActive] = true;\n    }\n    enableNetConnect(matcher) {\n        if (typeof matcher === \"string\" || typeof matcher === \"function\" || matcher instanceof RegExp) {\n            if (Array.isArray(this[kNetConnect])) {\n                this[kNetConnect].push(matcher);\n            } else {\n                this[kNetConnect] = [\n                    matcher\n                ];\n            }\n        } else if (typeof matcher === \"undefined\") {\n            this[kNetConnect] = true;\n        } else {\n            throw new InvalidArgumentError(\"Unsupported matcher. Must be one of String|Function|RegExp.\");\n        }\n    }\n    disableNetConnect() {\n        this[kNetConnect] = false;\n    }\n    // This is required to bypass issues caused by using global symbols - see:\n    // https://github.com/nodejs/undici/issues/1447\n    get isMockActive() {\n        return this[kIsMockActive];\n    }\n    [kMockAgentSet](origin, dispatcher) {\n        this[kClients].set(origin, new FakeWeakRef(dispatcher));\n    }\n    [kFactory](origin) {\n        const mockOptions = Object.assign({\n            agent: this\n        }, this[kOptions]);\n        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);\n    }\n    [kMockAgentGet](origin) {\n        // First check if we can immediately find it\n        const ref = this[kClients].get(origin);\n        if (ref) {\n            return ref.deref();\n        }\n        // If the origin is not a string create a dummy parent pool and return to user\n        if (typeof origin !== \"string\") {\n            const dispatcher = this[kFactory](\"http://localhost:9999\");\n            this[kMockAgentSet](origin, dispatcher);\n            return dispatcher;\n        }\n        // If we match, create a pool and assign the same dispatches\n        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])){\n            const nonExplicitDispatcher = nonExplicitRef.deref();\n            if (nonExplicitDispatcher && typeof keyMatcher !== \"string\" && matchValue(keyMatcher, origin)) {\n                const dispatcher = this[kFactory](origin);\n                this[kMockAgentSet](origin, dispatcher);\n                dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];\n                return dispatcher;\n            }\n        }\n    }\n    [kGetNetConnect]() {\n        return this[kNetConnect];\n    }\n    pendingInterceptors() {\n        const mockAgentClients = this[kClients];\n        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope])=>scope.deref()[kDispatches].map((dispatch)=>({\n                    ...dispatch,\n                    origin\n                }))).filter(({ pending })=>pending);\n    }\n    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n        const pending = this.pendingInterceptors();\n        if (pending.length === 0) {\n            return;\n        }\n        const pluralizer = new Pluralizer(\"interceptor\", \"interceptors\").pluralize(pending.length);\n        throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim());\n    }\n}\nmodule.exports = MockAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxRQUFRLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDN0IsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDdEIsTUFBTSxFQUNKRSxNQUFNLEVBQ05DLGFBQWEsRUFDYkMsYUFBYSxFQUNiQyxXQUFXLEVBQ1hDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxjQUFjLEVBQ2RDLFFBQVEsRUFDUkMsUUFBUSxFQUNULEdBQUdWLG1CQUFPQSxDQUFDO0FBQ1osTUFBTVcsYUFBYVgsbUJBQU9BLENBQUM7QUFDM0IsTUFBTVksV0FBV1osbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUFFYSxVQUFVLEVBQUVDLGdCQUFnQixFQUFFLEdBQUdkLG1CQUFPQSxDQUFDO0FBQ2pELE1BQU0sRUFBRWUsb0JBQW9CLEVBQUVDLFdBQVcsRUFBRSxHQUFHaEIsbUJBQU9BLENBQUM7QUFDdEQsTUFBTWlCLGFBQWFqQixtQkFBT0EsQ0FBQztBQUMzQixNQUFNa0IsYUFBYWxCLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1tQiwrQkFBK0JuQixtQkFBT0EsQ0FBQztBQUU3QyxNQUFNb0I7SUFDSkMsWUFBYUMsS0FBSyxDQUFFO1FBQ2xCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNmO0lBRUFDLFFBQVM7UUFDUCxPQUFPLElBQUksQ0FBQ0QsS0FBSztJQUNuQjtBQUNGO0FBRUEsTUFBTUUsa0JBQWtCUDtJQUN0QkksWUFBYUksSUFBSSxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFFTixJQUFJLENBQUNsQixZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDRCxjQUFjLEdBQUc7UUFFdEIsb0NBQW9DO1FBQ3BDLElBQUttQixRQUFRQSxLQUFLQyxLQUFLLElBQUksT0FBT0QsS0FBS0MsS0FBSyxDQUFDQyxRQUFRLEtBQUssWUFBYTtZQUNyRSxNQUFN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QUFZLENBQUM7QUFDM0IsRUFBRWlELFdBQVdFLEtBQUssQ0FBQyxDQUFDLEVBQUVGLFdBQVdHLElBQUksQ0FBQyxDQUFDLEVBQUVILFdBQVdJLEVBQUUsQ0FBQzs7QUFFdkQsRUFBRU4sNkJBQTZCTyxNQUFNLENBQUNULFNBQVM7QUFDL0MsQ0FBQyxDQUFDVSxJQUFJO0lBQ0o7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdqRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWFnZW50LmpzP2M0MmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga0NsaWVudHMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4uL2FnZW50JylcbmNvbnN0IHtcbiAga0FnZW50LFxuICBrTW9ja0FnZW50U2V0LFxuICBrTW9ja0FnZW50R2V0LFxuICBrRGlzcGF0Y2hlcyxcbiAga0lzTW9ja0FjdGl2ZSxcbiAga05ldENvbm5lY3QsXG4gIGtHZXROZXRDb25uZWN0LFxuICBrT3B0aW9ucyxcbiAga0ZhY3Rvcnlcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCBNb2NrQ2xpZW50ID0gcmVxdWlyZSgnLi9tb2NrLWNsaWVudCcpXG5jb25zdCBNb2NrUG9vbCA9IHJlcXVpcmUoJy4vbW9jay1wb29sJylcbmNvbnN0IHsgbWF0Y2hWYWx1ZSwgYnVpbGRNb2NrT3B0aW9ucyB9ID0gcmVxdWlyZSgnLi9tb2NrLXV0aWxzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFVuZGljaUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlcicpXG5jb25zdCBQbHVyYWxpemVyID0gcmVxdWlyZSgnLi9wbHVyYWxpemVyJylcbmNvbnN0IFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIgPSByZXF1aXJlKCcuL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlcicpXG5cbmNsYXNzIEZha2VXZWFrUmVmIHtcbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICBkZXJlZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxufVxuXG5jbGFzcyBNb2NrQWdlbnQgZXh0ZW5kcyBEaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuXG4gICAgdGhpc1trTmV0Q29ubmVjdF0gPSB0cnVlXG4gICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IHRydWVcblxuICAgIC8vIEluc3RhbnRpYXRlIEFnZW50IGFuZCBlbmNhcHN1bGF0ZVxuICAgIGlmICgob3B0cyAmJiBvcHRzLmFnZW50ICYmIHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50JylcbiAgICB9XG4gICAgY29uc3QgYWdlbnQgPSBvcHRzICYmIG9wdHMuYWdlbnQgPyBvcHRzLmFnZW50IDogbmV3IEFnZW50KG9wdHMpXG4gICAgdGhpc1trQWdlbnRdID0gYWdlbnRcblxuICAgIHRoaXNba0NsaWVudHNdID0gYWdlbnRba0NsaWVudHNdXG4gICAgdGhpc1trT3B0aW9uc10gPSBidWlsZE1vY2tPcHRpb25zKG9wdHMpXG4gIH1cblxuICBnZXQgKG9yaWdpbikge1xuICAgIGxldCBkaXNwYXRjaGVyID0gdGhpc1trTW9ja0FnZW50R2V0XShvcmlnaW4pXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcmlnaW4pXG4gICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICB9XG4gICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgLy8gQ2FsbCBNb2NrQWdlbnQuZ2V0IHRvIHBlcmZvcm0gYWRkaXRpb25hbCBzZXR1cCBiZWZvcmUgZGlzcGF0Y2hpbmcgYXMgbm9ybWFsXG4gICAgdGhpcy5nZXQob3B0cy5vcmlnaW4pXG4gICAgcmV0dXJuIHRoaXNba0FnZW50XS5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9XG5cbiAgYXN5bmMgY2xvc2UgKCkge1xuICAgIGF3YWl0IHRoaXNba0FnZW50XS5jbG9zZSgpXG4gICAgdGhpc1trQ2xpZW50c10uY2xlYXIoKVxuICB9XG5cbiAgZGVhY3RpdmF0ZSAoKSB7XG4gICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IGZhbHNlXG4gIH1cblxuICBhY3RpdmF0ZSAoKSB7XG4gICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IHRydWVcbiAgfVxuXG4gIGVuYWJsZU5ldENvbm5lY3QgKG1hdGNoZXIpIHtcbiAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBtYXRjaGVyID09PSAnZnVuY3Rpb24nIHx8IG1hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXNba05ldENvbm5lY3RdKSkge1xuICAgICAgICB0aGlzW2tOZXRDb25uZWN0XS5wdXNoKG1hdGNoZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW2tOZXRDb25uZWN0XSA9IFttYXRjaGVyXVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2tOZXRDb25uZWN0XSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdVbnN1cHBvcnRlZCBtYXRjaGVyLiBNdXN0IGJlIG9uZSBvZiBTdHJpbmd8RnVuY3Rpb258UmVnRXhwLicpXG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZU5ldENvbm5lY3QgKCkge1xuICAgIHRoaXNba05ldENvbm5lY3RdID0gZmFsc2VcbiAgfVxuXG4gIC8vIFRoaXMgaXMgcmVxdWlyZWQgdG8gYnlwYXNzIGlzc3VlcyBjYXVzZWQgYnkgdXNpbmcgZ2xvYmFsIHN5bWJvbHMgLSBzZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNDQ3XG4gIGdldCBpc01vY2tBY3RpdmUgKCkge1xuICAgIHJldHVybiB0aGlzW2tJc01vY2tBY3RpdmVdXG4gIH1cblxuICBba01vY2tBZ2VudFNldF0gKG9yaWdpbiwgZGlzcGF0Y2hlcikge1xuICAgIHRoaXNba0NsaWVudHNdLnNldChvcmlnaW4sIG5ldyBGYWtlV2Vha1JlZihkaXNwYXRjaGVyKSlcbiAgfVxuXG4gIFtrRmFjdG9yeV0gKG9yaWdpbikge1xuICAgIGNvbnN0IG1vY2tPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGFnZW50OiB0aGlzIH0sIHRoaXNba09wdGlvbnNdKVxuICAgIHJldHVybiB0aGlzW2tPcHRpb25zXSAmJiB0aGlzW2tPcHRpb25zXS5jb25uZWN0aW9ucyA9PT0gMVxuICAgICAgPyBuZXcgTW9ja0NsaWVudChvcmlnaW4sIG1vY2tPcHRpb25zKVxuICAgICAgOiBuZXcgTW9ja1Bvb2wob3JpZ2luLCBtb2NrT3B0aW9ucylcbiAgfVxuXG4gIFtrTW9ja0FnZW50R2V0XSAob3JpZ2luKSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UgY2FuIGltbWVkaWF0ZWx5IGZpbmQgaXRcbiAgICBjb25zdCByZWYgPSB0aGlzW2tDbGllbnRzXS5nZXQob3JpZ2luKVxuICAgIGlmIChyZWYpIHtcbiAgICAgIHJldHVybiByZWYuZGVyZWYoKVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBvcmlnaW4gaXMgbm90IGEgc3RyaW5nIGNyZWF0ZSBhIGR1bW15IHBhcmVudCBwb29sIGFuZCByZXR1cm4gdG8gdXNlclxuICAgIGlmICh0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKCdodHRwOi8vbG9jYWxob3N0Ojk5OTknKVxuICAgICAgdGhpc1trTW9ja0FnZW50U2V0XShvcmlnaW4sIGRpc3BhdGNoZXIpXG4gICAgICByZXR1cm4gZGlzcGF0Y2hlclxuICAgIH1cblxuICAgIC8vIElmIHdlIG1hdGNoLCBjcmVhdGUgYSBwb29sIGFuZCBhc3NpZ24gdGhlIHNhbWUgZGlzcGF0Y2hlc1xuICAgIGZvciAoY29uc3QgW2tleU1hdGNoZXIsIG5vbkV4cGxpY2l0UmVmXSBvZiBBcnJheS5mcm9tKHRoaXNba0NsaWVudHNdKSkge1xuICAgICAgY29uc3Qgbm9uRXhwbGljaXREaXNwYXRjaGVyID0gbm9uRXhwbGljaXRSZWYuZGVyZWYoKVxuICAgICAgaWYgKG5vbkV4cGxpY2l0RGlzcGF0Y2hlciAmJiB0eXBlb2Yga2V5TWF0Y2hlciAhPT0gJ3N0cmluZycgJiYgbWF0Y2hWYWx1ZShrZXlNYXRjaGVyLCBvcmlnaW4pKSB7XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcmlnaW4pXG4gICAgICAgIHRoaXNba01vY2tBZ2VudFNldF0ob3JpZ2luLCBkaXNwYXRjaGVyKVxuICAgICAgICBkaXNwYXRjaGVyW2tEaXNwYXRjaGVzXSA9IG5vbkV4cGxpY2l0RGlzcGF0Y2hlcltrRGlzcGF0Y2hlc11cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBba0dldE5ldENvbm5lY3RdICgpIHtcbiAgICByZXR1cm4gdGhpc1trTmV0Q29ubmVjdF1cbiAgfVxuXG4gIHBlbmRpbmdJbnRlcmNlcHRvcnMgKCkge1xuICAgIGNvbnN0IG1vY2tBZ2VudENsaWVudHMgPSB0aGlzW2tDbGllbnRzXVxuXG4gICAgcmV0dXJuIEFycmF5LmZyb20obW9ja0FnZW50Q2xpZW50cy5lbnRyaWVzKCkpXG4gICAgICAuZmxhdE1hcCgoW29yaWdpbiwgc2NvcGVdKSA9PiBzY29wZS5kZXJlZigpW2tEaXNwYXRjaGVzXS5tYXAoZGlzcGF0Y2ggPT4gKHsgLi4uZGlzcGF0Y2gsIG9yaWdpbiB9KSkpXG4gICAgICAuZmlsdGVyKCh7IHBlbmRpbmcgfSkgPT4gcGVuZGluZylcbiAgfVxuXG4gIGFzc2VydE5vUGVuZGluZ0ludGVyY2VwdG9ycyAoeyBwZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyID0gbmV3IFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIoKSB9ID0ge30pIHtcbiAgICBjb25zdCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nSW50ZXJjZXB0b3JzKClcblxuICAgIGlmIChwZW5kaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcGx1cmFsaXplciA9IG5ldyBQbHVyYWxpemVyKCdpbnRlcmNlcHRvcicsICdpbnRlcmNlcHRvcnMnKS5wbHVyYWxpemUocGVuZGluZy5sZW5ndGgpXG5cbiAgICB0aHJvdyBuZXcgVW5kaWNpRXJyb3IoYFxuJHtwbHVyYWxpemVyLmNvdW50fSAke3BsdXJhbGl6ZXIubm91bn0gJHtwbHVyYWxpemVyLmlzfSBwZW5kaW5nOlxuXG4ke3BlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIuZm9ybWF0KHBlbmRpbmcpfVxuYC50cmltKCkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb2NrQWdlbnRcbiJdLCJuYW1lcyI6WyJrQ2xpZW50cyIsInJlcXVpcmUiLCJBZ2VudCIsImtBZ2VudCIsImtNb2NrQWdlbnRTZXQiLCJrTW9ja0FnZW50R2V0Iiwia0Rpc3BhdGNoZXMiLCJrSXNNb2NrQWN0aXZlIiwia05ldENvbm5lY3QiLCJrR2V0TmV0Q29ubmVjdCIsImtPcHRpb25zIiwia0ZhY3RvcnkiLCJNb2NrQ2xpZW50IiwiTW9ja1Bvb2wiLCJtYXRjaFZhbHVlIiwiYnVpbGRNb2NrT3B0aW9ucyIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiVW5kaWNpRXJyb3IiLCJEaXNwYXRjaGVyIiwiUGx1cmFsaXplciIsIlBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIiLCJGYWtlV2Vha1JlZiIsImNvbnN0cnVjdG9yIiwidmFsdWUiLCJkZXJlZiIsIk1vY2tBZ2VudCIsIm9wdHMiLCJhZ2VudCIsImRpc3BhdGNoIiwiZ2V0Iiwib3JpZ2luIiwiZGlzcGF0Y2hlciIsImhhbmRsZXIiLCJjbG9zZSIsImNsZWFyIiwiZGVhY3RpdmF0ZSIsImFjdGl2YXRlIiwiZW5hYmxlTmV0Q29ubmVjdCIsIm1hdGNoZXIiLCJSZWdFeHAiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwiZGlzYWJsZU5ldENvbm5lY3QiLCJpc01vY2tBY3RpdmUiLCJzZXQiLCJtb2NrT3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsImNvbm5lY3Rpb25zIiwicmVmIiwia2V5TWF0Y2hlciIsIm5vbkV4cGxpY2l0UmVmIiwiZnJvbSIsIm5vbkV4cGxpY2l0RGlzcGF0Y2hlciIsInBlbmRpbmdJbnRlcmNlcHRvcnMiLCJtb2NrQWdlbnRDbGllbnRzIiwiZW50cmllcyIsImZsYXRNYXAiLCJzY29wZSIsIm1hcCIsImZpbHRlciIsInBlbmRpbmciLCJhc3NlcnROb1BlbmRpbmdJbnRlcmNlcHRvcnMiLCJwZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyIiwibGVuZ3RoIiwicGx1cmFsaXplciIsInBsdXJhbGl6ZSIsImNvdW50Iiwibm91biIsImlzIiwiZm9ybWF0IiwidHJpbSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/mock/mock-agent.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/mock/mock-client.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-client.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst Client = __webpack_require__(/*! ../client */ \"(rsc)/../../node_modules/undici/lib/client.js\");\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/../../node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/../../node_modules/undici/lib/mock/mock-symbols.js\");\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(rsc)/../../node_modules/undici/lib/mock/mock-interceptor.js\");\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */ class MockClient extends Client {\n    constructor(origin, opts){\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== \"function\") {\n            throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n    }\n    get [Symbols.kConnected]() {\n        return this[kConnected];\n    }\n    /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */ intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n    }\n    async [kClose]() {\n        await promisify(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n    }\n}\nmodule.exports = MockClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsU0FBUyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUUsaUJBQWlCLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDdEMsTUFBTSxFQUNKRyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsTUFBTSxFQUNOQyxjQUFjLEVBQ2RDLE9BQU8sRUFDUEMsaUJBQWlCLEVBQ2pCQyxVQUFVLEVBQ1gsR0FBR1QsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVVLGVBQWUsRUFBRSxHQUFHVixtQkFBT0EsQ0FBQztBQUNwQyxNQUFNVyxVQUFVWCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNLEVBQUVZLG9CQUFvQixFQUFFLEdBQUdaLG1CQUFPQSxDQUFDO0FBRXpDOztDQUVDLEdBQ0QsTUFBTWEsbUJBQW1CWjtJQUN2QmEsWUFBYUMsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDekIsS0FBSyxDQUFDRCxRQUFRQztRQUVkLElBQUksQ0FBQ0EsUUFBUSxDQUFDQSxLQUFLQyxLQUFLLElBQUksT0FBT0QsS0FBS0MsS0FBSyxDQUFDQyxRQUFRLEtBQUssWUFBWTtZQUNyRSxNQUFNLElBQUlOLHFCQUFxQjtRQUNqQztRQUVBLElBQUksQ0FBQ1IsV0FBVyxHQUFHWSxLQUFLQyxLQUFLO1FBQzdCLElBQUksQ0FBQ1YsUUFBUSxHQUFHUTtRQUNoQixJQUFJLENBQUNaLFlBQVksR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQ00sV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0Qsa0JBQWtCLEdBQUcsSUFBSSxDQUFDVSxRQUFRO1FBQ3ZDLElBQUksQ0FBQ1osZUFBZSxHQUFHLElBQUksQ0FBQ2EsS0FBSyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUUzQyxJQUFJLENBQUNGLFFBQVEsR0FBR2hCLGtCQUFrQm1CLElBQUksQ0FBQyxJQUFJO1FBQzNDLElBQUksQ0FBQ0YsS0FBSyxHQUFHLElBQUksQ0FBQ2QsT0FBTztJQUMzQjtJQUVBLElBQUksQ0FBQ00sUUFBUUYsVUFBVSxDQUFDLEdBQUk7UUFDMUIsT0FBTyxJQUFJLENBQUNBLFdBQVc7SUFDekI7SUFFQTs7R0FFQyxHQUNEYSxVQUFXTixJQUFJLEVBQUU7UUFDZixPQUFPLElBQUlOLGdCQUFnQk0sTUFBTSxJQUFJLENBQUNiLFlBQVk7SUFDcEQ7SUFFQSxNQUFNLENBQUNFLE9BQU8sR0FBSTtRQUNoQixNQUFNTixVQUFVLElBQUksQ0FBQ08sZUFBZTtRQUNwQyxJQUFJLENBQUNHLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNMLFdBQVcsQ0FBQ08sUUFBUVksUUFBUSxDQUFDLENBQUNDLE1BQU0sQ0FBQyxJQUFJLENBQUNqQixRQUFRO0lBQ3pEO0FBQ0Y7QUFFQWtCLE9BQU9DLE9BQU8sR0FBR2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1jbGllbnQuanM/Mjc4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKVxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50JylcbmNvbnN0IHsgYnVpbGRNb2NrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4vbW9jay11dGlscycpXG5jb25zdCB7XG4gIGtEaXNwYXRjaGVzLFxuICBrTW9ja0FnZW50LFxuICBrQ2xvc2UsXG4gIGtPcmlnaW5hbENsb3NlLFxuICBrT3JpZ2luLFxuICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAga0Nvbm5lY3RlZFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgTW9ja0ludGVyY2VwdG9yIH0gPSByZXF1aXJlKCcuL21vY2staW50ZXJjZXB0b3InKVxuY29uc3QgU3ltYm9scyA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbi8qKlxuICogTW9ja0NsaWVudCBwcm92aWRlcyBhbiBBUEkgdGhhdCBleHRlbmRzIHRoZSBDbGllbnQgdG8gaW5mbHVlbmNlIHRoZSBtb2NrRGlzcGF0Y2hlcy5cbiAqL1xuY2xhc3MgTW9ja0NsaWVudCBleHRlbmRzIENsaWVudCB7XG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIG9wdHMpIHtcbiAgICBzdXBlcihvcmlnaW4sIG9wdHMpXG5cbiAgICBpZiAoIW9wdHMgfHwgIW9wdHMuYWdlbnQgfHwgdHlwZW9mIG9wdHMuYWdlbnQuZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgb3B0cy5hZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudCcpXG4gICAgfVxuXG4gICAgdGhpc1trTW9ja0FnZW50XSA9IG9wdHMuYWdlbnRcbiAgICB0aGlzW2tPcmlnaW5dID0gb3JpZ2luXG4gICAgdGhpc1trRGlzcGF0Y2hlc10gPSBbXVxuICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAxXG4gICAgdGhpc1trT3JpZ2luYWxEaXNwYXRjaF0gPSB0aGlzLmRpc3BhdGNoXG4gICAgdGhpc1trT3JpZ2luYWxDbG9zZV0gPSB0aGlzLmNsb3NlLmJpbmQodGhpcylcblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBidWlsZE1vY2tEaXNwYXRjaC5jYWxsKHRoaXMpXG4gICAgdGhpcy5jbG9zZSA9IHRoaXNba0Nsb3NlXVxuICB9XG5cbiAgZ2V0IFtTeW1ib2xzLmtDb25uZWN0ZWRdICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29ubmVjdGVkXVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIGJhc2UgaW50ZXJjZXB0b3IgZm9yIG1vY2tpbmcgcmVwbGllcyBmcm9tIHVuZGljaS5cbiAgICovXG4gIGludGVyY2VwdCAob3B0cykge1xuICAgIHJldHVybiBuZXcgTW9ja0ludGVyY2VwdG9yKG9wdHMsIHRoaXNba0Rpc3BhdGNoZXNdKVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGF3YWl0IHByb21pc2lmeSh0aGlzW2tPcmlnaW5hbENsb3NlXSkoKVxuICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAwXG4gICAgdGhpc1trTW9ja0FnZW50XVtTeW1ib2xzLmtDbGllbnRzXS5kZWxldGUodGhpc1trT3JpZ2luXSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vY2tDbGllbnRcbiJdLCJuYW1lcyI6WyJwcm9taXNpZnkiLCJyZXF1aXJlIiwiQ2xpZW50IiwiYnVpbGRNb2NrRGlzcGF0Y2giLCJrRGlzcGF0Y2hlcyIsImtNb2NrQWdlbnQiLCJrQ2xvc2UiLCJrT3JpZ2luYWxDbG9zZSIsImtPcmlnaW4iLCJrT3JpZ2luYWxEaXNwYXRjaCIsImtDb25uZWN0ZWQiLCJNb2NrSW50ZXJjZXB0b3IiLCJTeW1ib2xzIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJNb2NrQ2xpZW50IiwiY29uc3RydWN0b3IiLCJvcmlnaW4iLCJvcHRzIiwiYWdlbnQiLCJkaXNwYXRjaCIsImNsb3NlIiwiYmluZCIsImNhbGwiLCJpbnRlcmNlcHQiLCJrQ2xpZW50cyIsImRlbGV0ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/mock/mock-client.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/mock/mock-errors.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-errors.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { UndiciError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nclass MockNotMatchedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, MockNotMatchedError);\n        this.name = \"MockNotMatchedError\";\n        this.message = message || \"The request does not match any registered mock dispatches\";\n        this.code = \"UND_MOCK_ERR_MOCK_NOT_MATCHED\";\n    }\n}\nmodule.exports = {\n    MockNotMatchedError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWVycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsV0FBVyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRWhDLE1BQU1DLDRCQUE0QkY7SUFDaENHLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ05DLE1BQU1DLGlCQUFpQixDQUFDLElBQUksRUFBRUo7UUFDOUIsSUFBSSxDQUFDSyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNILE9BQU8sR0FBR0EsV0FBVztRQUMxQixJQUFJLENBQUNJLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZSO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1lcnJvcnMuanM/ZmI3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBVbmRpY2lFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG5jbGFzcyBNb2NrTm90TWF0Y2hlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTW9ja05vdE1hdGNoZWRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnTW9ja05vdE1hdGNoZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdUaGUgcmVxdWVzdCBkb2VzIG5vdCBtYXRjaCBhbnkgcmVnaXN0ZXJlZCBtb2NrIGRpc3BhdGNoZXMnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9NT0NLX0VSUl9NT0NLX05PVF9NQVRDSEVEJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNb2NrTm90TWF0Y2hlZEVycm9yXG59XG4iXSwibmFtZXMiOlsiVW5kaWNpRXJyb3IiLCJyZXF1aXJlIiwiTW9ja05vdE1hdGNoZWRFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJuYW1lIiwiY29kZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/mock/mock-errors.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/mock/mock-interceptor.js":
/*!**************************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-interceptor.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/../../node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/../../node_modules/undici/lib/mock/mock-symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst { buildURL } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\n/**\n * Defines the scope API for an interceptor reply\n */ class MockScope {\n    constructor(mockDispatch){\n        this[kMockDispatch] = mockDispatch;\n    }\n    /**\n   * Delay a reply by a set amount in ms.\n   */ delay(waitInMs) {\n        if (typeof waitInMs !== \"number\" || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n            throw new InvalidArgumentError(\"waitInMs must be a valid integer > 0\");\n        }\n        this[kMockDispatch].delay = waitInMs;\n        return this;\n    }\n    /**\n   * For a defined reply, never mark as consumed.\n   */ persist() {\n        this[kMockDispatch].persist = true;\n        return this;\n    }\n    /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */ times(repeatTimes) {\n        if (typeof repeatTimes !== \"number\" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n            throw new InvalidArgumentError(\"repeatTimes must be a valid integer > 0\");\n        }\n        this[kMockDispatch].times = repeatTimes;\n        return this;\n    }\n}\n/**\n * Defines an interceptor for a Mock\n */ class MockInterceptor {\n    constructor(opts, mockDispatches){\n        if (typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"opts must be an object\");\n        }\n        if (typeof opts.path === \"undefined\") {\n            throw new InvalidArgumentError(\"opts.path must be defined\");\n        }\n        if (typeof opts.method === \"undefined\") {\n            opts.method = \"GET\";\n        }\n        // See https://github.com/nodejs/undici/issues/1245\n        // As per RFC 3986, clients are not supposed to send URI\n        // fragments to servers when they retrieve a document,\n        if (typeof opts.path === \"string\") {\n            if (opts.query) {\n                opts.path = buildURL(opts.path, opts.query);\n            } else {\n                // Matches https://github.com/nodejs/undici/blob/main/lib/fetch/index.js#L1811\n                const parsedURL = new URL(opts.path, \"data://\");\n                opts.path = parsedURL.pathname + parsedURL.search;\n            }\n        }\n        if (typeof opts.method === \"string\") {\n            opts.method = opts.method.toUpperCase();\n        }\n        this[kDispatchKey] = buildKey(opts);\n        this[kDispatches] = mockDispatches;\n        this[kDefaultHeaders] = {};\n        this[kDefaultTrailers] = {};\n        this[kContentLength] = false;\n    }\n    createMockScopeDispatchData(statusCode, data, responseOptions = {}) {\n        const responseData = getResponseData(data);\n        const contentLength = this[kContentLength] ? {\n            \"content-length\": responseData.length\n        } : {};\n        const headers = {\n            ...this[kDefaultHeaders],\n            ...contentLength,\n            ...responseOptions.headers\n        };\n        const trailers = {\n            ...this[kDefaultTrailers],\n            ...responseOptions.trailers\n        };\n        return {\n            statusCode,\n            data,\n            headers,\n            trailers\n        };\n    }\n    validateReplyParameters(statusCode, data, responseOptions) {\n        if (typeof statusCode === \"undefined\") {\n            throw new InvalidArgumentError(\"statusCode must be defined\");\n        }\n        if (typeof data === \"undefined\") {\n            throw new InvalidArgumentError(\"data must be defined\");\n        }\n        if (typeof responseOptions !== \"object\") {\n            throw new InvalidArgumentError(\"responseOptions must be an object\");\n        }\n    }\n    /**\n   * Mock an undici request with a defined reply.\n   */ reply(replyData) {\n        // Values of reply aren't available right now as they\n        // can only be available when the reply callback is invoked.\n        if (typeof replyData === \"function\") {\n            // We'll first wrap the provided callback in another function,\n            // this function will properly resolve the data from the callback\n            // when invoked.\n            const wrappedDefaultsCallback = (opts)=>{\n                // Our reply options callback contains the parameter for statusCode, data and options.\n                const resolvedData = replyData(opts);\n                // Check if it is in the right format\n                if (typeof resolvedData !== \"object\") {\n                    throw new InvalidArgumentError(\"reply options callback must return an object\");\n                }\n                const { statusCode, data = \"\", responseOptions = {} } = resolvedData;\n                this.validateReplyParameters(statusCode, data, responseOptions);\n                // Since the values can be obtained immediately we return them\n                // from this higher order function that will be resolved later.\n                return {\n                    ...this.createMockScopeDispatchData(statusCode, data, responseOptions)\n                };\n            };\n            // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n            const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);\n            return new MockScope(newMockDispatch);\n        }\n        // We can have either one or three parameters, if we get here,\n        // we should have 1-3 parameters. So we spread the arguments of\n        // this function to obtain the parameters, since replyData will always\n        // just be the statusCode.\n        const [statusCode, data = \"\", responseOptions = {}] = [\n            ...arguments\n        ];\n        this.validateReplyParameters(statusCode, data, responseOptions);\n        // Send in-already provided data like usual\n        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);\n        return new MockScope(newMockDispatch);\n    }\n    /**\n   * Mock an undici request with a defined error.\n   */ replyWithError(error) {\n        if (typeof error === \"undefined\") {\n            throw new InvalidArgumentError(\"error must be defined\");\n        }\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], {\n            error\n        });\n        return new MockScope(newMockDispatch);\n    }\n    /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */ defaultReplyHeaders(headers) {\n        if (typeof headers === \"undefined\") {\n            throw new InvalidArgumentError(\"headers must be defined\");\n        }\n        this[kDefaultHeaders] = headers;\n        return this;\n    }\n    /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */ defaultReplyTrailers(trailers) {\n        if (typeof trailers === \"undefined\") {\n            throw new InvalidArgumentError(\"trailers must be defined\");\n        }\n        this[kDefaultTrailers] = trailers;\n        return this;\n    }\n    /**\n   * Set reply content length header for replies on the interceptor\n   */ replyContentLength() {\n        this[kContentLength] = true;\n        return this;\n    }\n}\nmodule.exports.MockInterceptor = MockInterceptor;\nmodule.exports.MockScope = MockScope;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWludGVyY2VwdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxlQUFlLEVBQUVDLFFBQVEsRUFBRUMsZUFBZSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQy9ELE1BQU0sRUFDSkMsV0FBVyxFQUNYQyxZQUFZLEVBQ1pDLGVBQWUsRUFDZkMsZ0JBQWdCLEVBQ2hCQyxjQUFjLEVBQ2RDLGFBQWEsRUFDZCxHQUFHTixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRU8sb0JBQW9CLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDekMsTUFBTSxFQUFFUSxRQUFRLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFFN0I7O0NBRUMsR0FDRCxNQUFNUztJQUNKQyxZQUFhQyxZQUFZLENBQUU7UUFDekIsSUFBSSxDQUFDTCxjQUFjLEdBQUdLO0lBQ3hCO0lBRUE7O0dBRUMsR0FDREMsTUFBT0MsUUFBUSxFQUFFO1FBQ2YsSUFBSSxPQUFPQSxhQUFhLFlBQVksQ0FBQ0MsT0FBT0MsU0FBUyxDQUFDRixhQUFhQSxZQUFZLEdBQUc7WUFDaEYsTUFBTSxJQUFJTixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUNELGNBQWMsQ0FBQ00sS0FBSyxHQUFHQztRQUM1QixPQUFPLElBQUk7SUFDYjtJQUVBOztHQUVDLEdBQ0RHLFVBQVc7UUFDVCxJQUFJLENBQUNWLGNBQWMsQ0FBQ1UsT0FBTyxHQUFHO1FBQzlCLE9BQU8sSUFBSTtJQUNiO0lBRUE7O0dBRUMsR0FDREMsTUFBT0MsV0FBVyxFQUFFO1FBQ2xCLElBQUksT0FBT0EsZ0JBQWdCLFlBQVksQ0FBQ0osT0FBT0MsU0FBUyxDQUFDRyxnQkFBZ0JBLGVBQWUsR0FBRztZQUN6RixNQUFNLElBQUlYLHFCQUFxQjtRQUNqQztRQUVBLElBQUksQ0FBQ0QsY0FBYyxDQUFDVyxLQUFLLEdBQUdDO1FBQzVCLE9BQU8sSUFBSTtJQUNiO0FB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O0lBQ2I7SUFFQTs7R0FFQyxHQUNEYSxxQkFBc0JaLFFBQVEsRUFBRTtRQUM5QixJQUFJLE9BQU9BLGFBQWEsYUFBYTtZQUNuQyxNQUFNLElBQUkvQixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUNILGlCQUFpQixHQUFHa0M7UUFDekIsT0FBTyxJQUFJO0lBQ2I7SUFFQTs7R0FFQyxHQUNEYSxxQkFBc0I7UUFDcEIsSUFBSSxDQUFDOUMsZUFBZSxHQUFHO1FBQ3ZCLE9BQU8sSUFBSTtJQUNiO0FBQ0Y7QUFFQStDLDhCQUE4QixHQUFHakM7QUFDakNpQyx3QkFBd0IsR0FBRzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2staW50ZXJjZXB0b3IuanM/ZTk2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBnZXRSZXNwb25zZURhdGEsIGJ1aWxkS2V5LCBhZGRNb2NrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4vbW9jay11dGlscycpXG5jb25zdCB7XG4gIGtEaXNwYXRjaGVzLFxuICBrRGlzcGF0Y2hLZXksXG4gIGtEZWZhdWx0SGVhZGVycyxcbiAga0RlZmF1bHRUcmFpbGVycyxcbiAga0NvbnRlbnRMZW5ndGgsXG4gIGtNb2NrRGlzcGF0Y2hcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7IGJ1aWxkVVJMIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG4vKipcbiAqIERlZmluZXMgdGhlIHNjb3BlIEFQSSBmb3IgYW4gaW50ZXJjZXB0b3IgcmVwbHlcbiAqL1xuY2xhc3MgTW9ja1Njb3BlIHtcbiAgY29uc3RydWN0b3IgKG1vY2tEaXNwYXRjaCkge1xuICAgIHRoaXNba01vY2tEaXNwYXRjaF0gPSBtb2NrRGlzcGF0Y2hcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxheSBhIHJlcGx5IGJ5IGEgc2V0IGFtb3VudCBpbiBtcy5cbiAgICovXG4gIGRlbGF5ICh3YWl0SW5Ncykge1xuICAgIGlmICh0eXBlb2Ygd2FpdEluTXMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHdhaXRJbk1zKSB8fCB3YWl0SW5NcyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3dhaXRJbk1zIG11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyID4gMCcpXG4gICAgfVxuXG4gICAgdGhpc1trTW9ja0Rpc3BhdGNoXS5kZWxheSA9IHdhaXRJbk1zXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYSBkZWZpbmVkIHJlcGx5LCBuZXZlciBtYXJrIGFzIGNvbnN1bWVkLlxuICAgKi9cbiAgcGVyc2lzdCAoKSB7XG4gICAgdGhpc1trTW9ja0Rpc3BhdGNoXS5wZXJzaXN0ID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgb25lIHRvIGRlZmluZSBhIHJlcGx5IGZvciBhIHNldCBhbW91bnQgb2YgbWF0Y2hpbmcgcmVxdWVzdHMuXG4gICAqL1xuICB0aW1lcyAocmVwZWF0VGltZXMpIHtcbiAgICBpZiAodHlwZW9mIHJlcGVhdFRpbWVzICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihyZXBlYXRUaW1lcykgfHwgcmVwZWF0VGltZXMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdyZXBlYXRUaW1lcyBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciA+IDAnKVxuICAgIH1cblxuICAgIHRoaXNba01vY2tEaXNwYXRjaF0udGltZXMgPSByZXBlYXRUaW1lc1xuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxuLyoqXG4gKiBEZWZpbmVzIGFuIGludGVyY2VwdG9yIGZvciBhIE1vY2tcbiAqL1xuY2xhc3MgTW9ja0ludGVyY2VwdG9yIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIG1vY2tEaXNwYXRjaGVzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMucGF0aCBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMubWV0aG9kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0cy5tZXRob2QgPSAnR0VUJ1xuICAgIH1cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzEyNDVcbiAgICAvLyBBcyBwZXIgUkZDIDM5ODYsIGNsaWVudHMgYXJlIG5vdCBzdXBwb3NlZCB0byBzZW5kIFVSSVxuICAgIC8vIGZyYWdtZW50cyB0byBzZXJ2ZXJzIHdoZW4gdGhleSByZXRyaWV2ZSBhIGRvY3VtZW50LFxuICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKG9wdHMucXVlcnkpIHtcbiAgICAgICAgb3B0cy5wYXRoID0gYnVpbGRVUkwob3B0cy5wYXRoLCBvcHRzLnF1ZXJ5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWF0Y2hlcyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9ibG9iL21haW4vbGliL2ZldGNoL2luZGV4LmpzI0wxODExXG4gICAgICAgIGNvbnN0IHBhcnNlZFVSTCA9IG5ldyBVUkwob3B0cy5wYXRoLCAnZGF0YTovLycpXG4gICAgICAgIG9wdHMucGF0aCA9IHBhcnNlZFVSTC5wYXRobmFtZSArIHBhcnNlZFVSTC5zZWFyY2hcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLm1ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdHMubWV0aG9kID0gb3B0cy5tZXRob2QudG9VcHBlckNhc2UoKVxuICAgIH1cblxuICAgIHRoaXNba0Rpc3BhdGNoS2V5XSA9IGJ1aWxkS2V5KG9wdHMpXG4gICAgdGhpc1trRGlzcGF0Y2hlc10gPSBtb2NrRGlzcGF0Y2hlc1xuICAgIHRoaXNba0RlZmF1bHRIZWFkZXJzXSA9IHt9XG4gICAgdGhpc1trRGVmYXVsdFRyYWlsZXJzXSA9IHt9XG4gICAgdGhpc1trQ29udGVudExlbmd0aF0gPSBmYWxzZVxuICB9XG5cbiAgY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhIChzdGF0dXNDb2RlLCBkYXRhLCByZXNwb25zZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGdldFJlc3BvbnNlRGF0YShkYXRhKVxuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSB0aGlzW2tDb250ZW50TGVuZ3RoXSA/IHsgJ2NvbnRlbnQtbGVuZ3RoJzogcmVzcG9uc2VEYXRhLmxlbmd0aCB9IDoge31cbiAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzW2tEZWZhdWx0SGVhZGVyc10sIC4uLmNvbnRlbnRMZW5ndGgsIC4uLnJlc3BvbnNlT3B0aW9ucy5oZWFkZXJzIH1cbiAgICBjb25zdCB0cmFpbGVycyA9IHsgLi4udGhpc1trRGVmYXVsdFRyYWlsZXJzXSwgLi4ucmVzcG9uc2VPcHRpb25zLnRyYWlsZXJzIH1cblxuICAgIHJldHVybiB7IHN0YXR1c0NvZGUsIGRhdGEsIGhlYWRlcnMsIHRyYWlsZXJzIH1cbiAgfVxuXG4gIHZhbGlkYXRlUmVwbHlQYXJhbWV0ZXJzIChzdGF0dXNDb2RlLCBkYXRhLCByZXNwb25zZU9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHN0YXR1c0NvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3N0YXR1c0NvZGUgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdkYXRhIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VPcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdyZXNwb25zZU9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb2NrIGFuIHVuZGljaSByZXF1ZXN0IHdpdGggYSBkZWZpbmVkIHJlcGx5LlxuICAgKi9cbiAgcmVwbHkgKHJlcGx5RGF0YSkge1xuICAgIC8vIFZhbHVlcyBvZiByZXBseSBhcmVuJ3QgYXZhaWxhYmxlIHJpZ2h0IG5vdyBhcyB0aGV5XG4gICAgLy8gY2FuIG9ubHkgYmUgYXZhaWxhYmxlIHdoZW4gdGhlIHJlcGx5IGNhbGxiYWNrIGlzIGludm9rZWQuXG4gICAgaWYgKHR5cGVvZiByZXBseURhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFdlJ2xsIGZpcnN0IHdyYXAgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGluIGFub3RoZXIgZnVuY3Rpb24sXG4gICAgICAvLyB0aGlzIGZ1bmN0aW9uIHdpbGwgcHJvcGVybHkgcmVzb2x2ZSB0aGUgZGF0YSBmcm9tIHRoZSBjYWxsYmFja1xuICAgICAgLy8gd2hlbiBpbnZva2VkLlxuICAgICAgY29uc3Qgd3JhcHBlZERlZmF1bHRzQ2FsbGJhY2sgPSAob3B0cykgPT4ge1xuICAgICAgICAvLyBPdXIgcmVwbHkgb3B0aW9ucyBjYWxsYmFjayBjb250YWlucyB0aGUgcGFyYW1ldGVyIGZvciBzdGF0dXNDb2RlLCBkYXRhIGFuZCBvcHRpb25zLlxuICAgICAgICBjb25zdCByZXNvbHZlZERhdGEgPSByZXBseURhdGEob3B0cylcblxuICAgICAgICAvLyBDaGVjayBpZiBpdCBpcyBpbiB0aGUgcmlnaHQgZm9ybWF0XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZWREYXRhICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncmVwbHkgb3B0aW9ucyBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBvYmplY3QnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzdGF0dXNDb2RlLCBkYXRhID0gJycsIHJlc3BvbnNlT3B0aW9ucyA9IHt9IH0gPSByZXNvbHZlZERhdGFcbiAgICAgICAgdGhpcy52YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyhzdGF0dXNDb2RlLCBkYXRhLCByZXNwb25zZU9wdGlvbnMpXG4gICAgICAgIC8vIFNpbmNlIHRoZSB2YWx1ZXMgY2FuIGJlIG9idGFpbmVkIGltbWVkaWF0ZWx5IHdlIHJldHVybiB0aGVtXG4gICAgICAgIC8vIGZyb20gdGhpcyBoaWdoZXIgb3JkZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHJlc29sdmVkIGxhdGVyLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnRoaXMuY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhKHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdXN1YWwgZGlzcGF0Y2ggZGF0YSwgYnV0IHRoaXMgdGltZSBzZXQgdGhlIGRhdGEgcGFyYW1ldGVyIHRvIGZ1bmN0aW9uIHRoYXQgd2lsbCBldmVudHVhbGx5IHByb3ZpZGUgZGF0YS5cbiAgICAgIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IGFkZE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwgdGhpc1trRGlzcGF0Y2hLZXldLCB3cmFwcGVkRGVmYXVsdHNDYWxsYmFjaylcbiAgICAgIHJldHVybiBuZXcgTW9ja1Njb3BlKG5ld01vY2tEaXNwYXRjaClcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4gaGF2ZSBlaXRoZXIgb25lIG9yIHRocmVlIHBhcmFtZXRlcnMsIGlmIHdlIGdldCBoZXJlLFxuICAgIC8vIHdlIHNob3VsZCBoYXZlIDEtMyBwYXJhbWV0ZXJzLiBTbyB3ZSBzcHJlYWQgdGhlIGFyZ3VtZW50cyBvZlxuICAgIC8vIHRoaXMgZnVuY3Rpb24gdG8gb2J0YWluIHRoZSBwYXJhbWV0ZXJzLCBzaW5jZSByZXBseURhdGEgd2lsbCBhbHdheXNcbiAgICAvLyBqdXN0IGJlIHRoZSBzdGF0dXNDb2RlLlxuICAgIGNvbnN0IFtzdGF0dXNDb2RlLCBkYXRhID0gJycsIHJlc3BvbnNlT3B0aW9ucyA9IHt9XSA9IFsuLi5hcmd1bWVudHNdXG4gICAgdGhpcy52YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyhzdGF0dXNDb2RlLCBkYXRhLCByZXNwb25zZU9wdGlvbnMpXG5cbiAgICAvLyBTZW5kIGluLWFscmVhZHkgcHJvdmlkZWQgZGF0YSBsaWtlIHVzdWFsXG4gICAgY29uc3QgZGlzcGF0Y2hEYXRhID0gdGhpcy5jcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEoc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zKVxuICAgIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IGFkZE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwgdGhpc1trRGlzcGF0Y2hLZXldLCBkaXNwYXRjaERhdGEpXG4gICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1vY2sgYW4gdW5kaWNpIHJlcXVlc3Qgd2l0aCBhIGRlZmluZWQgZXJyb3IuXG4gICAqL1xuICByZXBseVdpdGhFcnJvciAoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdlcnJvciBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IGFkZE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwgdGhpc1trRGlzcGF0Y2hLZXldLCB7IGVycm9yIH0pXG4gICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IHJlcGx5IGhlYWRlcnMgb24gdGhlIGludGVyY2VwdG9yIGZvciBzdWJzZXF1ZW50IHJlcGxpZXNcbiAgICovXG4gIGRlZmF1bHRSZXBseUhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgICBpZiAodHlwZW9mIGhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG5cbiAgICB0aGlzW2tEZWZhdWx0SGVhZGVyc10gPSBoZWFkZXJzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZGVmYXVsdCByZXBseSB0cmFpbGVycyBvbiB0aGUgaW50ZXJjZXB0b3IgZm9yIHN1YnNlcXVlbnQgcmVwbGllc1xuICAgKi9cbiAgZGVmYXVsdFJlcGx5VHJhaWxlcnMgKHRyYWlsZXJzKSB7XG4gICAgaWYgKHR5cGVvZiB0cmFpbGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndHJhaWxlcnMgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG5cbiAgICB0aGlzW2tEZWZhdWx0VHJhaWxlcnNdID0gdHJhaWxlcnNcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCByZXBseSBjb250ZW50IGxlbmd0aCBoZWFkZXIgZm9yIHJlcGxpZXMgb24gdGhlIGludGVyY2VwdG9yXG4gICAqL1xuICByZXBseUNvbnRlbnRMZW5ndGggKCkge1xuICAgIHRoaXNba0NvbnRlbnRMZW5ndGhdID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuTW9ja0ludGVyY2VwdG9yID0gTW9ja0ludGVyY2VwdG9yXG5tb2R1bGUuZXhwb3J0cy5Nb2NrU2NvcGUgPSBNb2NrU2NvcGVcbiJdLCJuYW1lcyI6WyJnZXRSZXNwb25zZURhdGEiLCJidWlsZEtleSIsImFkZE1vY2tEaXNwYXRjaCIsInJlcXVpcmUiLCJrRGlzcGF0Y2hlcyIsImtEaXNwYXRjaEtleSIsImtEZWZhdWx0SGVhZGVycyIsImtEZWZhdWx0VHJhaWxlcnMiLCJrQ29udGVudExlbmd0aCIsImtNb2NrRGlzcGF0Y2giLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImJ1aWxkVVJMIiwiTW9ja1Njb3BlIiwiY29uc3RydWN0b3IiLCJtb2NrRGlzcGF0Y2giLCJkZWxheSIsIndhaXRJbk1zIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwicGVyc2lzdCIsInRpbWVzIiwicmVwZWF0VGltZXMiLCJNb2NrSW50ZXJjZXB0b3IiLCJvcHRzIiwibW9ja0Rpc3BhdGNoZXMiLCJwYXRoIiwibWV0aG9kIiwicXVlcnkiLCJwYXJzZWRVUkwiLCJVUkwiLCJwYXRobmFtZSIsInNlYXJjaCIsInRvVXBwZXJDYXNlIiwiY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhIiwic3RhdHVzQ29kZSIsImRhdGEiLCJyZXNwb25zZU9wdGlvbnMiLCJyZXNwb25zZURhdGEiLCJjb250ZW50TGVuZ3RoIiwibGVuZ3RoIiwiaGVhZGVycyIsInRyYWlsZXJzIiwidmFsaWRhdGVSZXBseVBhcmFtZXRlcnMiLCJyZXBseSIsInJlcGx5RGF0YSIsIndyYXBwZWREZWZhdWx0c0NhbGxiYWNrIiwicmVzb2x2ZWREYXRhIiwibmV3TW9ja0Rpc3BhdGNoIiwiYXJndW1lbnRzIiwiZGlzcGF0Y2hEYXRhIiwicmVwbHlXaXRoRXJyb3IiLCJlcnJvciIsImRlZmF1bHRSZXBseUhlYWRlcnMiLCJkZWZhdWx0UmVwbHlUcmFpbGVycyIsInJlcGx5Q29udGVudExlbmd0aCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/mock/mock-interceptor.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/mock/mock-pool.js":
/*!*******************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-pool.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst Pool = __webpack_require__(/*! ../pool */ \"(rsc)/../../node_modules/undici/lib/pool.js\");\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/../../node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/../../node_modules/undici/lib/mock/mock-symbols.js\");\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(rsc)/../../node_modules/undici/lib/mock/mock-interceptor.js\");\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */ class MockPool extends Pool {\n    constructor(origin, opts){\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== \"function\") {\n            throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n    }\n    get [Symbols.kConnected]() {\n        return this[kConnected];\n    }\n    /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */ intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n    }\n    async [kClose]() {\n        await promisify(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n    }\n}\nmodule.exports = MockPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFNBQVMsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM5QixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVFLGlCQUFpQixFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ3RDLE1BQU0sRUFDSkcsV0FBVyxFQUNYQyxVQUFVLEVBQ1ZDLE1BQU0sRUFDTkMsY0FBYyxFQUNkQyxPQUFPLEVBQ1BDLGlCQUFpQixFQUNqQkMsVUFBVSxFQUNYLEdBQUdULG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFVSxlQUFlLEVBQUUsR0FBR1YsbUJBQU9BLENBQUM7QUFDcEMsTUFBTVcsVUFBVVgsbUJBQU9BLENBQUM7QUFDeEIsTUFBTSxFQUFFWSxvQkFBb0IsRUFBRSxHQUFHWixtQkFBT0EsQ0FBQztBQUV6Qzs7Q0FFQyxHQUNELE1BQU1hLGlCQUFpQlo7SUFDckJhLFlBQWFDLE1BQU0sRUFBRUMsSUFBSSxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0QsUUFBUUM7UUFFZCxJQUFJLENBQUNBLFFBQVEsQ0FBQ0EsS0FBS0MsS0FBSyxJQUFJLE9BQU9ELEtBQUtDLEtBQUssQ0FBQ0MsUUFBUSxLQUFLLFlBQVk7WUFDckUsTUFBTSxJQUFJTixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUNSLFdBQVcsR0FBR1ksS0FBS0MsS0FBSztRQUM3QixJQUFJLENBQUNWLFFBQVEsR0FBR1E7UUFDaEIsSUFBSSxDQUFDWixZQUFZLEdBQUcsRUFBRTtRQUN0QixJQUFJLENBQUNNLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNELGtCQUFrQixHQUFHLElBQUksQ0FBQ1UsUUFBUTtRQUN2QyxJQUFJLENBQUNaLGVBQWUsR0FBRyxJQUFJLENBQUNhLEtBQUssQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFFM0MsSUFBSSxDQUFDRixRQUFRLEdBQUdoQixrQkFBa0JtQixJQUFJLENBQUMsSUFBSTtRQUMzQyxJQUFJLENBQUNGLEtBQUssR0FBRyxJQUFJLENBQUNkLE9BQU87SUFDM0I7SUFFQSxJQUFJLENBQUNNLFFBQVFGLFVBQVUsQ0FBQyxHQUFJO1FBQzFCLE9BQU8sSUFBSSxDQUFDQSxXQUFXO0lBQ3pCO0lBRUE7O0dBRUMsR0FDRGEsVUFBV04sSUFBSSxFQUFFO1FBQ2YsT0FBTyxJQUFJTixnQkFBZ0JNLE1BQU0sSUFBSSxDQUFDYixZQUFZO0lBQ3BEO0lBRUEsTUFBTSxDQUFDRSxPQUFPLEdBQUk7UUFDaEIsTUFBTU4sVUFBVSxJQUFJLENBQUNPLGVBQWU7UUFDcEMsSUFBSSxDQUFDRyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDTCxXQUFXLENBQUNPLFFBQVFZLFFBQVEsQ0FBQyxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDakIsUUFBUTtJQUN6RDtBQUNGO0FBRUFrQixPQUFPQyxPQUFPLEdBQUdiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stcG9vbC5qcz85NWM1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi4vcG9vbCcpXG5jb25zdCB7IGJ1aWxkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga01vY2tBZ2VudCxcbiAga0Nsb3NlLFxuICBrT3JpZ2luYWxDbG9zZSxcbiAga09yaWdpbixcbiAga09yaWdpbmFsRGlzcGF0Y2gsXG4gIGtDb25uZWN0ZWRcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCB7IE1vY2tJbnRlcmNlcHRvciB9ID0gcmVxdWlyZSgnLi9tb2NrLWludGVyY2VwdG9yJylcbmNvbnN0IFN5bWJvbHMgPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG4vKipcbiAqIE1vY2tQb29sIHByb3ZpZGVzIGFuIEFQSSB0aGF0IGV4dGVuZHMgdGhlIFBvb2wgdG8gaW5mbHVlbmNlIHRoZSBtb2NrRGlzcGF0Y2hlcy5cbiAqL1xuY2xhc3MgTW9ja1Bvb2wgZXh0ZW5kcyBQb29sIHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwgb3B0cykge1xuICAgIHN1cGVyKG9yaWdpbiwgb3B0cylcblxuICAgIGlmICghb3B0cyB8fCAhb3B0cy5hZ2VudCB8fCB0eXBlb2Ygb3B0cy5hZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50JylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrQWdlbnRdID0gb3B0cy5hZ2VudFxuICAgIHRoaXNba09yaWdpbl0gPSBvcmlnaW5cbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IFtdXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDFcbiAgICB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXSA9IHRoaXMuZGlzcGF0Y2hcbiAgICB0aGlzW2tPcmlnaW5hbENsb3NlXSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGJ1aWxkTW9ja0Rpc3BhdGNoLmNhbGwodGhpcylcbiAgICB0aGlzLmNsb3NlID0gdGhpc1trQ2xvc2VdXG4gIH1cblxuICBnZXQgW1N5bWJvbHMua0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDb25uZWN0ZWRdXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgYmFzZSBpbnRlcmNlcHRvciBmb3IgbW9ja2luZyByZXBsaWVzIGZyb20gdW5kaWNpLlxuICAgKi9cbiAgaW50ZXJjZXB0IChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBNb2NrSW50ZXJjZXB0b3Iob3B0cywgdGhpc1trRGlzcGF0Y2hlc10pXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgcHJvbWlzaWZ5KHRoaXNba09yaWdpbmFsQ2xvc2VdKSgpXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDBcbiAgICB0aGlzW2tNb2NrQWdlbnRdW1N5bWJvbHMua0NsaWVudHNdLmRlbGV0ZSh0aGlzW2tPcmlnaW5dKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9ja1Bvb2xcbiJdLCJuYW1lcyI6WyJwcm9taXNpZnkiLCJyZXF1aXJlIiwiUG9vbCIsImJ1aWxkTW9ja0Rpc3BhdGNoIiwia0Rpc3BhdGNoZXMiLCJrTW9ja0FnZW50Iiwia0Nsb3NlIiwia09yaWdpbmFsQ2xvc2UiLCJrT3JpZ2luIiwia09yaWdpbmFsRGlzcGF0Y2giLCJrQ29ubmVjdGVkIiwiTW9ja0ludGVyY2VwdG9yIiwiU3ltYm9scyIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiTW9ja1Bvb2wiLCJjb25zdHJ1Y3RvciIsIm9yaWdpbiIsIm9wdHMiLCJhZ2VudCIsImRpc3BhdGNoIiwiY2xvc2UiLCJiaW5kIiwiY2FsbCIsImludGVyY2VwdCIsImtDbGllbnRzIiwiZGVsZXRlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/mock/mock-pool.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/mock/mock-symbols.js":
/*!**********************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-symbols.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    kAgent: Symbol(\"agent\"),\n    kOptions: Symbol(\"options\"),\n    kFactory: Symbol(\"factory\"),\n    kDispatches: Symbol(\"dispatches\"),\n    kDispatchKey: Symbol(\"dispatch key\"),\n    kDefaultHeaders: Symbol(\"default headers\"),\n    kDefaultTrailers: Symbol(\"default trailers\"),\n    kContentLength: Symbol(\"content length\"),\n    kMockAgent: Symbol(\"mock agent\"),\n    kMockAgentSet: Symbol(\"mock agent set\"),\n    kMockAgentGet: Symbol(\"mock agent get\"),\n    kMockDispatch: Symbol(\"mock dispatch\"),\n    kClose: Symbol(\"close\"),\n    kOriginalClose: Symbol(\"original agent close\"),\n    kOrigin: Symbol(\"origin\"),\n    kIsMockActive: Symbol(\"is mock active\"),\n    kNetConnect: Symbol(\"net connect\"),\n    kGetNetConnect: Symbol(\"get net connect\"),\n    kConnected: Symbol(\"connected\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXN5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZDLFFBQVFDLE9BQU87SUFDZkMsVUFBVUQsT0FBTztJQUNqQkUsVUFBVUYsT0FBTztJQUNqQkcsYUFBYUgsT0FBTztJQUNwQkksY0FBY0osT0FBTztJQUNyQkssaUJBQWlCTCxPQUFPO0lBQ3hCTSxrQkFBa0JOLE9BQU87SUFDekJPLGdCQUFnQlAsT0FBTztJQUN2QlEsWUFBWVIsT0FBTztJQUNuQlMsZUFBZVQsT0FBTztJQUN0QlUsZUFBZVYsT0FBTztJQUN0QlcsZUFBZVgsT0FBTztJQUN0QlksUUFBUVosT0FBTztJQUNmYSxnQkFBZ0JiLE9BQU87SUFDdkJjLFNBQVNkLE9BQU87SUFDaEJlLGVBQWVmLE9BQU87SUFDdEJnQixhQUFhaEIsT0FBTztJQUNwQmlCLGdCQUFnQmpCLE9BQU87SUFDdkJrQixZQUFZbEIsT0FBTztBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXN5bWJvbHMuanM/NjI1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtBZ2VudDogU3ltYm9sKCdhZ2VudCcpLFxuICBrT3B0aW9uczogU3ltYm9sKCdvcHRpb25zJyksXG4gIGtGYWN0b3J5OiBTeW1ib2woJ2ZhY3RvcnknKSxcbiAga0Rpc3BhdGNoZXM6IFN5bWJvbCgnZGlzcGF0Y2hlcycpLFxuICBrRGlzcGF0Y2hLZXk6IFN5bWJvbCgnZGlzcGF0Y2gga2V5JyksXG4gIGtEZWZhdWx0SGVhZGVyczogU3ltYm9sKCdkZWZhdWx0IGhlYWRlcnMnKSxcbiAga0RlZmF1bHRUcmFpbGVyczogU3ltYm9sKCdkZWZhdWx0IHRyYWlsZXJzJyksXG4gIGtDb250ZW50TGVuZ3RoOiBTeW1ib2woJ2NvbnRlbnQgbGVuZ3RoJyksXG4gIGtNb2NrQWdlbnQ6IFN5bWJvbCgnbW9jayBhZ2VudCcpLFxuICBrTW9ja0FnZW50U2V0OiBTeW1ib2woJ21vY2sgYWdlbnQgc2V0JyksXG4gIGtNb2NrQWdlbnRHZXQ6IFN5bWJvbCgnbW9jayBhZ2VudCBnZXQnKSxcbiAga01vY2tEaXNwYXRjaDogU3ltYm9sKCdtb2NrIGRpc3BhdGNoJyksXG4gIGtDbG9zZTogU3ltYm9sKCdjbG9zZScpLFxuICBrT3JpZ2luYWxDbG9zZTogU3ltYm9sKCdvcmlnaW5hbCBhZ2VudCBjbG9zZScpLFxuICBrT3JpZ2luOiBTeW1ib2woJ29yaWdpbicpLFxuICBrSXNNb2NrQWN0aXZlOiBTeW1ib2woJ2lzIG1vY2sgYWN0aXZlJyksXG4gIGtOZXRDb25uZWN0OiBTeW1ib2woJ25ldCBjb25uZWN0JyksXG4gIGtHZXROZXRDb25uZWN0OiBTeW1ib2woJ2dldCBuZXQgY29ubmVjdCcpLFxuICBrQ29ubmVjdGVkOiBTeW1ib2woJ2Nvbm5lY3RlZCcpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtBZ2VudCIsIlN5bWJvbCIsImtPcHRpb25zIiwia0ZhY3RvcnkiLCJrRGlzcGF0Y2hlcyIsImtEaXNwYXRjaEtleSIsImtEZWZhdWx0SGVhZGVycyIsImtEZWZhdWx0VHJhaWxlcnMiLCJrQ29udGVudExlbmd0aCIsImtNb2NrQWdlbnQiLCJrTW9ja0FnZW50U2V0Iiwia01vY2tBZ2VudEdldCIsImtNb2NrRGlzcGF0Y2giLCJrQ2xvc2UiLCJrT3JpZ2luYWxDbG9zZSIsImtPcmlnaW4iLCJrSXNNb2NrQWN0aXZlIiwia05ldENvbm5lY3QiLCJrR2V0TmV0Q29ubmVjdCIsImtDb25uZWN0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/mock/mock-symbols.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/mock/mock-utils.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-utils.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ \"(rsc)/../../node_modules/undici/lib/mock/mock-errors.js\");\nconst { kDispatches, kMockAgent, kOriginalDispatch, kOrigin, kGetNetConnect } = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/../../node_modules/undici/lib/mock/mock-symbols.js\");\nconst { buildURL, nop } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\nconst { types: { isPromise } } = __webpack_require__(/*! util */ \"util\");\nfunction matchValue(match, value) {\n    if (typeof match === \"string\") {\n        return match === value;\n    }\n    if (match instanceof RegExp) {\n        return match.test(value);\n    }\n    if (typeof match === \"function\") {\n        return match(value) === true;\n    }\n    return false;\n}\nfunction lowerCaseEntries(headers) {\n    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue])=>{\n        return [\n            headerName.toLocaleLowerCase(),\n            headerValue\n        ];\n    }));\n}\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */ function getHeaderByName(headers, key) {\n    if (Array.isArray(headers)) {\n        for(let i = 0; i < headers.length; i += 2){\n            if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n                return headers[i + 1];\n            }\n        }\n        return undefined;\n    } else if (typeof headers.get === \"function\") {\n        return headers.get(key);\n    } else {\n        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];\n    }\n}\n/** @param {string[]} headers */ function buildHeadersFromArray(headers) {\n    const clone = headers.slice();\n    const entries = [];\n    for(let index = 0; index < clone.length; index += 2){\n        entries.push([\n            clone[index],\n            clone[index + 1]\n        ]);\n    }\n    return Object.fromEntries(entries);\n}\nfunction matchHeaders(mockDispatch, headers) {\n    if (typeof mockDispatch.headers === \"function\") {\n        if (Array.isArray(headers)) {\n            headers = buildHeadersFromArray(headers);\n        }\n        return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {});\n    }\n    if (typeof mockDispatch.headers === \"undefined\") {\n        return true;\n    }\n    if (typeof headers !== \"object\" || typeof mockDispatch.headers !== \"object\") {\n        return false;\n    }\n    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)){\n        const headerValue = getHeaderByName(headers, matchHeaderName);\n        if (!matchValue(matchHeaderValue, headerValue)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction safeUrl(path) {\n    if (typeof path !== \"string\") {\n        return path;\n    }\n    const pathSegments = path.split(\"?\");\n    if (pathSegments.length !== 2) {\n        return path;\n    }\n    const qp = new URLSearchParams(pathSegments.pop());\n    qp.sort();\n    return [\n        ...pathSegments,\n        qp.toString()\n    ].join(\"?\");\n}\nfunction matchKey(mockDispatch, { path, method, body, headers }) {\n    const pathMatch = matchValue(mockDispatch.path, path);\n    const methodMatch = matchValue(mockDispatch.method, method);\n    const bodyMatch = typeof mockDispatch.body !== \"undefined\" ? matchValue(mockDispatch.body, body) : true;\n    const headersMatch = matchHeaders(mockDispatch, headers);\n    return pathMatch && methodMatch && bodyMatch && headersMatch;\n}\nfunction getResponseData(data) {\n    if (Buffer.isBuffer(data)) {\n        return data;\n    } else if (typeof data === \"object\") {\n        return JSON.stringify(data);\n    } else {\n        return data.toString();\n    }\n}\nfunction getMockDispatch(mockDispatches, key) {\n    const basePath = key.query ? buildURL(key.path, key.query) : key.path;\n    const resolvedPath = typeof basePath === \"string\" ? safeUrl(basePath) : basePath;\n    // Match path\n    let matchedMockDispatches = mockDispatches.filter(({ consumed })=>!consumed).filter(({ path })=>matchValue(safeUrl(path), resolvedPath));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);\n    }\n    // Match method\n    matchedMockDispatches = matchedMockDispatches.filter(({ method })=>matchValue(method, key.method));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);\n    }\n    // Match body\n    matchedMockDispatches = matchedMockDispatches.filter(({ body })=>typeof body !== \"undefined\" ? matchValue(body, key.body) : true);\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);\n    }\n    // Match headers\n    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch)=>matchHeaders(mockDispatch, key.headers));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === \"object\" ? JSON.stringify(key.headers) : key.headers}'`);\n    }\n    return matchedMockDispatches[0];\n}\nfunction addMockDispatch(mockDispatches, key, data) {\n    const baseData = {\n        timesInvoked: 0,\n        times: 1,\n        persist: false,\n        consumed: false\n    };\n    const replyData = typeof data === \"function\" ? {\n        callback: data\n    } : {\n        ...data\n    };\n    const newMockDispatch = {\n        ...baseData,\n        ...key,\n        pending: true,\n        data: {\n            error: null,\n            ...replyData\n        }\n    };\n    mockDispatches.push(newMockDispatch);\n    return newMockDispatch;\n}\nfunction deleteMockDispatch(mockDispatches, key) {\n    const index = mockDispatches.findIndex((dispatch)=>{\n        if (!dispatch.consumed) {\n            return false;\n        }\n        return matchKey(dispatch, key);\n    });\n    if (index !== -1) {\n        mockDispatches.splice(index, 1);\n    }\n}\nfunction buildKey(opts) {\n    const { path, method, body, headers, query } = opts;\n    return {\n        path,\n        method,\n        body,\n        headers,\n        query\n    };\n}\nfunction generateKeyValues(data) {\n    return Object.entries(data).reduce((keyValuePairs, [key, value])=>[\n            ...keyValuePairs,\n            Buffer.from(`${key}`),\n            Array.isArray(value) ? value.map((x)=>Buffer.from(`${x}`)) : Buffer.from(`${value}`)\n        ], []);\n}\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */ function getStatusText(statusCode) {\n    return STATUS_CODES[statusCode] || \"unknown\";\n}\nasync function getResponse(body) {\n    const buffers = [];\n    for await (const data of body){\n        buffers.push(data);\n    }\n    return Buffer.concat(buffers).toString(\"utf8\");\n}\n/**\n * Mock dispatch function used to simulate undici dispatches\n */ function mockDispatch(opts, handler) {\n    // Get mock dispatch from built key\n    const key = buildKey(opts);\n    const mockDispatch = getMockDispatch(this[kDispatches], key);\n    mockDispatch.timesInvoked++;\n    // Here's where we resolve a callback if a callback is present for the dispatch data.\n    if (mockDispatch.data.callback) {\n        mockDispatch.data = {\n            ...mockDispatch.data,\n            ...mockDispatch.data.callback(opts)\n        };\n    }\n    // Parse mockDispatch data\n    const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch;\n    const { timesInvoked, times } = mockDispatch;\n    // If it's used up and not persistent, mark as consumed\n    mockDispatch.consumed = !persist && timesInvoked >= times;\n    mockDispatch.pending = timesInvoked < times;\n    // If specified, trigger dispatch error\n    if (error !== null) {\n        deleteMockDispatch(this[kDispatches], key);\n        handler.onError(error);\n        return true;\n    }\n    // Handle the request with a delay if necessary\n    if (typeof delay === \"number\" && delay > 0) {\n        setTimeout(()=>{\n            handleReply(this[kDispatches]);\n        }, delay);\n    } else {\n        handleReply(this[kDispatches]);\n    }\n    function handleReply(mockDispatches, _data = data) {\n        // fetch's HeadersList is a 1D string array\n        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;\n        const body = typeof _data === \"function\" ? _data({\n            ...opts,\n            headers: optsHeaders\n        }) : _data;\n        // util.types.isPromise is likely needed for jest.\n        if (isPromise(body)) {\n            // If handleReply is asynchronous, throwing an error\n            // in the callback will reject the promise, rather than\n            // synchronously throw the error, which breaks some tests.\n            // Rather, we wait for the callback to resolve if it is a\n            // promise, and then re-run handleReply with the new body.\n            body.then((newData)=>handleReply(mockDispatches, newData));\n            return;\n        }\n        const responseData = getResponseData(body);\n        const responseHeaders = generateKeyValues(headers);\n        const responseTrailers = generateKeyValues(trailers);\n        handler.abort = nop;\n        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));\n        handler.onData(Buffer.from(responseData));\n        handler.onComplete(responseTrailers);\n        deleteMockDispatch(mockDispatches, key);\n    }\n    function resume() {}\n    return true;\n}\nfunction buildMockDispatch() {\n    const agent = this[kMockAgent];\n    const origin = this[kOrigin];\n    const originalDispatch = this[kOriginalDispatch];\n    return function dispatch(opts, handler) {\n        if (agent.isMockActive) {\n            try {\n                mockDispatch.call(this, opts, handler);\n            } catch (error) {\n                if (error instanceof MockNotMatchedError) {\n                    const netConnect = agent[kGetNetConnect]();\n                    if (netConnect === false) {\n                        throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);\n                    }\n                    if (checkNetConnect(netConnect, origin)) {\n                        originalDispatch.call(this, opts, handler);\n                    } else {\n                        throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);\n                    }\n                } else {\n                    throw error;\n                }\n            }\n        } else {\n            originalDispatch.call(this, opts, handler);\n        }\n    };\n}\nfunction checkNetConnect(netConnect, origin) {\n    const url = new URL(origin);\n    if (netConnect === true) {\n        return true;\n    } else if (Array.isArray(netConnect) && netConnect.some((matcher)=>matchValue(matcher, url.host))) {\n        return true;\n    }\n    return false;\n}\nfunction buildMockOptions(opts) {\n    if (opts) {\n        const { agent, ...mockOptions } = opts;\n        return mockOptions;\n    }\n}\nmodule.exports = {\n    getResponseData,\n    getMockDispatch,\n    addMockDispatch,\n    deleteMockDispatch,\n    buildKey,\n    generateKeyValues,\n    matchValue,\n    getResponse,\n    getStatusText,\n    mockDispatch,\n    buildMockDispatch,\n    checkNetConnect,\n    buildMockOptions,\n    getHeaderByName\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxtQkFBbUIsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUN4QyxNQUFNLEVBQ0pDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxpQkFBaUIsRUFDakJDLE9BQU8sRUFDUEMsY0FBYyxFQUNmLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFTSxRQUFRLEVBQUVDLEdBQUcsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVRLFlBQVksRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUNqQyxNQUFNLEVBQ0pTLE9BQU8sRUFDTEMsU0FBUyxFQUNWLEVBQ0YsR0FBR1YsbUJBQU9BLENBQUM7QUFFWixTQUFTVyxXQUFZQyxLQUFLLEVBQUVDLEtBQUs7SUFDL0IsSUFBSSxPQUFPRCxVQUFVLFVBQVU7UUFDN0IsT0FBT0EsVUFBVUM7SUFDbkI7SUFDQSxJQUFJRCxpQkFBaUJFLFFBQVE7UUFDM0IsT0FBT0YsTUFBTUcsSUFBSSxDQUFDRjtJQUNwQjtJQUNBLElBQUksT0FBT0QsVUFBVSxZQUFZO1FBQy9CLE9BQU9BLE1BQU1DLFdBQVc7SUFDMUI7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTRyxpQkFBa0JDLE9BQU87SUFDaEMsT0FBT0MsT0FBT0MsV0FBVyxDQUN2QkQsT0FBT0UsT0FBTyxDQUFDSCxTQUFTSSxHQUFHLENBQUMsQ0FBQyxDQUFDQyxZQUFZQyxZQUFZO1FBQ3BELE9BQU87WUFBQ0QsV0FBV0UsaUJBQWlCO1lBQUlEO1NBQVk7SUFDdEQ7QUFFSjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNFLGdCQUFpQlIsT0FBTyxFQUFFUyxHQUFHO0lBQ3BDLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ1gsVUFBVTtRQUMxQixJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSVosUUFBUWEsTUFBTSxFQUFFRCxL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QUFTO3dCQUN2Q0MsaUJBQWlCRSxJQUFJLENBQUMsSUFBSSxFQUFFbEMsTUFBTVc7b0JBQ3BDLE9BQU87d0JBQ0wsTUFBTSxJQUFJcEcsb0JBQW9CLENBQUMsRUFBRW1GLE1BQU0wQyxPQUFPLENBQUMsK0JBQStCLEVBQUVMLE9BQU8sNkRBQTZELENBQUM7b0JBQ3ZKO2dCQUNGLE9BQU87b0JBQ0wsTUFBTXJDO2dCQUNSO1lBQ0Y7UUFDRixPQUFPO1lBQ0xzQyxpQkFBaUJFLElBQUksQ0FBQyxJQUFJLEVBQUVsQyxNQUFNVztRQUNwQztJQUNGO0FBQ0Y7QUFFQSxTQUFTMEIsZ0JBQWlCRixVQUFVLEVBQUVKLE1BQU07SUFDMUMsTUFBTU8sTUFBTSxJQUFJQyxJQUFJUjtJQUNwQixJQUFJSSxlQUFlLE1BQU07UUFDdkIsT0FBTztJQUNULE9BQU8sSUFBSWhHLE1BQU1DLE9BQU8sQ0FBQytGLGVBQWVBLFdBQVdLLElBQUksQ0FBQyxDQUFDQyxVQUFZdEgsV0FBV3NILFNBQVNILElBQUlJLElBQUksSUFBSTtRQUNuRyxPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTQyxpQkFBa0IzQyxJQUFJO0lBQzdCLElBQUlBLE1BQU07UUFDUixNQUFNLEVBQUU4QixLQUFLLEVBQUUsR0FBR2MsYUFBYSxHQUFHNUM7UUFDbEMsT0FBTzRDO0lBQ1Q7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZjNFO0lBQ0FNO0lBQ0FRO0lBQ0FVO0lBQ0FJO0lBQ0FFO0lBQ0E5RTtJQUNBcUY7SUFDQUY7SUFDQXZEO0lBQ0E4RTtJQUNBUTtJQUNBTTtJQUNBMUc7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXV0aWxzLmpzPzFkYmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgTW9ja05vdE1hdGNoZWRFcnJvciB9ID0gcmVxdWlyZSgnLi9tb2NrLWVycm9ycycpXG5jb25zdCB7XG4gIGtEaXNwYXRjaGVzLFxuICBrTW9ja0FnZW50LFxuICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAga09yaWdpbixcbiAga0dldE5ldENvbm5lY3Rcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCB7IGJ1aWxkVVJMLCBub3AgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnaHR0cCcpXG5jb25zdCB7XG4gIHR5cGVzOiB7XG4gICAgaXNQcm9taXNlXG4gIH1cbn0gPSByZXF1aXJlKCd1dGlsJylcblxuZnVuY3Rpb24gbWF0Y2hWYWx1ZSAobWF0Y2gsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1hdGNoID09PSB2YWx1ZVxuICB9XG4gIGlmIChtYXRjaCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBtYXRjaC50ZXN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgbWF0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF0Y2godmFsdWUpID09PSB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGxvd2VyQ2FzZUVudHJpZXMgKGhlYWRlcnMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhoZWFkZXJzKS5tYXAoKFtoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZV0pID0+IHtcbiAgICAgIHJldHVybiBbaGVhZGVyTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpLCBoZWFkZXJWYWx1ZV1cbiAgICB9KVxuICApXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL2luZGV4JykuSGVhZGVyc3xzdHJpbmdbXXxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBoZWFkZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cbmZ1bmN0aW9uIGdldEhlYWRlckJ5TmFtZSAoaGVhZGVycywga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAoaGVhZGVyc1tpXS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSBrZXkudG9Mb2NhbGVMb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4gaGVhZGVyc1tpICsgMV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH0gZWxzZSBpZiAodHlwZW9mIGhlYWRlcnMuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGhlYWRlcnMuZ2V0KGtleSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG93ZXJDYXNlRW50cmllcyhoZWFkZXJzKVtrZXkudG9Mb2NhbGVMb3dlckNhc2UoKV1cbiAgfVxufVxuXG4vKiogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVycyAqL1xuZnVuY3Rpb24gYnVpbGRIZWFkZXJzRnJvbUFycmF5IChoZWFkZXJzKSB7IC8vIGZldGNoIEhlYWRlcnNMaXN0XG4gIGNvbnN0IGNsb25lID0gaGVhZGVycy5zbGljZSgpXG4gIGNvbnN0IGVudHJpZXMgPSBbXVxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY2xvbmUubGVuZ3RoOyBpbmRleCArPSAyKSB7XG4gICAgZW50cmllcy5wdXNoKFtjbG9uZVtpbmRleF0sIGNsb25lW2luZGV4ICsgMV1dKVxuICB9XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcylcbn1cblxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJzIChtb2NrRGlzcGF0Y2gsIGhlYWRlcnMpIHtcbiAgaWYgKHR5cGVvZiBtb2NrRGlzcGF0Y2guaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7IC8vIGZldGNoIEhlYWRlcnNMaXN0XG4gICAgICBoZWFkZXJzID0gYnVpbGRIZWFkZXJzRnJvbUFycmF5KGhlYWRlcnMpXG4gICAgfVxuICAgIHJldHVybiBtb2NrRGlzcGF0Y2guaGVhZGVycyhoZWFkZXJzID8gbG93ZXJDYXNlRW50cmllcyhoZWFkZXJzKSA6IHt9KVxuICB9XG4gIGlmICh0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAodHlwZW9mIGhlYWRlcnMgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBtb2NrRGlzcGF0Y2guaGVhZGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAoY29uc3QgW21hdGNoSGVhZGVyTmFtZSwgbWF0Y2hIZWFkZXJWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobW9ja0Rpc3BhdGNoLmhlYWRlcnMpKSB7XG4gICAgY29uc3QgaGVhZGVyVmFsdWUgPSBnZXRIZWFkZXJCeU5hbWUoaGVhZGVycywgbWF0Y2hIZWFkZXJOYW1lKVxuXG4gICAgaWYgKCFtYXRjaFZhbHVlKG1hdGNoSGVhZGVyVmFsdWUsIGhlYWRlclZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHNhZmVVcmwgKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBjb25zdCBwYXRoU2VnbWVudHMgPSBwYXRoLnNwbGl0KCc/JylcblxuICBpZiAocGF0aFNlZ21lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBjb25zdCBxcCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGF0aFNlZ21lbnRzLnBvcCgpKVxuICBxcC5zb3J0KClcbiAgcmV0dXJuIFsuLi5wYXRoU2VnbWVudHMsIHFwLnRvU3RyaW5nKCldLmpvaW4oJz8nKVxufVxuXG5mdW5jdGlvbiBtYXRjaEtleSAobW9ja0Rpc3BhdGNoLCB7IHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycyB9KSB7XG4gIGNvbnN0IHBhdGhNYXRjaCA9IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoLnBhdGgsIHBhdGgpXG4gIGNvbnN0IG1ldGhvZE1hdGNoID0gbWF0Y2hWYWx1ZShtb2NrRGlzcGF0Y2gubWV0aG9kLCBtZXRob2QpXG4gIGNvbnN0IGJvZHlNYXRjaCA9IHR5cGVvZiBtb2NrRGlzcGF0Y2guYm9keSAhPT0gJ3VuZGVmaW5lZCcgPyBtYXRjaFZhbHVlKG1vY2tEaXNwYXRjaC5ib2R5LCBib2R5KSA6IHRydWVcbiAgY29uc3QgaGVhZGVyc01hdGNoID0gbWF0Y2hIZWFkZXJzKG1vY2tEaXNwYXRjaCwgaGVhZGVycylcbiAgcmV0dXJuIHBhdGhNYXRjaCAmJiBtZXRob2RNYXRjaCAmJiBib2R5TWF0Y2ggJiYgaGVhZGVyc01hdGNoXG59XG5cbmZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YSAoZGF0YSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGFcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGF0YS50b1N0cmluZygpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TW9ja0Rpc3BhdGNoIChtb2NrRGlzcGF0Y2hlcywga2V5KSB7XG4gIGNvbnN0IGJhc2VQYXRoID0ga2V5LnF1ZXJ5ID8gYnVpbGRVUkwoa2V5LnBhdGgsIGtleS5xdWVyeSkgOiBrZXkucGF0aFxuICBjb25zdCByZXNvbHZlZFBhdGggPSB0eXBlb2YgYmFzZVBhdGggPT09ICdzdHJpbmcnID8gc2FmZVVybChiYXNlUGF0aCkgOiBiYXNlUGF0aFxuXG4gIC8vIE1hdGNoIHBhdGhcbiAgbGV0IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBjb25zdW1lZCB9KSA9PiAhY29uc3VtZWQpLmZpbHRlcigoeyBwYXRoIH0pID0+IG1hdGNoVmFsdWUoc2FmZVVybChwYXRoKSwgcmVzb2x2ZWRQYXRoKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgcGF0aCAnJHtyZXNvbHZlZFBhdGh9J2ApXG4gIH1cblxuICAvLyBNYXRjaCBtZXRob2RcbiAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBtZXRob2QgfSkgPT4gbWF0Y2hWYWx1ZShtZXRob2QsIGtleS5tZXRob2QpKVxuICBpZiAobWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGBNb2NrIGRpc3BhdGNoIG5vdCBtYXRjaGVkIGZvciBtZXRob2QgJyR7a2V5Lm1ldGhvZH0nYClcbiAgfVxuXG4gIC8vIE1hdGNoIGJvZHlcbiAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBib2R5IH0pID0+IHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyA/IG1hdGNoVmFsdWUoYm9keSwga2V5LmJvZHkpIDogdHJ1ZSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgYm9keSAnJHtrZXkuYm9keX0nYClcbiAgfVxuXG4gIC8vIE1hdGNoIGhlYWRlcnNcbiAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigobW9ja0Rpc3BhdGNoKSA9PiBtYXRjaEhlYWRlcnMobW9ja0Rpc3BhdGNoLCBrZXkuaGVhZGVycykpXG4gIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIGhlYWRlcnMgJyR7dHlwZW9mIGtleS5oZWFkZXJzID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGtleS5oZWFkZXJzKSA6IGtleS5oZWFkZXJzfSdgKVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRNb2NrRGlzcGF0Y2hlc1swXVxufVxuXG5mdW5jdGlvbiBhZGRNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXksIGRhdGEpIHtcbiAgY29uc3QgYmFzZURhdGEgPSB7IHRpbWVzSW52b2tlZDogMCwgdGltZXM6IDEsIHBlcnNpc3Q6IGZhbHNlLCBjb25zdW1lZDogZmFsc2UgfVxuICBjb25zdCByZXBseURhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IHsgY2FsbGJhY2s6IGRhdGEgfSA6IHsgLi4uZGF0YSB9XG4gIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IHsgLi4uYmFzZURhdGEsIC4uLmtleSwgcGVuZGluZzogdHJ1ZSwgZGF0YTogeyBlcnJvcjogbnVsbCwgLi4ucmVwbHlEYXRhIH0gfVxuICBtb2NrRGlzcGF0Y2hlcy5wdXNoKG5ld01vY2tEaXNwYXRjaClcbiAgcmV0dXJuIG5ld01vY2tEaXNwYXRjaFxufVxuXG5mdW5jdGlvbiBkZWxldGVNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXkpIHtcbiAgY29uc3QgaW5kZXggPSBtb2NrRGlzcGF0Y2hlcy5maW5kSW5kZXgoZGlzcGF0Y2ggPT4ge1xuICAgIGlmICghZGlzcGF0Y2guY29uc3VtZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hLZXkoZGlzcGF0Y2gsIGtleSlcbiAgfSlcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIG1vY2tEaXNwYXRjaGVzLnNwbGljZShpbmRleCwgMSlcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEtleSAob3B0cykge1xuICBjb25zdCB7IHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycywgcXVlcnkgfSA9IG9wdHNcbiAgcmV0dXJuIHtcbiAgICBwYXRoLFxuICAgIG1ldGhvZCxcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG4gICAgcXVlcnlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUtleVZhbHVlcyAoZGF0YSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChrZXlWYWx1ZVBhaXJzLCBba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAuLi5rZXlWYWx1ZVBhaXJzLFxuICAgIEJ1ZmZlci5mcm9tKGAke2tleX1gKSxcbiAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh4ID0+IEJ1ZmZlci5mcm9tKGAke3h9YCkpIDogQnVmZmVyLmZyb20oYCR7dmFsdWV9YClcbiAgXSwgW10pXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1c1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1c0NvZGVcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdHVzVGV4dCAoc3RhdHVzQ29kZSkge1xuICByZXR1cm4gU1RBVFVTX0NPREVTW3N0YXR1c0NvZGVdIHx8ICd1bmtub3duJ1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRSZXNwb25zZSAoYm9keSkge1xuICBjb25zdCBidWZmZXJzID0gW11cbiAgZm9yIGF3YWl0IChjb25zdCBkYXRhIG9mIGJvZHkpIHtcbiAgICBidWZmZXJzLnB1c2goZGF0YSlcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChidWZmZXJzKS50b1N0cmluZygndXRmOCcpXG59XG5cbi8qKlxuICogTW9jayBkaXNwYXRjaCBmdW5jdGlvbiB1c2VkIHRvIHNpbXVsYXRlIHVuZGljaSBkaXNwYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIG1vY2tEaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAvLyBHZXQgbW9jayBkaXNwYXRjaCBmcm9tIGJ1aWx0IGtleVxuICBjb25zdCBrZXkgPSBidWlsZEtleShvcHRzKVxuICBjb25zdCBtb2NrRGlzcGF0Y2ggPSBnZXRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIGtleSlcblxuICBtb2NrRGlzcGF0Y2gudGltZXNJbnZva2VkKytcblxuICAvLyBIZXJlJ3Mgd2hlcmUgd2UgcmVzb2x2ZSBhIGNhbGxiYWNrIGlmIGEgY2FsbGJhY2sgaXMgcHJlc2VudCBmb3IgdGhlIGRpc3BhdGNoIGRhdGEuXG4gIGlmIChtb2NrRGlzcGF0Y2guZGF0YS5jYWxsYmFjaykge1xuICAgIG1vY2tEaXNwYXRjaC5kYXRhID0geyAuLi5tb2NrRGlzcGF0Y2guZGF0YSwgLi4ubW9ja0Rpc3BhdGNoLmRhdGEuY2FsbGJhY2sob3B0cykgfVxuICB9XG5cbiAgLy8gUGFyc2UgbW9ja0Rpc3BhdGNoIGRhdGFcbiAgY29uc3QgeyBkYXRhOiB7IHN0YXR1c0NvZGUsIGRhdGEsIGhlYWRlcnMsIHRyYWlsZXJzLCBlcnJvciB9LCBkZWxheSwgcGVyc2lzdCB9ID0gbW9ja0Rpc3BhdGNoXG4gIGNvbnN0IHsgdGltZXNJbnZva2VkLCB0aW1lcyB9ID0gbW9ja0Rpc3BhdGNoXG5cbiAgLy8gSWYgaXQncyB1c2VkIHVwIGFuZCBub3QgcGVyc2lzdGVudCwgbWFyayBhcyBjb25zdW1lZFxuICBtb2NrRGlzcGF0Y2guY29uc3VtZWQgPSAhcGVyc2lzdCAmJiB0aW1lc0ludm9rZWQgPj0gdGltZXNcbiAgbW9ja0Rpc3BhdGNoLnBlbmRpbmcgPSB0aW1lc0ludm9rZWQgPCB0aW1lc1xuXG4gIC8vIElmIHNwZWNpZmllZCwgdHJpZ2dlciBkaXNwYXRjaCBlcnJvclxuICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICBkZWxldGVNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIGtleSlcbiAgICBoYW5kbGVyLm9uRXJyb3IoZXJyb3IpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIEhhbmRsZSB0aGUgcmVxdWVzdCB3aXRoIGEgZGVsYXkgaWYgbmVjZXNzYXJ5XG4gIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInICYmIGRlbGF5ID4gMCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaGFuZGxlUmVwbHkodGhpc1trRGlzcGF0Y2hlc10pXG4gICAgfSwgZGVsYXkpXG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlUmVwbHkodGhpc1trRGlzcGF0Y2hlc10pXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVSZXBseSAobW9ja0Rpc3BhdGNoZXMsIF9kYXRhID0gZGF0YSkge1xuICAgIC8vIGZldGNoJ3MgSGVhZGVyc0xpc3QgaXMgYSAxRCBzdHJpbmcgYXJyYXlcbiAgICBjb25zdCBvcHRzSGVhZGVycyA9IEFycmF5LmlzQXJyYXkob3B0cy5oZWFkZXJzKVxuICAgICAgPyBidWlsZEhlYWRlcnNGcm9tQXJyYXkob3B0cy5oZWFkZXJzKVxuICAgICAgOiBvcHRzLmhlYWRlcnNcbiAgICBjb25zdCBib2R5ID0gdHlwZW9mIF9kYXRhID09PSAnZnVuY3Rpb24nXG4gICAgICA/IF9kYXRhKHsgLi4ub3B0cywgaGVhZGVyczogb3B0c0hlYWRlcnMgfSlcbiAgICAgIDogX2RhdGFcblxuICAgIC8vIHV0aWwudHlwZXMuaXNQcm9taXNlIGlzIGxpa2VseSBuZWVkZWQgZm9yIGplc3QuXG4gICAgaWYgKGlzUHJvbWlzZShib2R5KSkge1xuICAgICAgLy8gSWYgaGFuZGxlUmVwbHkgaXMgYXN5bmNocm9ub3VzLCB0aHJvd2luZyBhbiBlcnJvclxuICAgICAgLy8gaW4gdGhlIGNhbGxiYWNrIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLCByYXRoZXIgdGhhblxuICAgICAgLy8gc3luY2hyb25vdXNseSB0aHJvdyB0aGUgZXJyb3IsIHdoaWNoIGJyZWFrcyBzb21lIHRlc3RzLlxuICAgICAgLy8gUmF0aGVyLCB3ZSB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gcmVzb2x2ZSBpZiBpdCBpcyBhXG4gICAgICAvLyBwcm9taXNlLCBhbmQgdGhlbiByZS1ydW4gaGFuZGxlUmVwbHkgd2l0aCB0aGUgbmV3IGJvZHkuXG4gICAgICBib2R5LnRoZW4oKG5ld0RhdGEpID0+IGhhbmRsZVJlcGx5KG1vY2tEaXNwYXRjaGVzLCBuZXdEYXRhKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGdldFJlc3BvbnNlRGF0YShib2R5KVxuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGdlbmVyYXRlS2V5VmFsdWVzKGhlYWRlcnMpXG4gICAgY29uc3QgcmVzcG9uc2VUcmFpbGVycyA9IGdlbmVyYXRlS2V5VmFsdWVzKHRyYWlsZXJzKVxuXG4gICAgaGFuZGxlci5hYm9ydCA9IG5vcFxuICAgIGhhbmRsZXIub25IZWFkZXJzKHN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgcmVzdW1lLCBnZXRTdGF0dXNUZXh0KHN0YXR1c0NvZGUpKVxuICAgIGhhbmRsZXIub25EYXRhKEJ1ZmZlci5mcm9tKHJlc3BvbnNlRGF0YSkpXG4gICAgaGFuZGxlci5vbkNvbXBsZXRlKHJlc3BvbnNlVHJhaWxlcnMpXG4gICAgZGVsZXRlTW9ja0Rpc3BhdGNoKG1vY2tEaXNwYXRjaGVzLCBrZXkpXG4gIH1cblxuICBmdW5jdGlvbiByZXN1bWUgKCkge31cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBidWlsZE1vY2tEaXNwYXRjaCAoKSB7XG4gIGNvbnN0IGFnZW50ID0gdGhpc1trTW9ja0FnZW50XVxuICBjb25zdCBvcmlnaW4gPSB0aGlzW2tPcmlnaW5dXG4gIGNvbnN0IG9yaWdpbmFsRGlzcGF0Y2ggPSB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXVxuXG4gIHJldHVybiBmdW5jdGlvbiBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIGlmIChhZ2VudC5pc01vY2tBY3RpdmUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1vY2tEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBNb2NrTm90TWF0Y2hlZEVycm9yKSB7XG4gICAgICAgICAgY29uc3QgbmV0Q29ubmVjdCA9IGFnZW50W2tHZXROZXRDb25uZWN0XSgpXG4gICAgICAgICAgaWYgKG5ldENvbm5lY3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgJHtlcnJvci5tZXNzYWdlfTogc3Vic2VxdWVudCByZXF1ZXN0IHRvIG9yaWdpbiAke29yaWdpbn0gd2FzIG5vdCBhbGxvd2VkIChuZXQuY29ubmVjdCBkaXNhYmxlZClgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hlY2tOZXRDb25uZWN0KG5ldENvbm5lY3QsIG9yaWdpbikpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRGlzcGF0Y2guY2FsbCh0aGlzLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgJHtlcnJvci5tZXNzYWdlfTogc3Vic2VxdWVudCByZXF1ZXN0IHRvIG9yaWdpbiAke29yaWdpbn0gd2FzIG5vdCBhbGxvd2VkIChuZXQuY29ubmVjdCBpcyBub3QgZW5hYmxlZCBmb3IgdGhpcyBvcmlnaW4pYClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcmlnaW5hbERpc3BhdGNoLmNhbGwodGhpcywgb3B0cywgaGFuZGxlcilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOZXRDb25uZWN0IChuZXRDb25uZWN0LCBvcmlnaW4pIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChvcmlnaW4pXG4gIGlmIChuZXRDb25uZWN0ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5ldENvbm5lY3QpICYmIG5ldENvbm5lY3Quc29tZSgobWF0Y2hlcikgPT4gbWF0Y2hWYWx1ZShtYXRjaGVyLCB1cmwuaG9zdCkpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYnVpbGRNb2NrT3B0aW9ucyAob3B0cykge1xuICBpZiAob3B0cykge1xuICAgIGNvbnN0IHsgYWdlbnQsIC4uLm1vY2tPcHRpb25zIH0gPSBvcHRzXG4gICAgcmV0dXJuIG1vY2tPcHRpb25zXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldFJlc3BvbnNlRGF0YSxcbiAgZ2V0TW9ja0Rpc3BhdGNoLFxuICBhZGRNb2NrRGlzcGF0Y2gsXG4gIGRlbGV0ZU1vY2tEaXNwYXRjaCxcbiAgYnVpbGRLZXksXG4gIGdlbmVyYXRlS2V5VmFsdWVzLFxuICBtYXRjaFZhbHVlLFxuICBnZXRSZXNwb25zZSxcbiAgZ2V0U3RhdHVzVGV4dCxcbiAgbW9ja0Rpc3BhdGNoLFxuICBidWlsZE1vY2tEaXNwYXRjaCxcbiAgY2hlY2tOZXRDb25uZWN0LFxuICBidWlsZE1vY2tPcHRpb25zLFxuICBnZXRIZWFkZXJCeU5hbWVcbn1cbiJdLCJuYW1lcyI6WyJNb2NrTm90TWF0Y2hlZEVycm9yIiwicmVxdWlyZSIsImtEaXNwYXRjaGVzIiwia01vY2tBZ2VudCIsImtPcmlnaW5hbERpc3BhdGNoIiwia09yaWdpbiIsImtHZXROZXRDb25uZWN0IiwiYnVpbGRVUkwiLCJub3AiLCJTVEFUVVNfQ09ERVMiLCJ0eXBlcyIsImlzUHJvbWlzZSIsIm1hdGNoVmFsdWUiLCJtYXRjaCIsInZhbHVlIiwiUmVnRXhwIiwidGVzdCIsImxvd2VyQ2FzZUVudHJpZXMiLCJoZWFkZXJzIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwibWFwIiwiaGVhZGVyTmFtZSIsImhlYWRlclZhbHVlIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJnZXRIZWFkZXJCeU5hbWUiLCJrZXkiLCJBcnJheSIsImlzQXJyYXkiLCJpIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiZ2V0IiwiYnVpbGRIZWFkZXJzRnJvbUFycmF5IiwiY2xvbmUiLCJzbGljZSIsImluZGV4IiwicHVzaCIsIm1hdGNoSGVhZGVycyIsIm1vY2tEaXNwYXRjaCIsIm1hdGNoSGVhZGVyTmFtZSIsIm1hdGNoSGVhZGVyVmFsdWUiLCJzYWZlVXJsIiwicGF0aCIsInBhdGhTZWdtZW50cyIsInNwbGl0IiwicXAiLCJVUkxTZWFyY2hQYXJhbXMiLCJwb3AiLCJzb3J0IiwidG9TdHJpbmciLCJqb2luIiwibWF0Y2hLZXkiLCJtZXRob2QiLCJib2R5IiwicGF0aE1hdGNoIiwibWV0aG9kTWF0Y2giLCJib2R5TWF0Y2giLCJoZWFkZXJzTWF0Y2giLCJnZXRSZXNwb25zZURhdGEiLCJkYXRhIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0TW9ja0Rpc3BhdGNoIiwibW9ja0Rpc3BhdGNoZXMiLCJiYXNlUGF0aCIsInF1ZXJ5IiwicmVzb2x2ZWRQYXRoIiwibWF0Y2hlZE1vY2tEaXNwYXRjaGVzIiwiZmlsdGVyIiwiY29uc3VtZWQiLCJhZGRNb2NrRGlzcGF0Y2giLCJiYXNlRGF0YSIsInRpbWVzSW52b2tlZCIsInRpbWVzIiwicGVyc2lzdCIsInJlcGx5RGF0YSIsImNhbGxiYWNrIiwibmV3TW9ja0Rpc3BhdGNoIiwicGVuZGluZyIsImVycm9yIiwiZGVsZXRlTW9ja0Rpc3BhdGNoIiwiZmluZEluZGV4IiwiZGlzcGF0Y2giLCJzcGxpY2UiLCJidWlsZEtleSIsIm9wdHMiLCJnZW5lcmF0ZUtleVZhbHVlcyIsInJlZHVjZSIsImtleVZhbHVlUGFpcnMiLCJmcm9tIiwieCIsImdldFN0YXR1c1RleHQiLCJzdGF0dXNDb2RlIiwiZ2V0UmVzcG9uc2UiLCJidWZmZXJzIiwiY29uY2F0IiwiaGFuZGxlciIsInRyYWlsZXJzIiwiZGVsYXkiLCJvbkVycm9yIiwic2V0VGltZW91dCIsImhhbmRsZVJlcGx5IiwiX2RhdGEiLCJvcHRzSGVhZGVycyIsInRoZW4iLCJuZXdEYXRhIiwicmVzcG9uc2VEYXRhIiwicmVzcG9uc2VIZWFkZXJzIiwicmVzcG9uc2VUcmFpbGVycyIsImFib3J0Iiwib25IZWFkZXJzIiwicmVzdW1lIiwib25EYXRhIiwib25Db21wbGV0ZSIsImJ1aWxkTW9ja0Rpc3BhdGNoIiwiYWdlbnQiLCJvcmlnaW4iLCJvcmlnaW5hbERpc3BhdGNoIiwiaXNNb2NrQWN0aXZlIiwiY2FsbCIsIm5ldENvbm5lY3QiLCJtZXNzYWdlIiwiY2hlY2tOZXRDb25uZWN0IiwidXJsIiwiVVJMIiwic29tZSIsIm1hdGNoZXIiLCJob3N0IiwiYnVpbGRNb2NrT3B0aW9ucyIsIm1vY2tPcHRpb25zIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/mock/mock-utils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/mock/pending-interceptors-formatter.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/undici/lib/mock/pending-interceptors-formatter.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Transform } = __webpack_require__(/*! stream */ \"stream\");\nconst { Console } = __webpack_require__(/*! console */ \"console\");\n/**\n * Gets the output of `console.table()` as a string.\n */ module.exports = class PendingInterceptorsFormatter {\n    constructor({ disableColors } = {}){\n        this.transform = new Transform({\n            transform (chunk, _enc, cb) {\n                cb(null, chunk);\n            }\n        });\n        this.logger = new Console({\n            stdout: this.transform,\n            inspectOptions: {\n                colors: !disableColors && !process.env.CI\n            }\n        });\n    }\n    format(pendingInterceptors) {\n        const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin })=>({\n                Method: method,\n                Origin: origin,\n                Path: path,\n                \"Status code\": statusCode,\n                Persistent: persist ? \"\" : \"\",\n                Invocations: timesInvoked,\n                Remaining: persist ? Infinity : times - timesInvoked\n            }));\n        this.logger.table(withPrettyHeaders);\n        return this.transform.read().toString();\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9wZW5kaW5nLWludGVyY2VwdG9ycy1mb3JtYXR0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFNBQVMsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM5QixNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUU1Qjs7Q0FFQyxHQUNERSxPQUFPQyxPQUFPLEdBQUcsTUFBTUM7SUFDckJDLFlBQWEsRUFBRUMsYUFBYSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDbkMsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSVIsVUFBVTtZQUM3QlEsV0FBV0MsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLEVBQUU7Z0JBQ3hCQSxHQUFHLE1BQU1GO1lBQ1g7UUFDRjtRQUVBLElBQUksQ0FBQ0csTUFBTSxHQUFHLElBQUlWLFFBQVE7WUFDeEJXLFFBQVEsSUFBSSxDQUFDTCxTQUFTO1lBQ3RCTSxnQkFBZ0I7Z0JBQ2RDLFFBQVEsQ0FBQ1IsaUJBQWlCLENBQUNTLFFBQVFDLEdBQUcsQ0FBQ0MsRUFBRTtZQUMzQztRQUNGO0lBQ0Y7SUFFQUMsT0FBUUMsbUJBQW1CLEVBQUU7UUFDM0IsTUFBTUMsb0JBQW9CRCxvQkFBb0JFLEdBQUcsQ0FDL0MsQ0FBQyxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUUsRUFBRUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLFlBQVksRUFBRUMsTUFBTSxFQUFFLEdBQU07Z0JBQ2pGQyxRQUFRUjtnQkFDUlMsUUFBUUY7Z0JBQ1JHLE1BQU1UO2dCQUNOLGVBQWVFO2dCQUNmUSxZQUFZUCxVQUFVLE1BQU07Z0JBQzVCUSxhQUFhTjtnQkFDYk8sV0FBV1QsVUFBVVUsV0FBV1QsUUFBUUM7WUFDMUM7UUFFRixJQUFJLENBQUNqQixNQUFNLENBQUMwQixLQUFLLENBQUNqQjtRQUNsQixPQUFPLElBQUksQ0FBQ2IsU0FBUyxDQUFDK0IsSUFBSSxHQUFHQyxRQUFRO0lBQ3ZDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svcGVuZGluZy1pbnRlcmNlcHRvcnMtZm9ybWF0dGVyLmpzP2JlZmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgVHJhbnNmb3JtIH0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3QgeyBDb25zb2xlIH0gPSByZXF1aXJlKCdjb25zb2xlJylcblxuLyoqXG4gKiBHZXRzIHRoZSBvdXRwdXQgb2YgYGNvbnNvbGUudGFibGUo4oCmKWAgYXMgYSBzdHJpbmcuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yICh7IGRpc2FibGVDb2xvcnMgfSA9IHt9KSB7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKHtcbiAgICAgIHRyYW5zZm9ybSAoY2h1bmssIF9lbmMsIGNiKSB7XG4gICAgICAgIGNiKG51bGwsIGNodW5rKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmxvZ2dlciA9IG5ldyBDb25zb2xlKHtcbiAgICAgIHN0ZG91dDogdGhpcy50cmFuc2Zvcm0sXG4gICAgICBpbnNwZWN0T3B0aW9uczoge1xuICAgICAgICBjb2xvcnM6ICFkaXNhYmxlQ29sb3JzICYmICFwcm9jZXNzLmVudi5DSVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmb3JtYXQgKHBlbmRpbmdJbnRlcmNlcHRvcnMpIHtcbiAgICBjb25zdCB3aXRoUHJldHR5SGVhZGVycyA9IHBlbmRpbmdJbnRlcmNlcHRvcnMubWFwKFxuICAgICAgKHsgbWV0aG9kLCBwYXRoLCBkYXRhOiB7IHN0YXR1c0NvZGUgfSwgcGVyc2lzdCwgdGltZXMsIHRpbWVzSW52b2tlZCwgb3JpZ2luIH0pID0+ICh7XG4gICAgICAgIE1ldGhvZDogbWV0aG9kLFxuICAgICAgICBPcmlnaW46IG9yaWdpbixcbiAgICAgICAgUGF0aDogcGF0aCxcbiAgICAgICAgJ1N0YXR1cyBjb2RlJzogc3RhdHVzQ29kZSxcbiAgICAgICAgUGVyc2lzdGVudDogcGVyc2lzdCA/ICfinIUnIDogJ+KdjCcsXG4gICAgICAgIEludm9jYXRpb25zOiB0aW1lc0ludm9rZWQsXG4gICAgICAgIFJlbWFpbmluZzogcGVyc2lzdCA/IEluZmluaXR5IDogdGltZXMgLSB0aW1lc0ludm9rZWRcbiAgICAgIH0pKVxuXG4gICAgdGhpcy5sb2dnZXIudGFibGUod2l0aFByZXR0eUhlYWRlcnMpXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJlYWQoKS50b1N0cmluZygpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJUcmFuc2Zvcm0iLCJyZXF1aXJlIiwiQ29uc29sZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyIiwiY29uc3RydWN0b3IiLCJkaXNhYmxlQ29sb3JzIiwidHJhbnNmb3JtIiwiY2h1bmsiLCJfZW5jIiwiY2IiLCJsb2dnZXIiLCJzdGRvdXQiLCJpbnNwZWN0T3B0aW9ucyIsImNvbG9ycyIsInByb2Nlc3MiLCJlbnYiLCJDSSIsImZvcm1hdCIsInBlbmRpbmdJbnRlcmNlcHRvcnMiLCJ3aXRoUHJldHR5SGVhZGVycyIsIm1hcCIsIm1ldGhvZCIsInBhdGgiLCJkYXRhIiwic3RhdHVzQ29kZSIsInBlcnNpc3QiLCJ0aW1lcyIsInRpbWVzSW52b2tlZCIsIm9yaWdpbiIsIk1ldGhvZCIsIk9yaWdpbiIsIlBhdGgiLCJQZXJzaXN0ZW50IiwiSW52b2NhdGlvbnMiLCJSZW1haW5pbmciLCJJbmZpbml0eSIsInRhYmxlIiwicmVhZCIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/mock/pending-interceptors-formatter.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/mock/pluralizer.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/mock/pluralizer.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst singulars = {\n    pronoun: \"it\",\n    is: \"is\",\n    was: \"was\",\n    this: \"this\"\n};\nconst plurals = {\n    pronoun: \"they\",\n    is: \"are\",\n    was: \"were\",\n    this: \"these\"\n};\nmodule.exports = class Pluralizer {\n    constructor(singular, plural){\n        this.singular = singular;\n        this.plural = plural;\n    }\n    pluralize(count) {\n        const one = count === 1;\n        const keys = one ? singulars : plurals;\n        const noun = one ? this.singular : this.plural;\n        return {\n            ...keys,\n            count,\n            noun\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9wbHVyYWxpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsWUFBWTtJQUNoQkMsU0FBUztJQUNUQyxJQUFJO0lBQ0pDLEtBQUs7SUFDTEMsTUFBTTtBQUNSO0FBRUEsTUFBTUMsVUFBVTtJQUNkSixTQUFTO0lBQ1RDLElBQUk7SUFDSkMsS0FBSztJQUNMQyxNQUFNO0FBQ1I7QUFFQUUsT0FBT0MsT0FBTyxHQUFHLE1BQU1DO0lBQ3JCQyxZQUFhQyxRQUFRLEVBQUVDLE1BQU0sQ0FBRTtRQUM3QixJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO0lBQ2hCO0lBRUFDLFVBQVdDLEtBQUssRUFBRTtRQUNoQixNQUFNQyxNQUFNRCxVQUFVO1FBQ3RCLE1BQU1FLE9BQU9ELE1BQU1kLFlBQVlLO1FBQy9CLE1BQU1XLE9BQU9GLE1BQU0sSUFBSSxDQUFDSixRQUFRLEdBQUcsSUFBSSxDQUFDQyxNQUFNO1FBQzlDLE9BQU87WUFBRSxHQUFHSSxJQUFJO1lBQUVGO1lBQU9HO1FBQUs7SUFDaEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9wbHVyYWxpemVyLmpzPzJiNjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHNpbmd1bGFycyA9IHtcbiAgcHJvbm91bjogJ2l0JyxcbiAgaXM6ICdpcycsXG4gIHdhczogJ3dhcycsXG4gIHRoaXM6ICd0aGlzJ1xufVxuXG5jb25zdCBwbHVyYWxzID0ge1xuICBwcm9ub3VuOiAndGhleScsXG4gIGlzOiAnYXJlJyxcbiAgd2FzOiAnd2VyZScsXG4gIHRoaXM6ICd0aGVzZSdcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQbHVyYWxpemVyIHtcbiAgY29uc3RydWN0b3IgKHNpbmd1bGFyLCBwbHVyYWwpIHtcbiAgICB0aGlzLnNpbmd1bGFyID0gc2luZ3VsYXJcbiAgICB0aGlzLnBsdXJhbCA9IHBsdXJhbFxuICB9XG5cbiAgcGx1cmFsaXplIChjb3VudCkge1xuICAgIGNvbnN0IG9uZSA9IGNvdW50ID09PSAxXG4gICAgY29uc3Qga2V5cyA9IG9uZSA/IHNpbmd1bGFycyA6IHBsdXJhbHNcbiAgICBjb25zdCBub3VuID0gb25lID8gdGhpcy5zaW5ndWxhciA6IHRoaXMucGx1cmFsXG4gICAgcmV0dXJuIHsgLi4ua2V5cywgY291bnQsIG5vdW4gfVxuICB9XG59XG4iXSwibmFtZXMiOlsic2luZ3VsYXJzIiwicHJvbm91biIsImlzIiwid2FzIiwidGhpcyIsInBsdXJhbHMiLCJtb2R1bGUiLCJleHBvcnRzIiwiUGx1cmFsaXplciIsImNvbnN0cnVjdG9yIiwic2luZ3VsYXIiLCJwbHVyYWwiLCJwbHVyYWxpemUiLCJjb3VudCIsIm9uZSIsImtleXMiLCJub3VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/mock/pluralizer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/node/fixed-queue.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/node/fixed-queue.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("/* eslint-disable */ \n// Extracted from node/lib/internal/fixed_queue.js\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\nclass FixedCircularBuffer {\n    constructor(){\n        this.bottom = 0;\n        this.top = 0;\n        this.list = new Array(kSize);\n        this.next = null;\n    }\n    isEmpty() {\n        return this.top === this.bottom;\n    }\n    isFull() {\n        return (this.top + 1 & kMask) === this.bottom;\n    }\n    push(data) {\n        this.list[this.top] = data;\n        this.top = this.top + 1 & kMask;\n    }\n    shift() {\n        const nextItem = this.list[this.bottom];\n        if (nextItem === undefined) return null;\n        this.list[this.bottom] = undefined;\n        this.bottom = this.bottom + 1 & kMask;\n        return nextItem;\n    }\n}\nmodule.exports = class FixedQueue {\n    constructor(){\n        this.head = this.tail = new FixedCircularBuffer();\n    }\n    isEmpty() {\n        return this.head.isEmpty();\n    }\n    push(data) {\n        if (this.head.isFull()) {\n            // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n            // and sets it as the new main queue.\n            this.head = this.head.next = new FixedCircularBuffer();\n        }\n        this.head.push(data);\n    }\n    shift() {\n        const tail = this.tail;\n        const next = tail.shift();\n        if (tail.isEmpty() && tail.next !== null) {\n            // If there is another queue, it forms the new tail.\n            this.tail = tail.next;\n        }\n        return next;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbm9kZS9maXhlZC1xdWV1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsR0FFbEI7QUFFQSxrREFBa0Q7QUFFbEQsOEVBQThFO0FBQzlFLE1BQU1BLFFBQVE7QUFDZCxNQUFNQyxRQUFRRCxRQUFRO0FBRXRCLHNFQUFzRTtBQUN0RSxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG1FQUFtRTtBQUNuRSxrRUFBa0U7QUFDbEUsa0VBQWtFO0FBQ2xFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSxFQUFFO0FBQ0YsK0RBQStEO0FBQy9ELHdCQUF3QjtBQUN4QixFQUFFO0FBQ0YsMkRBQTJEO0FBQzNELHlEQUF5RDtBQUN6RCx5REFBeUQ7QUFDekQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELEVBQUU7QUFDRixtRUFBbUU7QUFDbkUsb0VBQW9FO0FBQ3BFLGdCQUFnQjtBQUNoQixFQUFFO0FBQ0YsNERBQTREO0FBQzVELHdFQUF3RTtBQUN4RSxrQ0FBa0M7QUFFbEMsTUFBTUU7SUFDSkMsYUFBYztRQUNaLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNDLElBQUksR0FBRyxJQUFJQyxNQUFNUDtRQUN0QixJQUFJLENBQUNRLElBQUksR0FBRztJQUNkO0lBRUFDLFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQ0osR0FBRyxLQUFLLElBQUksQ0FBQ0QsTUFBTTtJQUNqQztJQUVBTSxTQUFTO1FBQ1AsT0FBTyxDQUFDLElBQUssQ0FBQ0wsR0FBRyxHQUFHLElBQUtKLEtBQUksTUFBTyxJQUFJLENBQUNHLE1BQU07SUFDakQ7SUFFQU8sS0FBS0MsSUFBSSxFQUFFO1FBQ1QsSUFBSSxDQUFDTixJQUFJLENBQUMsSUFBSSxDQUFDRCxHQUFHLENBQUMsR0FBR087UUFDdEIsSUFBSSxDQUFDUCxHQUFHLEdBQUcsSUFBSyxDQUFDQSxHQUFHLEdBQUcsSUFBS0o7SUFDOUI7SUFFQVksUUFBUTtRQUNOLE1BQU1DLFdBQVcsSUFBSSxDQUFDUixJQUFJLENBQUMsSUFBSSxDQUFDRixNQUFNLENBQUM7UUFDdkMsSUFBSVUsYUFBYUMsV0FDZixPQUFPO1FBQ1QsSUFBSSxDQUFDVCxJQUFJLENBQUMsSUFBSSxDQUFDRixNQUFNLENBQUMsR0FBR1c7UUFDekIsSUFBSSxDQUFDWCxNQUFNLEdBQUcsSUFBSyxDQUFDQSxNQUFNLEdBQUcsSUFBS0g7UUFDbEMsT0FBT2E7SUFDVDtBQUNGO0FBRUFFLE9BQU9DLE9BQU8sR0FBRyxNQUFNQztJQUNyQmYsYUFBYztRQUNaLElBQUksQ0FBQ2dCLElBQUksR0FBRyxJQUFJLENBQUNDLElBQUksR0FBRyxJQUFJbEI7SUFDOUI7SUFFQU8sVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDVSxJQUFJLENBQUNWLE9BQU87SUFDMUI7SUFFQUUsS0FBS0MsSUFBSSxFQUFFO1FBQ1QsSUFBSSxJQUFJLENBQUNPLElBQUksQ0FBQ1QsTUFBTSxJQUFJO1lBQ3RCLHlFQUF5RTtZQUN6RSxxQ0FBcUM7WUFDckMsSUFBSSxDQUFDUyxJQUFJLEdBQUcsSUFBSSxDQUFDQSxJQUFJLENBQUNYLElBQUksR0FBRyxJQUFJTjtRQUNuQztRQUNBLElBQUksQ0FBQ2lCLElBQUksQ0FBQ1IsSUFBSSxDQUFDQztJQUNqQjtJQUVBQyxRQUFRO1FBQ04sTUFBTU8sT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTVosT0FBT1ksS0FBS1AsS0FBSztRQUN2QixJQUFJTyxLQUFLWCxPQUFPLE1BQU1XLEtBQUtaLElBQUksS0FBSyxNQUFNO1lBQ3hDLG9EQUFvRDtZQUNwRCxJQUFJLENBQUNZLElBQUksR0FBR0EsS0FBS1osSUFBSTtRQUN2QjtRQUNBLE9BQU9BO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbm9kZS9maXhlZC1xdWV1ZS5qcz8wZjU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vLyBFeHRyYWN0ZWQgZnJvbSBub2RlL2xpYi9pbnRlcm5hbC9maXhlZF9xdWV1ZS5qc1xuXG4vLyBDdXJyZW50bHkgb3B0aW1hbCBxdWV1ZSBzaXplLCB0ZXN0ZWQgb24gVjggNi4wIC0gNi42LiBNdXN0IGJlIHBvd2VyIG9mIHR3by5cbmNvbnN0IGtTaXplID0gMjA0ODtcbmNvbnN0IGtNYXNrID0ga1NpemUgLSAxO1xuXG4vLyBUaGUgRml4ZWRRdWV1ZSBpcyBpbXBsZW1lbnRlZCBhcyBhIHNpbmdseS1saW5rZWQgbGlzdCBvZiBmaXhlZC1zaXplXG4vLyBjaXJjdWxhciBidWZmZXJzLiBJdCBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuLy9cbi8vICBoZWFkICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhaWxcbi8vICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gICAgdiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2XG4vLyArLS0tLS0tLS0tLS0rIDwtLS0tLVxcICAgICAgICstLS0tLS0tLS0tLSsgPC0tLS0tLVxcICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW251bGxdICAgfCAgICAgICAgXFwtLS0tLSB8ICAgbmV4dCAgICB8ICAgICAgICAgXFwtLS0tLS0tIHwgICBuZXh0ICAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgIGl0ZW0gICAgfCA8LS0gYm90dG9tICAgIHwgICBpdGVtICAgIHwgPC0tIGJvdHRvbSAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICBib3R0b20gLS0+IHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgICAuLi4gICAgfCAgICAgICAgICAgICAgIHwgICAgLi4uICAgIHwgICAgICAgICAgICAgICAgICB8ICAgIC4uLiAgICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCA8LS0gdG9wICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8IDwtLSB0b3AgIHRvcCAtLT4gfCAgW2VtcHR5XSAgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vL1xuLy8gT3IsIGlmIHRoZXJlIGlzIG9ubHkgb25lIGNpcmN1bGFyIGJ1ZmZlciwgaXQgbG9va3Mgc29tZXRoaW5nXG4vLyBsaWtlIGVpdGhlciBvZiB0aGVzZTpcbi8vXG4vLyAgaGVhZCAgIHRhaWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkICAgdGFpbFxuLy8gICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8XG4vLyAgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgICAgIHZcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW251bGxdICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBbbnVsbF0gICB8XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICAgaXRlbSAgICB8IDwtLSBib3R0b20gICAgICAgICAgICB0b3AgLS0+IHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgW2VtcHR5XSAgfCA8LS0gdG9wICAgICAgICAgICAgYm90dG9tIC0tPiB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy9cbi8vIEFkZGluZyBhIHZhbHVlIG1lYW5zIG1vdmluZyBgdG9wYCBmb3J3YXJkIGJ5IG9uZSwgcmVtb3ZpbmcgbWVhbnNcbi8vIG1vdmluZyBgYm90dG9tYCBmb3J3YXJkIGJ5IG9uZS4gQWZ0ZXIgcmVhY2hpbmcgdGhlIGVuZCwgdGhlIHF1ZXVlXG4vLyB3cmFwcyBhcm91bmQuXG4vL1xuLy8gV2hlbiBgdG9wID09PSBib3R0b21gIHRoZSBjdXJyZW50IHF1ZXVlIGlzIGVtcHR5IGFuZCB3aGVuXG4vLyBgdG9wICsgMSA9PT0gYm90dG9tYCBpdCdzIGZ1bGwuIFRoaXMgd2FzdGVzIGEgc2luZ2xlIHNwYWNlIG9mIHN0b3JhZ2Vcbi8vIGJ1dCBhbGxvd3MgbXVjaCBxdWlja2VyIGNoZWNrcy5cblxuY2xhc3MgRml4ZWRDaXJjdWxhckJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYm90dG9tID0gMDtcbiAgICB0aGlzLnRvcCA9IDA7XG4gICAgdGhpcy5saXN0ID0gbmV3IEFycmF5KGtTaXplKTtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICB9XG5cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy50b3AgPT09IHRoaXMuYm90dG9tO1xuICB9XG5cbiAgaXNGdWxsKCkge1xuICAgIHJldHVybiAoKHRoaXMudG9wICsgMSkgJiBrTWFzaykgPT09IHRoaXMuYm90dG9tO1xuICB9XG5cbiAgcHVzaChkYXRhKSB7XG4gICAgdGhpcy5saXN0W3RoaXMudG9wXSA9IGRhdGE7XG4gICAgdGhpcy50b3AgPSAodGhpcy50b3AgKyAxKSAmIGtNYXNrO1xuICB9XG5cbiAgc2hpZnQoKSB7XG4gICAgY29uc3QgbmV4dEl0ZW0gPSB0aGlzLmxpc3RbdGhpcy5ib3R0b21dO1xuICAgIGlmIChuZXh0SXRlbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5saXN0W3RoaXMuYm90dG9tXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9ICh0aGlzLmJvdHRvbSArIDEpICYga01hc2s7XG4gICAgcmV0dXJuIG5leHRJdGVtO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRml4ZWRRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBGaXhlZENpcmN1bGFyQnVmZmVyKCk7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmhlYWQuaXNFbXB0eSgpO1xuICB9XG5cbiAgcHVzaChkYXRhKSB7XG4gICAgaWYgKHRoaXMuaGVhZC5pc0Z1bGwoKSkge1xuICAgICAgLy8gSGVhZCBpcyBmdWxsOiBDcmVhdGVzIGEgbmV3IHF1ZXVlLCBzZXRzIHRoZSBvbGQgcXVldWUncyBgLm5leHRgIHRvIGl0LFxuICAgICAgLy8gYW5kIHNldHMgaXQgYXMgdGhlIG5ldyBtYWluIHF1ZXVlLlxuICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQgPSBuZXcgRml4ZWRDaXJjdWxhckJ1ZmZlcigpO1xuICAgIH1cbiAgICB0aGlzLmhlYWQucHVzaChkYXRhKTtcbiAgfVxuXG4gIHNoaWZ0KCkge1xuICAgIGNvbnN0IHRhaWwgPSB0aGlzLnRhaWw7XG4gICAgY29uc3QgbmV4dCA9IHRhaWwuc2hpZnQoKTtcbiAgICBpZiAodGFpbC5pc0VtcHR5KCkgJiYgdGFpbC5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhbm90aGVyIHF1ZXVlLCBpdCBmb3JtcyB0aGUgbmV3IHRhaWwuXG4gICAgICB0aGlzLnRhaWwgPSB0YWlsLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBuZXh0O1xuICB9XG59O1xuIl0sIm5hbWVzIjpbImtTaXplIiwia01hc2siLCJGaXhlZENpcmN1bGFyQnVmZmVyIiwiY29uc3RydWN0b3IiLCJib3R0b20iLCJ0b3AiLCJsaXN0IiwiQXJyYXkiLCJuZXh0IiwiaXNFbXB0eSIsImlzRnVsbCIsInB1c2giLCJkYXRhIiwic2hpZnQiLCJuZXh0SXRlbSIsInVuZGVmaW5lZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJGaXhlZFF1ZXVlIiwiaGVhZCIsInRhaWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/node/fixed-queue.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/pool-base.js":
/*!**************************************************!*\
  !*** ../../node_modules/undici/lib/pool-base.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/../../node_modules/undici/lib/dispatcher-base.js\");\nconst FixedQueue = __webpack_require__(/*! ./node/fixed-queue */ \"(rsc)/../../node_modules/undici/lib/node/fixed-queue.js\");\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst PoolStats = __webpack_require__(/*! ./pool-stats */ \"(rsc)/../../node_modules/undici/lib/pool-stats.js\");\nconst kClients = Symbol(\"clients\");\nconst kNeedDrain = Symbol(\"needDrain\");\nconst kQueue = Symbol(\"queue\");\nconst kClosedResolve = Symbol(\"closed resolve\");\nconst kOnDrain = Symbol(\"onDrain\");\nconst kOnConnect = Symbol(\"onConnect\");\nconst kOnDisconnect = Symbol(\"onDisconnect\");\nconst kOnConnectionError = Symbol(\"onConnectionError\");\nconst kGetDispatcher = Symbol(\"get dispatcher\");\nconst kAddClient = Symbol(\"add client\");\nconst kRemoveClient = Symbol(\"remove client\");\nconst kStats = Symbol(\"stats\");\nclass PoolBase extends DispatcherBase {\n    constructor(){\n        super();\n        this[kQueue] = new FixedQueue();\n        this[kClients] = [];\n        this[kQueued] = 0;\n        const pool = this;\n        this[kOnDrain] = function onDrain(origin, targets) {\n            const queue = pool[kQueue];\n            let needDrain = false;\n            while(!needDrain){\n                const item = queue.shift();\n                if (!item) {\n                    break;\n                }\n                pool[kQueued]--;\n                needDrain = !this.dispatch(item.opts, item.handler);\n            }\n            this[kNeedDrain] = needDrain;\n            if (!this[kNeedDrain] && pool[kNeedDrain]) {\n                pool[kNeedDrain] = false;\n                pool.emit(\"drain\", origin, [\n                    pool,\n                    ...targets\n                ]);\n            }\n            if (pool[kClosedResolve] && queue.isEmpty()) {\n                Promise.all(pool[kClients].map((c)=>c.close())).then(pool[kClosedResolve]);\n            }\n        };\n        this[kOnConnect] = (origin, targets)=>{\n            pool.emit(\"connect\", origin, [\n                pool,\n                ...targets\n            ]);\n        };\n        this[kOnDisconnect] = (origin, targets, err)=>{\n            pool.emit(\"disconnect\", origin, [\n                pool,\n                ...targets\n            ], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err)=>{\n            pool.emit(\"connectionError\", origin, [\n                pool,\n                ...targets\n            ], err);\n        };\n        this[kStats] = new PoolStats(this);\n    }\n    get [kBusy]() {\n        return this[kNeedDrain];\n    }\n    get [kConnected]() {\n        return this[kClients].filter((client)=>client[kConnected]).length;\n    }\n    get [kFree]() {\n        return this[kClients].filter((client)=>client[kConnected] && !client[kNeedDrain]).length;\n    }\n    get [kPending]() {\n        let ret = this[kQueued];\n        for (const { [kPending]: pending } of this[kClients]){\n            ret += pending;\n        }\n        return ret;\n    }\n    get [kRunning]() {\n        let ret = 0;\n        for (const { [kRunning]: running } of this[kClients]){\n            ret += running;\n        }\n        return ret;\n    }\n    get [kSize]() {\n        let ret = this[kQueued];\n        for (const { [kSize]: size } of this[kClients]){\n            ret += size;\n        }\n        return ret;\n    }\n    get stats() {\n        return this[kStats];\n    }\n    async [kClose]() {\n        if (this[kQueue].isEmpty()) {\n            return Promise.all(this[kClients].map((c)=>c.close()));\n        } else {\n            return new Promise((resolve)=>{\n                this[kClosedResolve] = resolve;\n            });\n        }\n    }\n    async [kDestroy](err) {\n        while(true){\n            const item = this[kQueue].shift();\n            if (!item) {\n                break;\n            }\n            item.handler.onError(err);\n        }\n        return Promise.all(this[kClients].map((c)=>c.destroy(err)));\n    }\n    [kDispatch](opts, handler) {\n        const dispatcher = this[kGetDispatcher]();\n        if (!dispatcher) {\n            this[kNeedDrain] = true;\n            this[kQueue].push({\n                opts,\n                handler\n            });\n            this[kQueued]++;\n        } else if (!dispatcher.dispatch(opts, handler)) {\n            dispatcher[kNeedDrain] = true;\n            this[kNeedDrain] = !this[kGetDispatcher]();\n        }\n        return !this[kNeedDrain];\n    }\n    [kAddClient](client) {\n        client.on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]);\n        this[kClients].push(client);\n        if (this[kNeedDrain]) {\n            process.nextTick(()=>{\n                if (this[kNeedDrain]) {\n                    this[kOnDrain](client[kUrl], [\n                        this,\n                        client\n                    ]);\n                }\n            });\n        }\n        return this;\n    }\n    [kRemoveClient](client) {\n        client.close(()=>{\n            const idx = this[kClients].indexOf(client);\n            if (idx !== -1) {\n                this[kClients].splice(idx, 1);\n            }\n        });\n        this[kNeedDrain] = this[kClients].some((dispatcher)=>!dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n    }\n}\nmodule.exports = {\n    PoolBase,\n    kClients,\n    kNeedDrain,\n    kAddClient,\n    kRemoveClient,\n    kGetDispatcher\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC1iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsaUJBQWlCQyxtQkFBT0EsQ0FBQztBQUMvQixNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVFLFVBQVUsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEdBQUdaLG1CQUFPQSxDQUFDO0FBQ3BILE1BQU1hLFlBQVliLG1CQUFPQSxDQUFDO0FBRTFCLE1BQU1jLFdBQVdDLE9BQU87QUFDeEIsTUFBTUMsYUFBYUQsT0FBTztBQUMxQixNQUFNRSxTQUFTRixPQUFPO0FBQ3RCLE1BQU1HLGlCQUFpQkgsT0FBTztBQUM5QixNQUFNSSxXQUFXSixPQUFPO0FBQ3hCLE1BQU1LLGFBQWFMLE9BQU87QUFDMUIsTUFBTU0sZ0JBQWdCTixPQUFPO0FBQzdCLE1BQU1PLHFCQUFxQlAsT0FBTztBQUNsQyxNQUFNUSxpQkFBaUJSLE9BQU87QUFDOUIsTUFBTVMsYUFBYVQsT0FBTztBQUMxQixNQUFNVSxnQkFBZ0JWLE9BQU87QUFDN0IsTUFBTVcsU0FBU1gsT0FBTztBQUV0QixNQUFNWSxpQkFBaUI1QjtJQUNyQjZCLGFBQWU7UUFDYixLQUFLO1FBRUwsSUFBSSxDQUFDWCxPQUFPLEdBQUcsSUFBSWhCO1FBQ25CLElBQUksQ0FBQ2EsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDUixRQUFRLEdBQUc7UUFFaEIsTUFBTXVCLE9BQU8sSUFBSTtRQUVqQixJQUFJLENBQUNWLFNBQVMsR0FBRyxTQUFTVyxRQUFTQyxNQUFNLEVBQUVDLE9BQU87WUFDaEQsTUFBTUMsUUFBUUosSUFBSSxDQUFDWixPQUFPO1lBRTFCLElBQUlpQixZQUFZO1lBRWhCLE1BQU8sQ0FB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aS9saWIvcG9vbC1iYXNlLmpzP2RlOTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgRml4ZWRRdWV1ZSA9IHJlcXVpcmUoJy4vbm9kZS9maXhlZC1xdWV1ZScpXG5jb25zdCB7IGtDb25uZWN0ZWQsIGtTaXplLCBrUnVubmluZywga1BlbmRpbmcsIGtRdWV1ZWQsIGtCdXN5LCBrRnJlZSwga1VybCwga0Nsb3NlLCBrRGVzdHJveSwga0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL2NvcmUvc3ltYm9scycpXG5jb25zdCBQb29sU3RhdHMgPSByZXF1aXJlKCcuL3Bvb2wtc3RhdHMnKVxuXG5jb25zdCBrQ2xpZW50cyA9IFN5bWJvbCgnY2xpZW50cycpXG5jb25zdCBrTmVlZERyYWluID0gU3ltYm9sKCduZWVkRHJhaW4nKVxuY29uc3Qga1F1ZXVlID0gU3ltYm9sKCdxdWV1ZScpXG5jb25zdCBrQ2xvc2VkUmVzb2x2ZSA9IFN5bWJvbCgnY2xvc2VkIHJlc29sdmUnKVxuY29uc3Qga09uRHJhaW4gPSBTeW1ib2woJ29uRHJhaW4nKVxuY29uc3Qga09uQ29ubmVjdCA9IFN5bWJvbCgnb25Db25uZWN0JylcbmNvbnN0IGtPbkRpc2Nvbm5lY3QgPSBTeW1ib2woJ29uRGlzY29ubmVjdCcpXG5jb25zdCBrT25Db25uZWN0aW9uRXJyb3IgPSBTeW1ib2woJ29uQ29ubmVjdGlvbkVycm9yJylcbmNvbnN0IGtHZXREaXNwYXRjaGVyID0gU3ltYm9sKCdnZXQgZGlzcGF0Y2hlcicpXG5jb25zdCBrQWRkQ2xpZW50ID0gU3ltYm9sKCdhZGQgY2xpZW50JylcbmNvbnN0IGtSZW1vdmVDbGllbnQgPSBTeW1ib2woJ3JlbW92ZSBjbGllbnQnKVxuY29uc3Qga1N0YXRzID0gU3ltYm9sKCdzdGF0cycpXG5cbmNsYXNzIFBvb2xCYXNlIGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trUXVldWVdID0gbmV3IEZpeGVkUXVldWUoKVxuICAgIHRoaXNba0NsaWVudHNdID0gW11cbiAgICB0aGlzW2tRdWV1ZWRdID0gMFxuXG4gICAgY29uc3QgcG9vbCA9IHRoaXNcblxuICAgIHRoaXNba09uRHJhaW5dID0gZnVuY3Rpb24gb25EcmFpbiAob3JpZ2luLCB0YXJnZXRzKSB7XG4gICAgICBjb25zdCBxdWV1ZSA9IHBvb2xba1F1ZXVlXVxuXG4gICAgICBsZXQgbmVlZERyYWluID0gZmFsc2VcblxuICAgICAgd2hpbGUgKCFuZWVkRHJhaW4pIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHF1ZXVlLnNoaWZ0KClcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBwb29sW2tRdWV1ZWRdLS1cbiAgICAgICAgbmVlZERyYWluID0gIXRoaXMuZGlzcGF0Y2goaXRlbS5vcHRzLCBpdGVtLmhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSBuZWVkRHJhaW5cblxuICAgICAgaWYgKCF0aGlzW2tOZWVkRHJhaW5dICYmIHBvb2xba05lZWREcmFpbl0pIHtcbiAgICAgICAgcG9vbFtrTmVlZERyYWluXSA9IGZhbHNlXG4gICAgICAgIHBvb2wuZW1pdCgnZHJhaW4nLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSlcbiAgICAgIH1cblxuICAgICAgaWYgKHBvb2xba0Nsb3NlZFJlc29sdmVdICYmIHF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgICBQcm9taXNlXG4gICAgICAgICAgLmFsbChwb29sW2tDbGllbnRzXS5tYXAoYyA9PiBjLmNsb3NlKCkpKVxuICAgICAgICAgIC50aGVuKHBvb2xba0Nsb3NlZFJlc29sdmVdKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICBwb29sLmVtaXQoJ2Nvbm5lY3QnLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSlcbiAgICB9XG5cbiAgICB0aGlzW2tPbkRpc2Nvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICBwb29sLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgcG9vbC5lbWl0KCdjb25uZWN0aW9uRXJyb3InLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cblxuICAgIHRoaXNba1N0YXRzXSA9IG5ldyBQb29sU3RhdHModGhpcylcbiAgfVxuXG4gIGdldCBba0J1c3ldICgpIHtcbiAgICByZXR1cm4gdGhpc1trTmVlZERyYWluXVxuICB9XG5cbiAgZ2V0IFtrQ29ubmVjdGVkXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NsaWVudHNdLmZpbHRlcihjbGllbnQgPT4gY2xpZW50W2tDb25uZWN0ZWRdKS5sZW5ndGhcbiAgfVxuXG4gIGdldCBba0ZyZWVdICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c10uZmlsdGVyKGNsaWVudCA9PiBjbGllbnRba0Nvbm5lY3RlZF0gJiYgIWNsaWVudFtrTmVlZERyYWluXSkubGVuZ3RoXG4gIH1cblxuICBnZXQgW2tQZW5kaW5nXSAoKSB7XG4gICAgbGV0IHJldCA9IHRoaXNba1F1ZXVlZF1cbiAgICBmb3IgKGNvbnN0IHsgW2tQZW5kaW5nXTogcGVuZGluZyB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICByZXQgKz0gcGVuZGluZ1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgW2tSdW5uaW5nXSAoKSB7XG4gICAgbGV0IHJldCA9IDBcbiAgICBmb3IgKGNvbnN0IHsgW2tSdW5uaW5nXTogcnVubmluZyB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICByZXQgKz0gcnVubmluZ1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgW2tTaXplXSAoKSB7XG4gICAgbGV0IHJldCA9IHRoaXNba1F1ZXVlZF1cbiAgICBmb3IgKGNvbnN0IHsgW2tTaXplXTogc2l6ZSB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICByZXQgKz0gc2l6ZVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgc3RhdHMgKCkge1xuICAgIHJldHVybiB0aGlzW2tTdGF0c11cbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1trUXVldWVdLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXNba0NsaWVudHNdLm1hcChjID0+IGMuY2xvc2UoKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IHJlc29sdmVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgW2tEZXN0cm95XSAoZXJyKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2tRdWV1ZV0uc2hpZnQoKVxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpdGVtLmhhbmRsZXIub25FcnJvcihlcnIpXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXNba0NsaWVudHNdLm1hcChjID0+IGMuZGVzdHJveShlcnIpKSlcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0dldERpc3BhdGNoZXJdKClcblxuICAgIGlmICghZGlzcGF0Y2hlcikge1xuICAgICAgdGhpc1trTmVlZERyYWluXSA9IHRydWVcbiAgICAgIHRoaXNba1F1ZXVlXS5wdXNoKHsgb3B0cywgaGFuZGxlciB9KVxuICAgICAgdGhpc1trUXVldWVkXSsrXG4gICAgfSBlbHNlIGlmICghZGlzcGF0Y2hlci5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKSkge1xuICAgICAgZGlzcGF0Y2hlcltrTmVlZERyYWluXSA9IHRydWVcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSAhdGhpc1trR2V0RGlzcGF0Y2hlcl0oKVxuICAgIH1cblxuICAgIHJldHVybiAhdGhpc1trTmVlZERyYWluXVxuICB9XG5cbiAgW2tBZGRDbGllbnRdIChjbGllbnQpIHtcbiAgICBjbGllbnRcbiAgICAgIC5vbignZHJhaW4nLCB0aGlzW2tPbkRyYWluXSlcbiAgICAgIC5vbignY29ubmVjdCcsIHRoaXNba09uQ29ubmVjdF0pXG4gICAgICAub24oJ2Rpc2Nvbm5lY3QnLCB0aGlzW2tPbkRpc2Nvbm5lY3RdKVxuICAgICAgLm9uKCdjb25uZWN0aW9uRXJyb3InLCB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0pXG5cbiAgICB0aGlzW2tDbGllbnRzXS5wdXNoKGNsaWVudClcblxuICAgIGlmICh0aGlzW2tOZWVkRHJhaW5dKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXNba05lZWREcmFpbl0pIHtcbiAgICAgICAgICB0aGlzW2tPbkRyYWluXShjbGllbnRba1VybF0sIFt0aGlzLCBjbGllbnRdKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBba1JlbW92ZUNsaWVudF0gKGNsaWVudCkge1xuICAgIGNsaWVudC5jbG9zZSgoKSA9PiB7XG4gICAgICBjb25zdCBpZHggPSB0aGlzW2tDbGllbnRzXS5pbmRleE9mKGNsaWVudClcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIHRoaXNba0NsaWVudHNdLnNwbGljZShpZHgsIDEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXNba05lZWREcmFpbl0gPSB0aGlzW2tDbGllbnRzXS5zb21lKGRpc3BhdGNoZXIgPT4gKFxuICAgICAgIWRpc3BhdGNoZXJba05lZWREcmFpbl0gJiZcbiAgICAgIGRpc3BhdGNoZXIuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFBvb2xCYXNlLFxuICBrQ2xpZW50cyxcbiAga05lZWREcmFpbixcbiAga0FkZENsaWVudCxcbiAga1JlbW92ZUNsaWVudCxcbiAga0dldERpc3BhdGNoZXJcbn1cbiJdLCJuYW1lcyI6WyJEaXNwYXRjaGVyQmFzZSIsInJlcXVpcmUiLCJGaXhlZFF1ZXVlIiwia0Nvbm5lY3RlZCIsImtTaXplIiwia1J1bm5pbmciLCJrUGVuZGluZyIsImtRdWV1ZWQiLCJrQnVzeSIsImtGcmVlIiwia1VybCIsImtDbG9zZSIsImtEZXN0cm95Iiwia0Rpc3BhdGNoIiwiUG9vbFN0YXRzIiwia0NsaWVudHMiLCJTeW1ib2wiLCJrTmVlZERyYWluIiwia1F1ZXVlIiwia0Nsb3NlZFJlc29sdmUiLCJrT25EcmFpbiIsImtPbkNvbm5lY3QiLCJrT25EaXNjb25uZWN0Iiwia09uQ29ubmVjdGlvbkVycm9yIiwia0dldERpc3BhdGNoZXIiLCJrQWRkQ2xpZW50Iiwia1JlbW92ZUNsaWVudCIsImtTdGF0cyIsIlBvb2xCYXNlIiwiY29uc3RydWN0b3IiLCJwb29sIiwib25EcmFpbiIsIm9yaWdpbiIsInRhcmdldHMiLCJxdWV1ZSIsIm5lZWREcmFpbiIsIml0ZW0iLCJzaGlmdCIsImRpc3BhdGNoIiwib3B0cyIsImhhbmRsZXIiLCJlbWl0IiwiaXNFbXB0eSIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJjIiwiY2xvc2UiLCJ0aGVuIiwiZXJyIiwiZmlsdGVyIiwiY2xpZW50IiwibGVuZ3RoIiwicmV0IiwicGVuZGluZyIsInJ1bm5pbmciLCJzaXplIiwic3RhdHMiLCJyZXNvbHZlIiwib25FcnJvciIsImRlc3Ryb3kiLCJkaXNwYXRjaGVyIiwicHVzaCIsIm9uIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiaWR4IiwiaW5kZXhPZiIsInNwbGljZSIsInNvbWUiLCJjbG9zZWQiLCJkZXN0cm95ZWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/pool-base.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/pool-stats.js":
/*!***************************************************!*\
  !*** ../../node_modules/undici/lib/pool-stats.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst kPool = Symbol(\"pool\");\nclass PoolStats {\n    constructor(pool){\n        this[kPool] = pool;\n    }\n    get connected() {\n        return this[kPool][kConnected];\n    }\n    get free() {\n        return this[kPool][kFree];\n    }\n    get pending() {\n        return this[kPool][kPending];\n    }\n    get queued() {\n        return this[kPool][kQueued];\n    }\n    get running() {\n        return this[kPool][kRunning];\n    }\n    get size() {\n        return this[kPool][kSize];\n    }\n}\nmodule.exports = PoolStats;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC1zdGF0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNLEVBQUVBLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxLQUFLLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDMUUsTUFBTUMsUUFBUUMsT0FBTztBQUVyQixNQUFNQztJQUNKQyxZQUFhQyxJQUFJLENBQUU7UUFDakIsSUFBSSxDQUFDSixNQUFNLEdBQUdJO0lBQ2hCO0lBRUEsSUFBSUMsWUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDTCxNQUFNLENBQUNOLFdBQVc7SUFDaEM7SUFFQSxJQUFJWSxPQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUNOLE1BQU0sQ0FBQ1AsTUFBTTtJQUMzQjtJQUVBLElBQUljLFVBQVc7UUFDYixPQUFPLElBQUksQ0FBQ1AsTUFBTSxDQUFDTCxTQUFTO0lBQzlCO0lBRUEsSUFBSWEsU0FBVTtRQUNaLE9BQU8sSUFBSSxDQUFDUixNQUFNLENBQUNKLFFBQVE7SUFDN0I7SUFFQSxJQUFJYSxVQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUNULE1BQU0sQ0FBQ0gsU0FBUztJQUM5QjtJQUVBLElBQUlhLE9BQVE7UUFDVixPQUFPLElBQUksQ0FBQ1YsTUFBTSxDQUFDRixNQUFNO0lBQzNCO0FBQ0Y7QUFFQWEsT0FBT0MsT0FBTyxHQUFHViIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC1zdGF0cy5qcz85YTQ0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsga0ZyZWUsIGtDb25uZWN0ZWQsIGtQZW5kaW5nLCBrUXVldWVkLCBrUnVubmluZywga1NpemUgfSA9IHJlcXVpcmUoJy4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGtQb29sID0gU3ltYm9sKCdwb29sJylcblxuY2xhc3MgUG9vbFN0YXRzIHtcbiAgY29uc3RydWN0b3IgKHBvb2wpIHtcbiAgICB0aGlzW2tQb29sXSA9IHBvb2xcbiAgfVxuXG4gIGdldCBjb25uZWN0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrQ29ubmVjdGVkXVxuICB9XG5cbiAgZ2V0IGZyZWUgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrRnJlZV1cbiAgfVxuXG4gIGdldCBwZW5kaW5nICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba1BlbmRpbmddXG4gIH1cblxuICBnZXQgcXVldWVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba1F1ZXVlZF1cbiAgfVxuXG4gIGdldCBydW5uaW5nICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba1J1bm5pbmddXG4gIH1cblxuICBnZXQgc2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tTaXplXVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbFN0YXRzXG4iXSwibmFtZXMiOlsia0ZyZWUiLCJrQ29ubmVjdGVkIiwia1BlbmRpbmciLCJrUXVldWVkIiwia1J1bm5pbmciLCJrU2l6ZSIsInJlcXVpcmUiLCJrUG9vbCIsIlN5bWJvbCIsIlBvb2xTdGF0cyIsImNvbnN0cnVjdG9yIiwicG9vbCIsImNvbm5lY3RlZCIsImZyZWUiLCJwZW5kaW5nIiwicXVldWVkIiwicnVubmluZyIsInNpemUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/pool-stats.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/pool.js":
/*!*********************************************!*\
  !*** ../../node_modules/undici/lib/pool.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { PoolBase, kClients, kNeedDrain, kAddClient, kGetDispatcher } = __webpack_require__(/*! ./pool-base */ \"(rsc)/../../node_modules/undici/lib/pool-base.js\");\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/../../node_modules/undici/lib/client.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ./core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"(rsc)/../../node_modules/undici/lib/core/connect.js\");\nconst kOptions = Symbol(\"options\");\nconst kConnections = Symbol(\"connections\");\nconst kFactory = Symbol(\"factory\");\nfunction defaultFactory(origin, opts) {\n    return new Client(origin, opts);\n}\nclass Pool extends PoolBase {\n    constructor(origin, { connections, factory = defaultFactory, connect, connectTimeout, tls, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, ...options } = {}){\n        super();\n        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n            throw new InvalidArgumentError(\"invalid connections\");\n        }\n        if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n            throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (typeof connect !== \"function\") {\n            connect = buildConnector({\n                ...tls,\n                maxCachedSessions,\n                allowH2,\n                socketPath,\n                timeout: connectTimeout,\n                ...util.nodeHasAutoSelectFamily && autoSelectFamily ? {\n                    autoSelectFamily,\n                    autoSelectFamilyAttemptTimeout\n                } : undefined,\n                ...connect\n            });\n        }\n        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];\n        this[kConnections] = connections || null;\n        this[kUrl] = util.parseOrigin(origin);\n        this[kOptions] = {\n            ...util.deepClone(options),\n            connect,\n            allowH2\n        };\n        this[kOptions].interceptors = options.interceptors ? {\n            ...options.interceptors\n        } : undefined;\n        this[kFactory] = factory;\n    }\n    [kGetDispatcher]() {\n        let dispatcher = this[kClients].find((dispatcher)=>!dispatcher[kNeedDrain]);\n        if (dispatcher) {\n            return dispatcher;\n        }\n        if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n            dispatcher = this[kFactory](this[kUrl], this[kOptions]);\n            this[kAddClient](dispatcher);\n        }\n        return dispatcher;\n    }\n}\nmodule.exports = Pool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFDSkEsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLFVBQVUsRUFDVkMsVUFBVSxFQUNWQyxjQUFjLEVBQ2YsR0FBR0MsbUJBQU9BLENBQUM7QUFDWixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQ0pFLG9CQUFvQixFQUNyQixHQUFHRixtQkFBT0EsQ0FBQztBQUNaLE1BQU1HLE9BQU9ILG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUksSUFBSSxFQUFFQyxhQUFhLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDeEMsTUFBTU0saUJBQWlCTixtQkFBT0EsQ0FBQztBQUUvQixNQUFNTyxXQUFXQyxPQUFPO0FBQ3hCLE1BQU1DLGVBQWVELE9BQU87QUFDNUIsTUFBTUUsV0FBV0YsT0FBTztBQUV4QixTQUFTRyxlQUFnQkMsTUFBTSxFQUFFQyxJQUFJO0lBQ25DLE9BQU8sSUFBSVosT0FBT1csUUFBUUM7QUFDNUI7QUFFQSxNQUFNQyxhQUFhbkI7SUFDakJvQixZQUFhSCxNQUFNLEVBQUUsRUFDbkJJLFdBQVcsRUFDWEMsVUFBVU4sY0FBYyxFQUN4Qk8sT0FBTyxFQUNQQyxjQUFjLEVBQ2RDLEdBQUcsRUFDSEMsaUJBQWlCLEVBQ2pCQyxVQUFVLEVBQ1ZDLGdCQUFnQixFQUNoQkMsOEJBQThCLEVBQzlCQyxPQUFPLEVBQ1AsR0FBR0MsU0FDSixHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ04sS0FBSztRQUVMLElBQUlWLGVBQWUsUUFBUyxFQUFDVyxPQUFPQyxRQUFRLENBQUNaLGdCQUFnQkEsY0FBYyxJQUFJO1lBQzdFLE1BQU0sSUFBSWQscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxPQUFPZSxZQUFZLFlBQVk7WUFDakMsTUFBTSxJQUFJZixxQkFBcUI7UUFDakM7UUFFQSxJQUFJZ0IsV0FBVyxRQUFRLE9BQU9BLFlBQVksY0FBYyxPQUFPQSxZQUFZLFVBQVU7WUFDbkYsTUFBTSxJQUFJaEIscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxPQUFPZ0IsWUFBWSxZQUFZO1lBQ2pDQSxVQUFVWixlQUFlO2dCQUN2QixHQUFHYyxHQUFHO2dCQUNOQztnQkFDQUk7Z0JBQ0FIO2dCQUNBTyxTQUFTVjtnQkFDVCxHQUFJaEIsS0FBSzJCLHVCQUF1QixJQUFJUCxtQkFBbUI7b0JBQUVBO29CQUFrQkM7Z0JBQStCLElBQUlPLFNBQVM7Z0JBQ3ZILEdBQUdiLE9BQU87WUFDWjtRQUNGO1FBRUEsSUFBSSxDQUFDYixjQUFjLEdBQUdxQixRQUFRTSxZQUFZLElBQUlOLFFBQVFNLFlBQVksQ0FBQ2xCLElBQUksSUFBSW1CLE1BQU1DLE9BQU8sQ0FBQ1IsUUFBUU0sWUFBWSxDQUFDbEIsSUFBSSxJQUM5R1ksUUFBUU0sWUFBWSxDQUFDbEIsSUFBSSxHQUN6QixFQUFFO1FBQ04sSUFBSSxDQUFDTCxhQUFhLEdBQUdPLGVBQWU7UUFDcEMsSUFBSSxDQUFDWixLQUFLLEdBQUdELEtBQUtnQyxXQUFXLENBQUN2QjtRQUM5QixJQUFJLENBQUNMLFNBQVMsR0FBRztZQUFFLEdBQUdKLEtBQUtpQyxTQUFTLENBQUNWLFFBQVE7WUFBRVI7WUFBU087UUFBUTtRQUNoRSxJQUFJLENBQUNsQixTQUFTLENBQUN5QixZQUFZLEdBQUdOLFFBQVFNLFlBQVksR0FDOUM7WUFBRSxHQUFHTixRQUFRTSxZQUFZO1FBQUMsSUFDMUJEO1FBQ0osSUFBSSxDQUFDckIsU0FBUyxHQUFHTztJQUNuQjtJQUVBLENBQUNsQixlQUFlLEdBQUk7UUFDbEIsSUFBSXNDLGFBQWEsSUFBSSxDQUFDekMsU0FBUyxDQUFDMEMsSUFBSSxDQUFDRCxDQUFBQSxhQUFjLENBQUNBLFVBQVUsQ0FBQ3hDLFdBQVc7UUFFMUUsSUFBSXdDLFlBQVk7WUFDZCxPQUFPQTtRQUNUO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQzVCLGFBQWEsSUFBSSxJQUFJLENBQUNiLFNBQVMsQ0FBQzJDLE1BQU0sR0FBRyxJQUFJLENBQUM5QixhQUFhLEVBQUU7WUFDckU0QixhQUFhLElBQUksQ0FBQzNCLFNBQVMsQ0FBQyxJQUFJLENBQUNOLEtBQUssRUFBRSxJQUFJLENBQUNHLFNBQVM7WUFDdEQsSUFBSSxDQUFDVCxXQUFXLENBQUN1QztRQUNuQjtRQUVBLE9BQU9BO0lBQ1Q7QUFDRjtBQUVBRyxPQUFPQyxPQUFPLEdBQUczQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC5qcz9iYjJjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIFBvb2xCYXNlLFxuICBrQ2xpZW50cyxcbiAga05lZWREcmFpbixcbiAga0FkZENsaWVudCxcbiAga0dldERpc3BhdGNoZXJcbn0gPSByZXF1aXJlKCcuL3Bvb2wtYmFzZScpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBrVXJsLCBrSW50ZXJjZXB0b3JzIH0gPSByZXF1aXJlKCcuL2NvcmUvc3ltYm9scycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4vY29yZS9jb25uZWN0JylcblxuY29uc3Qga09wdGlvbnMgPSBTeW1ib2woJ29wdGlvbnMnKVxuY29uc3Qga0Nvbm5lY3Rpb25zID0gU3ltYm9sKCdjb25uZWN0aW9ucycpXG5jb25zdCBrRmFjdG9yeSA9IFN5bWJvbCgnZmFjdG9yeScpXG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBDbGllbnQob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBQb29sIGV4dGVuZHMgUG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCB7XG4gICAgY29ubmVjdGlvbnMsXG4gICAgZmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5LFxuICAgIGNvbm5lY3QsXG4gICAgY29ubmVjdFRpbWVvdXQsXG4gICAgdGxzLFxuICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgIHNvY2tldFBhdGgsXG4gICAgYXV0b1NlbGVjdEZhbWlseSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQsXG4gICAgYWxsb3dIMixcbiAgICAuLi5vcHRpb25zXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIGlmIChjb25uZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGNvbm5lY3Rpb25zKSB8fCBjb25uZWN0aW9ucyA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29ubmVjdGlvbnMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Nvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3Ioe1xuICAgICAgICAuLi50bHMsXG4gICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICBhbGxvd0gyLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICB0aW1lb3V0OiBjb25uZWN0VGltZW91dCxcbiAgICAgICAgLi4uKHV0aWwubm9kZUhhc0F1dG9TZWxlY3RGYW1pbHkgJiYgYXV0b1NlbGVjdEZhbWlseSA/IHsgYXV0b1NlbGVjdEZhbWlseSwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IH0gOiB1bmRlZmluZWQpLFxuICAgICAgICAuLi5jb25uZWN0XG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBvcHRpb25zLmludGVyY2VwdG9ycyAmJiBvcHRpb25zLmludGVyY2VwdG9ycy5Qb29sICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5pbnRlcmNlcHRvcnMuUG9vbClcbiAgICAgID8gb3B0aW9ucy5pbnRlcmNlcHRvcnMuUG9vbFxuICAgICAgOiBbXVxuICAgIHRoaXNba0Nvbm5lY3Rpb25zXSA9IGNvbm5lY3Rpb25zIHx8IG51bGxcbiAgICB0aGlzW2tVcmxdID0gdXRpbC5wYXJzZU9yaWdpbihvcmlnaW4pXG4gICAgdGhpc1trT3B0aW9uc10gPSB7IC4uLnV0aWwuZGVlcENsb25lKG9wdGlvbnMpLCBjb25uZWN0LCBhbGxvd0gyIH1cbiAgICB0aGlzW2tPcHRpb25zXS5pbnRlcmNlcHRvcnMgPSBvcHRpb25zLmludGVyY2VwdG9yc1xuICAgICAgPyB7IC4uLm9wdGlvbnMuaW50ZXJjZXB0b3JzIH1cbiAgICAgIDogdW5kZWZpbmVkXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG4gIH1cblxuICBba0dldERpc3BhdGNoZXJdICgpIHtcbiAgICBsZXQgZGlzcGF0Y2hlciA9IHRoaXNba0NsaWVudHNdLmZpbmQoZGlzcGF0Y2hlciA9PiAhZGlzcGF0Y2hlcltrTmVlZERyYWluXSlcblxuICAgIGlmIChkaXNwYXRjaGVyKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hlclxuICAgIH1cblxuICAgIGlmICghdGhpc1trQ29ubmVjdGlvbnNdIHx8IHRoaXNba0NsaWVudHNdLmxlbmd0aCA8IHRoaXNba0Nvbm5lY3Rpb25zXSkge1xuICAgICAgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKHRoaXNba1VybF0sIHRoaXNba09wdGlvbnNdKVxuICAgICAgdGhpc1trQWRkQ2xpZW50XShkaXNwYXRjaGVyKVxuICAgIH1cblxuICAgIHJldHVybiBkaXNwYXRjaGVyXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb29sXG4iXSwibmFtZXMiOlsiUG9vbEJhc2UiLCJrQ2xpZW50cyIsImtOZWVkRHJhaW4iLCJrQWRkQ2xpZW50Iiwia0dldERpc3BhdGNoZXIiLCJyZXF1aXJlIiwiQ2xpZW50IiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJ1dGlsIiwia1VybCIsImtJbnRlcmNlcHRvcnMiLCJidWlsZENvbm5lY3RvciIsImtPcHRpb25zIiwiU3ltYm9sIiwia0Nvbm5lY3Rpb25zIiwia0ZhY3RvcnkiLCJkZWZhdWx0RmFjdG9yeSIsIm9yaWdpbiIsIm9wdHMiLCJQb29sIiwiY29uc3RydWN0b3IiLCJjb25uZWN0aW9ucyIsImZhY3RvcnkiLCJjb25uZWN0IiwiY29ubmVjdFRpbWVvdXQiLCJ0bHMiLCJtYXhDYWNoZWRTZXNzaW9ucyIsInNvY2tldFBhdGgiLCJhdXRvU2VsZWN0RmFtaWx5IiwiYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IiwiYWxsb3dIMiIsIm9wdGlvbnMiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInRpbWVvdXQiLCJub2RlSGFzQXV0b1NlbGVjdEZhbWlseSIsInVuZGVmaW5lZCIsImludGVyY2VwdG9ycyIsIkFycmF5IiwiaXNBcnJheSIsInBhcnNlT3JpZ2luIiwiZGVlcENsb25lIiwiZGlzcGF0Y2hlciIsImZpbmQiLCJsZW5ndGgiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/pool.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/proxy-agent.js":
/*!****************************************************!*\
  !*** ../../node_modules/undici/lib/proxy-agent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kProxy, kClose, kDestroy, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\nconst Agent = __webpack_require__(/*! ./agent */ \"(rsc)/../../node_modules/undici/lib/agent.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/../../node_modules/undici/lib/pool.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/../../node_modules/undici/lib/dispatcher-base.js\");\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/../../node_modules/undici/lib/core/errors.js\");\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"(rsc)/../../node_modules/undici/lib/core/connect.js\");\nconst kAgent = Symbol(\"proxy agent\");\nconst kClient = Symbol(\"proxy client\");\nconst kProxyHeaders = Symbol(\"proxy headers\");\nconst kRequestTls = Symbol(\"request tls settings\");\nconst kProxyTls = Symbol(\"proxy tls settings\");\nconst kConnectEndpoint = Symbol(\"connect endpoint function\");\nfunction defaultProtocolPort(protocol) {\n    return protocol === \"https:\" ? 443 : 80;\n}\nfunction buildProxyOptions(opts) {\n    if (typeof opts === \"string\") {\n        opts = {\n            uri: opts\n        };\n    }\n    if (!opts || !opts.uri) {\n        throw new InvalidArgumentError(\"Proxy opts.uri is mandatory\");\n    }\n    return {\n        uri: opts.uri,\n        protocol: opts.protocol || \"https\"\n    };\n}\nfunction defaultFactory(origin, opts) {\n    return new Pool(origin, opts);\n}\nclass ProxyAgent extends DispatcherBase {\n    constructor(opts){\n        super(opts);\n        this[kProxy] = buildProxyOptions(opts);\n        this[kAgent] = new Agent(opts);\n        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];\n        if (typeof opts === \"string\") {\n            opts = {\n                uri: opts\n            };\n        }\n        if (!opts || !opts.uri) {\n            throw new InvalidArgumentError(\"Proxy opts.uri is mandatory\");\n        }\n        const { clientFactory = defaultFactory } = opts;\n        if (typeof clientFactory !== \"function\") {\n            throw new InvalidArgumentError(\"Proxy opts.clientFactory must be a function.\");\n        }\n        this[kRequestTls] = opts.requestTls;\n        this[kProxyTls] = opts.proxyTls;\n        this[kProxyHeaders] = opts.headers || {};\n        if (opts.auth && opts.token) {\n            throw new InvalidArgumentError(\"opts.auth cannot be used in combination with opts.token\");\n        } else if (opts.auth) {\n            /* @deprecated in favour of opts.token */ this[kProxyHeaders][\"proxy-authorization\"] = `Basic ${opts.auth}`;\n        } else if (opts.token) {\n            this[kProxyHeaders][\"proxy-authorization\"] = opts.token;\n        }\n        const resolvedUrl = new URL(opts.uri);\n        const { origin, port, host } = resolvedUrl;\n        const connect = buildConnector({\n            ...opts.proxyTls\n        });\n        this[kConnectEndpoint] = buildConnector({\n            ...opts.requestTls\n        });\n        this[kClient] = clientFactory(resolvedUrl, {\n            connect\n        });\n        this[kAgent] = new Agent({\n            ...opts,\n            connect: async (opts, callback)=>{\n                let requestedHost = opts.host;\n                if (!opts.port) {\n                    requestedHost += `:${defaultProtocolPort(opts.protocol)}`;\n                }\n                try {\n                    const { socket, statusCode } = await this[kClient].connect({\n                        origin,\n                        port,\n                        path: requestedHost,\n                        signal: opts.signal,\n                        headers: {\n                            ...this[kProxyHeaders],\n                            host\n                        }\n                    });\n                    if (statusCode !== 200) {\n                        socket.on(\"error\", ()=>{}).destroy();\n                        callback(new RequestAbortedError(\"Proxy response !== 200 when HTTP Tunneling\"));\n                    }\n                    if (opts.protocol !== \"https:\") {\n                        callback(null, socket);\n                        return;\n                    }\n                    let servername;\n                    if (this[kRequestTls]) {\n                        servername = this[kRequestTls].servername;\n                    } else {\n                        servername = opts.servername;\n                    }\n                    this[kConnectEndpoint]({\n                        ...opts,\n                        servername,\n                        httpSocket: socket\n                    }, callback);\n                } catch (err) {\n                    callback(err);\n                }\n            }\n        });\n    }\n    dispatch(opts, handler) {\n        const { host } = new URL(opts.origin);\n        const headers = buildHeaders(opts.headers);\n        throwIfProxyAuthIsSent(headers);\n        return this[kAgent].dispatch({\n            ...opts,\n            headers: {\n                ...headers,\n                host\n            }\n        }, handler);\n    }\n    async [kClose]() {\n        await this[kAgent].close();\n        await this[kClient].close();\n    }\n    async [kDestroy]() {\n        await this[kAgent].destroy();\n        await this[kClient].destroy();\n    }\n}\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */ function buildHeaders(headers) {\n    // When using undici.fetch, the headers list is stored\n    // as an array.\n    if (Array.isArray(headers)) {\n        /** @type {Record<string, string>} */ const headersPair = {};\n        for(let i = 0; i < headers.length; i += 2){\n            headersPair[headers[i]] = headers[i + 1];\n        }\n        return headersPair;\n    }\n    return headers;\n}\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */ function throwIfProxyAuthIsSent(headers) {\n    const existProxyAuth = headers && Object.keys(headers).find((key)=>key.toLowerCase() === \"proxy-authorization\");\n    if (existProxyAuth) {\n        throw new InvalidArgumentError(\"Proxy-Authorization should be sent in ProxyAgent constructor\");\n    }\n}\nmodule.exports = ProxyAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcHJveHktYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLGFBQWEsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM1RCxNQUFNLEVBQUVDLEdBQUcsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQztBQUN0QixNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNSSxpQkFBaUJKLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFBRUssb0JBQW9CLEVBQUVDLG1CQUFtQixFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQzlELE1BQU1PLGlCQUFpQlAsbUJBQU9BLENBQUM7QUFFL0IsTUFBTVEsU0FBU0MsT0FBTztBQUN0QixNQUFNQyxVQUFVRCxPQUFPO0FBQ3ZCLE1BQU1FLGdCQUFnQkYsT0FBTztBQUM3QixNQUFNRyxjQUFjSCxPQUFPO0FBQzNCLE1BQU1JLFlBQVlKLE9BQU87QUFDekIsTUFBTUssbUJBQW1CTCxPQUFPO0FBRWhDLFNBQVNNLG9CQUFxQkMsUUFBUTtJQUNwQyxPQUFPQSxhQUFhLFdBQVcsTUFBTTtBQUN2QztBQUVBLFNBQVNDLGtCQUFtQkMsSUFBSTtJQUM5QixJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUM1QkEsT0FBTztZQUFFQyxLQUFLRDtRQUFLO0lBQ3JCO0lBRUEsSUFBSSxDQUFDQSxRQUFRLENBQUNBLEtBQUtDLEdBQUcsRUFBRTtRQUN0QixNQUFNLElBQUlkLHFCQUFxQjtJQUNqQztJQUVBLE9BQU87UUFDTGMsS0FBS0QsS0FBS0MsR0FBRztRQUNiSCxVQUFVRSxLQUFLRixRQUFRLElBQUk7SUFDN0I7QUFDRjtBQUVBLFNBQVNJLGVBQWdCQyxNQUFNLEVBQUVILElBQUk7SUFDbkMsT0FBTyxJQUFJZixLQUFLa0IsUUFBUUg7QUFDMUI7QUFF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QyxJQUFJLEdBQUdBLElBQUl4QixRQUFReUIsTUFBTSxFQUFFRCxLQUFLLEVBQUc7WUFDMUNELFdBQVcsQ0FBQ3ZCLE9BQU8sQ0FBQ3dCLEVBQUUsQ0FBQyxHQUFHeEIsT0FBTyxDQUFDd0IsSUFBSSxFQUFFO1FBQzFDO1FBRUEsT0FBT0Q7SUFDVDtJQUVBLE9BQU92QjtBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNxQix1QkFBd0JyQixPQUFPO0lBQ3RDLE1BQU0wQixpQkFBaUIxQixXQUFXMkIsT0FBT0MsSUFBSSxDQUFDNUIsU0FDM0M2QixJQUFJLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSUMsV0FBVyxPQUFPO0lBQ3ZDLElBQUlMLGdCQUFnQjtRQUNsQixNQUFNLElBQUluRCxxQkFBcUI7SUFDakM7QUFDRjtBQUVBeUQsT0FBT0MsT0FBTyxHQUFHekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3Byb3h5LWFnZW50LmpzPzg1ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga1Byb3h5LCBrQ2xvc2UsIGtEZXN0cm95LCBrSW50ZXJjZXB0b3JzIH0gPSByZXF1aXJlKCcuL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudCcpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9wb29sJylcbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgUmVxdWVzdEFib3J0ZWRFcnJvciB9ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4vY29yZS9jb25uZWN0JylcblxuY29uc3Qga0FnZW50ID0gU3ltYm9sKCdwcm94eSBhZ2VudCcpXG5jb25zdCBrQ2xpZW50ID0gU3ltYm9sKCdwcm94eSBjbGllbnQnKVxuY29uc3Qga1Byb3h5SGVhZGVycyA9IFN5bWJvbCgncHJveHkgaGVhZGVycycpXG5jb25zdCBrUmVxdWVzdFRscyA9IFN5bWJvbCgncmVxdWVzdCB0bHMgc2V0dGluZ3MnKVxuY29uc3Qga1Byb3h5VGxzID0gU3ltYm9sKCdwcm94eSB0bHMgc2V0dGluZ3MnKVxuY29uc3Qga0Nvbm5lY3RFbmRwb2ludCA9IFN5bWJvbCgnY29ubmVjdCBlbmRwb2ludCBmdW5jdGlvbicpXG5cbmZ1bmN0aW9uIGRlZmF1bHRQcm90b2NvbFBvcnQgKHByb3RvY29sKSB7XG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MFxufVxuXG5mdW5jdGlvbiBidWlsZFByb3h5T3B0aW9ucyAob3B0cykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0cyA9IHsgdXJpOiBvcHRzIH1cbiAgfVxuXG4gIGlmICghb3B0cyB8fCAhb3B0cy51cmkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Byb3h5IG9wdHMudXJpIGlzIG1hbmRhdG9yeScpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVyaTogb3B0cy51cmksXG4gICAgcHJvdG9jb2w6IG9wdHMucHJvdG9jb2wgfHwgJ2h0dHBzJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBQb29sKG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgUHJveHlBZ2VudCBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXNba1Byb3h5XSA9IGJ1aWxkUHJveHlPcHRpb25zKG9wdHMpXG4gICAgdGhpc1trQWdlbnRdID0gbmV3IEFnZW50KG9wdHMpXG4gICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IG9wdHMuaW50ZXJjZXB0b3JzICYmIG9wdHMuaW50ZXJjZXB0b3JzLlByb3h5QWdlbnQgJiYgQXJyYXkuaXNBcnJheShvcHRzLmludGVyY2VwdG9ycy5Qcm94eUFnZW50KVxuICAgICAgPyBvcHRzLmludGVyY2VwdG9ycy5Qcm94eUFnZW50XG4gICAgICA6IFtdXG5cbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRzID0geyB1cmk6IG9wdHMgfVxuICAgIH1cblxuICAgIGlmICghb3B0cyB8fCAhb3B0cy51cmkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignUHJveHkgb3B0cy51cmkgaXMgbWFuZGF0b3J5JylcbiAgICB9XG5cbiAgICBjb25zdCB7IGNsaWVudEZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSB9ID0gb3B0c1xuXG4gICAgaWYgKHR5cGVvZiBjbGllbnRGYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Byb3h5IG9wdHMuY2xpZW50RmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICB0aGlzW2tSZXF1ZXN0VGxzXSA9IG9wdHMucmVxdWVzdFRsc1xuICAgIHRoaXNba1Byb3h5VGxzXSA9IG9wdHMucHJveHlUbHNcbiAgICB0aGlzW2tQcm94eUhlYWRlcnNdID0gb3B0cy5oZWFkZXJzIHx8IHt9XG5cbiAgICBpZiAob3B0cy5hdXRoICYmIG9wdHMudG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cy5hdXRoIGNhbm5vdCBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggb3B0cy50b2tlbicpXG4gICAgfSBlbHNlIGlmIChvcHRzLmF1dGgpIHtcbiAgICAgIC8qIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBvcHRzLnRva2VuICovXG4gICAgICB0aGlzW2tQcm94eUhlYWRlcnNdWydwcm94eS1hdXRob3JpemF0aW9uJ10gPSBgQmFzaWMgJHtvcHRzLmF1dGh9YFxuICAgIH0gZWxzZSBpZiAob3B0cy50b2tlbikge1xuICAgICAgdGhpc1trUHJveHlIZWFkZXJzXVsncHJveHktYXV0aG9yaXphdGlvbiddID0gb3B0cy50b2tlblxuICAgIH1cblxuICAgIGNvbnN0IHJlc29sdmVkVXJsID0gbmV3IFVSTChvcHRzLnVyaSlcbiAgICBjb25zdCB7IG9yaWdpbiwgcG9ydCwgaG9zdCB9ID0gcmVzb2x2ZWRVcmxcblxuICAgIGNvbnN0IGNvbm5lY3QgPSBidWlsZENvbm5lY3Rvcih7IC4uLm9wdHMucHJveHlUbHMgfSlcbiAgICB0aGlzW2tDb25uZWN0RW5kcG9pbnRdID0gYnVpbGRDb25uZWN0b3IoeyAuLi5vcHRzLnJlcXVlc3RUbHMgfSlcbiAgICB0aGlzW2tDbGllbnRdID0gY2xpZW50RmFjdG9yeShyZXNvbHZlZFVybCwgeyBjb25uZWN0IH0pXG4gICAgdGhpc1trQWdlbnRdID0gbmV3IEFnZW50KHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBjb25uZWN0OiBhc3luYyAob3B0cywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgbGV0IHJlcXVlc3RlZEhvc3QgPSBvcHRzLmhvc3RcbiAgICAgICAgaWYgKCFvcHRzLnBvcnQpIHtcbiAgICAgICAgICByZXF1ZXN0ZWRIb3N0ICs9IGA6JHtkZWZhdWx0UHJvdG9jb2xQb3J0KG9wdHMucHJvdG9jb2wpfWBcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgc29ja2V0LCBzdGF0dXNDb2RlIH0gPSBhd2FpdCB0aGlzW2tDbGllbnRdLmNvbm5lY3Qoe1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgIHBhdGg6IHJlcXVlc3RlZEhvc3QsXG4gICAgICAgICAgICBzaWduYWw6IG9wdHMuc2lnbmFsLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAuLi50aGlzW2tQcm94eUhlYWRlcnNdLFxuICAgICAgICAgICAgICBob3N0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICBpZiAoc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge30pLmRlc3Ryb3koKVxuICAgICAgICAgICAgY2FsbGJhY2sobmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoJ1Byb3h5IHJlc3BvbnNlICE9PSAyMDAgd2hlbiBIVFRQIFR1bm5lbGluZycpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0cy5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHNvY2tldClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgc2VydmVybmFtZVxuICAgICAgICAgIGlmICh0aGlzW2tSZXF1ZXN0VGxzXSkge1xuICAgICAgICAgICAgc2VydmVybmFtZSA9IHRoaXNba1JlcXVlc3RUbHNdLnNlcnZlcm5hbWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VydmVybmFtZSA9IG9wdHMuc2VydmVybmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW2tDb25uZWN0RW5kcG9pbnRdKHsgLi4ub3B0cywgc2VydmVybmFtZSwgaHR0cFNvY2tldDogc29ja2V0IH0sIGNhbGxiYWNrKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCB7IGhvc3QgfSA9IG5ldyBVUkwob3B0cy5vcmlnaW4pXG4gICAgY29uc3QgaGVhZGVycyA9IGJ1aWxkSGVhZGVycyhvcHRzLmhlYWRlcnMpXG4gICAgdGhyb3dJZlByb3h5QXV0aElzU2VudChoZWFkZXJzKVxuICAgIHJldHVybiB0aGlzW2tBZ2VudF0uZGlzcGF0Y2goXG4gICAgICB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgIGhvc3RcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhbmRsZXJcbiAgICApXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgdGhpc1trQWdlbnRdLmNsb3NlKClcbiAgICBhd2FpdCB0aGlzW2tDbGllbnRdLmNsb3NlKClcbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKCkge1xuICAgIGF3YWl0IHRoaXNba0FnZW50XS5kZXN0cm95KClcbiAgICBhd2FpdCB0aGlzW2tDbGllbnRdLmRlc3Ryb3koKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz59IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBidWlsZEhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgLy8gV2hlbiB1c2luZyB1bmRpY2kuZmV0Y2gsIHRoZSBoZWFkZXJzIGxpc3QgaXMgc3RvcmVkXG4gIC8vIGFzIGFuIGFycmF5LlxuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICBjb25zdCBoZWFkZXJzUGFpciA9IHt9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGhlYWRlcnNQYWlyW2hlYWRlcnNbaV1dID0gaGVhZGVyc1tpICsgMV1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1BhaXJcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBoZWFkZXJzXG4gKlxuICogUHJldmlvdXMgdmVyc2lvbnMgb2YgUHJveHlBZ2VudCBzdWdnZXN0cyB0aGUgUHJveHktQXV0aG9yaXphdGlvbiBpbiByZXF1ZXN0IGhlYWRlcnNcbiAqIE5ldmVydGhlbGVzcywgaXQgd2FzIGNoYW5nZWQgYW5kIHRvIGF2b2lkIGEgc2VjdXJpdHkgdnVsbmVyYWJpbGl0eSBieSBlbmQgdXNlcnNcbiAqIHRoaXMgY2hlY2sgd2FzIGNyZWF0ZWQuXG4gKiBJdCBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZQcm94eUF1dGhJc1NlbnQgKGhlYWRlcnMpIHtcbiAgY29uc3QgZXhpc3RQcm94eUF1dGggPSBoZWFkZXJzICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgLmZpbmQoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdwcm94eS1hdXRob3JpemF0aW9uJylcbiAgaWYgKGV4aXN0UHJveHlBdXRoKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eS1BdXRob3JpemF0aW9uIHNob3VsZCBiZSBzZW50IGluIFByb3h5QWdlbnQgY29uc3RydWN0b3InKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJveHlBZ2VudFxuIl0sIm5hbWVzIjpbImtQcm94eSIsImtDbG9zZSIsImtEZXN0cm95Iiwia0ludGVyY2VwdG9ycyIsInJlcXVpcmUiLCJVUkwiLCJBZ2VudCIsIlBvb2wiLCJEaXNwYXRjaGVyQmFzZSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsImJ1aWxkQ29ubmVjdG9yIiwia0FnZW50IiwiU3ltYm9sIiwia0NsaWVudCIsImtQcm94eUhlYWRlcnMiLCJrUmVxdWVzdFRscyIsImtQcm94eVRscyIsImtDb25uZWN0RW5kcG9pbnQiLCJkZWZhdWx0UHJvdG9jb2xQb3J0IiwicHJvdG9jb2wiLCJidWlsZFByb3h5T3B0aW9ucyIsIm9wdHMiLCJ1cmkiLCJkZWZhdWx0RmFjdG9yeSIsIm9yaWdpbiIsIlByb3h5QWdlbnQiLCJjb25zdHJ1Y3RvciIsImludGVyY2VwdG9ycyIsIkFycmF5IiwiaXNBcnJheSIsImNsaWVudEZhY3RvcnkiLCJyZXF1ZXN0VGxzIiwicHJveHlUbHMiLCJoZWFkZXJzIiwiYXV0aCIsInRva2VuIiwicmVzb2x2ZWRVcmwiLCJwb3J0IiwiaG9zdCIsImNvbm5lY3QiLCJjYWxsYmFjayIsInJlcXVlc3RlZEhvc3QiLCJzb2NrZXQiLCJzdGF0dXNDb2RlIiwicGF0aCIsInNpZ25hbCIsIm9uIiwiZGVzdHJveSIsInNlcnZlcm5hbWUiLCJodHRwU29ja2V0IiwiZXJyIiwiZGlzcGF0Y2giLCJoYW5kbGVyIiwiYnVpbGRIZWFkZXJzIiwidGhyb3dJZlByb3h5QXV0aElzU2VudCIsImNsb3NlIiwiaGVhZGVyc1BhaXIiLCJpIiwibGVuZ3RoIiwiZXhpc3RQcm94eUF1dGgiLCJPYmplY3QiLCJrZXlzIiwiZmluZCIsImtleSIsInRvTG93ZXJDYXNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/proxy-agent.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/timers.js":
/*!***********************************************!*\
  !*** ../../node_modules/undici/lib/timers.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\nlet fastNow = Date.now();\nlet fastNowTimeout;\nconst fastTimers = [];\nfunction onTimeout() {\n    fastNow = Date.now();\n    let len = fastTimers.length;\n    let idx = 0;\n    while(idx < len){\n        const timer = fastTimers[idx];\n        if (timer.state === 0) {\n            timer.state = fastNow + timer.delay;\n        } else if (timer.state > 0 && fastNow >= timer.state) {\n            timer.state = -1;\n            timer.callback(timer.opaque);\n        }\n        if (timer.state === -1) {\n            timer.state = -2;\n            if (idx !== len - 1) {\n                fastTimers[idx] = fastTimers.pop();\n            } else {\n                fastTimers.pop();\n            }\n            len -= 1;\n        } else {\n            idx += 1;\n        }\n    }\n    if (fastTimers.length > 0) {\n        refreshTimeout();\n    }\n}\nfunction refreshTimeout() {\n    if (fastNowTimeout && fastNowTimeout.refresh) {\n        fastNowTimeout.refresh();\n    } else {\n        clearTimeout(fastNowTimeout);\n        fastNowTimeout = setTimeout(onTimeout, 1e3);\n        if (fastNowTimeout.unref) {\n            fastNowTimeout.unref();\n        }\n    }\n}\nclass Timeout {\n    constructor(callback, delay, opaque){\n        this.callback = callback;\n        this.delay = delay;\n        this.opaque = opaque;\n        //  -2 not in timer list\n        //  -1 in timer list but inactive\n        //   0 in timer list waiting for time\n        // > 0 in timer list waiting for time to expire\n        this.state = -2;\n        this.refresh();\n    }\n    refresh() {\n        if (this.state === -2) {\n            fastTimers.push(this);\n            if (!fastNowTimeout || fastTimers.length === 1) {\n                refreshTimeout();\n            }\n        }\n        this.state = 0;\n    }\n    clear() {\n        this.state = -1;\n    }\n}\nmodule.exports = {\n    setTimeout (callback, delay, opaque) {\n        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);\n    },\n    clearTimeout (timeout) {\n        if (timeout instanceof Timeout) {\n            timeout.clear();\n        } else {\n            clearTimeout(timeout);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvdGltZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsVUFBVUMsS0FBS0MsR0FBRztBQUN0QixJQUFJQztBQUVKLE1BQU1DLGFBQWEsRUFBRTtBQUVyQixTQUFTQztJQUNQTCxVQUFVQyxLQUFLQyxHQUFHO0lBRWxCLElBQUlJLE1BQU1GLFdBQVdHLE1BQU07SUFDM0IsSUFBSUMsTUFBTTtJQUNWLE1BQU9BLE1BQU1GLElBQUs7UUFDaEIsTUFBTUcsUUFBUUwsVUFBVSxDQUFDSSxJQUFJO1FBRTdCLElBQUlDLE1BQU1DLEtBQUssS0FBSyxHQUFHO1lBQ3JCRCxNQUFNQyxLQUFLLEdBQUdWLFVBQVVTLE1BQU1FLEtBQUs7UUFDckMsT0FBTyxJQUFJRixNQUFNQyxLQUFLLEdBQUcsS0FBS1YsV0FBV1MsTUFBTUMsS0FBSyxFQUFFO1lBQ3BERCxNQUFNQyxLQUFLLEdBQUcsQ0FBQztZQUNmRCxNQUFNRyxRQUFRLENBQUNILE1BQU1JLE1BQU07UUFDN0I7UUFFQSxJQUFJSixNQUFNQyxLQUFLLEtBQUssQ0FBQyxHQUFHO1lBQ3RCRCxNQUFNQyxLQUFLLEdBQUcsQ0FBQztZQUNmLElBQUlGLFFBQVFGLE1BQU0sR0FBRztnQkFDbkJGLFVBQVUsQ0FBQ0ksSUFBSSxHQUFHSixXQUFXVSxHQUFHO1lBQ2xDLE9BQU87Z0JBQ0xWLFdBQVdVLEdBQUc7WUFDaEI7WUFDQVIsT0FBTztRQUNULE9BQU87WUFDTEUsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFJSixXQUFXRyxNQUFNLEdBQUcsR0FBRztRQUN6QlE7SUFDRjtBQUNGO0FBRUEsU0FBU0E7SUFDUCxJQUFJWixrQkFBa0JBLGVBQWVhLE9BQU8sRUFBRTtRQUM1Q2IsZUFBZWEsT0FBTztJQUN4QixPQUFPO1FBQ0xDLGFBQWFkO1FBQ2JBLGlCQUFpQmUsV0FBV2IsV0FBVztRQUN2QyxJQUFJRixlQUFlZ0IsS0FBSyxFQUFFO1lBQ3hCaEIsZUFBZWdCLEtBQUs7UUFDdEI7SUFDRjtBQUNGO0FBRUEsTUFBTUM7SUFDSkMsWUFBYVQsUUFBUSxFQUFFRCxLQUFLLEVBQUVFLE1BQU0sQ0FBRTtRQUNwQyxJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDRSxNQUFNLEdBQUdBO1FBRWQsd0JBQXdCO1FBQ3hCLGlDQUFpQztRQUNqQyxxQ0FBcUM7UUFDckMsK0NBQStDO1FBQy9DLElBQUksQ0FBQ0gsS0FBSyxHQUFHLENBQUM7UUFFZCxJQUFJLENBQUNNLE9BQU87SUFDZDtJQUVBQSxVQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUNOLEtBQUssS0FBSyxDQUFDLEdBQUc7WUFDckJOLFdBQVdrQixJQUFJLENBQUMsSUFBSTtZQUNwQixJQUFJLENBQUNuQixrQkFBa0JDLFdBQVdHLE1BQU0sS0FBSyxHQUFHO2dCQUM5Q1E7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDTCxLQUFLLEdBQUc7SUFDZjtJQUVBYSxRQUFTO1FBQ1AsSUFBSSxDQUFDYixLQUFLLEdBQUcsQ0FBQztJQUNoQjtBQUNGO0FBRUFjLE9BQU9DLE9BQU8sR0FBRztJQUNmUCxZQUFZTixRQUFRLEVBQUVELEtBQUssRUFBRUUsTUFBTTtRQUNqQyxPQUFPRixRQUFRLE1BQ1hPLFdBQVdOLFVBQVVELE9BQU9FLFVBQzVCLElBQUlPLFFBQVFSLFVBQVVELE9BQU9FO0lBQ25DO0lBQ0FJLGNBQWNTLE9BQU87UUFDbkIsSUFBSUEsbUJBQW1CTixTQUFTO1lBQzlCTSxRQUFRSCxLQUFLO1FBQ2YsT0FBTztZQUNMTixhQUFhUztRQUNmO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvdGltZXJzLmpzP2ExZDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmxldCBmYXN0Tm93ID0gRGF0ZS5ub3coKVxubGV0IGZhc3ROb3dUaW1lb3V0XG5cbmNvbnN0IGZhc3RUaW1lcnMgPSBbXVxuXG5mdW5jdGlvbiBvblRpbWVvdXQgKCkge1xuICBmYXN0Tm93ID0gRGF0ZS5ub3coKVxuXG4gIGxldCBsZW4gPSBmYXN0VGltZXJzLmxlbmd0aFxuICBsZXQgaWR4ID0gMFxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgY29uc3QgdGltZXIgPSBmYXN0VGltZXJzW2lkeF1cblxuICAgIGlmICh0aW1lci5zdGF0ZSA9PT0gMCkge1xuICAgICAgdGltZXIuc3RhdGUgPSBmYXN0Tm93ICsgdGltZXIuZGVsYXlcbiAgICB9IGVsc2UgaWYgKHRpbWVyLnN0YXRlID4gMCAmJiBmYXN0Tm93ID49IHRpbWVyLnN0YXRlKSB7XG4gICAgICB0aW1lci5zdGF0ZSA9IC0xXG4gICAgICB0aW1lci5jYWxsYmFjayh0aW1lci5vcGFxdWUpXG4gICAgfVxuXG4gICAgaWYgKHRpbWVyLnN0YXRlID09PSAtMSkge1xuICAgICAgdGltZXIuc3RhdGUgPSAtMlxuICAgICAgaWYgKGlkeCAhPT0gbGVuIC0gMSkge1xuICAgICAgICBmYXN0VGltZXJzW2lkeF0gPSBmYXN0VGltZXJzLnBvcCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYXN0VGltZXJzLnBvcCgpXG4gICAgICB9XG4gICAgICBsZW4gLT0gMVxuICAgIH0gZWxzZSB7XG4gICAgICBpZHggKz0gMVxuICAgIH1cbiAgfVxuXG4gIGlmIChmYXN0VGltZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZWZyZXNoVGltZW91dCgpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVmcmVzaFRpbWVvdXQgKCkge1xuICBpZiAoZmFzdE5vd1RpbWVvdXQgJiYgZmFzdE5vd1RpbWVvdXQucmVmcmVzaCkge1xuICAgIGZhc3ROb3dUaW1lb3V0LnJlZnJlc2goKVxuICB9IGVsc2Uge1xuICAgIGNsZWFyVGltZW91dChmYXN0Tm93VGltZW91dClcbiAgICBmYXN0Tm93VGltZW91dCA9IHNldFRpbWVvdXQob25UaW1lb3V0LCAxZTMpXG4gICAgaWYgKGZhc3ROb3dUaW1lb3V0LnVucmVmKSB7XG4gICAgICBmYXN0Tm93VGltZW91dC51bnJlZigpXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFRpbWVvdXQge1xuICBjb25zdHJ1Y3RvciAoY2FsbGJhY2ssIGRlbGF5LCBvcGFxdWUpIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLmRlbGF5ID0gZGVsYXlcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZVxuXG4gICAgLy8gIC0yIG5vdCBpbiB0aW1lciBsaXN0XG4gICAgLy8gIC0xIGluIHRpbWVyIGxpc3QgYnV0IGluYWN0aXZlXG4gICAgLy8gICAwIGluIHRpbWVyIGxpc3Qgd2FpdGluZyBmb3IgdGltZVxuICAgIC8vID4gMCBpbiB0aW1lciBsaXN0IHdhaXRpbmcgZm9yIHRpbWUgdG8gZXhwaXJlXG4gICAgdGhpcy5zdGF0ZSA9IC0yXG5cbiAgICB0aGlzLnJlZnJlc2goKVxuICB9XG5cbiAgcmVmcmVzaCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IC0yKSB7XG4gICAgICBmYXN0VGltZXJzLnB1c2godGhpcylcbiAgICAgIGlmICghZmFzdE5vd1RpbWVvdXQgfHwgZmFzdFRpbWVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmVmcmVzaFRpbWVvdXQoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSAwXG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IC0xXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldFRpbWVvdXQgKGNhbGxiYWNrLCBkZWxheSwgb3BhcXVlKSB7XG4gICAgcmV0dXJuIGRlbGF5IDwgMWUzXG4gICAgICA/IHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5LCBvcGFxdWUpXG4gICAgICA6IG5ldyBUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSwgb3BhcXVlKVxuICB9LFxuICBjbGVhclRpbWVvdXQgKHRpbWVvdXQpIHtcbiAgICBpZiAodGltZW91dCBpbnN0YW5jZW9mIFRpbWVvdXQpIHtcbiAgICAgIHRpbWVvdXQuY2xlYXIoKVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJmYXN0Tm93IiwiRGF0ZSIsIm5vdyIsImZhc3ROb3dUaW1lb3V0IiwiZmFzdFRpbWVycyIsIm9uVGltZW91dCIsImxlbiIsImxlbmd0aCIsImlkeCIsInRpbWVyIiwic3RhdGUiLCJkZWxheSIsImNhbGxiYWNrIiwib3BhcXVlIiwicG9wIiwicmVmcmVzaFRpbWVvdXQiLCJyZWZyZXNoIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInVucmVmIiwiVGltZW91dCIsImNvbnN0cnVjdG9yIiwicHVzaCIsImNsZWFyIiwibW9kdWxlIiwiZXhwb3J0cyIsInRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/timers.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/websocket/connection.js":
/*!*************************************************************!*\
  !*** ../../node_modules/undici/lib/websocket/connection.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\nconst { uid, states } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/undici/lib/websocket/constants.js\");\nconst { kReadyState, kSentClose, kByteParser, kReceivedClose } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/websocket/symbols.js\");\nconst { fireEvent, failWebsocketConnection } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/websocket/util.js\");\nconst { CloseEvent } = __webpack_require__(/*! ./events */ \"(rsc)/../../node_modules/undici/lib/websocket/events.js\");\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/../../node_modules/undici/lib/fetch/request.js\");\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(rsc)/../../node_modules/undici/lib/fetch/index.js\");\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(rsc)/../../node_modules/undici/lib/fetch/headers.js\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(rsc)/../../node_modules/undici/lib/global.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/../../node_modules/undici/lib/core/symbols.js\");\nconst channels = {};\nchannels.open = diagnosticsChannel.channel(\"undici:websocket:open\");\nchannels.close = diagnosticsChannel.channel(\"undici:websocket:close\");\nchannels.socketError = diagnosticsChannel.channel(\"undici:websocket:socket_error\");\n/** @type {import('crypto')} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n} catch  {}\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */ function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {\n    // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if urls\n    //    scheme is \"ws\", and to \"https\" otherwise.\n    const requestURL = url;\n    requestURL.protocol = url.protocol === \"ws:\" ? \"http:\" : \"https:\";\n    // 2. Let request be a new request, whose URL is requestURL, client is client,\n    //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n    //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n    //    and redirect mode is \"error\".\n    const request = makeRequest({\n        urlList: [\n            requestURL\n        ],\n        serviceWorkers: \"none\",\n        referrer: \"no-referrer\",\n        mode: \"websocket\",\n        credentials: \"include\",\n        cache: \"no-store\",\n        redirect: \"error\"\n    });\n    // Note: undici extension, allow setting custom headers.\n    if (options.headers) {\n        const headersList = new Headers(options.headers)[kHeadersList];\n        request.headersList = headersList;\n    }\n    // 3. Append (`Upgrade`, `websocket`) to requests header list.\n    // 4. Append (`Connection`, `Upgrade`) to requests header list.\n    // Note: both of these are handled by undici currently.\n    // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n    // 5. Let keyValue be a nonce consisting of a randomly selected\n    //    16-byte value that has been forgiving-base64-encoded and\n    //    isomorphic encoded.\n    const keyValue = crypto.randomBytes(16).toString(\"base64\");\n    // 6. Append (`Sec-WebSocket-Key`, keyValue) to requests\n    //    header list.\n    request.headersList.append(\"sec-websocket-key\", keyValue);\n    // 7. Append (`Sec-WebSocket-Version`, `13`) to requests\n    //    header list.\n    request.headersList.append(\"sec-websocket-version\", \"13\");\n    // 8. For each protocol in protocols, combine\n    //    (`Sec-WebSocket-Protocol`, protocol) in requests header\n    //    list.\n    for (const protocol of protocols){\n        request.headersList.append(\"sec-websocket-protocol\", protocol);\n    }\n    // 9. Let permessageDeflate be a user-agent defined\n    //    \"permessage-deflate\" extension header value.\n    // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n    // TODO: enable once permessage-deflate is supported\n    const permessageDeflate = \"\" // 'permessage-deflate; 15'\n    ;\n    // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n    //     requests header list.\n    // request.headersList.append('sec-websocket-extensions', permessageDeflate)\n    // 11. Fetch request with useParallelQueue set to true, and\n    //     processResponse given response being these steps:\n    const controller = fetching({\n        request,\n        useParallelQueue: true,\n        dispatcher: options.dispatcher ?? getGlobalDispatcher(),\n        processResponse (response) {\n            // 1. If response is a network error or its status is not 101,\n            //    fail the WebSocket connection.\n            if (response.type === \"error\" || response.status !== 101) {\n                failWebsocketConnection(ws, \"Received network error or non-101 status code.\");\n                return;\n            }\n            // 2. If protocols is not the empty list and extracting header\n            //    list values given `Sec-WebSocket-Protocol` and responses\n            //    header list results in null, failure, or the empty byte\n            //    sequence, then fail the WebSocket connection.\n            if (protocols.length !== 0 && !response.headersList.get(\"Sec-WebSocket-Protocol\")) {\n                failWebsocketConnection(ws, \"Server did not respond with sent protocols.\");\n                return;\n            }\n            // 3. Follow the requirements stated step 2 to step 6, inclusive,\n            //    of the last set of steps in section 4.1 of The WebSocket\n            //    Protocol to validate response. This either results in fail\n            //    the WebSocket connection or the WebSocket connection is\n            //    established.\n            // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n            //    header field contains a value that is not an ASCII case-\n            //    insensitive match for the value \"websocket\", the client MUST\n            //    _Fail the WebSocket Connection_.\n            if (response.headersList.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\n                failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".');\n                return;\n            }\n            // 3. If the response lacks a |Connection| header field or the\n            //    |Connection| header field doesn't contain a token that is an\n            //    ASCII case-insensitive match for the value \"Upgrade\", the client\n            //    MUST _Fail the WebSocket Connection_.\n            if (response.headersList.get(\"Connection\")?.toLowerCase() !== \"upgrade\") {\n                failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".');\n                return;\n            }\n            // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n            //    the |Sec-WebSocket-Accept| contains a value other than the\n            //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n            //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n            //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n            //    trailing whitespace, the client MUST _Fail the WebSocket\n            //    Connection_.\n            const secWSAccept = response.headersList.get(\"Sec-WebSocket-Accept\");\n            const digest = crypto.createHash(\"sha1\").update(keyValue + uid).digest(\"base64\");\n            if (secWSAccept !== digest) {\n                failWebsocketConnection(ws, \"Incorrect hash received in Sec-WebSocket-Accept header.\");\n                return;\n            }\n            // 5. If the response includes a |Sec-WebSocket-Extensions| header\n            //    field and this header field indicates the use of an extension\n            //    that was not present in the client's handshake (the server has\n            //    indicated an extension not requested by the client), the client\n            //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n            //    header field to determine which extensions are requested is\n            //    discussed in Section 9.1.)\n            const secExtension = response.headersList.get(\"Sec-WebSocket-Extensions\");\n            if (secExtension !== null && secExtension !== permessageDeflate) {\n                failWebsocketConnection(ws, \"Received different permessage-deflate than the one set.\");\n                return;\n            }\n            // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n            //    and this header field indicates the use of a subprotocol that was\n            //    not present in the client's handshake (the server has indicated a\n            //    subprotocol not requested by the client), the client MUST _Fail\n            //    the WebSocket Connection_.\n            const secProtocol = response.headersList.get(\"Sec-WebSocket-Protocol\");\n            if (secProtocol !== null && secProtocol !== request.headersList.get(\"Sec-WebSocket-Protocol\")) {\n                failWebsocketConnection(ws, \"Protocol was not set in the opening handshake.\");\n                return;\n            }\n            response.socket.on(\"data\", onSocketData);\n            response.socket.on(\"close\", onSocketClose);\n            response.socket.on(\"error\", onSocketError);\n            if (channels.open.hasSubscribers) {\n                channels.open.publish({\n                    address: response.socket.address(),\n                    protocol: secProtocol,\n                    extensions: secExtension\n                });\n            }\n            onEstablish(response);\n        }\n    });\n    return controller;\n}\n/**\n * @param {Buffer} chunk\n */ function onSocketData(chunk) {\n    if (!this.ws[kByteParser].write(chunk)) {\n        this.pause();\n    }\n}\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */ function onSocketClose() {\n    const { ws } = this;\n    // If the TCP connection was closed after the\n    // WebSocket closing handshake was completed, the WebSocket connection\n    // is said to have been closed _cleanly_.\n    const wasClean = ws[kSentClose] && ws[kReceivedClose];\n    let code = 1005;\n    let reason = \"\";\n    const result = ws[kByteParser].closingInfo;\n    if (result) {\n        code = result.code ?? 1005;\n        reason = result.reason;\n    } else if (!ws[kSentClose]) {\n        // If _The WebSocket\n        // Connection is Closed_ and no Close control frame was received by the\n        // endpoint (such as could occur if the underlying transport connection\n        // is lost), _The WebSocket Connection Close Code_ is considered to be\n        // 1006.\n        code = 1006;\n    }\n    // 1. Change the ready state to CLOSED (3).\n    ws[kReadyState] = states.CLOSED;\n    // 2. If the user agent was required to fail the WebSocket\n    //    connection, or if the WebSocket connection was closed\n    //    after being flagged as full, fire an event named error\n    //    at the WebSocket object.\n    // TODO\n    // 3. Fire an event named close at the WebSocket object,\n    //    using CloseEvent, with the wasClean attribute\n    //    initialized to true if the connection closed cleanly\n    //    and false otherwise, the code attribute initialized to\n    //    the WebSocket connection close code, and the reason\n    //    attribute initialized to the result of applying UTF-8\n    //    decode without BOM to the WebSocket connection close\n    //    reason.\n    fireEvent(\"close\", ws, CloseEvent, {\n        wasClean,\n        code,\n        reason\n    });\n    if (channels.close.hasSubscribers) {\n        channels.close.publish({\n            websocket: ws,\n            code,\n            reason\n        });\n    }\n}\nfunction onSocketError(error) {\n    const { ws } = this;\n    ws[kReadyState] = states.CLOSING;\n    if (channels.socketError.hasSubscribers) {\n        channels.socketError.publish(error);\n    }\n    this.destroy();\n}\nmodule.exports = {\n    establishWebSocketConnection\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxxQkFBcUJDLG1CQUFPQSxDQUFDO0FBQ25DLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxNQUFNLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDaEMsTUFBTSxFQUNKRyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxjQUFjLEVBQ2YsR0FBR04sbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVPLFNBQVMsRUFBRUMsdUJBQXVCLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFDdkQsTUFBTSxFQUFFUyxVQUFVLEVBQUUsR0FBR1QsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFFVSxXQUFXLEVBQUUsR0FBR1YsbUJBQU9BLENBQUM7QUFDaEMsTUFBTSxFQUFFVyxRQUFRLEVBQUUsR0FBR1gsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFWSxPQUFPLEVBQUUsR0FBR1osbUJBQU9BLENBQUM7QUFDNUIsTUFBTSxFQUFFYSxtQkFBbUIsRUFBRSxHQUFHYixtQkFBT0EsQ0FBQztBQUN4QyxNQUFNLEVBQUVjLFlBQVksRUFBRSxHQUFHZCxtQkFBT0EsQ0FBQztBQUVqQyxNQUFNZSxXQUFXLENBQUM7QUFDbEJBLFNBQVNDLElBQUksR0FBR2pCLG1CQUFtQmtCLE9BQU8sQ0FBQztBQUMzQ0YsU0FBU0csS0FBSyxHQUFHbkIsbUJBQW1Ca0IsT0FBTyxDQUFDO0FBQzVDRixTQUFTSSxXQUFXLEdBQUdwQixtQkFBbUJrQixPQUFPLENBQUM7QUFFbEQsNkJBQTZCLEdBQzdCLElBQUlHO0FBQ0osSUFBSTtJQUNGQSxTQUFTcEIsbUJBQU9BLENBQUM7QUFDbkIsRUFBRSxPQUFNLENBRVI7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU3FCLDZCQUE4QkMsR0FBRyxFQUFFQyxTQUFTLEVBQUVDLEVBQUUsRUFBRUMsV0FB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QUFPLENBQUM7WUFDckJZLFdBQVd0RDtZQUNYaUQ7WUFDQUM7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTVixjQUFlZSxLQUFLO0lBQzNCLE1BQU0sRUFBRXZELEVBQUUsRUFBRSxHQUFHLElBQUk7SUFFbkJBLEVBQUUsQ0FBQ3JCLFlBQVksR0FBR0QsT0FBTzhFLE9BQU87SUFFaEMsSUFBSWpFLFNBQVNJLFdBQVcsQ0FBQzhDLGNBQWMsRUFBRTtRQUN2Q2xELFNBQVNJLFdBQVcsQ0FBQytDLE9BQU8sQ0FBQ2E7SUFDL0I7SUFFQSxJQUFJLENBQUNFLE9BQU87QUFDZDtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZjlEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYnNvY2tldC9jb25uZWN0aW9uLmpzP2FiYjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRpYWdub3N0aWNzQ2hhbm5lbCA9IHJlcXVpcmUoJ2RpYWdub3N0aWNzX2NoYW5uZWwnKVxuY29uc3QgeyB1aWQsIHN0YXRlcyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBrUmVhZHlTdGF0ZSxcbiAga1NlbnRDbG9zZSxcbiAga0J5dGVQYXJzZXIsXG4gIGtSZWNlaXZlZENsb3NlXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgZmlyZUV2ZW50LCBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgQ2xvc2VFdmVudCB9ID0gcmVxdWlyZSgnLi9ldmVudHMnKVxuY29uc3QgeyBtYWtlUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVxdWVzdCcpXG5jb25zdCB7IGZldGNoaW5nIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9pbmRleCcpXG5jb25zdCB7IEhlYWRlcnMgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2hlYWRlcnMnKVxuY29uc3QgeyBnZXRHbG9iYWxEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCcuLi9nbG9iYWwnKVxuY29uc3QgeyBrSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5cbmNvbnN0IGNoYW5uZWxzID0ge31cbmNoYW5uZWxzLm9wZW4gPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpvcGVuJylcbmNoYW5uZWxzLmNsb3NlID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6Y2xvc2UnKVxuY2hhbm5lbHMuc29ja2V0RXJyb3IgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpzb2NrZXRfZXJyb3InKVxuXG4vKiogQHR5cGUge2ltcG9ydCgnY3J5cHRvJyl9ICovXG5sZXQgY3J5cHRvXG50cnkge1xuICBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxufSBjYXRjaCB7XG5cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtd2Vic29ja2V0LWVzdGFibGlzaFxuICogQHBhcmFtIHtVUkx9IHVybFxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHByb3RvY29sc1xuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHBhcmFtIHsocmVzcG9uc2U6IGFueSkgPT4gdm9pZH0gb25Fc3RhYmxpc2hcbiAqIEBwYXJhbSB7UGFydGlhbDxpbXBvcnQoJy4uLy4uL3R5cGVzL3dlYnNvY2tldCcpLldlYlNvY2tldEluaXQ+fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24gKHVybCwgcHJvdG9jb2xzLCB3cywgb25Fc3RhYmxpc2gsIG9wdGlvbnMpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3RVUkwgYmUgYSBjb3B5IG9mIHVybCwgd2l0aCBpdHMgc2NoZW1lIHNldCB0byBcImh0dHBcIiwgaWYgdXJs4oCZc1xuICAvLyAgICBzY2hlbWUgaXMgXCJ3c1wiLCBhbmQgdG8gXCJodHRwc1wiIG90aGVyd2lzZS5cbiAgY29uc3QgcmVxdWVzdFVSTCA9IHVybFxuXG4gIHJlcXVlc3RVUkwucHJvdG9jb2wgPSB1cmwucHJvdG9jb2wgPT09ICd3czonID8gJ2h0dHA6JyA6ICdodHRwczonXG5cbiAgLy8gMi4gTGV0IHJlcXVlc3QgYmUgYSBuZXcgcmVxdWVzdCwgd2hvc2UgVVJMIGlzIHJlcXVlc3RVUkwsIGNsaWVudCBpcyBjbGllbnQsXG4gIC8vICAgIHNlcnZpY2Utd29ya2VycyBtb2RlIGlzIFwibm9uZVwiLCByZWZlcnJlciBpcyBcIm5vLXJlZmVycmVyXCIsIG1vZGUgaXNcbiAgLy8gICAgXCJ3ZWJzb2NrZXRcIiwgY3JlZGVudGlhbHMgbW9kZSBpcyBcImluY2x1ZGVcIiwgY2FjaGUgbW9kZSBpcyBcIm5vLXN0b3JlXCIgLFxuICAvLyAgICBhbmQgcmVkaXJlY3QgbW9kZSBpcyBcImVycm9yXCIuXG4gIGNvbnN0IHJlcXVlc3QgPSBtYWtlUmVxdWVzdCh7XG4gICAgdXJsTGlzdDogW3JlcXVlc3RVUkxdLFxuICAgIHNlcnZpY2VXb3JrZXJzOiAnbm9uZScsXG4gICAgcmVmZXJyZXI6ICduby1yZWZlcnJlcicsXG4gICAgbW9kZTogJ3dlYnNvY2tldCcsXG4gICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICBjYWNoZTogJ25vLXN0b3JlJyxcbiAgICByZWRpcmVjdDogJ2Vycm9yJ1xuICB9KVxuXG4gIC8vIE5vdGU6IHVuZGljaSBleHRlbnNpb24sIGFsbG93IHNldHRpbmcgY3VzdG9tIGhlYWRlcnMuXG4gIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJzTGlzdCA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylba0hlYWRlcnNMaXN0XVxuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdCA9IGhlYWRlcnNMaXN0XG4gIH1cblxuICAvLyAzLiBBcHBlbmQgKGBVcGdyYWRlYCwgYHdlYnNvY2tldGApIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAvLyA0LiBBcHBlbmQgKGBDb25uZWN0aW9uYCwgYFVwZ3JhZGVgKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgLy8gTm90ZTogYm90aCBvZiB0aGVzZSBhcmUgaGFuZGxlZCBieSB1bmRpY2kgY3VycmVudGx5LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9ibG9iLzY4YzI2OWM0MTQ0YzQ0NmYzZjEyMjA5NTEzMzhkYWVmNGE2YjVlYzQvbGliL2NsaWVudC5qcyNMMTM5N1xuXG4gIC8vIDUuIExldCBrZXlWYWx1ZSBiZSBhIG5vbmNlIGNvbnNpc3Rpbmcgb2YgYSByYW5kb21seSBzZWxlY3RlZFxuICAvLyAgICAxNi1ieXRlIHZhbHVlIHRoYXQgaGFzIGJlZW4gZm9yZ2l2aW5nLWJhc2U2NC1lbmNvZGVkIGFuZFxuICAvLyAgICBpc29tb3JwaGljIGVuY29kZWQuXG4gIGNvbnN0IGtleVZhbHVlID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0JylcblxuICAvLyA2LiBBcHBlbmQgKGBTZWMtV2ViU29ja2V0LUtleWAsIGtleVZhbHVlKSB0byByZXF1ZXN04oCZc1xuICAvLyAgICBoZWFkZXIgbGlzdC5cbiAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQta2V5Jywga2V5VmFsdWUpXG5cbiAgLy8gNy4gQXBwZW5kIChgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCwgYDEzYCkgdG8gcmVxdWVzdOKAmXNcbiAgLy8gICAgaGVhZGVyIGxpc3QuXG4gIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdzZWMtd2Vic29ja2V0LXZlcnNpb24nLCAnMTMnKVxuXG4gIC8vIDguIEZvciBlYWNoIHByb3RvY29sIGluIHByb3RvY29scywgY29tYmluZVxuICAvLyAgICAoYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgLCBwcm90b2NvbCkgaW4gcmVxdWVzdOKAmXMgaGVhZGVyXG4gIC8vICAgIGxpc3QuXG4gIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnLCBwcm90b2NvbClcbiAgfVxuXG4gIC8vIDkuIExldCBwZXJtZXNzYWdlRGVmbGF0ZSBiZSBhIHVzZXItYWdlbnQgZGVmaW5lZFxuICAvLyAgICBcInBlcm1lc3NhZ2UtZGVmbGF0ZVwiIGV4dGVuc2lvbiBoZWFkZXIgdmFsdWUuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iL2NlNzgyMzRmNWU2NTNhNWQzOTE2ODEzZmY5OTBmMDUzNTEwMjI3YmMvbmV0d2Vyay9wcm90b2NvbC93ZWJzb2NrZXQvV2ViU29ja2V0Q2hhbm5lbC5jcHAjTDI2NzNcbiAgLy8gVE9ETzogZW5hYmxlIG9uY2UgcGVybWVzc2FnZS1kZWZsYXRlIGlzIHN1cHBvcnRlZFxuICBjb25zdCBwZXJtZXNzYWdlRGVmbGF0ZSA9ICcnIC8vICdwZXJtZXNzYWdlLWRlZmxhdGU7IDE1J1xuXG4gIC8vIDEwLiBBcHBlbmQgKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgLCBwZXJtZXNzYWdlRGVmbGF0ZSkgdG9cbiAgLy8gICAgIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAvLyByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJywgcGVybWVzc2FnZURlZmxhdGUpXG5cbiAgLy8gMTEuIEZldGNoIHJlcXVlc3Qgd2l0aCB1c2VQYXJhbGxlbFF1ZXVlIHNldCB0byB0cnVlLCBhbmRcbiAgLy8gICAgIHByb2Nlc3NSZXNwb25zZSBnaXZlbiByZXNwb25zZSBiZWluZyB0aGVzZSBzdGVwczpcbiAgY29uc3QgY29udHJvbGxlciA9IGZldGNoaW5nKHtcbiAgICByZXF1ZXN0LFxuICAgIHVzZVBhcmFsbGVsUXVldWU6IHRydWUsXG4gICAgZGlzcGF0Y2hlcjogb3B0aW9ucy5kaXNwYXRjaGVyID8/IGdldEdsb2JhbERpc3BhdGNoZXIoKSxcbiAgICBwcm9jZXNzUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgICAvLyAxLiBJZiByZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3Igb3IgaXRzIHN0YXR1cyBpcyBub3QgMTAxLFxuICAgICAgLy8gICAgZmFpbCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyB8fCByZXNwb25zZS5zdGF0dXMgIT09IDEwMSkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ1JlY2VpdmVkIG5ldHdvcmsgZXJyb3Igb3Igbm9uLTEwMSBzdGF0dXMgY29kZS4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgcHJvdG9jb2xzIGlzIG5vdCB0aGUgZW1wdHkgbGlzdCBhbmQgZXh0cmFjdGluZyBoZWFkZXJcbiAgICAgIC8vICAgIGxpc3QgdmFsdWVzIGdpdmVuIGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCBhbmQgcmVzcG9uc2XigJlzXG4gICAgICAvLyAgICBoZWFkZXIgbGlzdCByZXN1bHRzIGluIG51bGwsIGZhaWx1cmUsIG9yIHRoZSBlbXB0eSBieXRlXG4gICAgICAvLyAgICBzZXF1ZW5jZSwgdGhlbiBmYWlsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICAgIGlmIChwcm90b2NvbHMubGVuZ3RoICE9PSAwICYmICFyZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnKSkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ1NlcnZlciBkaWQgbm90IHJlc3BvbmQgd2l0aCBzZW50IHByb3RvY29scy4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMy4gRm9sbG93IHRoZSByZXF1aXJlbWVudHMgc3RhdGVkIHN0ZXAgMiB0byBzdGVwIDYsIGluY2x1c2l2ZSxcbiAgICAgIC8vICAgIG9mIHRoZSBsYXN0IHNldCBvZiBzdGVwcyBpbiBzZWN0aW9uIDQuMSBvZiBUaGUgV2ViU29ja2V0XG4gICAgICAvLyAgICBQcm90b2NvbCB0byB2YWxpZGF0ZSByZXNwb25zZS4gVGhpcyBlaXRoZXIgcmVzdWx0cyBpbiBmYWlsXG4gICAgICAvLyAgICB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gb3IgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzXG4gICAgICAvLyAgICBlc3RhYmxpc2hlZC5cblxuICAgICAgLy8gMi4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGFuIHxVcGdyYWRlfCBoZWFkZXIgZmllbGQgb3IgdGhlIHxVcGdyYWRlfFxuICAgICAgLy8gICAgaGVhZGVyIGZpZWxkIGNvbnRhaW5zIGEgdmFsdWUgdGhhdCBpcyBub3QgYW4gQVNDSUkgY2FzZS1cbiAgICAgIC8vICAgIGluc2Vuc2l0aXZlIG1hdGNoIGZvciB0aGUgdmFsdWUgXCJ3ZWJzb2NrZXRcIiwgdGhlIGNsaWVudCBNVVNUXG4gICAgICAvLyAgICBfRmFpbCB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLlxuICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnVXBncmFkZScpPy50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ1NlcnZlciBkaWQgbm90IHNldCBVcGdyYWRlIGhlYWRlciB0byBcIndlYnNvY2tldFwiLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAzLiBJZiB0aGUgcmVzcG9uc2UgbGFja3MgYSB8Q29ubmVjdGlvbnwgaGVhZGVyIGZpZWxkIG9yIHRoZVxuICAgICAgLy8gICAgfENvbm5lY3Rpb258IGhlYWRlciBmaWVsZCBkb2Vzbid0IGNvbnRhaW4gYSB0b2tlbiB0aGF0IGlzIGFuXG4gICAgICAvLyAgICBBU0NJSSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciB0aGUgdmFsdWUgXCJVcGdyYWRlXCIsIHRoZSBjbGllbnRcbiAgICAgIC8vICAgIE1VU1QgX0ZhaWwgdGhlIFdlYlNvY2tldCBDb25uZWN0aW9uXy5cbiAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ0Nvbm5lY3Rpb24nKT8udG9Mb3dlckNhc2UoKSAhPT0gJ3VwZ3JhZGUnKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnU2VydmVyIGRpZCBub3Qgc2V0IENvbm5lY3Rpb24gaGVhZGVyIHRvIFwidXBncmFkZVwiLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA0LiBJZiB0aGUgcmVzcG9uc2UgbGFja3MgYSB8U2VjLVdlYlNvY2tldC1BY2NlcHR8IGhlYWRlciBmaWVsZCBvclxuICAgICAgLy8gICAgdGhlIHxTZWMtV2ViU29ja2V0LUFjY2VwdHwgY29udGFpbnMgYSB2YWx1ZSBvdGhlciB0aGFuIHRoZVxuICAgICAgLy8gICAgYmFzZTY0LWVuY29kZWQgU0hBLTEgb2YgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIHxTZWMtV2ViU29ja2V0LVxuICAgICAgLy8gICAgS2V5fCAoYXMgYSBzdHJpbmcsIG5vdCBiYXNlNjQtZGVjb2RlZCkgd2l0aCB0aGUgc3RyaW5nIFwiMjU4RUFGQTUtXG4gICAgICAvLyAgICBFOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTFcIiBidXQgaWdub3JpbmcgYW55IGxlYWRpbmcgYW5kXG4gICAgICAvLyAgICB0cmFpbGluZyB3aGl0ZXNwYWNlLCB0aGUgY2xpZW50IE1VU1QgX0ZhaWwgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gICAgQ29ubmVjdGlvbl8uXG4gICAgICBjb25zdCBzZWNXU0FjY2VwdCA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1BY2NlcHQnKVxuICAgICAgY29uc3QgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoa2V5VmFsdWUgKyB1aWQpLmRpZ2VzdCgnYmFzZTY0JylcbiAgICAgIGlmIChzZWNXU0FjY2VwdCAhPT0gZGlnZXN0KSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnSW5jb3JyZWN0IGhhc2ggcmVjZWl2ZWQgaW4gU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA1LiBJZiB0aGUgcmVzcG9uc2UgaW5jbHVkZXMgYSB8U2VjLVdlYlNvY2tldC1FeHRlbnNpb25zfCBoZWFkZXJcbiAgICAgIC8vICAgIGZpZWxkIGFuZCB0aGlzIGhlYWRlciBmaWVsZCBpbmRpY2F0ZXMgdGhlIHVzZSBvZiBhbiBleHRlbnNpb25cbiAgICAgIC8vICAgIHRoYXQgd2FzIG5vdCBwcmVzZW50IGluIHRoZSBjbGllbnQncyBoYW5kc2hha2UgKHRoZSBzZXJ2ZXIgaGFzXG4gICAgICAvLyAgICBpbmRpY2F0ZWQgYW4gZXh0ZW5zaW9uIG5vdCByZXF1ZXN0ZWQgYnkgdGhlIGNsaWVudCksIHRoZSBjbGllbnRcbiAgICAgIC8vICAgIE1VU1QgX0ZhaWwgdGhlIFdlYlNvY2tldCBDb25uZWN0aW9uXy4gIChUaGUgcGFyc2luZyBvZiB0aGlzXG4gICAgICAvLyAgICBoZWFkZXIgZmllbGQgdG8gZGV0ZXJtaW5lIHdoaWNoIGV4dGVuc2lvbnMgYXJlIHJlcXVlc3RlZCBpc1xuICAgICAgLy8gICAgZGlzY3Vzc2VkIGluIFNlY3Rpb24gOS4xLilcbiAgICAgIGNvbnN0IHNlY0V4dGVuc2lvbiA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJylcblxuICAgICAgaWYgKHNlY0V4dGVuc2lvbiAhPT0gbnVsbCAmJiBzZWNFeHRlbnNpb24gIT09IHBlcm1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnUmVjZWl2ZWQgZGlmZmVyZW50IHBlcm1lc3NhZ2UtZGVmbGF0ZSB0aGFuIHRoZSBvbmUgc2V0LicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA2LiBJZiB0aGUgcmVzcG9uc2UgaW5jbHVkZXMgYSB8U2VjLVdlYlNvY2tldC1Qcm90b2NvbHwgaGVhZGVyIGZpZWxkXG4gICAgICAvLyAgICBhbmQgdGhpcyBoZWFkZXIgZmllbGQgaW5kaWNhdGVzIHRoZSB1c2Ugb2YgYSBzdWJwcm90b2NvbCB0aGF0IHdhc1xuICAgICAgLy8gICAgbm90IHByZXNlbnQgaW4gdGhlIGNsaWVudCdzIGhhbmRzaGFrZSAodGhlIHNlcnZlciBoYXMgaW5kaWNhdGVkIGFcbiAgICAgIC8vICAgIHN1YnByb3RvY29sIG5vdCByZXF1ZXN0ZWQgYnkgdGhlIGNsaWVudCksIHRoZSBjbGllbnQgTVVTVCBfRmFpbFxuICAgICAgLy8gICAgdGhlIFdlYlNvY2tldCBDb25uZWN0aW9uXy5cbiAgICAgIGNvbnN0IHNlY1Byb3RvY29sID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LVByb3RvY29sJylcblxuICAgICAgaWYgKHNlY1Byb3RvY29sICE9PSBudWxsICYmIHNlY1Byb3RvY29sICE9PSByZXF1ZXN0LmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcpKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnUHJvdG9jb2wgd2FzIG5vdCBzZXQgaW4gdGhlIG9wZW5pbmcgaGFuZHNoYWtlLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByZXNwb25zZS5zb2NrZXQub24oJ2RhdGEnLCBvblNvY2tldERhdGEpXG4gICAgICByZXNwb25zZS5zb2NrZXQub24oJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSlcbiAgICAgIHJlc3BvbnNlLnNvY2tldC5vbignZXJyb3InLCBvblNvY2tldEVycm9yKVxuXG4gICAgICBpZiAoY2hhbm5lbHMub3Blbi5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICBjaGFubmVscy5vcGVuLnB1Ymxpc2goe1xuICAgICAgICAgIGFkZHJlc3M6IHJlc3BvbnNlLnNvY2tldC5hZGRyZXNzKCksXG4gICAgICAgICAgcHJvdG9jb2w6IHNlY1Byb3RvY29sLFxuICAgICAgICAgIGV4dGVuc2lvbnM6IHNlY0V4dGVuc2lvblxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBvbkVzdGFibGlzaChyZXNwb25zZSlcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGNvbnRyb2xsZXJcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAqL1xuZnVuY3Rpb24gb25Tb2NrZXREYXRhIChjaHVuaykge1xuICBpZiAoIXRoaXMud3Nba0J5dGVQYXJzZXJdLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNmZWVkYmFjay1mcm9tLXRoZS1wcm90b2NvbFxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LjEuNFxuICovXG5mdW5jdGlvbiBvblNvY2tldENsb3NlICgpIHtcbiAgY29uc3QgeyB3cyB9ID0gdGhpc1xuXG4gIC8vIElmIHRoZSBUQ1AgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGFmdGVyIHRoZVxuICAvLyBXZWJTb2NrZXQgY2xvc2luZyBoYW5kc2hha2Ugd2FzIGNvbXBsZXRlZCwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gIC8vIGlzIHNhaWQgdG8gaGF2ZSBiZWVuIGNsb3NlZCBfY2xlYW5seV8uXG4gIGNvbnN0IHdhc0NsZWFuID0gd3Nba1NlbnRDbG9zZV0gJiYgd3Nba1JlY2VpdmVkQ2xvc2VdXG5cbiAgbGV0IGNvZGUgPSAxMDA1XG4gIGxldCByZWFzb24gPSAnJ1xuXG4gIGNvbnN0IHJlc3VsdCA9IHdzW2tCeXRlUGFyc2VyXS5jbG9zaW5nSW5mb1xuXG4gIGlmIChyZXN1bHQpIHtcbiAgICBjb2RlID0gcmVzdWx0LmNvZGUgPz8gMTAwNVxuICAgIHJlYXNvbiA9IHJlc3VsdC5yZWFzb25cbiAgfSBlbHNlIGlmICghd3Nba1NlbnRDbG9zZV0pIHtcbiAgICAvLyBJZiBfVGhlIFdlYlNvY2tldFxuICAgIC8vIENvbm5lY3Rpb24gaXMgQ2xvc2VkXyBhbmQgbm8gQ2xvc2UgY29udHJvbCBmcmFtZSB3YXMgcmVjZWl2ZWQgYnkgdGhlXG4gICAgLy8gZW5kcG9pbnQgKHN1Y2ggYXMgY291bGQgb2NjdXIgaWYgdGhlIHVuZGVybHlpbmcgdHJhbnNwb3J0IGNvbm5lY3Rpb25cbiAgICAvLyBpcyBsb3N0KSwgX1RoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbiBDbG9zZSBDb2RlXyBpcyBjb25zaWRlcmVkIHRvIGJlXG4gICAgLy8gMTAwNi5cbiAgICBjb2RlID0gMTAwNlxuICB9XG5cbiAgLy8gMS4gQ2hhbmdlIHRoZSByZWFkeSBzdGF0ZSB0byBDTE9TRUQgKDMpLlxuICB3c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0VEXG5cbiAgLy8gMi4gSWYgdGhlIHVzZXIgYWdlbnQgd2FzIHJlcXVpcmVkIHRvIGZhaWwgdGhlIFdlYlNvY2tldFxuICAvLyAgICBjb25uZWN0aW9uLCBvciBpZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAvLyAgICBhZnRlciBiZWluZyBmbGFnZ2VkIGFzIGZ1bGwsIGZpcmUgYW4gZXZlbnQgbmFtZWQgZXJyb3JcbiAgLy8gICAgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QuXG4gIC8vIFRPRE9cblxuICAvLyAzLiBGaXJlIGFuIGV2ZW50IG5hbWVkIGNsb3NlIGF0IHRoZSBXZWJTb2NrZXQgb2JqZWN0LFxuICAvLyAgICB1c2luZyBDbG9zZUV2ZW50LCB3aXRoIHRoZSB3YXNDbGVhbiBhdHRyaWJ1dGVcbiAgLy8gICAgaW5pdGlhbGl6ZWQgdG8gdHJ1ZSBpZiB0aGUgY29ubmVjdGlvbiBjbG9zZWQgY2xlYW5seVxuICAvLyAgICBhbmQgZmFsc2Ugb3RoZXJ3aXNlLCB0aGUgY29kZSBhdHRyaWJ1dGUgaW5pdGlhbGl6ZWQgdG9cbiAgLy8gICAgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlIGNvZGUsIGFuZCB0aGUgcmVhc29uXG4gIC8vICAgIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0byB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIFVURi04XG4gIC8vICAgIGRlY29kZSB3aXRob3V0IEJPTSB0byB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2VcbiAgLy8gICAgcmVhc29uLlxuICBmaXJlRXZlbnQoJ2Nsb3NlJywgd3MsIENsb3NlRXZlbnQsIHtcbiAgICB3YXNDbGVhbiwgY29kZSwgcmVhc29uXG4gIH0pXG5cbiAgaWYgKGNoYW5uZWxzLmNsb3NlLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuY2xvc2UucHVibGlzaCh7XG4gICAgICB3ZWJzb2NrZXQ6IHdzLFxuICAgICAgY29kZSxcbiAgICAgIHJlYXNvblxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gb25Tb2NrZXRFcnJvciAoZXJyb3IpIHtcbiAgY29uc3QgeyB3cyB9ID0gdGhpc1xuXG4gIHdzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TSU5HXG5cbiAgaWYgKGNoYW5uZWxzLnNvY2tldEVycm9yLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuc29ja2V0RXJyb3IucHVibGlzaChlcnJvcilcbiAgfVxuXG4gIHRoaXMuZGVzdHJveSgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uXG59XG4iXSwibmFtZXMiOlsiZGlhZ25vc3RpY3NDaGFubmVsIiwicmVxdWlyZSIsInVpZCIsInN0YXRlcyIsImtSZWFkeVN0YXRlIiwia1NlbnRDbG9zZSIsImtCeXRlUGFyc2VyIiwia1JlY2VpdmVkQ2xvc2UiLCJmaXJlRXZlbnQiLCJmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiIsIkNsb3NlRXZlbnQiLCJtYWtlUmVxdWVzdCIsImZldGNoaW5nIiwiSGVhZGVycyIsImdldEdsb2JhbERpc3BhdGNoZXIiLCJrSGVhZGVyc0xpc3QiLCJjaGFubmVscyIsIm9wZW4iLCJjaGFubmVsIiwiY2xvc2UiLCJzb2NrZXRFcnJvciIsImNyeXB0byIsImVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24iLCJ1cmwiLCJwcm90b2NvbHMiLCJ3cyIsIm9uRXN0YWJsaXNoIiwib3B0aW9ucyIsInJlcXVlc3RVUkwiLCJwcm90b2NvbCIsInJlcXVlc3QiLCJ1cmxMaXN0Iiwic2VydmljZVdvcmtlcnMiLCJyZWZlcnJlciIsIm1vZGUiLCJjcmVkZW50aWFscyIsImNhY2hlIiwicmVkaXJlY3QiLCJoZWFkZXJzIiwiaGVhZGVyc0xpc3QiLCJrZXlWYWx1ZSIsInJhbmRvbUJ5dGVzIiwidG9TdHJpbmciLCJhcHBlbmQiLCJwZXJtZXNzYWdlRGVmbGF0ZSIsImNvbnRyb2xsZXIiLCJ1c2VQYXJhbGxlbFF1ZXVlIiwiZGlzcGF0Y2hlciIsInByb2Nlc3NSZXNwb25zZSIsInJlc3BvbnNlIiwidHlwZSIsInN0YXR1cyIsImxlbmd0aCIsImdldCIsInRvTG93ZXJDYXNlIiwic2VjV1NBY2NlcHQiLCJkaWdlc3QiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwic2VjRXh0ZW5zaW9uIiwic2VjUHJvdG9jb2wiLCJzb2NrZXQiLCJvbiIsIm9uU29ja2V0RGF0YSIsIm9uU29ja2V0Q2xvc2UiLCJvblNvY2tldEVycm9yIiwiaGFzU3Vic2NyaWJlcnMiLCJwdWJsaXNoIiwiYWRkcmVzcyIsImV4dGVuc2lvbnMiLCJjaHVuayIsIndyaXRlIiwicGF1c2UiLCJ3YXNDbGVhbiIsImNvZGUiLCJyZWFzb24iLCJyZXN1bHQiLCJjbG9zaW5nSW5mbyIsIkNMT1NFRCIsIndlYnNvY2tldCIsImVycm9yIiwiQ0xPU0lORyIsImRlc3Ryb3kiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/websocket/connection.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/websocket/constants.js":
/*!************************************************************!*\
  !*** ../../node_modules/undici/lib/websocket/constants.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n// This is a Globally Unique Identifier unique used\n// to validate that the endpoint accepts websocket\n// connections.\n// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3\nconst uid = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n/** @type {PropertyDescriptor} */ const staticPropertyDescriptors = {\n    enumerable: true,\n    writable: false,\n    configurable: false\n};\nconst states = {\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSING: 2,\n    CLOSED: 3\n};\nconst opcodes = {\n    CONTINUATION: 0x0,\n    TEXT: 0x1,\n    BINARY: 0x2,\n    CLOSE: 0x8,\n    PING: 0x9,\n    PONG: 0xA\n};\nconst maxUnsigned16Bit = 2 ** 16 - 1 // 65535\n;\nconst parserStates = {\n    INFO: 0,\n    PAYLOADLENGTH_16: 2,\n    PAYLOADLENGTH_64: 3,\n    READ_DATA: 4\n};\nconst emptyBuffer = Buffer.allocUnsafe(0);\nmodule.exports = {\n    uid,\n    staticPropertyDescriptors,\n    states,\n    opcodes,\n    maxUnsigned16Bit,\n    parserStates,\n    emptyBuffer\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLG1EQUFtRDtBQUNuRCxrREFBa0Q7QUFDbEQsZUFBZTtBQUNmLDhEQUE4RDtBQUM5RCxNQUFNQSxNQUFNO0FBRVosK0JBQStCLEdBQy9CLE1BQU1DLDRCQUE0QjtJQUNoQ0MsWUFBWTtJQUNaQyxVQUFVO0lBQ1ZDLGNBQWM7QUFDaEI7QUFFQSxNQUFNQyxTQUFTO0lBQ2JDLFlBQVk7SUFDWkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFFBQVE7QUFDVjtBQUVBLE1BQU1DLFVBQVU7SUFDZEMsY0FBYztJQUNkQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE1BQU07QUFDUjtBQUVBLE1BQU1DLG1CQUFtQixLQUFLLEtBQUssRUFBRSxRQUFROztBQUU3QyxNQUFNQyxlQUFlO0lBQ25CQyxNQUFNO0lBQ05DLGtCQUFrQjtJQUNsQkMsa0JBQWtCO0lBQ2xCQyxXQUFXO0FBQ2I7QUFFQSxNQUFNQyxjQUFjQyxPQUFPQyxXQUFXLENBQUM7QUFFdkNDLE9BQU9DLE9BQU8sR0FBRztJQUNmM0I7SUFDQUM7SUFDQUk7SUFDQUs7SUFDQU87SUFDQUM7SUFDQUs7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2NvbnN0YW50cy5qcz8zMmRlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBUaGlzIGlzIGEgR2xvYmFsbHkgVW5pcXVlIElkZW50aWZpZXIgdW5pcXVlIHVzZWRcbi8vIHRvIHZhbGlkYXRlIHRoYXQgdGhlIGVuZHBvaW50IGFjY2VwdHMgd2Vic29ja2V0XG4vLyBjb25uZWN0aW9ucy5cbi8vIFNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjQ1NS5odG1sI3NlY3Rpb24tMS4zXG5jb25zdCB1aWQgPSAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJ1xuXG4vKiogQHR5cGUge1Byb3BlcnR5RGVzY3JpcHRvcn0gKi9cbmNvbnN0IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMgPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufVxuXG5jb25zdCBzdGF0ZXMgPSB7XG4gIENPTk5FQ1RJTkc6IDAsXG4gIE9QRU46IDEsXG4gIENMT1NJTkc6IDIsXG4gIENMT1NFRDogM1xufVxuXG5jb25zdCBvcGNvZGVzID0ge1xuICBDT05USU5VQVRJT046IDB4MCxcbiAgVEVYVDogMHgxLFxuICBCSU5BUlk6IDB4MixcbiAgQ0xPU0U6IDB4OCxcbiAgUElORzogMHg5LFxuICBQT05HOiAweEFcbn1cblxuY29uc3QgbWF4VW5zaWduZWQxNkJpdCA9IDIgKiogMTYgLSAxIC8vIDY1NTM1XG5cbmNvbnN0IHBhcnNlclN0YXRlcyA9IHtcbiAgSU5GTzogMCxcbiAgUEFZTE9BRExFTkdUSF8xNjogMixcbiAgUEFZTE9BRExFTkdUSF82NDogMyxcbiAgUkVBRF9EQVRBOiA0XG59XG5cbmNvbnN0IGVtcHR5QnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB1aWQsXG4gIHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHN0YXRlcyxcbiAgb3Bjb2RlcyxcbiAgbWF4VW5zaWduZWQxNkJpdCxcbiAgcGFyc2VyU3RhdGVzLFxuICBlbXB0eUJ1ZmZlclxufVxuIl0sIm5hbWVzIjpbInVpZCIsInN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJzdGF0ZXMiLCJDT05ORUNUSU5HIiwiT1BFTiIsIkNMT1NJTkciLCJDTE9TRUQiLCJvcGNvZGVzIiwiQ09OVElOVUFUSU9OIiwiVEVYVCIsIkJJTkFSWSIsIkNMT1NFIiwiUElORyIsIlBPTkciLCJtYXhVbnNpZ25lZDE2Qml0IiwicGFyc2VyU3RhdGVzIiwiSU5GTyIsIlBBWUxPQURMRU5HVEhfMTYiLCJQQVlMT0FETEVOR1RIXzY0IiwiUkVBRF9EQVRBIiwiZW1wdHlCdWZmZXIiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/websocket/constants.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/websocket/events.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/websocket/events.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { MessagePort } = __webpack_require__(/*! worker_threads */ \"worker_threads\");\n/**\n * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent\n */ class MessageEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict = {}){\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"MessageEvent constructor\"\n        });\n        type = webidl.converters.DOMString(type);\n        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);\n        super(type, eventInitDict);\n        this.#eventInit = eventInitDict;\n    }\n    get data() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.data;\n    }\n    get origin() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.origin;\n    }\n    get lastEventId() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.lastEventId;\n    }\n    get source() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.source;\n    }\n    get ports() {\n        webidl.brandCheck(this, MessageEvent);\n        if (!Object.isFrozen(this.#eventInit.ports)) {\n            Object.freeze(this.#eventInit.ports);\n        }\n        return this.#eventInit.ports;\n    }\n    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = \"\", lastEventId = \"\", source = null, ports = []) {\n        webidl.brandCheck(this, MessageEvent);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"MessageEvent.initMessageEvent\"\n        });\n        return new MessageEvent(type, {\n            bubbles,\n            cancelable,\n            data,\n            origin,\n            lastEventId,\n            source,\n            ports\n        });\n    }\n}\n/**\n * @see https://websockets.spec.whatwg.org/#the-closeevent-interface\n */ class CloseEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict = {}){\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CloseEvent constructor\"\n        });\n        type = webidl.converters.DOMString(type);\n        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);\n        super(type, eventInitDict);\n        this.#eventInit = eventInitDict;\n    }\n    get wasClean() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.wasClean;\n    }\n    get code() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.code;\n    }\n    get reason() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.reason;\n    }\n}\n// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface\nclass ErrorEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict){\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"ErrorEvent constructor\"\n        });\n        super(type, eventInitDict);\n        type = webidl.converters.DOMString(type);\n        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});\n        this.#eventInit = eventInitDict;\n    }\n    get message() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.message;\n    }\n    get filename() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.filename;\n    }\n    get lineno() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.lineno;\n    }\n    get colno() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.colno;\n    }\n    get error() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.error;\n    }\n}\nObject.defineProperties(MessageEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"MessageEvent\",\n        configurable: true\n    },\n    data: kEnumerableProperty,\n    origin: kEnumerableProperty,\n    lastEventId: kEnumerableProperty,\n    source: kEnumerableProperty,\n    ports: kEnumerableProperty,\n    initMessageEvent: kEnumerableProperty\n});\nObject.defineProperties(CloseEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"CloseEvent\",\n        configurable: true\n    },\n    reason: kEnumerableProperty,\n    code: kEnumerableProperty,\n    wasClean: kEnumerableProperty\n});\nObject.defineProperties(ErrorEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"ErrorEvent\",\n        configurable: true\n    },\n    message: kEnumerableProperty,\n    filename: kEnumerableProperty,\n    lineno: kEnumerableProperty,\n    colno: kEnumerableProperty,\n    error: kEnumerableProperty\n});\nwebidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);\nwebidl.converters[\"sequence<MessagePort>\"] = webidl.sequenceConverter(webidl.converters.MessagePort);\nconst eventInit = [\n    {\n        key: \"bubbles\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"cancelable\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"composed\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    }\n];\nwebidl.converters.MessageEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: \"data\",\n        converter: webidl.converters.any,\n        defaultValue: null\n    },\n    {\n        key: \"origin\",\n        converter: webidl.converters.USVString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"lastEventId\",\n        converter: webidl.converters.DOMString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"source\",\n        // Node doesn't implement WindowProxy or ServiceWorker, so the only\n        // valid value for source is a MessagePort.\n        converter: webidl.nullableConverter(webidl.converters.MessagePort),\n        defaultValue: null\n    },\n    {\n        key: \"ports\",\n        converter: webidl.converters[\"sequence<MessagePort>\"],\n        get defaultValue () {\n            return [];\n        }\n    }\n]);\nwebidl.converters.CloseEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: \"wasClean\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"code\",\n        converter: webidl.converters[\"unsigned short\"],\n        defaultValue: 0\n    },\n    {\n        key: \"reason\",\n        converter: webidl.converters.USVString,\n        defaultValue: \"\"\n    }\n]);\nwebidl.converters.ErrorEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: \"message\",\n        converter: webidl.converters.DOMString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"filename\",\n        converter: webidl.converters.USVString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"lineno\",\n        converter: webidl.converters[\"unsigned long\"],\n        defaultValue: 0\n    },\n    {\n        key: \"colno\",\n        converter: webidl.converters[\"unsigned long\"],\n        defaultValue: 0\n    },\n    {\n        key: \"error\",\n        converter: webidl.converters.any\n    }\n]);\nmodule.exports = {\n    MessageEvent,\n    CloseEvent,\n    ErrorEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRUMsbUJBQW1CLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDeEMsTUFBTSxFQUFFRSxXQUFXLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFFaEM7O0NBRUMsR0FDRCxNQUFNRyxxQkFBcUJDO0lBQ3pCLENBQUNDLFNBQVM7SUFFVkMsWUFBYUMsSUFBSSxFQUFFQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUU7UUFDckNULE9BQU9VLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7WUFBRUMsUUFBUTtRQUEyQjtRQUU5RUosT0FBT1IsT0FBT2EsVUFBVSxDQUFDQyxTQUFTLENBQUNOO1FBQ25DQyxnQkFBZ0JULE9BQU9hLFVBQVUsQ0FBQ0UsZ0JBQWdCLENBQUNOO1FBRW5ELEtBQUssQ0FBQ0QsTUFBTUM7UUFFWixJQUFJLENBQUMsQ0FBQ0gsU0FBUyxHQUFHRztJQUNwQjtJQUVBLElBQUlPLE9BQVE7UUFDVmhCLE9BQU9pQixVQUFVLENBQUMsSUFBSSxFQUFFYjtRQUV4QixPQUFPLElBQUksQ0FBQyxDQUFDRSxTQUFTLENBQUNVLElBQUk7SUFDN0I7SUFFQSxJQUFJRSxTQUFVO1FBQ1psQixPQUFPaUIsVUFBVSxDQUFDLElBQUksRUFBRWI7UUFFeEIsT0FBTyxJQUFJLENBQUMsQ0FBQ0UsU0FBUyxDQUFDWSxNQUFNO0lBQy9CO0lBRUEsSUFBSUMsY0FBZTtRQUNqQm5CLE9BQU9pQixVQUFVLENBQUMsSUFBSSxFQUFFYjtRQUV4QixPQUFPLElBQUksQ0FBQyxDQUFDRSxTQUFTLENBQUNhLFdBQVc7SUFDcEM7SUFFQSxJQUFJQyxTQUFVO1FBQ1pwQixPQUFPaUIsVUFBVSxDQUFDLElBQUksRUFBRWI7UUFFeEIsT0FBTyxJQUFJLENBQUMsQ0FB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RUgsS0FBSztRQUNMQyxXQUFXakQsT0FBT2EsVUFBVSxDQUFDeUMsU0FBUztRQUN0Q0gsY0FBYztJQUNoQjtDQUNEO0FBRURuRCxPQUFPYSxVQUFVLENBQUNxQixjQUFjLEdBQUdsQyxPQUFPb0QsbUJBQW1CLENBQUM7T0FDekQ5QztJQUNIO1FBQ0UwQyxLQUFLO1FBQ0xDLFdBQVdqRCxPQUFPYSxVQUFVLENBQUNDLFNBQVM7UUFDdENxQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXakQsT0FBT2EsVUFBVSxDQUFDeUMsU0FBUztRQUN0Q0gsY0FBYztJQUNoQjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2pELE9BQU9hLFVBQVUsQ0FBQyxnQkFBZ0I7UUFDN0NzQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXakQsT0FBT2EsVUFBVSxDQUFDLGdCQUFnQjtRQUM3Q3NDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdqRCxPQUFPYSxVQUFVLENBQUN3QyxHQUFHO0lBQ2xDO0NBQ0Q7QUFFREcsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZyRDtJQUNBd0I7SUFDQUs7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2V2ZW50cy5qcz9jOTc0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgTWVzc2FnZVBvcnQgfSA9IHJlcXVpcmUoJ3dvcmtlcl90aHJlYWRzJylcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjbWVzc2FnZWV2ZW50XG4gKi9cbmNsYXNzIE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgI2V2ZW50SW5pdFxuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBldmVudEluaXREaWN0ID0ge30pIHtcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnTWVzc2FnZUV2ZW50IGNvbnN0cnVjdG9yJyB9KVxuXG4gICAgdHlwZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0eXBlKVxuICAgIGV2ZW50SW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5NZXNzYWdlRXZlbnRJbml0KGV2ZW50SW5pdERpY3QpXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuXG4gICAgdGhpcy4jZXZlbnRJbml0ID0gZXZlbnRJbml0RGljdFxuICB9XG5cbiAgZ2V0IGRhdGEgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuZGF0YVxuICB9XG5cbiAgZ2V0IG9yaWdpbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5vcmlnaW5cbiAgfVxuXG4gIGdldCBsYXN0RXZlbnRJZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5sYXN0RXZlbnRJZFxuICB9XG5cbiAgZ2V0IHNvdXJjZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5zb3VyY2VcbiAgfVxuXG4gIGdldCBwb3J0cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgaWYgKCFPYmplY3QuaXNGcm96ZW4odGhpcy4jZXZlbnRJbml0LnBvcnRzKSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzLiNldmVudEluaXQucG9ydHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5wb3J0c1xuICB9XG5cbiAgaW5pdE1lc3NhZ2VFdmVudCAoXG4gICAgdHlwZSxcbiAgICBidWJibGVzID0gZmFsc2UsXG4gICAgY2FuY2VsYWJsZSA9IGZhbHNlLFxuICAgIGRhdGEgPSBudWxsLFxuICAgIG9yaWdpbiA9ICcnLFxuICAgIGxhc3RFdmVudElkID0gJycsXG4gICAgc291cmNlID0gbnVsbCxcbiAgICBwb3J0cyA9IFtdXG4gICkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdNZXNzYWdlRXZlbnQuaW5pdE1lc3NhZ2VFdmVudCcgfSlcblxuICAgIHJldHVybiBuZXcgTWVzc2FnZUV2ZW50KHR5cGUsIHtcbiAgICAgIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRhdGEsIG9yaWdpbiwgbGFzdEV2ZW50SWQsIHNvdXJjZSwgcG9ydHNcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyN0aGUtY2xvc2VldmVudC1pbnRlcmZhY2VcbiAqL1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgI2V2ZW50SW5pdFxuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBldmVudEluaXREaWN0ID0ge30pIHtcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2xvc2VFdmVudCBjb25zdHJ1Y3RvcicgfSlcblxuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSlcbiAgICBldmVudEluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2xvc2VFdmVudEluaXQoZXZlbnRJbml0RGljdClcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0aGlzLiNldmVudEluaXQgPSBldmVudEluaXREaWN0XG4gIH1cblxuICBnZXQgd2FzQ2xlYW4gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENsb3NlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lndhc0NsZWFuXG4gIH1cblxuICBnZXQgY29kZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2xvc2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuY29kZVxuICB9XG5cbiAgZ2V0IHJlYXNvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2xvc2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQucmVhc29uXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3RoZS1lcnJvcmV2ZW50LWludGVyZmFjZVxuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgI2V2ZW50SW5pdFxuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBldmVudEluaXREaWN0KSB7XG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0Vycm9yRXZlbnQgY29uc3RydWN0b3InIH0pXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuXG4gICAgdHlwZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0eXBlKVxuICAgIGV2ZW50SW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5FcnJvckV2ZW50SW5pdChldmVudEluaXREaWN0ID8/IHt9KVxuXG4gICAgdGhpcy4jZXZlbnRJbml0ID0gZXZlbnRJbml0RGljdFxuICB9XG5cbiAgZ2V0IG1lc3NhZ2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lm1lc3NhZ2VcbiAgfVxuXG4gIGdldCBmaWxlbmFtZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuZmlsZW5hbWVcbiAgfVxuXG4gIGdldCBsaW5lbm8gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmxpbmVub1xuICB9XG5cbiAgZ2V0IGNvbG5vICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5jb2xub1xuICB9XG5cbiAgZ2V0IGVycm9yICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5lcnJvclxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1lc3NhZ2VFdmVudC5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ01lc3NhZ2VFdmVudCcsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIGRhdGE6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9yaWdpbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbGFzdEV2ZW50SWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNvdXJjZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcG9ydHM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGluaXRNZXNzYWdlRXZlbnQ6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENsb3NlRXZlbnQucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdDbG9zZUV2ZW50JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgcmVhc29uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjb2RlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB3YXNDbGVhbjoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXJyb3JFdmVudC5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0Vycm9yRXZlbnQnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBtZXNzYWdlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBmaWxlbmFtZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbGluZW5vOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjb2xubzoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VQb3J0ID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihNZXNzYWdlUG9ydClcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPE1lc3NhZ2VQb3J0PiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5NZXNzYWdlUG9ydFxuKVxuXG5jb25zdCBldmVudEluaXQgPSBbXG4gIHtcbiAgICBrZXk6ICdidWJibGVzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY2FuY2VsYWJsZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NvbXBvc2VkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9XG5dXG5cbndlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VFdmVudEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIC4uLmV2ZW50SW5pdCxcbiAge1xuICAgIGtleTogJ2RhdGEnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55LFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAga2V5OiAnb3JpZ2luJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdsYXN0RXZlbnRJZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnc291cmNlJyxcbiAgICAvLyBOb2RlIGRvZXNuJ3QgaW1wbGVtZW50IFdpbmRvd1Byb3h5IG9yIFNlcnZpY2VXb3JrZXIsIHNvIHRoZSBvbmx5XG4gICAgLy8gdmFsaWQgdmFsdWUgZm9yIHNvdXJjZSBpcyBhIE1lc3NhZ2VQb3J0LlxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VQb3J0KSxcbiAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgfSxcbiAge1xuICAgIGtleTogJ3BvcnRzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxNZXNzYWdlUG9ydD4nXSxcbiAgICBnZXQgZGVmYXVsdFZhbHVlICgpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuQ2xvc2VFdmVudEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIC4uLmV2ZW50SW5pdCxcbiAge1xuICAgIGtleTogJ3dhc0NsZWFuJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY29kZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXSxcbiAgICBkZWZhdWx0VmFsdWU6IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ3JlYXNvbicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAnJ1xuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5FcnJvckV2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uZXZlbnRJbml0LFxuICB7XG4gICAga2V5OiAnbWVzc2FnZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnZmlsZW5hbWUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2xpbmVubycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyddLFxuICAgIGRlZmF1bHRWYWx1ZTogMFxuICB9LFxuICB7XG4gICAga2V5OiAnY29sbm8nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ2Vycm9yJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTWVzc2FnZUV2ZW50LFxuICBDbG9zZUV2ZW50LFxuICBFcnJvckV2ZW50XG59XG4iXSwibmFtZXMiOlsid2ViaWRsIiwicmVxdWlyZSIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJNZXNzYWdlUG9ydCIsIk1lc3NhZ2VFdmVudCIsIkV2ZW50IiwiZXZlbnRJbml0IiwiY29uc3RydWN0b3IiLCJ0eXBlIiwiZXZlbnRJbml0RGljdCIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJoZWFkZXIiLCJjb252ZXJ0ZXJzIiwiRE9NU3RyaW5nIiwiTWVzc2FnZUV2ZW50SW5pdCIsImRhdGEiLCJicmFuZENoZWNrIiwib3JpZ2luIiwibGFzdEV2ZW50SWQiLCJzb3VyY2UiLCJwb3J0cyIsIk9iamVjdCIsImlzRnJvemVuIiwiZnJlZXplIiwiaW5pdE1lc3NhZ2VFdmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiQ2xvc2VFdmVudCIsIkNsb3NlRXZlbnRJbml0Iiwid2FzQ2xlYW4iLCJjb2RlIiwicmVhc29uIiwiRXJyb3JFdmVudCIsIkVycm9yRXZlbnRJbml0IiwibWVzc2FnZSIsImZpbGVuYW1lIiwibGluZW5vIiwiY29sbm8iLCJlcnJvciIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiaW50ZXJmYWNlQ29udmVydGVyIiwic2VxdWVuY2VDb252ZXJ0ZXIiLCJrZXkiLCJjb252ZXJ0ZXIiLCJib29sZWFuIiwiZGVmYXVsdFZhbHVlIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImFueSIsIlVTVlN0cmluZyIsIm51bGxhYmxlQ29udmVydGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/websocket/events.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/websocket/frame.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/websocket/frame.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { maxUnsigned16Bit } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/undici/lib/websocket/constants.js\");\n/** @type {import('crypto')} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n} catch  {}\nclass WebsocketFrameSend {\n    /**\n   * @param {Buffer|undefined} data\n   */ constructor(data){\n        this.frameData = data;\n        this.maskKey = crypto.randomBytes(4);\n    }\n    createFrame(opcode) {\n        const bodyLength = this.frameData?.byteLength ?? 0;\n        /** @type {number} */ let payloadLength = bodyLength // 0-125\n        ;\n        let offset = 6;\n        if (bodyLength > maxUnsigned16Bit) {\n            offset += 8 // payload length is next 8 bytes\n            ;\n            payloadLength = 127;\n        } else if (bodyLength > 125) {\n            offset += 2 // payload length is next 2 bytes\n            ;\n            payloadLength = 126;\n        }\n        const buffer = Buffer.allocUnsafe(bodyLength + offset);\n        // Clear first 2 bytes, everything else is overwritten\n        buffer[0] = buffer[1] = 0;\n        buffer[0] |= 0x80 // FIN\n        ;\n        buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n        ;\n        /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */ buffer[offset - 4] = this.maskKey[0];\n        buffer[offset - 3] = this.maskKey[1];\n        buffer[offset - 2] = this.maskKey[2];\n        buffer[offset - 1] = this.maskKey[3];\n        buffer[1] = payloadLength;\n        if (payloadLength === 126) {\n            buffer.writeUInt16BE(bodyLength, 2);\n        } else if (payloadLength === 127) {\n            // Clear extended payload length\n            buffer[2] = buffer[3] = 0;\n            buffer.writeUIntBE(bodyLength, 4, 6);\n        }\n        buffer[1] |= 0x80 // MASK\n        ;\n        // mask body\n        for(let i = 0; i < bodyLength; i++){\n            buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];\n        }\n        return buffer;\n    }\n}\nmodule.exports = {\n    WebsocketFrameSend\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2ZyYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxnQkFBZ0IsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUVyQyw2QkFBNkIsR0FDN0IsSUFBSUM7QUFDSixJQUFJO0lBQ0ZBLFNBQVNELG1CQUFPQSxDQUFDO0FBQ25CLEVBQUUsT0FBTSxDQUVSO0FBRUEsTUFBTUU7SUFDSjs7R0FFQyxHQUNEQyxZQUFhQyxJQUFJLENBQUU7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdEO1FBQ2pCLElBQUksQ0FBQ0UsT0FBTyxHQUFHTCxPQUFPTSxXQUFXLENBQUM7SUFDcEM7SUFFQUMsWUFBYUMsTUFBTSxFQUFFO1FBQ25CLE1BQU1DLGFBQWEsSUFBSSxDQUFDTCxTQUFTLEVBQUVNLGNBQWM7UUFFakQsbUJBQW1CLEdBQ25CLElBQUlDLGdCQUFnQkYsV0FBVyxRQUFROztRQUN2QyxJQUFJRyxTQUFTO1FBRWIsSUFBSUgsYUFBYVgsa0JBQWtCO1lBQ2pDYyxVQUFVLEVBQUUsaUNBQWlDOztZQUM3Q0QsZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSUYsYUFBYSxLQUFLO1lBQzNCRyxVQUFVLEVBQUUsaUNBQWlDOztZQUM3Q0QsZ0JBQWdCO1FBQ2xCO1FBRUEsTUFBTUUsU0FBU0MsT0FBT0MsV0FBVyxDQUFDTixhQUFhRztRQUUvQyxzREFBc0Q7UUFDdERDLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7UUFDeEJBLE1BQU0sQ0FBQyxFQUFFLElBQUksS0FBSyxNQUFNOztRQUN4QkEsTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDQSxNQUFNLENBQUMsRUFBRSxHQUFHLElBQUcsSUFBS0wsT0FBTyxTQUFTOztRQUVqRCw2REFBNkQsR0FDN0RLLE1BQU0sQ0FBQ0QsU0FBUyxFQUFFLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUMsRUFBRTtRQUNwQ1EsTUFBTSxDQUFDRCxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUNQLE9BQU8sQ0FBQyxFQUFFO1FBQ3BDUSxNQUFNLENBQUNELFNBQVMsRUFBRSxHQUFHLElBQUksQ0FBQ1AsT0FBTyxDQUFDLEVBQUU7UUFDcENRLE1BQU0sQ0FBQ0QsU0FBUyxFQUFFLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUMsRUFBRTtRQUVwQ1EsTUFBTSxDQUFDLEVBQUUsR0FBR0Y7UUFFWixJQUFJQSxrQkFBa0IsS0FBSztZQUN6QkUsT0FBT0csYUFBYSxDQUFDUCxZQUFZO1FBQ25DLE9BQU8sSUFBSUUsa0JBQWtCLEtBQUs7WUFDaEMsZ0NBQWdDO1lBQ2hDRSxNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRSxHQUFHO1lBQ3hCQSxPQUFPSSxXQUFXLENBQUNSLFlBQVksR0FBRztRQUNwQztRQUVBSSxNQUFNLENBQUMsRUFBRSxJQUFJLEtBQUssT0FBTzs7UUFFekIsWUFBWTtRQUNaLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJVCxZQUFZUyxJQUFLO1lBQ25DTCxNQUFNLENBQUNELFNBQVNNLEVBQUUsR0FBRyxJQUFJLENBQUNkLFNBQVMsQ0FBQ2MsRUFBRSxHQUFHLElBQUksQ0FBQ2IsT0FBTyxDQUFDYSxJQUFJLEVBQUU7UUFDOUQ7UUFFQSxPQUFPTDtJQUNUO0FBQ0Y7QUFFQU0sT0FBT0MsT0FBTyxHQUFHO0lBQ2ZuQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvZnJhbWUuanM/MzI5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBtYXhVbnNpZ25lZDE2Qml0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCdjcnlwdG8nKX0gKi9cbmxldCBjcnlwdG9cbnRyeSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG59IGNhdGNoIHtcblxufVxuXG5jbGFzcyBXZWJzb2NrZXRGcmFtZVNlbmQge1xuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ8dW5kZWZpbmVkfSBkYXRhXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIHRoaXMuZnJhbWVEYXRhID0gZGF0YVxuICAgIHRoaXMubWFza0tleSA9IGNyeXB0by5yYW5kb21CeXRlcyg0KVxuICB9XG5cbiAgY3JlYXRlRnJhbWUgKG9wY29kZSkge1xuICAgIGNvbnN0IGJvZHlMZW5ndGggPSB0aGlzLmZyYW1lRGF0YT8uYnl0ZUxlbmd0aCA/PyAwXG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICBsZXQgcGF5bG9hZExlbmd0aCA9IGJvZHlMZW5ndGggLy8gMC0xMjVcbiAgICBsZXQgb2Zmc2V0ID0gNlxuXG4gICAgaWYgKGJvZHlMZW5ndGggPiBtYXhVbnNpZ25lZDE2Qml0KSB7XG4gICAgICBvZmZzZXQgKz0gOCAvLyBwYXlsb2FkIGxlbmd0aCBpcyBuZXh0IDggYnl0ZXNcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjdcbiAgICB9IGVsc2UgaWYgKGJvZHlMZW5ndGggPiAxMjUpIHtcbiAgICAgIG9mZnNldCArPSAyIC8vIHBheWxvYWQgbGVuZ3RoIGlzIG5leHQgMiBieXRlc1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNlxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShib2R5TGVuZ3RoICsgb2Zmc2V0KVxuXG4gICAgLy8gQ2xlYXIgZmlyc3QgMiBieXRlcywgZXZlcnl0aGluZyBlbHNlIGlzIG92ZXJ3cml0dGVuXG4gICAgYnVmZmVyWzBdID0gYnVmZmVyWzFdID0gMFxuICAgIGJ1ZmZlclswXSB8PSAweDgwIC8vIEZJTlxuICAgIGJ1ZmZlclswXSA9IChidWZmZXJbMF0gJiAweEYwKSArIG9wY29kZSAvLyBvcGNvZGVcblxuICAgIC8qISB3cy4gTUlUIExpY2Vuc2UuIEVpbmFyIE90dG8gU3Rhbmd2aWsgPGVpbmFyb3NAZ21haWwuY29tPiAqL1xuICAgIGJ1ZmZlcltvZmZzZXQgLSA0XSA9IHRoaXMubWFza0tleVswXVxuICAgIGJ1ZmZlcltvZmZzZXQgLSAzXSA9IHRoaXMubWFza0tleVsxXVxuICAgIGJ1ZmZlcltvZmZzZXQgLSAyXSA9IHRoaXMubWFza0tleVsyXVxuICAgIGJ1ZmZlcltvZmZzZXQgLSAxXSA9IHRoaXMubWFza0tleVszXVxuXG4gICAgYnVmZmVyWzFdID0gcGF5bG9hZExlbmd0aFxuXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgYnVmZmVyLndyaXRlVUludDE2QkUoYm9keUxlbmd0aCwgMilcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgLy8gQ2xlYXIgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGhcbiAgICAgIGJ1ZmZlclsyXSA9IGJ1ZmZlclszXSA9IDBcbiAgICAgIGJ1ZmZlci53cml0ZVVJbnRCRShib2R5TGVuZ3RoLCA0LCA2KVxuICAgIH1cblxuICAgIGJ1ZmZlclsxXSB8PSAweDgwIC8vIE1BU0tcblxuICAgIC8vIG1hc2sgYm9keVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9keUxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSB0aGlzLmZyYW1lRGF0YVtpXSBeIHRoaXMubWFza0tleVtpICUgNF1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYnNvY2tldEZyYW1lU2VuZFxufVxuIl0sIm5hbWVzIjpbIm1heFVuc2lnbmVkMTZCaXQiLCJyZXF1aXJlIiwiY3J5cHRvIiwiV2Vic29ja2V0RnJhbWVTZW5kIiwiY29uc3RydWN0b3IiLCJkYXRhIiwiZnJhbWVEYXRhIiwibWFza0tleSIsInJhbmRvbUJ5dGVzIiwiY3JlYXRlRnJhbWUiLCJvcGNvZGUiLCJib2R5TGVuZ3RoIiwiYnl0ZUxlbmd0aCIsInBheWxvYWRMZW5ndGgiLCJvZmZzZXQiLCJidWZmZXIiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVJbnRCRSIsImkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/websocket/frame.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/websocket/receiver.js":
/*!***********************************************************!*\
  !*** ../../node_modules/undici/lib/websocket/receiver.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\nconst diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\nconst { parserStates, opcodes, states, emptyBuffer } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/undici/lib/websocket/constants.js\");\nconst { kReadyState, kSentClose, kResponse, kReceivedClose } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/websocket/symbols.js\");\nconst { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/websocket/util.js\");\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/../../node_modules/undici/lib/websocket/frame.js\");\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\nconst channels = {};\nchannels.ping = diagnosticsChannel.channel(\"undici:websocket:ping\");\nchannels.pong = diagnosticsChannel.channel(\"undici:websocket:pong\");\nclass ByteParser extends Writable {\n    #buffers;\n    #byteOffset;\n    #state;\n    #info;\n    #fragments;\n    constructor(ws){\n        super();\n        this.#buffers = [];\n        this.#byteOffset = 0;\n        this.#state = parserStates.INFO;\n        this.#info = {};\n        this.#fragments = [];\n        this.ws = ws;\n    }\n    /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */ _write(chunk, _, callback) {\n        this.#buffers.push(chunk);\n        this.#byteOffset += chunk.length;\n        this.run(callback);\n    }\n    /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */ run(callback) {\n        while(true){\n            if (this.#state === parserStates.INFO) {\n                // If there aren't enough bytes to parse the payload length, etc.\n                if (this.#byteOffset < 2) {\n                    return callback();\n                }\n                const buffer = this.consume(2);\n                this.#info.fin = (buffer[0] & 0x80) !== 0;\n                this.#info.opcode = buffer[0] & 0x0F;\n                // If we receive a fragmented message, we use the type of the first\n                // frame to parse the full message as binary/text, when it's terminated\n                this.#info.originalOpcode ??= this.#info.opcode;\n                this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;\n                if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {\n                    // Only text and binary frames can be fragmented\n                    failWebsocketConnection(this.ws, \"Invalid frame type was fragmented.\");\n                    return;\n                }\n                const payloadLength = buffer[1] & 0x7F;\n                if (payloadLength <= 125) {\n                    this.#info.payloadLength = payloadLength;\n                    this.#state = parserStates.READ_DATA;\n                } else if (payloadLength === 126) {\n                    this.#state = parserStates.PAYLOADLENGTH_16;\n                } else if (payloadLength === 127) {\n                    this.#state = parserStates.PAYLOADLENGTH_64;\n                }\n                if (this.#info.fragmented && payloadLength > 125) {\n                    // A fragmented frame can't be fragmented itself\n                    failWebsocketConnection(this.ws, \"Fragmented frame exceeded 125 bytes.\");\n                    return;\n                } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {\n                    // Control frames can have a payload length of 125 bytes MAX\n                    failWebsocketConnection(this.ws, \"Payload length for control frame exceeded 125 bytes.\");\n                    return;\n                } else if (this.#info.opcode === opcodes.CLOSE) {\n                    if (payloadLength === 1) {\n                        failWebsocketConnection(this.ws, \"Received close frame with a 1-byte body.\");\n                        return;\n                    }\n                    const body = this.consume(payloadLength);\n                    this.#info.closeInfo = this.parseCloseBody(false, body);\n                    if (!this.ws[kSentClose]) {\n                        // If an endpoint receives a Close frame and did not previously send a\n                        // Close frame, the endpoint MUST send a Close frame in response.  (When\n                        // sending a Close frame in response, the endpoint typically echos the\n                        // status code it received.)\n                        const body = Buffer.allocUnsafe(2);\n                        body.writeUInt16BE(this.#info.closeInfo.code, 0);\n                        const closeFrame = new WebsocketFrameSend(body);\n                        this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err)=>{\n                            if (!err) {\n                                this.ws[kSentClose] = true;\n                            }\n                        });\n                    }\n                    // Upon either sending or receiving a Close control frame, it is said\n                    // that _The WebSocket Closing Handshake is Started_ and that the\n                    // WebSocket connection is in the CLOSING state.\n                    this.ws[kReadyState] = states.CLOSING;\n                    this.ws[kReceivedClose] = true;\n                    this.end();\n                    return;\n                } else if (this.#info.opcode === opcodes.PING) {\n                    // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n                    // response, unless it already received a Close frame.\n                    // A Pong frame sent in response to a Ping frame must have identical\n                    // \"Application data\"\n                    const body = this.consume(payloadLength);\n                    if (!this.ws[kReceivedClose]) {\n                        const frame = new WebsocketFrameSend(body);\n                        this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));\n                        if (channels.ping.hasSubscribers) {\n                            channels.ping.publish({\n                                payload: body\n                            });\n                        }\n                    }\n                    this.#state = parserStates.INFO;\n                    if (this.#byteOffset > 0) {\n                        continue;\n                    } else {\n                        callback();\n                        return;\n                    }\n                } else if (this.#info.opcode === opcodes.PONG) {\n                    // A Pong frame MAY be sent unsolicited.  This serves as a\n                    // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n                    // not expected.\n                    const body = this.consume(payloadLength);\n                    if (channels.pong.hasSubscribers) {\n                        channels.pong.publish({\n                            payload: body\n                        });\n                    }\n                    if (this.#byteOffset > 0) {\n                        continue;\n                    } else {\n                        callback();\n                        return;\n                    }\n                }\n            } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n                if (this.#byteOffset < 2) {\n                    return callback();\n                }\n                const buffer = this.consume(2);\n                this.#info.payloadLength = buffer.readUInt16BE(0);\n                this.#state = parserStates.READ_DATA;\n            } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n                if (this.#byteOffset < 8) {\n                    return callback();\n                }\n                const buffer = this.consume(8);\n                const upper = buffer.readUInt32BE(0);\n                // 2^31 is the maxinimum bytes an arraybuffer can contain\n                // on 32-bit systems. Although, on 64-bit systems, this is\n                // 2^53-1 bytes.\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n                // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n                // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n                if (upper > 2 ** 31 - 1) {\n                    failWebsocketConnection(this.ws, \"Received payload length > 2^31 bytes.\");\n                    return;\n                }\n                const lower = buffer.readUInt32BE(4);\n                this.#info.payloadLength = (upper << 8) + lower;\n                this.#state = parserStates.READ_DATA;\n            } else if (this.#state === parserStates.READ_DATA) {\n                if (this.#byteOffset < this.#info.payloadLength) {\n                    // If there is still more data in this chunk that needs to be read\n                    return callback();\n                } else if (this.#byteOffset >= this.#info.payloadLength) {\n                    // If the server sent multiple frames in a single chunk\n                    const body = this.consume(this.#info.payloadLength);\n                    this.#fragments.push(body);\n                    // If the frame is unfragmented, or a fragmented frame was terminated,\n                    // a message was received\n                    if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {\n                        const fullMessage = Buffer.concat(this.#fragments);\n                        websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);\n                        this.#info = {};\n                        this.#fragments.length = 0;\n                    }\n                    this.#state = parserStates.INFO;\n                }\n            }\n            if (this.#byteOffset > 0) {\n                continue;\n            } else {\n                callback();\n                break;\n            }\n        }\n    }\n    /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer|null}\n   */ consume(n) {\n        if (n > this.#byteOffset) {\n            return null;\n        } else if (n === 0) {\n            return emptyBuffer;\n        }\n        if (this.#buffers[0].length === n) {\n            this.#byteOffset -= this.#buffers[0].length;\n            return this.#buffers.shift();\n        }\n        const buffer = Buffer.allocUnsafe(n);\n        let offset = 0;\n        while(offset !== n){\n            const next = this.#buffers[0];\n            const { length } = next;\n            if (length + offset === n) {\n                buffer.set(this.#buffers.shift(), offset);\n                break;\n            } else if (length + offset > n) {\n                buffer.set(next.subarray(0, n - offset), offset);\n                this.#buffers[0] = next.subarray(n - offset);\n                break;\n            } else {\n                buffer.set(this.#buffers.shift(), offset);\n                offset += next.length;\n            }\n        }\n        this.#byteOffset -= n;\n        return buffer;\n    }\n    parseCloseBody(onlyCode, data) {\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n        /** @type {number|undefined} */ let code;\n        if (data.length >= 2) {\n            // _The WebSocket Connection Close Code_ is\n            // defined as the status code (Section 7.4) contained in the first Close\n            // control frame received by the application\n            code = data.readUInt16BE(0);\n        }\n        if (onlyCode) {\n            if (!isValidStatusCode(code)) {\n                return null;\n            }\n            return {\n                code\n            };\n        }\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n        /** @type {Buffer} */ let reason = data.subarray(2);\n        // Remove BOM\n        if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n            reason = reason.subarray(3);\n        }\n        if (code !== undefined && !isValidStatusCode(code)) {\n            return null;\n        }\n        try {\n            // TODO: optimize this\n            reason = new TextDecoder(\"utf-8\", {\n                fatal: true\n            }).decode(reason);\n        } catch  {\n            return null;\n        }\n        return {\n            code,\n            reason\n        };\n    }\n    get closingInfo() {\n        return this.#info.closeInfo;\n    }\n}\nmodule.exports = {\n    ByteParser\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxRQUFRLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDN0IsTUFBTUMscUJBQXFCRCxtQkFBT0EsQ0FBQztBQUNuQyxNQUFNLEVBQUVFLFlBQVksRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFdBQVcsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUMvRCxNQUFNLEVBQUVNLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVDLGNBQWMsRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQztBQUN2RSxNQUFNLEVBQUVVLGlCQUFpQixFQUFFQyx1QkFBdUIsRUFBRUMsd0JBQXdCLEVBQUUsR0FBR1osbUJBQU9BLENBQUM7QUFDekYsTUFBTSxFQUFFYSxrQkFBa0IsRUFBRSxHQUFHYixtQkFBT0EsQ0FBQztBQUV2QyxpRUFBaUU7QUFDakUsNkRBQTZEO0FBQzdELHNEQUFzRDtBQUN0RCxrREFBa0Q7QUFFbEQsTUFBTWMsV0FBVyxDQUFDO0FBQ2xCQSxTQUFTQyxJQUFJLEdBQUdkLG1CQUFtQmUsT0FBTyxDQUFDO0FBQzNDRixTQUFTRyxJQUFJLEdBQUdoQixtQkFBbUJlLE9BQU8sQ0FBQztBQUUzQyxNQUFNRSxtQkFBbUJuQjtJQUN2QixDQUFDb0IsT0FBTyxDQUFLO0lBQ2IsQ0FBQ0MsVUFBVSxDQUFJO0lBRWYsQ0FBQ0MsS0FBSyxDQUFvQjtJQUUxQixDQUFDQyxJQUFJLENBQUs7SUFDVixDQUFDQyxTQUFTLENBQUs7SUFFZkMsWUFBYUMsRUFBRSxDQUFFO1FBQ2YsS0FBSzthQVRQLENBQUNOLE9BQU8sR0FBRyxFQUFFO2FBQ2IsQ0FBQ0MsVUFBVSxHQUFHO2FBRWQsQ0FBQ0MsS0FBSyxHQUFHbkIsYUFBYXdCLElBQUk7YUFFMUIsQ0FBQ0osSUFBSSxHQUFHLENBQUM7YUFDVCxDQUFDQyxTQUFTLEdBQUcs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RCxNQUFNLElBQUksR0FBRztZQUNwQiwyQ0FBMkM7WUFDM0Msd0VBQXdFO1lBQ3hFLDRDQUE0QztZQUM1Q3dCLE9BQU95QixLQUFLYixZQUFZLENBQUM7UUFDM0I7UUFFQSxJQUFJWSxVQUFVO1lBQ1osSUFBSSxDQUFDdEUsa0JBQWtCOEMsT0FBTztnQkFDNUIsT0FBTztZQUNUO1lBRUEsT0FBTztnQkFBRUE7WUFBSztRQUNoQjtRQUVBLDhEQUE4RDtRQUM5RCxtQkFBbUIsR0FDbkIsSUFBSTBCLFNBQVNELEtBQUtGLFFBQVEsQ0FBQztRQUUzQixhQUFhO1FBQ2IsSUFBSUcsTUFBTSxDQUFDLEVBQUUsS0FBSyxRQUFRQSxNQUFNLENBQUMsRUFBRSxLQUFLLFFBQVFBLE1BQU0sQ0FBQyxFQUFFLEtBQUssTUFBTTtZQUNsRUEsU0FBU0EsT0FBT0gsUUFBUSxDQUFDO1FBQzNCO1FBRUEsSUFBSXZCLFNBQVMyQixhQUFhLENBQUN6RSxrQkFBa0I4QyxPQUFPO1lBQ2xELE9BQU87UUFDVDtRQUVBLElBQUk7WUFDRixzQkFBc0I7WUFDdEIwQixTQUFTLElBQUlFLFlBQVksU0FBUztnQkFBRUMsT0FBTztZQUFLLEdBQUdDLE1BQU0sQ0FBQ0o7UUFDNUQsRUFBRSxPQUFNO1lBQ04sT0FBTztRQUNUO1FBRUEsT0FBTztZQUFFMUI7WUFBTTBCO1FBQU87SUFDeEI7SUFFQSxJQUFJSyxjQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLENBQUNqRSxJQUFJLENBQUM2QixTQUFTO0lBQzdCO0FBQ0Y7QUFFQXFDLE9BQU9DLE9BQU8sR0FBRztJQUNmdkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3JlY2VpdmVyLmpzPzVlODQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCBkaWFnbm9zdGljc0NoYW5uZWwgPSByZXF1aXJlKCdkaWFnbm9zdGljc19jaGFubmVsJylcbmNvbnN0IHsgcGFyc2VyU3RhdGVzLCBvcGNvZGVzLCBzdGF0ZXMsIGVtcHR5QnVmZmVyIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGtSZWFkeVN0YXRlLCBrU2VudENsb3NlLCBrUmVzcG9uc2UsIGtSZWNlaXZlZENsb3NlIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24sIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgV2Vic29ja2V0RnJhbWVTZW5kIH0gPSByZXF1aXJlKCcuL2ZyYW1lJylcblxuLy8gVGhpcyBjb2RlIHdhcyBpbmZsdWVuY2VkIGJ5IHdzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vIENvcHlyaWdodCAoYykgMjAxMSBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBcm5vdXQgS2F6ZW1pZXIgYW5kIGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE2IEx1aWdpIFBpbmNhIGFuZCBjb250cmlidXRvcnNcblxuY29uc3QgY2hhbm5lbHMgPSB7fVxuY2hhbm5lbHMucGluZyA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnBpbmcnKVxuY2hhbm5lbHMucG9uZyA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnBvbmcnKVxuXG5jbGFzcyBCeXRlUGFyc2VyIGV4dGVuZHMgV3JpdGFibGUge1xuICAjYnVmZmVycyA9IFtdXG4gICNieXRlT2Zmc2V0ID0gMFxuXG4gICNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG5cbiAgI2luZm8gPSB7fVxuICAjZnJhZ21lbnRzID0gW11cblxuICBjb25zdHJ1Y3RvciAod3MpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLndzID0gd3NcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAgICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYWxsYmFja1xuICAgKi9cbiAgX3dyaXRlIChjaHVuaywgXywgY2FsbGJhY2spIHtcbiAgICB0aGlzLiNidWZmZXJzLnB1c2goY2h1bmspXG4gICAgdGhpcy4jYnl0ZU9mZnNldCArPSBjaHVuay5sZW5ndGhcblxuICAgIHRoaXMucnVuKGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgd2hlbmV2ZXIgYSBuZXcgY2h1bmsgaXMgcmVjZWl2ZWQuXG4gICAqIENhbGxiYWNrIGlzIGNhbGxlZCB3aGVuZXZlciB0aGVyZSBhcmUgbm8gbW9yZSBjaHVua3MgYnVmZmVyaW5nLFxuICAgKiBvciBub3QgZW5vdWdoIGJ5dGVzIGFyZSBidWZmZXJlZCB0byBwYXJzZS5cbiAgICovXG4gIHJ1biAoY2FsbGJhY2spIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuSU5GTykge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmVuJ3QgZW5vdWdoIGJ5dGVzIHRvIHBhcnNlIHRoZSBwYXlsb2FkIGxlbmd0aCwgZXRjLlxuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5jb25zdW1lKDIpXG5cbiAgICAgICAgdGhpcy4jaW5mby5maW4gPSAoYnVmZmVyWzBdICYgMHg4MCkgIT09IDBcbiAgICAgICAgdGhpcy4jaW5mby5vcGNvZGUgPSBidWZmZXJbMF0gJiAweDBGXG5cbiAgICAgICAgLy8gSWYgd2UgcmVjZWl2ZSBhIGZyYWdtZW50ZWQgbWVzc2FnZSwgd2UgdXNlIHRoZSB0eXBlIG9mIHRoZSBmaXJzdFxuICAgICAgICAvLyBmcmFtZSB0byBwYXJzZSB0aGUgZnVsbCBtZXNzYWdlIGFzIGJpbmFyeS90ZXh0LCB3aGVuIGl0J3MgdGVybWluYXRlZFxuICAgICAgICB0aGlzLiNpbmZvLm9yaWdpbmFsT3Bjb2RlID8/PSB0aGlzLiNpbmZvLm9wY29kZVxuXG4gICAgICAgIHRoaXMuI2luZm8uZnJhZ21lbnRlZCA9ICF0aGlzLiNpbmZvLmZpbiAmJiB0aGlzLiNpbmZvLm9wY29kZSAhPT0gb3Bjb2Rlcy5DT05USU5VQVRJT05cblxuICAgICAgICBpZiAodGhpcy4jaW5mby5mcmFnbWVudGVkICYmIHRoaXMuI2luZm8ub3Bjb2RlICE9PSBvcGNvZGVzLkJJTkFSWSAmJiB0aGlzLiNpbmZvLm9wY29kZSAhPT0gb3Bjb2Rlcy5URVhUKSB7XG4gICAgICAgICAgLy8gT25seSB0ZXh0IGFuZCBiaW5hcnkgZnJhbWVzIGNhbiBiZSBmcmFnbWVudGVkXG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0ludmFsaWQgZnJhbWUgdHlwZSB3YXMgZnJhZ21lbnRlZC4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGF5bG9hZExlbmd0aCA9IGJ1ZmZlclsxXSAmIDB4N0ZcblxuICAgICAgICBpZiAocGF5bG9hZExlbmd0aCA8PSAxMjUpIHtcbiAgICAgICAgICB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGggPSBwYXlsb2FkTGVuZ3RoXG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBXG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF8xNlxuICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlBBWUxPQURMRU5HVEhfNjRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLiNpbmZvLmZyYWdtZW50ZWQgJiYgcGF5bG9hZExlbmd0aCA+IDEyNSkge1xuICAgICAgICAgIC8vIEEgZnJhZ21lbnRlZCBmcmFtZSBjYW4ndCBiZSBmcmFnbWVudGVkIGl0c2VsZlxuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdGcmFnbWVudGVkIGZyYW1lIGV4Y2VlZGVkIDEyNSBieXRlcy4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICh0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5QSU5HIHx8XG4gICAgICAgICAgICB0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5QT05HIHx8XG4gICAgICAgICAgICB0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5DTE9TRSkgJiZcbiAgICAgICAgICBwYXlsb2FkTGVuZ3RoID4gMTI1XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIENvbnRyb2wgZnJhbWVzIGNhbiBoYXZlIGEgcGF5bG9hZCBsZW5ndGggb2YgMTI1IGJ5dGVzIE1BWFxuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdQYXlsb2FkIGxlbmd0aCBmb3IgY29udHJvbCBmcmFtZSBleGNlZWRlZCAxMjUgYnl0ZXMuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5DTE9TRSkge1xuICAgICAgICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnUmVjZWl2ZWQgY2xvc2UgZnJhbWUgd2l0aCBhIDEtYnl0ZSBib2R5LicpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5jb25zdW1lKHBheWxvYWRMZW5ndGgpXG5cbiAgICAgICAgICB0aGlzLiNpbmZvLmNsb3NlSW5mbyA9IHRoaXMucGFyc2VDbG9zZUJvZHkoZmFsc2UsIGJvZHkpXG5cbiAgICAgICAgICBpZiAoIXRoaXMud3Nba1NlbnRDbG9zZV0pIHtcbiAgICAgICAgICAgIC8vIElmIGFuIGVuZHBvaW50IHJlY2VpdmVzIGEgQ2xvc2UgZnJhbWUgYW5kIGRpZCBub3QgcHJldmlvdXNseSBzZW5kIGFcbiAgICAgICAgICAgIC8vIENsb3NlIGZyYW1lLCB0aGUgZW5kcG9pbnQgTVVTVCBzZW5kIGEgQ2xvc2UgZnJhbWUgaW4gcmVzcG9uc2UuICAoV2hlblxuICAgICAgICAgICAgLy8gc2VuZGluZyBhIENsb3NlIGZyYW1lIGluIHJlc3BvbnNlLCB0aGUgZW5kcG9pbnQgdHlwaWNhbGx5IGVjaG9zIHRoZVxuICAgICAgICAgICAgLy8gc3RhdHVzIGNvZGUgaXQgcmVjZWl2ZWQuKVxuICAgICAgICAgICAgY29uc3QgYm9keSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKVxuICAgICAgICAgICAgYm9keS53cml0ZVVJbnQxNkJFKHRoaXMuI2luZm8uY2xvc2VJbmZvLmNvZGUsIDApXG4gICAgICAgICAgICBjb25zdCBjbG9zZUZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZChib2R5KVxuXG4gICAgICAgICAgICB0aGlzLndzW2tSZXNwb25zZV0uc29ja2V0LndyaXRlKFxuICAgICAgICAgICAgICBjbG9zZUZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuQ0xPU0UpLFxuICAgICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMud3Nba1NlbnRDbG9zZV0gPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gICAgICAgICAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgICAgICAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgICAgICAgICB0aGlzLndzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TSU5HXG4gICAgICAgICAgdGhpcy53c1trUmVjZWl2ZWRDbG9zZV0gPSB0cnVlXG5cbiAgICAgICAgICB0aGlzLmVuZCgpXG5cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5QSU5HKSB7XG4gICAgICAgICAgLy8gVXBvbiByZWNlaXB0IG9mIGEgUGluZyBmcmFtZSwgYW4gZW5kcG9pbnQgTVVTVCBzZW5kIGEgUG9uZyBmcmFtZSBpblxuICAgICAgICAgIC8vIHJlc3BvbnNlLCB1bmxlc3MgaXQgYWxyZWFkeSByZWNlaXZlZCBhIENsb3NlIGZyYW1lLlxuICAgICAgICAgIC8vIEEgUG9uZyBmcmFtZSBzZW50IGluIHJlc3BvbnNlIHRvIGEgUGluZyBmcmFtZSBtdXN0IGhhdmUgaWRlbnRpY2FsXG4gICAgICAgICAgLy8gXCJBcHBsaWNhdGlvbiBkYXRhXCJcblxuICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmNvbnN1bWUocGF5bG9hZExlbmd0aClcblxuICAgICAgICAgIGlmICghdGhpcy53c1trUmVjZWl2ZWRDbG9zZV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZChib2R5KVxuXG4gICAgICAgICAgICB0aGlzLndzW2tSZXNwb25zZV0uc29ja2V0LndyaXRlKGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuUE9ORykpXG5cbiAgICAgICAgICAgIGlmIChjaGFubmVscy5waW5nLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICAgIGNoYW5uZWxzLnBpbmcucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogYm9keVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cblxuICAgICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuI2luZm8ub3Bjb2RlID09PSBvcGNvZGVzLlBPTkcpIHtcbiAgICAgICAgICAvLyBBIFBvbmcgZnJhbWUgTUFZIGJlIHNlbnQgdW5zb2xpY2l0ZWQuICBUaGlzIHNlcnZlcyBhcyBhXG4gICAgICAgICAgLy8gdW5pZGlyZWN0aW9uYWwgaGVhcnRiZWF0LiAgQSByZXNwb25zZSB0byBhbiB1bnNvbGljaXRlZCBQb25nIGZyYW1lIGlzXG4gICAgICAgICAgLy8gbm90IGV4cGVjdGVkLlxuXG4gICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuY29uc3VtZShwYXlsb2FkTGVuZ3RoKVxuXG4gICAgICAgICAgaWYgKGNoYW5uZWxzLnBvbmcuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgIGNoYW5uZWxzLnBvbmcucHVibGlzaCh7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IGJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzE2KSB7XG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgMikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNvbnN1bWUoMilcblxuICAgICAgICB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGggPSBidWZmZXIucmVhZFVJbnQxNkJFKDApXG4gICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlJFQURfREFUQVxuICAgICAgfSBlbHNlIGlmICh0aGlzLiNzdGF0ZSA9PT0gcGFyc2VyU3RhdGVzLlBBWUxPQURMRU5HVEhfNjQpIHtcbiAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPCA4KSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuY29uc3VtZSg4KVxuICAgICAgICBjb25zdCB1cHBlciA9IGJ1ZmZlci5yZWFkVUludDMyQkUoMClcblxuICAgICAgICAvLyAyXjMxIGlzIHRoZSBtYXhpbmltdW0gYnl0ZXMgYW4gYXJyYXlidWZmZXIgY2FuIGNvbnRhaW5cbiAgICAgICAgLy8gb24gMzItYml0IHN5c3RlbXMuIEFsdGhvdWdoLCBvbiA2NC1iaXQgc3lzdGVtcywgdGhpcyBpc1xuICAgICAgICAvLyAyXjUzLTEgYnl0ZXMuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycy9JbnZhbGlkX2FycmF5X2xlbmd0aFxuICAgICAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp2OC9zcmMvY29tbW9uL2dsb2JhbHMuaDtkcmM9MTk0NjIxMmFjMDEwMDY2OGYxNGViOWUyODQzYmRkODQ2ZTUxMGExZTticHY9MTticHQ9MTtsPTEyNzVcbiAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46djgvc3JjL29iamVjdHMvanMtYXJyYXktYnVmZmVyLmg7bD0zNDtkcmM9MTk0NjIxMmFjMDEwMDY2OGYxNGViOWUyODQzYmRkODQ2ZTUxMGExZVxuICAgICAgICBpZiAodXBwZXIgPiAyICoqIDMxIC0gMSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdSZWNlaXZlZCBwYXlsb2FkIGxlbmd0aCA+IDJeMzEgYnl0ZXMuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvd2VyID0gYnVmZmVyLnJlYWRVSW50MzJCRSg0KVxuXG4gICAgICAgIHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCA9ICh1cHBlciA8PCA4KSArIGxvd2VyXG4gICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlJFQURfREFUQVxuICAgICAgfSBlbHNlIGlmICh0aGlzLiNzdGF0ZSA9PT0gcGFyc2VyU3RhdGVzLlJFQURfREFUQSkge1xuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIHN0aWxsIG1vcmUgZGF0YSBpbiB0aGlzIGNodW5rIHRoYXQgbmVlZHMgdG8gYmUgcmVhZFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy4jYnl0ZU9mZnNldCA+PSB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIHNlbnQgbXVsdGlwbGUgZnJhbWVzIGluIGEgc2luZ2xlIGNodW5rXG5cbiAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5jb25zdW1lKHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aClcblxuICAgICAgICAgIHRoaXMuI2ZyYWdtZW50cy5wdXNoKGJvZHkpXG5cbiAgICAgICAgICAvLyBJZiB0aGUgZnJhbWUgaXMgdW5mcmFnbWVudGVkLCBvciBhIGZyYWdtZW50ZWQgZnJhbWUgd2FzIHRlcm1pbmF0ZWQsXG4gICAgICAgICAgLy8gYSBtZXNzYWdlIHdhcyByZWNlaXZlZFxuICAgICAgICAgIGlmICghdGhpcy4jaW5mby5mcmFnbWVudGVkIHx8ICh0aGlzLiNpbmZvLmZpbiAmJiB0aGlzLiNpbmZvLm9wY29kZSA9PT0gb3Bjb2Rlcy5DT05USU5VQVRJT04pKSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IEJ1ZmZlci5jb25jYXQodGhpcy4jZnJhZ21lbnRzKVxuXG4gICAgICAgICAgICB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQodGhpcy53cywgdGhpcy4jaW5mby5vcmlnaW5hbE9wY29kZSwgZnVsbE1lc3NhZ2UpXG5cbiAgICAgICAgICAgIHRoaXMuI2luZm8gPSB7fVxuICAgICAgICAgICAgdGhpcy4jZnJhZ21lbnRzLmxlbmd0aCA9IDBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPiAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2UgbiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBCdWZmZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ8bnVsbH1cbiAgICovXG4gIGNvbnN1bWUgKG4pIHtcbiAgICBpZiAobiA+IHRoaXMuI2J5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm4gZW1wdHlCdWZmZXJcbiAgICB9XG5cbiAgICBpZiAodGhpcy4jYnVmZmVyc1swXS5sZW5ndGggPT09IG4pIHtcbiAgICAgIHRoaXMuI2J5dGVPZmZzZXQgLT0gdGhpcy4jYnVmZmVyc1swXS5sZW5ndGhcbiAgICAgIHJldHVybiB0aGlzLiNidWZmZXJzLnNoaWZ0KClcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobilcbiAgICBsZXQgb2Zmc2V0ID0gMFxuXG4gICAgd2hpbGUgKG9mZnNldCAhPT0gbikge1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMuI2J1ZmZlcnNbMF1cbiAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBuZXh0XG5cbiAgICAgIGlmIChsZW5ndGggKyBvZmZzZXQgPT09IG4pIHtcbiAgICAgICAgYnVmZmVyLnNldCh0aGlzLiNidWZmZXJzLnNoaWZ0KCksIG9mZnNldClcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoICsgb2Zmc2V0ID4gbikge1xuICAgICAgICBidWZmZXIuc2V0KG5leHQuc3ViYXJyYXkoMCwgbiAtIG9mZnNldCksIG9mZnNldClcbiAgICAgICAgdGhpcy4jYnVmZmVyc1swXSA9IG5leHQuc3ViYXJyYXkobiAtIG9mZnNldClcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5zZXQodGhpcy4jYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBuZXh0Lmxlbmd0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuI2J5dGVPZmZzZXQgLT0gblxuXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgcGFyc2VDbG9zZUJvZHkgKG9ubHlDb2RlLCBkYXRhKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy4xLjVcbiAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgbGV0IGNvZGVcblxuICAgIGlmIChkYXRhLmxlbmd0aCA+PSAyKSB7XG4gICAgICAvLyBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIENsb3NlIENvZGVfIGlzXG4gICAgICAvLyBkZWZpbmVkIGFzIHRoZSBzdGF0dXMgY29kZSAoU2VjdGlvbiA3LjQpIGNvbnRhaW5lZCBpbiB0aGUgZmlyc3QgQ2xvc2VcbiAgICAgIC8vIGNvbnRyb2wgZnJhbWUgcmVjZWl2ZWQgYnkgdGhlIGFwcGxpY2F0aW9uXG4gICAgICBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMClcbiAgICB9XG5cbiAgICBpZiAob25seUNvZGUpIHtcbiAgICAgIGlmICghaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgY29kZSB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy4xLjZcbiAgICAvKiogQHR5cGUge0J1ZmZlcn0gKi9cbiAgICBsZXQgcmVhc29uID0gZGF0YS5zdWJhcnJheSgyKVxuXG4gICAgLy8gUmVtb3ZlIEJPTVxuICAgIGlmIChyZWFzb25bMF0gPT09IDB4RUYgJiYgcmVhc29uWzFdID09PSAweEJCICYmIHJlYXNvblsyXSA9PT0gMHhCRikge1xuICAgICAgcmVhc29uID0gcmVhc29uLnN1YmFycmF5KDMpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCAmJiAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRPRE86IG9wdGltaXplIHRoaXNcbiAgICAgIHJlYXNvbiA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiB0cnVlIH0pLmRlY29kZShyZWFzb24pXG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiB7IGNvZGUsIHJlYXNvbiB9XG4gIH1cblxuICBnZXQgY2xvc2luZ0luZm8gKCkge1xuICAgIHJldHVybiB0aGlzLiNpbmZvLmNsb3NlSW5mb1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCeXRlUGFyc2VyXG59XG4iXSwibmFtZXMiOlsiV3JpdGFibGUiLCJyZXF1aXJlIiwiZGlhZ25vc3RpY3NDaGFubmVsIiwicGFyc2VyU3RhdGVzIiwib3Bjb2RlcyIsInN0YXRlcyIsImVtcHR5QnVmZmVyIiwia1JlYWR5U3RhdGUiLCJrU2VudENsb3NlIiwia1Jlc3BvbnNlIiwia1JlY2VpdmVkQ2xvc2UiLCJpc1ZhbGlkU3RhdHVzQ29kZSIsImZhaWxXZWJzb2NrZXRDb25uZWN0aW9uIiwid2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkIiwiV2Vic29ja2V0RnJhbWVTZW5kIiwiY2hhbm5lbHMiLCJwaW5nIiwiY2hhbm5lbCIsInBvbmciLCJCeXRlUGFyc2VyIiwiYnVmZmVycyIsImJ5dGVPZmZzZXQiLCJzdGF0ZSIsImluZm8iLCJmcmFnbWVudHMiLCJjb25zdHJ1Y3RvciIsIndzIiwiSU5GTyIsIl93cml0ZSIsImNodW5rIiwiXyIsImNhbGxiYWNrIiwicHVzaCIsImxlbmd0aCIsInJ1biIsImJ1ZmZlciIsImNvbnN1bWUiLCJmaW4iLCJvcGNvZGUiLCJvcmlnaW5hbE9wY29kZSIsImZyYWdtZW50ZWQiLCJDT05USU5VQVRJT04iLCJCSU5BUlkiLCJURVhUIiwicGF5bG9hZExlbmd0aCIsIlJFQURfREFUQSIsIlBBWUxPQURMRU5HVEhfMTYiLCJQQVlMT0FETEVOR1RIXzY0IiwiUElORyIsIlBPTkciLCJDTE9TRSIsImJvZHkiLCJjbG9zZUluZm8iLCJwYXJzZUNsb3NlQm9keSIsIkJ1ZmZlciIsImFsbG9jVW5zYWZlIiwid3JpdGVVSW50MTZCRSIsImNvZGUiLCJjbG9zZUZyYW1lIiwic29ja2V0Iiwid3JpdGUiLCJjcmVhdGVGcmFtZSIsImVyciIsIkNMT1NJTkciLCJlbmQiLCJmcmFtZSIsImhhc1N1YnNjcmliZXJzIiwicHVibGlzaCIsInBheWxvYWQiLCJyZWFkVUludDE2QkUiLCJ1cHBlciIsInJlYWRVSW50MzJCRSIsImxvd2VyIiwiZnVsbE1lc3NhZ2UiLCJjb25jYXQiLCJuIiwic2hpZnQiLCJvZmZzZXQiLCJuZXh0Iiwic2V0Iiwic3ViYXJyYXkiLCJvbmx5Q29kZSIsImRhdGEiLCJyZWFzb24iLCJ1bmRlZmluZWQiLCJUZXh0RGVjb2RlciIsImZhdGFsIiwiZGVjb2RlIiwiY2xvc2luZ0luZm8iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/websocket/receiver.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/websocket/symbols.js":
/*!**********************************************************!*\
  !*** ../../node_modules/undici/lib/websocket/symbols.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    kWebSocketURL: Symbol(\"url\"),\n    kReadyState: Symbol(\"ready state\"),\n    kController: Symbol(\"controller\"),\n    kResponse: Symbol(\"response\"),\n    kBinaryType: Symbol(\"binary type\"),\n    kSentClose: Symbol(\"sent close\"),\n    kReceivedClose: Symbol(\"received close\"),\n    kByteParser: Symbol(\"byte parser\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZDLGVBQWVDLE9BQU87SUFDdEJDLGFBQWFELE9BQU87SUFDcEJFLGFBQWFGLE9BQU87SUFDcEJHLFdBQVdILE9BQU87SUFDbEJJLGFBQWFKLE9BQU87SUFDcEJLLFlBQVlMLE9BQU87SUFDbkJNLGdCQUFnQk4sT0FBTztJQUN2Qk8sYUFBYVAsT0FBTztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3N5bWJvbHMuanM/ZTQ2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtXZWJTb2NrZXRVUkw6IFN5bWJvbCgndXJsJyksXG4gIGtSZWFkeVN0YXRlOiBTeW1ib2woJ3JlYWR5IHN0YXRlJyksXG4gIGtDb250cm9sbGVyOiBTeW1ib2woJ2NvbnRyb2xsZXInKSxcbiAga1Jlc3BvbnNlOiBTeW1ib2woJ3Jlc3BvbnNlJyksXG4gIGtCaW5hcnlUeXBlOiBTeW1ib2woJ2JpbmFyeSB0eXBlJyksXG4gIGtTZW50Q2xvc2U6IFN5bWJvbCgnc2VudCBjbG9zZScpLFxuICBrUmVjZWl2ZWRDbG9zZTogU3ltYm9sKCdyZWNlaXZlZCBjbG9zZScpLFxuICBrQnl0ZVBhcnNlcjogU3ltYm9sKCdieXRlIHBhcnNlcicpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtXZWJTb2NrZXRVUkwiLCJTeW1ib2wiLCJrUmVhZHlTdGF0ZSIsImtDb250cm9sbGVyIiwia1Jlc3BvbnNlIiwia0JpbmFyeVR5cGUiLCJrU2VudENsb3NlIiwia1JlY2VpdmVkQ2xvc2UiLCJrQnl0ZVBhcnNlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/websocket/symbols.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/websocket/util.js":
/*!*******************************************************!*\
  !*** ../../node_modules/undici/lib/websocket/util.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/websocket/symbols.js\");\nconst { states, opcodes } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/undici/lib/websocket/constants.js\");\nconst { MessageEvent, ErrorEvent } = __webpack_require__(/*! ./events */ \"(rsc)/../../node_modules/undici/lib/websocket/events.js\");\n/* globals Blob */ /**\n * @param {import('./websocket').WebSocket} ws\n */ function isEstablished(ws) {\n    // If the server's response is validated as provided for above, it is\n    // said that _The WebSocket Connection is Established_ and that the\n    // WebSocket Connection is in the OPEN state.\n    return ws[kReadyState] === states.OPEN;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n */ function isClosing(ws) {\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    return ws[kReadyState] === states.CLOSING;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n */ function isClosed(ws) {\n    return ws[kReadyState] === states.CLOSED;\n}\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {EventInit | undefined} eventInitDict\n */ function fireEvent(e, target, eventConstructor = Event, eventInitDict) {\n    // 1. If eventConstructor is not given, then let eventConstructor be Event.\n    // 2. Let event be the result of creating an event given eventConstructor,\n    //    in the relevant realm of target.\n    // 3. Initialize events type attribute to e.\n    const event = new eventConstructor(e, eventInitDict) // eslint-disable-line new-cap\n    ;\n    // 4. Initialize any other IDL attributes of event as described in the\n    //    invocation of this algorithm.\n    // 5. Return the result of dispatching event at target, with legacy target\n    //    override flag set if set.\n    target.dispatchEvent(event);\n}\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */ function websocketMessageReceived(ws, type, data) {\n    // 1. If ready state is not OPEN (1), then return.\n    if (ws[kReadyState] !== states.OPEN) {\n        return;\n    }\n    // 2. Let dataForEvent be determined by switching on type and binary type:\n    let dataForEvent;\n    if (type === opcodes.TEXT) {\n        // -> type indicates that the data is Text\n        //      a new DOMString containing data\n        try {\n            dataForEvent = new TextDecoder(\"utf-8\", {\n                fatal: true\n            }).decode(data);\n        } catch  {\n            failWebsocketConnection(ws, \"Received invalid UTF-8 in text frame.\");\n            return;\n        }\n    } else if (type === opcodes.BINARY) {\n        if (ws[kBinaryType] === \"blob\") {\n            // -> type indicates that the data is Binary and binary type is \"blob\"\n            //      a new Blob object, created in the relevant Realm of the WebSocket\n            //      object, that represents data as its raw data\n            dataForEvent = new Blob([\n                data\n            ]);\n        } else {\n            // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n            //      a new ArrayBuffer object, created in the relevant Realm of the\n            //      WebSocket object, whose contents are data\n            dataForEvent = new Uint8Array(data).buffer;\n        }\n    }\n    // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n    //    with the origin attribute initialized to the serialization of the WebSocket\n    //    objects url's origin, and the data attribute initialized to dataForEvent.\n    fireEvent(\"message\", ws, MessageEvent, {\n        origin: ws[kWebSocketURL].origin,\n        data: dataForEvent\n    });\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */ function isValidSubprotocol(protocol) {\n    // If present, this value indicates one\n    // or more comma-separated subprotocol the client wishes to speak,\n    // ordered by preference.  The elements that comprise this value\n    // MUST be non-empty strings with characters in the range U+0021 to\n    // U+007E not including separator characters as defined in\n    // [RFC2616] and MUST all be unique strings.\n    if (protocol.length === 0) {\n        return false;\n    }\n    for (const char of protocol){\n        const code = char.charCodeAt(0);\n        if (code < 0x21 || code > 0x7E || char === \"(\" || char === \")\" || char === \"<\" || char === \">\" || char === \"@\" || char === \",\" || char === \";\" || char === \":\" || char === \"\\\\\" || char === '\"' || char === \"/\" || char === \"[\" || char === \"]\" || char === \"?\" || char === \"=\" || char === \"{\" || char === \"}\" || code === 32 || // SP\n        code === 9 // HT\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */ function isValidStatusCode(code) {\n    if (code >= 1000 && code < 1015) {\n        return code !== 1004 && // reserved\n        code !== 1005 && // \"MUST NOT be set as a status code\"\n        code !== 1006 // \"MUST NOT be set as a status code\"\n        ;\n    }\n    return code >= 3000 && code <= 4999;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */ function failWebsocketConnection(ws, reason) {\n    const { [kController]: controller, [kResponse]: response } = ws;\n    controller.abort();\n    if (response?.socket && !response.socket.destroyed) {\n        response.socket.destroy();\n    }\n    if (reason) {\n        fireEvent(\"error\", ws, ErrorEvent, {\n            error: new Error(reason)\n        });\n    }\n}\nmodule.exports = {\n    isEstablished,\n    isClosing,\n    isClosed,\n    fireEvent,\n    isValidSubprotocol,\n    isValidStatusCode,\n    failWebsocketConnection,\n    websocketMessageReceived\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsYUFBYSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3BGLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDcEMsTUFBTSxFQUFFRyxZQUFZLEVBQUVDLFVBQVUsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUU3QyxnQkFBZ0IsR0FFaEI7O0NBRUMsR0FDRCxTQUFTSyxjQUFlQyxFQUFFO0lBQ3hCLHFFQUFxRTtJQUNyRSxtRUFBbUU7SUFDbkUsNkNBQTZDO0lBQzdDLE9BQU9BLEVBQUUsQ0FBQ1gsWUFBWSxLQUFLTSxPQUFPTSxJQUFJO0FBQ3hDO0FBRUE7O0NBRUMsR0FDRCxTQUFTQyxVQUFXRixFQUFFO0lBQ3BCLHFFQUFxRTtJQUNyRSxpRUFBaUU7SUFDakUsZ0RBQWdEO0lBQ2hELE9BQU9BLEVBQUUsQ0FBQ1gsWUFBWSxLQUFLTSxPQUFPUSxPQUFPO0FBQzNDO0FBRUE7O0NBRUMsR0FDRCxTQUFTQyxTQUFVSixFQUFFO0lBQ25CLE9BQU9BLEVBQUUsQ0FBQ1gsWUFBWSxLQUFLTSxPQUFPVSxNQUFNO0FBQzFDO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTQyxVQUFXQyxDQUFDLEVBQUVDLE1BQU0sRUFBRUMsbUJBQW1CQyxLQUFLLEVBQUVDLGFBQWE7SUFDcEUsMkVBQTJFO0lBRTNFLDBFQUEwRTtJQUMxRSxzQ0FBc0M7SUFDdEMsNkNBQTZDO0lBQzdDLE1BQU1DLFFBQVEsSUFBSUgsaUJBQWlCRixHQUFHSSxlQUFlLDhCQUE4Qjs7SUFFbkYsc0VBQXNFO0lBQ3RFLG1DQUFtQztJQUVuQywwRUFBMEU7SUFDMUUsK0JBQStCO0lBQy9CSCxPQUFPSyxhQUFhLENBQUNEO0FBQ3ZCO0FB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QUU7SUFDQXNCO0lBQ0FNO0lBQ0FaO0lBQ0FSO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYnNvY2tldC91dGlsLmpzPzA5N2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga1JlYWR5U3RhdGUsIGtDb250cm9sbGVyLCBrUmVzcG9uc2UsIGtCaW5hcnlUeXBlLCBrV2ViU29ja2V0VVJMIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBzdGF0ZXMsIG9wY29kZXMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgTWVzc2FnZUV2ZW50LCBFcnJvckV2ZW50IH0gPSByZXF1aXJlKCcuL2V2ZW50cycpXG5cbi8qIGdsb2JhbHMgQmxvYiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqL1xuZnVuY3Rpb24gaXNFc3RhYmxpc2hlZCAod3MpIHtcbiAgLy8gSWYgdGhlIHNlcnZlcidzIHJlc3BvbnNlIGlzIHZhbGlkYXRlZCBhcyBwcm92aWRlZCBmb3IgYWJvdmUsIGl0IGlzXG4gIC8vIHNhaWQgdGhhdCBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIGlzIEVzdGFibGlzaGVkXyBhbmQgdGhhdCB0aGVcbiAgLy8gV2ViU29ja2V0IENvbm5lY3Rpb24gaXMgaW4gdGhlIE9QRU4gc3RhdGUuXG4gIHJldHVybiB3c1trUmVhZHlTdGF0ZV0gPT09IHN0YXRlcy5PUEVOXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICovXG5mdW5jdGlvbiBpc0Nsb3NpbmcgKHdzKSB7XG4gIC8vIFVwb24gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIGEgQ2xvc2UgY29udHJvbCBmcmFtZSwgaXQgaXMgc2FpZFxuICAvLyB0aGF0IF9UaGUgV2ViU29ja2V0IENsb3NpbmcgSGFuZHNoYWtlIGlzIFN0YXJ0ZWRfIGFuZCB0aGF0IHRoZVxuICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgcmV0dXJuIHdzW2tSZWFkeVN0YXRlXSA9PT0gc3RhdGVzLkNMT1NJTkdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKi9cbmZ1bmN0aW9uIGlzQ2xvc2VkICh3cykge1xuICByZXR1cm4gd3Nba1JlYWR5U3RhdGVdID09PSBzdGF0ZXMuQ0xPU0VEXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZXZlbnQtZmlyZVxuICogQHBhcmFtIHtzdHJpbmd9IGVcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtFdmVudEluaXQgfCB1bmRlZmluZWR9IGV2ZW50SW5pdERpY3RcbiAqL1xuZnVuY3Rpb24gZmlyZUV2ZW50IChlLCB0YXJnZXQsIGV2ZW50Q29uc3RydWN0b3IgPSBFdmVudCwgZXZlbnRJbml0RGljdCkge1xuICAvLyAxLiBJZiBldmVudENvbnN0cnVjdG9yIGlzIG5vdCBnaXZlbiwgdGhlbiBsZXQgZXZlbnRDb25zdHJ1Y3RvciBiZSBFdmVudC5cblxuICAvLyAyLiBMZXQgZXZlbnQgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBldmVudCBnaXZlbiBldmVudENvbnN0cnVjdG9yLFxuICAvLyAgICBpbiB0aGUgcmVsZXZhbnQgcmVhbG0gb2YgdGFyZ2V0LlxuICAvLyAzLiBJbml0aWFsaXplIGV2ZW504oCZcyB0eXBlIGF0dHJpYnV0ZSB0byBlLlxuICBjb25zdCBldmVudCA9IG5ldyBldmVudENvbnN0cnVjdG9yKGUsIGV2ZW50SW5pdERpY3QpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXG4gIC8vIDQuIEluaXRpYWxpemUgYW55IG90aGVyIElETCBhdHRyaWJ1dGVzIG9mIGV2ZW50IGFzIGRlc2NyaWJlZCBpbiB0aGVcbiAgLy8gICAgaW52b2NhdGlvbiBvZiB0aGlzIGFsZ29yaXRobS5cblxuICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBkaXNwYXRjaGluZyBldmVudCBhdCB0YXJnZXQsIHdpdGggbGVnYWN5IHRhcmdldFxuICAvLyAgICBvdmVycmlkZSBmbGFnIHNldCBpZiBzZXQuXG4gIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZmVlZGJhY2stZnJvbS10aGUtcHJvdG9jb2xcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIE9wY29kZVxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgYXBwbGljYXRpb24gZGF0YVxuICovXG5mdW5jdGlvbiB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQgKHdzLCB0eXBlLCBkYXRhKSB7XG4gIC8vIDEuIElmIHJlYWR5IHN0YXRlIGlzIG5vdCBPUEVOICgxKSwgdGhlbiByZXR1cm4uXG4gIGlmICh3c1trUmVhZHlTdGF0ZV0gIT09IHN0YXRlcy5PUEVOKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyAyLiBMZXQgZGF0YUZvckV2ZW50IGJlIGRldGVybWluZWQgYnkgc3dpdGNoaW5nIG9uIHR5cGUgYW5kIGJpbmFyeSB0eXBlOlxuICBsZXQgZGF0YUZvckV2ZW50XG5cbiAgaWYgKHR5cGUgPT09IG9wY29kZXMuVEVYVCkge1xuICAgIC8vIC0+IHR5cGUgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgVGV4dFxuICAgIC8vICAgICAgYSBuZXcgRE9NU3RyaW5nIGNvbnRhaW5pbmcgZGF0YVxuICAgIHRyeSB7XG4gICAgICBkYXRhRm9yRXZlbnQgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBmYXRhbDogdHJ1ZSB9KS5kZWNvZGUoZGF0YSlcbiAgICB9IGNhdGNoIHtcbiAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnUmVjZWl2ZWQgaW52YWxpZCBVVEYtOCBpbiB0ZXh0IGZyYW1lLicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gb3Bjb2Rlcy5CSU5BUlkpIHtcbiAgICBpZiAod3Nba0JpbmFyeVR5cGVdID09PSAnYmxvYicpIHtcbiAgICAgIC8vIC0+IHR5cGUgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgQmluYXJ5IGFuZCBiaW5hcnkgdHlwZSBpcyBcImJsb2JcIlxuICAgICAgLy8gICAgICBhIG5ldyBCbG9iIG9iamVjdCwgY3JlYXRlZCBpbiB0aGUgcmVsZXZhbnQgUmVhbG0gb2YgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gICAgICBvYmplY3QsIHRoYXQgcmVwcmVzZW50cyBkYXRhIGFzIGl0cyByYXcgZGF0YVxuICAgICAgZGF0YUZvckV2ZW50ID0gbmV3IEJsb2IoW2RhdGFdKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAtPiB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIEJpbmFyeSBhbmQgYmluYXJ5IHR5cGUgaXMgXCJhcnJheWJ1ZmZlclwiXG4gICAgICAvLyAgICAgIGEgbmV3IEFycmF5QnVmZmVyIG9iamVjdCwgY3JlYXRlZCBpbiB0aGUgcmVsZXZhbnQgUmVhbG0gb2YgdGhlXG4gICAgICAvLyAgICAgIFdlYlNvY2tldCBvYmplY3QsIHdob3NlIGNvbnRlbnRzIGFyZSBkYXRhXG4gICAgICBkYXRhRm9yRXZlbnQgPSBuZXcgVWludDhBcnJheShkYXRhKS5idWZmZXJcbiAgICB9XG4gIH1cblxuICAvLyAzLiBGaXJlIGFuIGV2ZW50IG5hbWVkIG1lc3NhZ2UgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QsIHVzaW5nIE1lc3NhZ2VFdmVudCxcbiAgLy8gICAgd2l0aCB0aGUgb3JpZ2luIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0byB0aGUgc2VyaWFsaXphdGlvbiBvZiB0aGUgV2ViU29ja2V0XG4gIC8vICAgIG9iamVjdOKAmXMgdXJsJ3Mgb3JpZ2luLCBhbmQgdGhlIGRhdGEgYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIGRhdGFGb3JFdmVudC5cbiAgZmlyZUV2ZW50KCdtZXNzYWdlJywgd3MsIE1lc3NhZ2VFdmVudCwge1xuICAgIG9yaWdpbjogd3Nba1dlYlNvY2tldFVSTF0ub3JpZ2luLFxuICAgIGRhdGE6IGRhdGFGb3JFdmVudFxuICB9KVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1XG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMjYxNlxuICogQHNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zOTg0MDdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3VicHJvdG9jb2wgKHByb3RvY29sKSB7XG4gIC8vIElmIHByZXNlbnQsIHRoaXMgdmFsdWUgaW5kaWNhdGVzIG9uZVxuICAvLyBvciBtb3JlIGNvbW1hLXNlcGFyYXRlZCBzdWJwcm90b2NvbCB0aGUgY2xpZW50IHdpc2hlcyB0byBzcGVhayxcbiAgLy8gb3JkZXJlZCBieSBwcmVmZXJlbmNlLiAgVGhlIGVsZW1lbnRzIHRoYXQgY29tcHJpc2UgdGhpcyB2YWx1ZVxuICAvLyBNVVNUIGJlIG5vbi1lbXB0eSBzdHJpbmdzIHdpdGggY2hhcmFjdGVycyBpbiB0aGUgcmFuZ2UgVSswMDIxIHRvXG4gIC8vIFUrMDA3RSBub3QgaW5jbHVkaW5nIHNlcGFyYXRvciBjaGFyYWN0ZXJzIGFzIGRlZmluZWQgaW5cbiAgLy8gW1JGQzI2MTZdIGFuZCBNVVNUIGFsbCBiZSB1bmlxdWUgc3RyaW5ncy5cbiAgaWYgKHByb3RvY29sLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjaGFyIG9mIHByb3RvY29sKSB7XG4gICAgY29uc3QgY29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA8IDB4MjEgfHxcbiAgICAgIGNvZGUgPiAweDdFIHx8XG4gICAgICBjaGFyID09PSAnKCcgfHxcbiAgICAgIGNoYXIgPT09ICcpJyB8fFxuICAgICAgY2hhciA9PT0gJzwnIHx8XG4gICAgICBjaGFyID09PSAnPicgfHxcbiAgICAgIGNoYXIgPT09ICdAJyB8fFxuICAgICAgY2hhciA9PT0gJywnIHx8XG4gICAgICBjaGFyID09PSAnOycgfHxcbiAgICAgIGNoYXIgPT09ICc6JyB8fFxuICAgICAgY2hhciA9PT0gJ1xcXFwnIHx8XG4gICAgICBjaGFyID09PSAnXCInIHx8XG4gICAgICBjaGFyID09PSAnLycgfHxcbiAgICAgIGNoYXIgPT09ICdbJyB8fFxuICAgICAgY2hhciA9PT0gJ10nIHx8XG4gICAgICBjaGFyID09PSAnPycgfHxcbiAgICAgIGNoYXIgPT09ICc9JyB8fFxuICAgICAgY2hhciA9PT0gJ3snIHx8XG4gICAgICBjaGFyID09PSAnfScgfHxcbiAgICAgIGNvZGUgPT09IDMyIHx8IC8vIFNQXG4gICAgICBjb2RlID09PSA5IC8vIEhUXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy00XG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZSAoY29kZSkge1xuICBpZiAoY29kZSA+PSAxMDAwICYmIGNvZGUgPCAxMDE1KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNvZGUgIT09IDEwMDQgJiYgLy8gcmVzZXJ2ZWRcbiAgICAgIGNvZGUgIT09IDEwMDUgJiYgLy8gXCJNVVNUIE5PVCBiZSBzZXQgYXMgYSBzdGF0dXMgY29kZVwiXG4gICAgICBjb2RlICE9PSAxMDA2IC8vIFwiTVVTVCBOT1QgYmUgc2V0IGFzIGEgc3RhdHVzIGNvZGVcIlxuICAgIClcbiAgfVxuXG4gIHJldHVybiBjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSByZWFzb25cbiAqL1xuZnVuY3Rpb24gZmFpbFdlYnNvY2tldENvbm5lY3Rpb24gKHdzLCByZWFzb24pIHtcbiAgY29uc3QgeyBba0NvbnRyb2xsZXJdOiBjb250cm9sbGVyLCBba1Jlc3BvbnNlXTogcmVzcG9uc2UgfSA9IHdzXG5cbiAgY29udHJvbGxlci5hYm9ydCgpXG5cbiAgaWYgKHJlc3BvbnNlPy5zb2NrZXQgJiYgIXJlc3BvbnNlLnNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICByZXNwb25zZS5zb2NrZXQuZGVzdHJveSgpXG4gIH1cblxuICBpZiAocmVhc29uKSB7XG4gICAgZmlyZUV2ZW50KCdlcnJvcicsIHdzLCBFcnJvckV2ZW50LCB7XG4gICAgICBlcnJvcjogbmV3IEVycm9yKHJlYXNvbilcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0VzdGFibGlzaGVkLFxuICBpc0Nsb3NpbmcsXG4gIGlzQ2xvc2VkLFxuICBmaXJlRXZlbnQsXG4gIGlzVmFsaWRTdWJwcm90b2NvbCxcbiAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uLFxuICB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWRcbn1cbiJdLCJuYW1lcyI6WyJrUmVhZHlTdGF0ZSIsImtDb250cm9sbGVyIiwia1Jlc3BvbnNlIiwia0JpbmFyeVR5cGUiLCJrV2ViU29ja2V0VVJMIiwicmVxdWlyZSIsInN0YXRlcyIsIm9wY29kZXMiLCJNZXNzYWdlRXZlbnQiLCJFcnJvckV2ZW50IiwiaXNFc3RhYmxpc2hlZCIsIndzIiwiT1BFTiIsImlzQ2xvc2luZyIsIkNMT1NJTkciLCJpc0Nsb3NlZCIsIkNMT1NFRCIsImZpcmVFdmVudCIsImUiLCJ0YXJnZXQiLCJldmVudENvbnN0cnVjdG9yIiwiRXZlbnQiLCJldmVudEluaXREaWN0IiwiZXZlbnQiLCJkaXNwYXRjaEV2ZW50Iiwid2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkIiwidHlwZSIsImRhdGEiLCJkYXRhRm9yRXZlbnQiLCJURVhUIiwiVGV4dERlY29kZXIiLCJmYXRhbCIsImRlY29kZSIsImZhaWxXZWJzb2NrZXRDb25uZWN0aW9uIiwiQklOQVJZIiwiQmxvYiIsIlVpbnQ4QXJyYXkiLCJidWZmZXIiLCJvcmlnaW4iLCJpc1ZhbGlkU3VicHJvdG9jb2wiLCJwcm90b2NvbCIsImxlbmd0aCIsImNoYXIiLCJjb2RlIiwiY2hhckNvZGVBdCIsImlzVmFsaWRTdGF0dXNDb2RlIiwicmVhc29uIiwiY29udHJvbGxlciIsInJlc3BvbnNlIiwiYWJvcnQiLCJzb2NrZXQiLCJkZXN0cm95ZWQiLCJkZXN0cm95IiwiZXJyb3IiLCJFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/websocket/util.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/lib/websocket/websocket.js":
/*!************************************************************!*\
  !*** ../../node_modules/undici/lib/websocket/websocket.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/../../node_modules/undici/lib/fetch/webidl.js\");\nconst { DOMException } = __webpack_require__(/*! ../fetch/constants */ \"(rsc)/../../node_modules/undici/lib/fetch/constants.js\");\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/dataURL */ \"(rsc)/../../node_modules/undici/lib/fetch/dataURL.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ../fetch/global */ \"(rsc)/../../node_modules/undici/lib/fetch/global.js\");\nconst { staticPropertyDescriptors, states, opcodes, emptyBuffer } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/undici/lib/websocket/constants.js\");\nconst { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = __webpack_require__(/*! ./symbols */ \"(rsc)/../../node_modules/undici/lib/websocket/symbols.js\");\nconst { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/undici/lib/websocket/util.js\");\nconst { establishWebSocketConnection } = __webpack_require__(/*! ./connection */ \"(rsc)/../../node_modules/undici/lib/websocket/connection.js\");\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/../../node_modules/undici/lib/websocket/frame.js\");\nconst { ByteParser } = __webpack_require__(/*! ./receiver */ \"(rsc)/../../node_modules/undici/lib/websocket/receiver.js\");\nconst { kEnumerableProperty, isBlobLike } = __webpack_require__(/*! ../core/util */ \"(rsc)/../../node_modules/undici/lib/core/util.js\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(rsc)/../../node_modules/undici/lib/global.js\");\nconst { types } = __webpack_require__(/*! util */ \"util\");\nlet experimentalWarned = false;\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n    #events;\n    #bufferedAmount;\n    #protocol;\n    #extensions;\n    /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */ constructor(url, protocols = []){\n        super();\n        this.#events = {\n            open: null,\n            error: null,\n            close: null,\n            message: null\n        };\n        this.#bufferedAmount = 0;\n        this.#protocol = \"\";\n        this.#extensions = \"\";\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"WebSocket constructor\"\n        });\n        if (!experimentalWarned) {\n            experimentalWarned = true;\n            process.emitWarning(\"WebSockets are experimental, expect them to change at any time.\", {\n                code: \"UNDICI-WS\"\n            });\n        }\n        const options = webidl.converters[\"DOMString or sequence<DOMString> or WebSocketInit\"](protocols);\n        url = webidl.converters.USVString(url);\n        protocols = options.protocols;\n        // 1. Let baseURL be this's relevant settings object's API base URL.\n        const baseURL = getGlobalOrigin();\n        // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n        let urlRecord;\n        try {\n            urlRecord = new URL(url, baseURL);\n        } catch (e) {\n            // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n            throw new DOMException(e, \"SyntaxError\");\n        }\n        // 4. If urlRecords scheme is \"http\", then set urlRecords scheme to \"ws\".\n        if (urlRecord.protocol === \"http:\") {\n            urlRecord.protocol = \"ws:\";\n        } else if (urlRecord.protocol === \"https:\") {\n            // 5. Otherwise, if urlRecords scheme is \"https\", set urlRecords scheme to \"wss\".\n            urlRecord.protocol = \"wss:\";\n        }\n        // 6. If urlRecords scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n        if (urlRecord.protocol !== \"ws:\" && urlRecord.protocol !== \"wss:\") {\n            throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, \"SyntaxError\");\n        }\n        // 7. If urlRecords fragment is non-null, then throw a \"SyntaxError\"\n        //    DOMException.\n        if (urlRecord.hash || urlRecord.href.endsWith(\"#\")) {\n            throw new DOMException(\"Got fragment\", \"SyntaxError\");\n        }\n        // 8. If protocols is a string, set protocols to a sequence consisting\n        //    of just that string.\n        if (typeof protocols === \"string\") {\n            protocols = [\n                protocols\n            ];\n        }\n        // 9. If any of the values in protocols occur more than once or otherwise\n        //    fail to match the requirements for elements that comprise the value\n        //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n        //    protocol, then throw a \"SyntaxError\" DOMException.\n        if (protocols.length !== new Set(protocols.map((p)=>p.toLowerCase())).size) {\n            throw new DOMException(\"Invalid Sec-WebSocket-Protocol value\", \"SyntaxError\");\n        }\n        if (protocols.length > 0 && !protocols.every((p)=>isValidSubprotocol(p))) {\n            throw new DOMException(\"Invalid Sec-WebSocket-Protocol value\", \"SyntaxError\");\n        }\n        // 10. Set this's url to urlRecord.\n        this[kWebSocketURL] = new URL(urlRecord.href);\n        // 11. Let client be this's relevant settings object.\n        // 12. Run this step in parallel:\n        //    1. Establish a WebSocket connection given urlRecord, protocols,\n        //       and client.\n        this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response)=>this.#onConnectionEstablished(response), options);\n        // Each WebSocket object has an associated ready state, which is a\n        // number representing the state of the connection. Initially it must\n        // be CONNECTING (0).\n        this[kReadyState] = WebSocket.CONNECTING;\n        // The extensions attribute must initially return the empty string.\n        // The protocol attribute must initially return the empty string.\n        // Each WebSocket object has an associated binary type, which is a\n        // BinaryType. Initially it must be \"blob\".\n        this[kBinaryType] = \"blob\";\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */ close(code = undefined, reason = undefined) {\n        webidl.brandCheck(this, WebSocket);\n        if (code !== undefined) {\n            code = webidl.converters[\"unsigned short\"](code, {\n                clamp: true\n            });\n        }\n        if (reason !== undefined) {\n            reason = webidl.converters.USVString(reason);\n        }\n        // 1. If code is present, but is neither an integer equal to 1000 nor an\n        //    integer in the range 3000 to 4999, inclusive, throw an\n        //    \"InvalidAccessError\" DOMException.\n        if (code !== undefined) {\n            if (code !== 1000 && (code < 3000 || code > 4999)) {\n                throw new DOMException(\"invalid code\", \"InvalidAccessError\");\n            }\n        }\n        let reasonByteLength = 0;\n        // 2. If reason is present, then run these substeps:\n        if (reason !== undefined) {\n            // 1. Let reasonBytes be the result of encoding reason.\n            // 2. If reasonBytes is longer than 123 bytes, then throw a\n            //    \"SyntaxError\" DOMException.\n            reasonByteLength = Buffer.byteLength(reason);\n            if (reasonByteLength > 123) {\n                throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, \"SyntaxError\");\n            }\n        }\n        // 3. Run the first matching steps from the following list:\n        if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {\n        // If this's ready state is CLOSING (2) or CLOSED (3)\n        // Do nothing.\n        } else if (!isEstablished(this)) {\n            // If the WebSocket connection is not yet established\n            // Fail the WebSocket connection and set this's ready state\n            // to CLOSING (2).\n            failWebsocketConnection(this, \"Connection was closed before it was established.\");\n            this[kReadyState] = WebSocket.CLOSING;\n        } else if (!isClosing(this)) {\n            // If the WebSocket closing handshake has not yet been started\n            // Start the WebSocket closing handshake and set this's ready\n            // state to CLOSING (2).\n            // - If neither code nor reason is present, the WebSocket Close\n            //   message must not have a body.\n            // - If code is present, then the status code to use in the\n            //   WebSocket Close message must be the integer given by code.\n            // - If reason is also present, then reasonBytes must be\n            //   provided in the Close message after the status code.\n            const frame = new WebsocketFrameSend();\n            // If neither code nor reason is present, the WebSocket Close\n            // message must not have a body.\n            // If code is present, then the status code to use in the\n            // WebSocket Close message must be the integer given by code.\n            if (code !== undefined && reason === undefined) {\n                frame.frameData = Buffer.allocUnsafe(2);\n                frame.frameData.writeUInt16BE(code, 0);\n            } else if (code !== undefined && reason !== undefined) {\n                // If reason is also present, then reasonBytes must be\n                // provided in the Close message after the status code.\n                frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);\n                frame.frameData.writeUInt16BE(code, 0);\n                // the body MAY contain UTF-8-encoded data with value /reason/\n                frame.frameData.write(reason, 2, \"utf-8\");\n            } else {\n                frame.frameData = emptyBuffer;\n            }\n            /** @type {import('stream').Duplex} */ const socket = this[kResponse].socket;\n            socket.write(frame.createFrame(opcodes.CLOSE), (err)=>{\n                if (!err) {\n                    this[kSentClose] = true;\n                }\n            });\n            // Upon either sending or receiving a Close control frame, it is said\n            // that _The WebSocket Closing Handshake is Started_ and that the\n            // WebSocket connection is in the CLOSING state.\n            this[kReadyState] = states.CLOSING;\n        } else {\n            // Otherwise\n            // Set this's ready state to CLOSING (2).\n            this[kReadyState] = WebSocket.CLOSING;\n        }\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */ send(data) {\n        webidl.brandCheck(this, WebSocket);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"WebSocket.send\"\n        });\n        data = webidl.converters.WebSocketSendData(data);\n        // 1. If this's ready state is CONNECTING, then throw an\n        //    \"InvalidStateError\" DOMException.\n        if (this[kReadyState] === WebSocket.CONNECTING) {\n            throw new DOMException(\"Sent before connected.\", \"InvalidStateError\");\n        }\n        // 2. Run the appropriate set of steps from the following list:\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n        if (!isEstablished(this) || isClosing(this)) {\n            return;\n        }\n        /** @type {import('stream').Duplex} */ const socket = this[kResponse].socket;\n        // If data is a string\n        if (typeof data === \"string\") {\n            // If the WebSocket connection is established and the WebSocket\n            // closing handshake has not yet started, then the user agent\n            // must send a WebSocket Message comprised of the data argument\n            // using a text frame opcode; if the data cannot be sent, e.g.\n            // because it would need to be buffered but the buffer is full,\n            // the user agent must flag the WebSocket as full and then close\n            // the WebSocket connection. Any invocation of this method with a\n            // string argument that does not throw an exception must increase\n            // the bufferedAmount attribute by the number of bytes needed to\n            // express the argument as UTF-8.\n            const value = Buffer.from(data);\n            const frame = new WebsocketFrameSend(value);\n            const buffer = frame.createFrame(opcodes.TEXT);\n            this.#bufferedAmount += value.byteLength;\n            socket.write(buffer, ()=>{\n                this.#bufferedAmount -= value.byteLength;\n            });\n        } else if (types.isArrayBuffer(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need\n            // to be buffered but the buffer is full, the user agent must flag\n            // the WebSocket as full and then close the WebSocket connection.\n            // The data to be sent is the data stored in the buffer described\n            // by the ArrayBuffer object. Any invocation of this method with an\n            // ArrayBuffer argument that does not throw an exception must\n            // increase the bufferedAmount attribute by the length of the\n            // ArrayBuffer in bytes.\n            const value = Buffer.from(data);\n            const frame = new WebsocketFrameSend(value);\n            const buffer = frame.createFrame(opcodes.BINARY);\n            this.#bufferedAmount += value.byteLength;\n            socket.write(buffer, ()=>{\n                this.#bufferedAmount -= value.byteLength;\n            });\n        } else if (ArrayBuffer.isView(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need to\n            // be buffered but the buffer is full, the user agent must flag the\n            // WebSocket as full and then close the WebSocket connection. The\n            // data to be sent is the data stored in the section of the buffer\n            // described by the ArrayBuffer object that data references. Any\n            // invocation of this method with this kind of argument that does\n            // not throw an exception must increase the bufferedAmount attribute\n            // by the length of datas buffer in bytes.\n            const ab = Buffer.from(data, data.byteOffset, data.byteLength);\n            const frame = new WebsocketFrameSend(ab);\n            const buffer = frame.createFrame(opcodes.BINARY);\n            this.#bufferedAmount += ab.byteLength;\n            socket.write(buffer, ()=>{\n                this.#bufferedAmount -= ab.byteLength;\n            });\n        } else if (isBlobLike(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need to\n            // be buffered but the buffer is full, the user agent must flag the\n            // WebSocket as full and then close the WebSocket connection. The data\n            // to be sent is the raw data represented by the Blob object. Any\n            // invocation of this method with a Blob argument that does not throw\n            // an exception must increase the bufferedAmount attribute by the size\n            // of the Blob objects raw data, in bytes.\n            const frame = new WebsocketFrameSend();\n            data.arrayBuffer().then((ab)=>{\n                const value = Buffer.from(ab);\n                frame.frameData = value;\n                const buffer = frame.createFrame(opcodes.BINARY);\n                this.#bufferedAmount += value.byteLength;\n                socket.write(buffer, ()=>{\n                    this.#bufferedAmount -= value.byteLength;\n                });\n            });\n        }\n    }\n    get readyState() {\n        webidl.brandCheck(this, WebSocket);\n        // The readyState getter steps are to return this's ready state.\n        return this[kReadyState];\n    }\n    get bufferedAmount() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#bufferedAmount;\n    }\n    get url() {\n        webidl.brandCheck(this, WebSocket);\n        // The url getter steps are to return this's url, serialized.\n        return URLSerializer(this[kWebSocketURL]);\n    }\n    get extensions() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#extensions;\n    }\n    get protocol() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#protocol;\n    }\n    get onopen() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.open;\n    }\n    set onopen(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.open) {\n            this.removeEventListener(\"open\", this.#events.open);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.open = fn;\n            this.addEventListener(\"open\", fn);\n        } else {\n            this.#events.open = null;\n        }\n    }\n    get onerror() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.error;\n    }\n    set onerror(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.error) {\n            this.removeEventListener(\"error\", this.#events.error);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.error = fn;\n            this.addEventListener(\"error\", fn);\n        } else {\n            this.#events.error = null;\n        }\n    }\n    get onclose() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.close;\n    }\n    set onclose(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.close) {\n            this.removeEventListener(\"close\", this.#events.close);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.close = fn;\n            this.addEventListener(\"close\", fn);\n        } else {\n            this.#events.close = null;\n        }\n    }\n    get onmessage() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.message;\n    }\n    set onmessage(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.message) {\n            this.removeEventListener(\"message\", this.#events.message);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.message = fn;\n            this.addEventListener(\"message\", fn);\n        } else {\n            this.#events.message = null;\n        }\n    }\n    get binaryType() {\n        webidl.brandCheck(this, WebSocket);\n        return this[kBinaryType];\n    }\n    set binaryType(type) {\n        webidl.brandCheck(this, WebSocket);\n        if (type !== \"blob\" && type !== \"arraybuffer\") {\n            this[kBinaryType] = \"blob\";\n        } else {\n            this[kBinaryType] = type;\n        }\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */ #onConnectionEstablished(response) {\n        // processResponse is called when the \"responses header list has been received and initialized.\"\n        // once this happens, the connection is open\n        this[kResponse] = response;\n        const parser = new ByteParser(this);\n        parser.on(\"drain\", function onParserDrain() {\n            this.ws[kResponse].socket.resume();\n        });\n        response.socket.ws = this;\n        this[kByteParser] = parser;\n        // 1. Change the ready state to OPEN (1).\n        this[kReadyState] = states.OPEN;\n        // 2. Change the extensions attributes value to the extensions in use, if\n        //    it is not the null value.\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n        const extensions = response.headersList.get(\"sec-websocket-extensions\");\n        if (extensions !== null) {\n            this.#extensions = extensions;\n        }\n        // 3. Change the protocol attributes value to the subprotocol in use, if\n        //    it is not the null value.\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n        const protocol = response.headersList.get(\"sec-websocket-protocol\");\n        if (protocol !== null) {\n            this.#protocol = protocol;\n        }\n        // 4. Fire an event named open at the WebSocket object.\n        fireEvent(\"open\", this);\n    }\n}\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;\nObject.defineProperties(WebSocket.prototype, {\n    CONNECTING: staticPropertyDescriptors,\n    OPEN: staticPropertyDescriptors,\n    CLOSING: staticPropertyDescriptors,\n    CLOSED: staticPropertyDescriptors,\n    url: kEnumerableProperty,\n    readyState: kEnumerableProperty,\n    bufferedAmount: kEnumerableProperty,\n    onopen: kEnumerableProperty,\n    onerror: kEnumerableProperty,\n    onclose: kEnumerableProperty,\n    close: kEnumerableProperty,\n    onmessage: kEnumerableProperty,\n    binaryType: kEnumerableProperty,\n    send: kEnumerableProperty,\n    extensions: kEnumerableProperty,\n    protocol: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"WebSocket\",\n        writable: false,\n        enumerable: false,\n        configurable: true\n    }\n});\nObject.defineProperties(WebSocket, {\n    CONNECTING: staticPropertyDescriptors,\n    OPEN: staticPropertyDescriptors,\n    CLOSING: staticPropertyDescriptors,\n    CLOSED: staticPropertyDescriptors\n});\nwebidl.converters[\"sequence<DOMString>\"] = webidl.sequenceConverter(webidl.converters.DOMString);\nwebidl.converters[\"DOMString or sequence<DOMString>\"] = function(V) {\n    if (webidl.util.Type(V) === \"Object\" && Symbol.iterator in V) {\n        return webidl.converters[\"sequence<DOMString>\"](V);\n    }\n    return webidl.converters.DOMString(V);\n};\n// This implements the propsal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n    {\n        key: \"protocols\",\n        converter: webidl.converters[\"DOMString or sequence<DOMString>\"],\n        get defaultValue () {\n            return [];\n        }\n    },\n    {\n        key: \"dispatcher\",\n        converter: (V)=>V,\n        get defaultValue () {\n            return getGlobalDispatcher();\n        }\n    },\n    {\n        key: \"headers\",\n        converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n    }\n]);\nwebidl.converters[\"DOMString or sequence<DOMString> or WebSocketInit\"] = function(V) {\n    if (webidl.util.Type(V) === \"Object\" && !(Symbol.iterator in V)) {\n        return webidl.converters.WebSocketInit(V);\n    }\n    return {\n        protocols: webidl.converters[\"DOMString or sequence<DOMString>\"](V)\n    };\n};\nwebidl.converters.WebSocketSendData = function(V) {\n    if (webidl.util.Type(V) === \"Object\") {\n        if (isBlobLike(V)) {\n            return webidl.converters.Blob(V, {\n                strict: false\n            });\n        }\n        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n            return webidl.converters.BufferSource(V);\n        }\n    }\n    return webidl.converters.USVString(V);\n};\nmodule.exports = {\n    WebSocket\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRUMsWUFBWSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU0sRUFBRUUsYUFBYSxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRUcsZUFBZSxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQ3BDLE1BQU0sRUFBRUkseUJBQXlCLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxXQUFXLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDNUUsTUFBTSxFQUNKUSxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1osR0FBR2QsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVlLGFBQWEsRUFBRUMsU0FBUyxFQUFFQyxrQkFBa0IsRUFBRUMsdUJBQXVCLEVBQUVDLFNBQVMsRUFBRSxHQUFHbkIsbUJBQU9BLENBQUM7QUFDckcsTUFBTSxFQUFFb0IsNEJBQTRCLEVBQUUsR0FBR3BCLG1CQUFPQSxDQUFDO0FBQ2pELE1BQU0sRUFBRXFCLGtCQUFrQixFQUFFLEdBQUdyQixtQkFBT0EsQ0FBQztBQUN2QyxNQUFNLEVBQUVzQixVQUFVLEVBQUUsR0FBR3RCLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFBRXVCLG1CQUFtQixFQUFFQyxVQUFVLEVBQUUsR0FBR3hCLG1CQUFPQSxDQUFDO0FBQ3BELE1BQU0sRUFBRXlCLG1CQUFtQixFQUFFLEdBQUd6QixtQkFBT0EsQ0FBQztBQUN4QyxNQUFNLEVBQUUwQixLQUFLLEVBQUUsR0FBRzFCLG1CQUFPQSxDQUFDO0FBRTFCLElBQUkyQixxQkFBcUI7QUFFekIsMkRBQTJEO0FBQzNE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VWdGLENBQUM7SUFDbEYsSUFBSWpJLE9BQU9rSSxJQUFJLENBQUNDLElBQUksQ0FBQ0YsT0FBTyxZQUFZLENBQUVQLENBQUFBLE9BQU9VLFFBQVEsSUFBSUgsQ0FBQUEsR0FBSTtRQUMvRCxPQUFPakksT0FBT2lELFVBQVUsQ0FBQ29GLGFBQWEsQ0FBQ0o7SUFDekM7SUFFQSxPQUFPO1FBQUU1RixXQUFXckMsT0FBT2lELFVBQVUsQ0FBQyxtQ0FBbUMsQ0FBQ2dGO0lBQUc7QUFDL0U7QUFFQWpJLE9BQU9pRCxVQUFVLENBQUN1QyxpQkFBaUIsR0FBRyxTQUFVeUMsQ0FBQztJQUMvQyxJQUFJakksT0FBT2tJLElBQUksQ0FBQ0MsSUFBSSxDQUFDRixPQUFPLFVBQVU7UUFDcEMsSUFBSXhHLFdBQVd3RyxJQUFJO1lBQ2pCLE9BQU9qSSxPQUFPaUQsVUFBVSxDQUFDMkYsSUFBSSxDQUFDWCxHQUFHO2dCQUFFWSxRQUFRO1lBQU07UUFDbkQ7UUFFQSxJQUFJOUMsWUFBWUMsTUFBTSxDQUFDaUMsTUFBTXRHLE1BQU1tSCxnQkFBZ0IsQ0FBQ2IsSUFBSTtZQUN0RCxPQUFPakksT0FBT2lELFVBQVUsQ0FBQzhGLFlBQVksQ0FBQ2Q7UUFDeEM7SUFDRjtJQUVBLE9BQU9qSSxPQUFPaUQsVUFBVSxDQUFDQyxTQUFTLENBQUMrRTtBQUNyQztBQUVBZSxPQUFPQyxPQUFPLEdBQUc7SUFDZnBIO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYnNvY2tldC93ZWJzb2NrZXQuanM/ODFjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IERPTUV4Y2VwdGlvbiB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvY29uc3RhbnRzJylcbmNvbnN0IHsgVVJMU2VyaWFsaXplciB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YVVSTCcpXG5jb25zdCB7IGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZ2xvYmFsJylcbmNvbnN0IHsgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycywgc3RhdGVzLCBvcGNvZGVzLCBlbXB0eUJ1ZmZlciB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBrV2ViU29ja2V0VVJMLFxuICBrUmVhZHlTdGF0ZSxcbiAga0NvbnRyb2xsZXIsXG4gIGtCaW5hcnlUeXBlLFxuICBrUmVzcG9uc2UsXG4gIGtTZW50Q2xvc2UsXG4gIGtCeXRlUGFyc2VyXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgaXNFc3RhYmxpc2hlZCwgaXNDbG9zaW5nLCBpc1ZhbGlkU3VicHJvdG9jb2wsIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uLCBmaXJlRXZlbnQgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24gfSA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpXG5jb25zdCB7IFdlYnNvY2tldEZyYW1lU2VuZCB9ID0gcmVxdWlyZSgnLi9mcmFtZScpXG5jb25zdCB7IEJ5dGVQYXJzZXIgfSA9IHJlcXVpcmUoJy4vcmVjZWl2ZXInKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5LCBpc0Jsb2JMaWtlIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBnZXRHbG9iYWxEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCcuLi9nbG9iYWwnKVxuY29uc3QgeyB0eXBlcyB9ID0gcmVxdWlyZSgndXRpbCcpXG5cbmxldCBleHBlcmltZW50YWxXYXJuZWQgPSBmYWxzZVxuXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtZGVmaW5pdGlvblxuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAjZXZlbnRzID0ge1xuICAgIG9wZW46IG51bGwsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgY2xvc2U6IG51bGwsXG4gICAgbWVzc2FnZTogbnVsbFxuICB9XG5cbiAgI2J1ZmZlcmVkQW1vdW50ID0gMFxuICAjcHJvdG9jb2wgPSAnJ1xuICAjZXh0ZW5zaW9ucyA9ICcnXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHByb3RvY29sc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHVybCwgcHJvdG9jb2xzID0gW10pIHtcbiAgICBzdXBlcigpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnV2ViU29ja2V0IGNvbnN0cnVjdG9yJyB9KVxuXG4gICAgaWYgKCFleHBlcmltZW50YWxXYXJuZWQpIHtcbiAgICAgIGV4cGVyaW1lbnRhbFdhcm5lZCA9IHRydWVcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ1dlYlNvY2tldHMgYXJlIGV4cGVyaW1lbnRhbCwgZXhwZWN0IHRoZW0gdG8gY2hhbmdlIGF0IGFueSB0aW1lLicsIHtcbiAgICAgICAgY29kZTogJ1VORElDSS1XUydcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiBvciBXZWJTb2NrZXRJbml0J10ocHJvdG9jb2xzKVxuXG4gICAgdXJsID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHVybClcbiAgICBwcm90b2NvbHMgPSBvcHRpb25zLnByb3RvY29sc1xuXG4gICAgLy8gMS4gTGV0IGJhc2VVUkwgYmUgdGhpcydzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdCdzIEFQSSBiYXNlIFVSTC5cbiAgICBjb25zdCBiYXNlVVJMID0gZ2V0R2xvYmFsT3JpZ2luKClcblxuICAgIC8vIDEuIExldCB1cmxSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgVVJMIHBhcnNlciB0byB1cmwgd2l0aCBiYXNlVVJMLlxuICAgIGxldCB1cmxSZWNvcmRcblxuICAgIHRyeSB7XG4gICAgICB1cmxSZWNvcmQgPSBuZXcgVVJMKHVybCwgYmFzZVVSTClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyAzLiBJZiB1cmxSZWNvcmQgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGUsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gNC4gSWYgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgaXMgXCJodHRwXCIsIHRoZW4gc2V0IHVybFJlY29yZOKAmXMgc2NoZW1lIHRvIFwid3NcIi5cbiAgICBpZiAodXJsUmVjb3JkLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgICB1cmxSZWNvcmQucHJvdG9jb2wgPSAnd3M6J1xuICAgIH0gZWxzZSBpZiAodXJsUmVjb3JkLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiB1cmxSZWNvcmTigJlzIHNjaGVtZSBpcyBcImh0dHBzXCIsIHNldCB1cmxSZWNvcmTigJlzIHNjaGVtZSB0byBcIndzc1wiLlxuICAgICAgdXJsUmVjb3JkLnByb3RvY29sID0gJ3dzczonXG4gICAgfVxuXG4gICAgLy8gNi4gSWYgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgaXMgbm90IFwid3NcIiBvciBcIndzc1wiLCB0aGVuIHRocm93IGEgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAodXJsUmVjb3JkLnByb3RvY29sICE9PSAnd3M6JyAmJiB1cmxSZWNvcmQucHJvdG9jb2wgIT09ICd3c3M6Jykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgYEV4cGVjdGVkIGEgd3M6IG9yIHdzczogcHJvdG9jb2wsIGdvdCAke3VybFJlY29yZC5wcm90b2NvbH1gLFxuICAgICAgICAnU3ludGF4RXJyb3InXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gNy4gSWYgdXJsUmVjb3Jk4oCZcyBmcmFnbWVudCBpcyBub24tbnVsbCwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIlxuICAgIC8vICAgIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAodXJsUmVjb3JkLmhhc2ggfHwgdXJsUmVjb3JkLmhyZWYuZW5kc1dpdGgoJyMnKSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignR290IGZyYWdtZW50JywgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICAvLyA4LiBJZiBwcm90b2NvbHMgaXMgYSBzdHJpbmcsIHNldCBwcm90b2NvbHMgdG8gYSBzZXF1ZW5jZSBjb25zaXN0aW5nXG4gICAgLy8gICAgb2YganVzdCB0aGF0IHN0cmluZy5cbiAgICBpZiAodHlwZW9mIHByb3RvY29scyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdXG4gICAgfVxuXG4gICAgLy8gOS4gSWYgYW55IG9mIHRoZSB2YWx1ZXMgaW4gcHJvdG9jb2xzIG9jY3VyIG1vcmUgdGhhbiBvbmNlIG9yIG90aGVyd2lzZVxuICAgIC8vICAgIGZhaWwgdG8gbWF0Y2ggdGhlIHJlcXVpcmVtZW50cyBmb3IgZWxlbWVudHMgdGhhdCBjb21wcmlzZSB0aGUgdmFsdWVcbiAgICAvLyAgICBvZiBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgZmllbGRzIGFzIGRlZmluZWQgYnkgVGhlIFdlYlNvY2tldFxuICAgIC8vICAgIHByb3RvY29sLCB0aGVuIHRocm93IGEgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCAhPT0gbmV3IFNldChwcm90b2NvbHMubWFwKHAgPT4gcC50b0xvd2VyQ2FzZSgpKSkuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIHZhbHVlJywgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCA+IDAgJiYgIXByb3RvY29scy5ldmVyeShwID0+IGlzVmFsaWRTdWJwcm90b2NvbChwKSkpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCB2YWx1ZScsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gMTAuIFNldCB0aGlzJ3MgdXJsIHRvIHVybFJlY29yZC5cbiAgICB0aGlzW2tXZWJTb2NrZXRVUkxdID0gbmV3IFVSTCh1cmxSZWNvcmQuaHJlZilcblxuICAgIC8vIDExLiBMZXQgY2xpZW50IGJlIHRoaXMncyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QuXG5cbiAgICAvLyAxMi4gUnVuIHRoaXMgc3RlcCBpbiBwYXJhbGxlbDpcblxuICAgIC8vICAgIDEuIEVzdGFibGlzaCBhIFdlYlNvY2tldCBjb25uZWN0aW9uIGdpdmVuIHVybFJlY29yZCwgcHJvdG9jb2xzLFxuICAgIC8vICAgICAgIGFuZCBjbGllbnQuXG4gICAgdGhpc1trQ29udHJvbGxlcl0gPSBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uKFxuICAgICAgdXJsUmVjb3JkLFxuICAgICAgcHJvdG9jb2xzLFxuICAgICAgdGhpcyxcbiAgICAgIChyZXNwb25zZSkgPT4gdGhpcy4jb25Db25uZWN0aW9uRXN0YWJsaXNoZWQocmVzcG9uc2UpLFxuICAgICAgb3B0aW9uc1xuICAgIClcblxuICAgIC8vIEVhY2ggV2ViU29ja2V0IG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCByZWFkeSBzdGF0ZSwgd2hpY2ggaXMgYVxuICAgIC8vIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBjb25uZWN0aW9uLiBJbml0aWFsbHkgaXQgbXVzdFxuICAgIC8vIGJlIENPTk5FQ1RJTkcgKDApLlxuICAgIHRoaXNba1JlYWR5U3RhdGVdID0gV2ViU29ja2V0LkNPTk5FQ1RJTkdcblxuICAgIC8vIFRoZSBleHRlbnNpb25zIGF0dHJpYnV0ZSBtdXN0IGluaXRpYWxseSByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cblxuICAgIC8vIFRoZSBwcm90b2NvbCBhdHRyaWJ1dGUgbXVzdCBpbml0aWFsbHkgcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICAvLyBFYWNoIFdlYlNvY2tldCBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgYmluYXJ5IHR5cGUsIHdoaWNoIGlzIGFcbiAgICAvLyBCaW5hcnlUeXBlLiBJbml0aWFsbHkgaXQgbXVzdCBiZSBcImJsb2JcIi5cbiAgICB0aGlzW2tCaW5hcnlUeXBlXSA9ICdibG9iJ1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jbG9zZVxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSByZWFzb25cbiAgICovXG4gIGNsb3NlIChjb2RlID0gdW5kZWZpbmVkLCByZWFzb24gPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb2RlID0gd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10oY29kZSwgeyBjbGFtcDogdHJ1ZSB9KVxuICAgIH1cblxuICAgIGlmIChyZWFzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVhc29uID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHJlYXNvbilcbiAgICB9XG5cbiAgICAvLyAxLiBJZiBjb2RlIGlzIHByZXNlbnQsIGJ1dCBpcyBuZWl0aGVyIGFuIGludGVnZXIgZXF1YWwgdG8gMTAwMCBub3IgYW5cbiAgICAvLyAgICBpbnRlZ2VyIGluIHRoZSByYW5nZSAzMDAwIHRvIDQ5OTksIGluY2x1c2l2ZSwgdGhyb3cgYW5cbiAgICAvLyAgICBcIkludmFsaWRBY2Nlc3NFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29kZSAhPT0gMTAwMCAmJiAoY29kZSA8IDMwMDAgfHwgY29kZSA+IDQ5OTkpKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ2ludmFsaWQgY29kZScsICdJbnZhbGlkQWNjZXNzRXJyb3InKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCByZWFzb25CeXRlTGVuZ3RoID0gMFxuXG4gICAgLy8gMi4gSWYgcmVhc29uIGlzIHByZXNlbnQsIHRoZW4gcnVuIHRoZXNlIHN1YnN0ZXBzOlxuICAgIGlmIChyZWFzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gMS4gTGV0IHJlYXNvbkJ5dGVzIGJlIHRoZSByZXN1bHQgb2YgZW5jb2RpbmcgcmVhc29uLlxuICAgICAgLy8gMi4gSWYgcmVhc29uQnl0ZXMgaXMgbG9uZ2VyIHRoYW4gMTIzIGJ5dGVzLCB0aGVuIHRocm93IGFcbiAgICAgIC8vICAgIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgICByZWFzb25CeXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgocmVhc29uKVxuXG4gICAgICBpZiAocmVhc29uQnl0ZUxlbmd0aCA+IDEyMykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAgIGBSZWFzb24gbXVzdCBiZSBsZXNzIHRoYW4gMTIzIGJ5dGVzOyByZWNlaXZlZCAke3JlYXNvbkJ5dGVMZW5ndGh9YCxcbiAgICAgICAgICAnU3ludGF4RXJyb3InXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBSdW4gdGhlIGZpcnN0IG1hdGNoaW5nIHN0ZXBzIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuICAgIGlmICh0aGlzW2tSZWFkeVN0YXRlXSA9PT0gV2ViU29ja2V0LkNMT1NJTkcgfHwgdGhpc1trUmVhZHlTdGF0ZV0gPT09IFdlYlNvY2tldC5DTE9TRUQpIHtcbiAgICAgIC8vIElmIHRoaXMncyByZWFkeSBzdGF0ZSBpcyBDTE9TSU5HICgyKSBvciBDTE9TRUQgKDMpXG4gICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH0gZWxzZSBpZiAoIWlzRXN0YWJsaXNoZWQodGhpcykpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBub3QgeWV0IGVzdGFibGlzaGVkXG4gICAgICAvLyBGYWlsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBhbmQgc2V0IHRoaXMncyByZWFkeSBzdGF0ZVxuICAgICAgLy8gdG8gQ0xPU0lORyAoMikuXG4gICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLCAnQ29ubmVjdGlvbiB3YXMgY2xvc2VkIGJlZm9yZSBpdCB3YXMgZXN0YWJsaXNoZWQuJylcbiAgICAgIHRoaXNba1JlYWR5U3RhdGVdID0gV2ViU29ja2V0LkNMT1NJTkdcbiAgICB9IGVsc2UgaWYgKCFpc0Nsb3NpbmcodGhpcykpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgYmVlbiBzdGFydGVkXG4gICAgICAvLyBTdGFydCB0aGUgV2ViU29ja2V0IGNsb3NpbmcgaGFuZHNoYWtlIGFuZCBzZXQgdGhpcydzIHJlYWR5XG4gICAgICAvLyBzdGF0ZSB0byBDTE9TSU5HICgyKS5cbiAgICAgIC8vIC0gSWYgbmVpdGhlciBjb2RlIG5vciByZWFzb24gaXMgcHJlc2VudCwgdGhlIFdlYlNvY2tldCBDbG9zZVxuICAgICAgLy8gICBtZXNzYWdlIG11c3Qgbm90IGhhdmUgYSBib2R5LlxuICAgICAgLy8gLSBJZiBjb2RlIGlzIHByZXNlbnQsIHRoZW4gdGhlIHN0YXR1cyBjb2RlIHRvIHVzZSBpbiB0aGVcbiAgICAgIC8vICAgV2ViU29ja2V0IENsb3NlIG1lc3NhZ2UgbXVzdCBiZSB0aGUgaW50ZWdlciBnaXZlbiBieSBjb2RlLlxuICAgICAgLy8gLSBJZiByZWFzb24gaXMgYWxzbyBwcmVzZW50LCB0aGVuIHJlYXNvbkJ5dGVzIG11c3QgYmVcbiAgICAgIC8vICAgcHJvdmlkZWQgaW4gdGhlIENsb3NlIG1lc3NhZ2UgYWZ0ZXIgdGhlIHN0YXR1cyBjb2RlLlxuXG4gICAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoKVxuXG4gICAgICAvLyBJZiBuZWl0aGVyIGNvZGUgbm9yIHJlYXNvbiBpcyBwcmVzZW50LCB0aGUgV2ViU29ja2V0IENsb3NlXG4gICAgICAvLyBtZXNzYWdlIG11c3Qgbm90IGhhdmUgYSBib2R5LlxuXG4gICAgICAvLyBJZiBjb2RlIGlzIHByZXNlbnQsIHRoZW4gdGhlIHN0YXR1cyBjb2RlIHRvIHVzZSBpbiB0aGVcbiAgICAgIC8vIFdlYlNvY2tldCBDbG9zZSBtZXNzYWdlIG11c3QgYmUgdGhlIGludGVnZXIgZ2l2ZW4gYnkgY29kZS5cbiAgICAgIGlmIChjb2RlICE9PSB1bmRlZmluZWQgJiYgcmVhc29uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZnJhbWUuZnJhbWVEYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gICAgICAgIGZyYW1lLmZyYW1lRGF0YS53cml0ZVVJbnQxNkJFKGNvZGUsIDApXG4gICAgICB9IGVsc2UgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCAmJiByZWFzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBJZiByZWFzb24gaXMgYWxzbyBwcmVzZW50LCB0aGVuIHJlYXNvbkJ5dGVzIG11c3QgYmVcbiAgICAgICAgLy8gcHJvdmlkZWQgaW4gdGhlIENsb3NlIG1lc3NhZ2UgYWZ0ZXIgdGhlIHN0YXR1cyBjb2RlLlxuICAgICAgICBmcmFtZS5mcmFtZURhdGEgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIHJlYXNvbkJ5dGVMZW5ndGgpXG4gICAgICAgIGZyYW1lLmZyYW1lRGF0YS53cml0ZVVJbnQxNkJFKGNvZGUsIDApXG4gICAgICAgIC8vIHRoZSBib2R5IE1BWSBjb250YWluIFVURi04LWVuY29kZWQgZGF0YSB3aXRoIHZhbHVlIC9yZWFzb24vXG4gICAgICAgIGZyYW1lLmZyYW1lRGF0YS53cml0ZShyZWFzb24sIDIsICd1dGYtOCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFtZS5mcmFtZURhdGEgPSBlbXB0eUJ1ZmZlclxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge2ltcG9ydCgnc3RyZWFtJykuRHVwbGV4fSAqL1xuICAgICAgY29uc3Qgc29ja2V0ID0gdGhpc1trUmVzcG9uc2VdLnNvY2tldFxuXG4gICAgICBzb2NrZXQud3JpdGUoZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5DTE9TRSksIChlcnIpID0+IHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICB0aGlzW2tTZW50Q2xvc2VdID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBVcG9uIGVpdGhlciBzZW5kaW5nIG9yIHJlY2VpdmluZyBhIENsb3NlIGNvbnRyb2wgZnJhbWUsIGl0IGlzIHNhaWRcbiAgICAgIC8vIHRoYXQgX1RoZSBXZWJTb2NrZXQgQ2xvc2luZyBIYW5kc2hha2UgaXMgU3RhcnRlZF8gYW5kIHRoYXQgdGhlXG4gICAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgICAgIHRoaXNba1JlYWR5U3RhdGVdID0gc3RhdGVzLkNMT1NJTkdcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlXG4gICAgICAvLyBTZXQgdGhpcydzIHJlYWR5IHN0YXRlIHRvIENMT1NJTkcgKDIpLlxuICAgICAgdGhpc1trUmVhZHlTdGF0ZV0gPSBXZWJTb2NrZXQuQ0xPU0lOR1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtc2VuZFxuICAgKiBAcGFyYW0ge05vZGVKUy5UeXBlZEFycmF5fEFycmF5QnVmZmVyfEJsb2J8c3RyaW5nfSBkYXRhXG4gICAqL1xuICBzZW5kIChkYXRhKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ1dlYlNvY2tldC5zZW5kJyB9KVxuXG4gICAgZGF0YSA9IHdlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldFNlbmREYXRhKGRhdGEpXG5cbiAgICAvLyAxLiBJZiB0aGlzJ3MgcmVhZHkgc3RhdGUgaXMgQ09OTkVDVElORywgdGhlbiB0aHJvdyBhblxuICAgIC8vICAgIFwiSW52YWxpZFN0YXRlRXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKHRoaXNba1JlYWR5U3RhdGVdID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignU2VudCBiZWZvcmUgY29ubmVjdGVkLicsICdJbnZhbGlkU3RhdGVFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gMi4gUnVuIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc3RlcHMgZnJvbSB0aGUgZm9sbG93aW5nIGxpc3Q6XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNi4xXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNS4yXG5cbiAgICBpZiAoIWlzRXN0YWJsaXNoZWQodGhpcykgfHwgaXNDbG9zaW5nKHRoaXMpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnc3RyZWFtJykuRHVwbGV4fSAqL1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXNba1Jlc3BvbnNlXS5zb2NrZXRcblxuICAgIC8vIElmIGRhdGEgaXMgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnRcbiAgICAgIC8vIG11c3Qgc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiB0aGUgZGF0YSBhcmd1bWVudFxuICAgICAgLy8gdXNpbmcgYSB0ZXh0IGZyYW1lIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy5cbiAgICAgIC8vIGJlY2F1c2UgaXQgd291bGQgbmVlZCB0byBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLFxuICAgICAgLy8gdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnIHRoZSBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZVxuICAgICAgLy8gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBBbnkgaW52b2NhdGlvbiBvZiB0aGlzIG1ldGhvZCB3aXRoIGFcbiAgICAgIC8vIHN0cmluZyBhcmd1bWVudCB0aGF0IGRvZXMgbm90IHRocm93IGFuIGV4Y2VwdGlvbiBtdXN0IGluY3JlYXNlXG4gICAgICAvLyB0aGUgYnVmZmVyZWRBbW91bnQgYXR0cmlidXRlIGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvXG4gICAgICAvLyBleHByZXNzIHRoZSBhcmd1bWVudCBhcyBVVEYtOC5cblxuICAgICAgY29uc3QgdmFsdWUgPSBCdWZmZXIuZnJvbShkYXRhKVxuICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKHZhbHVlKVxuICAgICAgY29uc3QgYnVmZmVyID0gZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5URVhUKVxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICBzb2NrZXQud3JpdGUoYnVmZmVyLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IHZhbHVlLmJ5dGVMZW5ndGhcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICh0eXBlcy5pc0FycmF5QnVmZmVyKGRhdGEpKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQsIGFuZCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBzdGFydGVkLCB0aGVuIHRoZSB1c2VyIGFnZW50IG11c3RcbiAgICAgIC8vIHNlbmQgYSBXZWJTb2NrZXQgTWVzc2FnZSBjb21wcmlzZWQgb2YgZGF0YSB1c2luZyBhIGJpbmFyeSBmcmFtZVxuICAgICAgLy8gb3Bjb2RlOyBpZiB0aGUgZGF0YSBjYW5ub3QgYmUgc2VudCwgZS5nLiBiZWNhdXNlIGl0IHdvdWxkIG5lZWRcbiAgICAgIC8vIHRvIGJlIGJ1ZmZlcmVkIGJ1dCB0aGUgYnVmZmVyIGlzIGZ1bGwsIHRoZSB1c2VyIGFnZW50IG11c3QgZmxhZ1xuICAgICAgLy8gdGhlIFdlYlNvY2tldCBhcyBmdWxsIGFuZCB0aGVuIGNsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICAgIC8vIFRoZSBkYXRhIHRvIGJlIHNlbnQgaXMgdGhlIGRhdGEgc3RvcmVkIGluIHRoZSBidWZmZXIgZGVzY3JpYmVkXG4gICAgICAvLyBieSB0aGUgQXJyYXlCdWZmZXIgb2JqZWN0LiBBbnkgaW52b2NhdGlvbiBvZiB0aGlzIG1ldGhvZCB3aXRoIGFuXG4gICAgICAvLyBBcnJheUJ1ZmZlciBhcmd1bWVudCB0aGF0IGRvZXMgbm90IHRocm93IGFuIGV4Y2VwdGlvbiBtdXN0XG4gICAgICAvLyBpbmNyZWFzZSB0aGUgYnVmZmVyZWRBbW91bnQgYXR0cmlidXRlIGJ5IHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICAvLyBBcnJheUJ1ZmZlciBpbiBieXRlcy5cblxuICAgICAgY29uc3QgdmFsdWUgPSBCdWZmZXIuZnJvbShkYXRhKVxuICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKHZhbHVlKVxuICAgICAgY29uc3QgYnVmZmVyID0gZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5CSU5BUlkpXG5cbiAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50ICs9IHZhbHVlLmJ5dGVMZW5ndGhcbiAgICAgIHNvY2tldC53cml0ZShidWZmZXIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgLT0gdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgICAvLyBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIGRhdGEgdXNpbmcgYSBiaW5hcnkgZnJhbWVcbiAgICAgIC8vIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy4gYmVjYXVzZSBpdCB3b3VsZCBuZWVkIHRvXG4gICAgICAvLyBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLCB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWcgdGhlXG4gICAgICAvLyBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uIFRoZVxuICAgICAgLy8gZGF0YSB0byBiZSBzZW50IGlzIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgc2VjdGlvbiBvZiB0aGUgYnVmZmVyXG4gICAgICAvLyBkZXNjcmliZWQgYnkgdGhlIEFycmF5QnVmZmVyIG9iamVjdCB0aGF0IGRhdGEgcmVmZXJlbmNlcy4gQW55XG4gICAgICAvLyBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggdGhpcyBraW5kIG9mIGFyZ3VtZW50IHRoYXQgZG9lc1xuICAgICAgLy8gbm90IHRocm93IGFuIGV4Y2VwdGlvbiBtdXN0IGluY3JlYXNlIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGVcbiAgICAgIC8vIGJ5IHRoZSBsZW5ndGggb2YgZGF0YeKAmXMgYnVmZmVyIGluIGJ5dGVzLlxuXG4gICAgICBjb25zdCBhYiA9IEJ1ZmZlci5mcm9tKGRhdGEsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKVxuXG4gICAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoYWIpXG4gICAgICBjb25zdCBidWZmZXIgPSBmcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLkJJTkFSWSlcblxuICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgKz0gYWIuYnl0ZUxlbmd0aFxuICAgICAgc29ja2V0LndyaXRlKGJ1ZmZlciwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSBhYi5ieXRlTGVuZ3RoXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShkYXRhKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgICAvLyBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIGRhdGEgdXNpbmcgYSBiaW5hcnkgZnJhbWVcbiAgICAgIC8vIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy4gYmVjYXVzZSBpdCB3b3VsZCBuZWVkIHRvXG4gICAgICAvLyBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLCB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWcgdGhlXG4gICAgICAvLyBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uIFRoZSBkYXRhXG4gICAgICAvLyB0byBiZSBzZW50IGlzIHRoZSByYXcgZGF0YSByZXByZXNlbnRlZCBieSB0aGUgQmxvYiBvYmplY3QuIEFueVxuICAgICAgLy8gaW52b2NhdGlvbiBvZiB0aGlzIG1ldGhvZCB3aXRoIGEgQmxvYiBhcmd1bWVudCB0aGF0IGRvZXMgbm90IHRocm93XG4gICAgICAvLyBhbiBleGNlcHRpb24gbXVzdCBpbmNyZWFzZSB0aGUgYnVmZmVyZWRBbW91bnQgYXR0cmlidXRlIGJ5IHRoZSBzaXplXG4gICAgICAvLyBvZiB0aGUgQmxvYiBvYmplY3TigJlzIHJhdyBkYXRhLCBpbiBieXRlcy5cblxuICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKClcblxuICAgICAgZGF0YS5hcnJheUJ1ZmZlcigpLnRoZW4oKGFiKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQnVmZmVyLmZyb20oYWIpXG4gICAgICAgIGZyYW1lLmZyYW1lRGF0YSA9IHZhbHVlXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuQklOQVJZKVxuXG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50ICs9IHZhbHVlLmJ5dGVMZW5ndGhcbiAgICAgICAgc29ja2V0LndyaXRlKGJ1ZmZlciwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IHZhbHVlLmJ5dGVMZW5ndGhcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZ2V0IHJlYWR5U3RhdGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIC8vIFRoZSByZWFkeVN0YXRlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXMncyByZWFkeSBzdGF0ZS5cbiAgICByZXR1cm4gdGhpc1trUmVhZHlTdGF0ZV1cbiAgfVxuXG4gIGdldCBidWZmZXJlZEFtb3VudCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2J1ZmZlcmVkQW1vdW50XG4gIH1cblxuICBnZXQgdXJsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICAvLyBUaGUgdXJsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXMncyB1cmwsIHNlcmlhbGl6ZWQuXG4gICAgcmV0dXJuIFVSTFNlcmlhbGl6ZXIodGhpc1trV2ViU29ja2V0VVJMXSlcbiAgfVxuXG4gIGdldCBleHRlbnNpb25zICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXh0ZW5zaW9uc1xuICB9XG5cbiAgZ2V0IHByb3RvY29sICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jcHJvdG9jb2xcbiAgfVxuXG4gIGdldCBvbm9wZW4gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMub3BlblxuICB9XG5cbiAgc2V0IG9ub3BlbiAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLm9wZW4pIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIHRoaXMuI2V2ZW50cy5vcGVuKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5vcGVuID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMub3BlbiA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25lcnJvciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5lcnJvclxuICB9XG5cbiAgc2V0IG9uZXJyb3IgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHRoaXMuI2V2ZW50cy5lcnJvcikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuI2V2ZW50cy5lcnJvcilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMuZXJyb3IgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMuZXJyb3IgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9uY2xvc2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMuY2xvc2VcbiAgfVxuXG4gIHNldCBvbmNsb3NlIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0aGlzLiNldmVudHMuY2xvc2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCB0aGlzLiNldmVudHMuY2xvc2UpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLmNsb3NlID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLmNsb3NlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbm1lc3NhZ2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMubWVzc2FnZVxuICB9XG5cbiAgc2V0IG9ubWVzc2FnZSAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLm1lc3NhZ2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuI2V2ZW50cy5tZXNzYWdlKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5tZXNzYWdlID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMubWVzc2FnZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgYmluYXJ5VHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXNba0JpbmFyeVR5cGVdXG4gIH1cblxuICBzZXQgYmluYXJ5VHlwZSAodHlwZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0eXBlICE9PSAnYmxvYicgJiYgdHlwZSAhPT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgdGhpc1trQmluYXJ5VHlwZV0gPSAnYmxvYidcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trQmluYXJ5VHlwZV0gPSB0eXBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZmVlZGJhY2stZnJvbS10aGUtcHJvdG9jb2xcbiAgICovXG4gICNvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZCAocmVzcG9uc2UpIHtcbiAgICAvLyBwcm9jZXNzUmVzcG9uc2UgaXMgY2FsbGVkIHdoZW4gdGhlIFwicmVzcG9uc2XigJlzIGhlYWRlciBsaXN0IGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBpbml0aWFsaXplZC5cIlxuICAgIC8vIG9uY2UgdGhpcyBoYXBwZW5zLCB0aGUgY29ubmVjdGlvbiBpcyBvcGVuXG4gICAgdGhpc1trUmVzcG9uc2VdID0gcmVzcG9uc2VcblxuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBCeXRlUGFyc2VyKHRoaXMpXG4gICAgcGFyc2VyLm9uKCdkcmFpbicsIGZ1bmN0aW9uIG9uUGFyc2VyRHJhaW4gKCkge1xuICAgICAgdGhpcy53c1trUmVzcG9uc2VdLnNvY2tldC5yZXN1bWUoKVxuICAgIH0pXG5cbiAgICByZXNwb25zZS5zb2NrZXQud3MgPSB0aGlzXG4gICAgdGhpc1trQnl0ZVBhcnNlcl0gPSBwYXJzZXJcblxuICAgIC8vIDEuIENoYW5nZSB0aGUgcmVhZHkgc3RhdGUgdG8gT1BFTiAoMSkuXG4gICAgdGhpc1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuT1BFTlxuXG4gICAgLy8gMi4gQ2hhbmdlIHRoZSBleHRlbnNpb25zIGF0dHJpYnV0ZeKAmXMgdmFsdWUgdG8gdGhlIGV4dGVuc2lvbnMgaW4gdXNlLCBpZlxuICAgIC8vICAgIGl0IGlzIG5vdCB0aGUgbnVsbCB2YWx1ZS5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICBjb25zdCBleHRlbnNpb25zID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnKVxuXG4gICAgaWYgKGV4dGVuc2lvbnMgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuI2V4dGVuc2lvbnMgPSBleHRlbnNpb25zXG4gICAgfVxuXG4gICAgLy8gMy4gQ2hhbmdlIHRoZSBwcm90b2NvbCBhdHRyaWJ1dGXigJlzIHZhbHVlIHRvIHRoZSBzdWJwcm90b2NvbCBpbiB1c2UsIGlmXG4gICAgLy8gICAgaXQgaXMgbm90IHRoZSBudWxsIHZhbHVlLlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTEuOVxuICAgIGNvbnN0IHByb3RvY29sID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdzZWMtd2Vic29ja2V0LXByb3RvY29sJylcblxuICAgIGlmIChwcm90b2NvbCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy4jcHJvdG9jb2wgPSBwcm90b2NvbFxuICAgIH1cblxuICAgIC8vIDQuIEZpcmUgYW4gZXZlbnQgbmFtZWQgb3BlbiBhdCB0aGUgV2ViU29ja2V0IG9iamVjdC5cbiAgICBmaXJlRXZlbnQoJ29wZW4nLCB0aGlzKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY29ubmVjdGluZ1xuV2ViU29ja2V0LkNPTk5FQ1RJTkcgPSBXZWJTb2NrZXQucHJvdG90eXBlLkNPTk5FQ1RJTkcgPSBzdGF0ZXMuQ09OTkVDVElOR1xuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1vcGVuXG5XZWJTb2NrZXQuT1BFTiA9IFdlYlNvY2tldC5wcm90b3R5cGUuT1BFTiA9IHN0YXRlcy5PUEVOXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNsb3NpbmdcbldlYlNvY2tldC5DTE9TSU5HID0gV2ViU29ja2V0LnByb3RvdHlwZS5DTE9TSU5HID0gc3RhdGVzLkNMT1NJTkdcbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY2xvc2VkXG5XZWJTb2NrZXQuQ0xPU0VEID0gV2ViU29ja2V0LnByb3RvdHlwZS5DTE9TRUQgPSBzdGF0ZXMuQ0xPU0VEXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdlYlNvY2tldC5wcm90b3R5cGUsIHtcbiAgQ09OTkVDVElORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgT1BFTjogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0lORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0VEOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWR5U3RhdGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJ1ZmZlcmVkQW1vdW50OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbm9wZW46IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uY2xvc2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNsb3NlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbm1lc3NhZ2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJpbmFyeVR5cGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGV4dGVuc2lvbnM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHByb3RvY29sOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnV2ViU29ja2V0JyxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdlYlNvY2tldCwge1xuICBDT05ORUNUSU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBPUEVOOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBDTE9TSU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBDTE9TRUQ6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnNcbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxET01TdHJpbmc+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZ1xuKVxuXG53ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4nXSA9IGZ1bmN0aW9uIChWKSB7XG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSAnT2JqZWN0JyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gVikge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8RE9NU3RyaW5nPiddKFYpXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYpXG59XG5cbi8vIFRoaXMgaW1wbGVtZW50cyB0aGUgcHJvcHNhbCBtYWRlIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvd2Vic29ja2V0cy9pc3N1ZXMvNDJcbndlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdwcm90b2NvbHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+J10sXG4gICAgZ2V0IGRlZmF1bHRWYWx1ZSAoKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdkaXNwYXRjaGVyJyxcbiAgICBjb252ZXJ0ZXI6IChWKSA9PiBWLFxuICAgIGdldCBkZWZhdWx0VmFsdWUgKCkge1xuICAgICAgcmV0dXJuIGdldEdsb2JhbERpc3BhdGNoZXIoKVxuICAgIH1cbiAgfSxcbiAge1xuICAgIGtleTogJ2hlYWRlcnMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0KVxuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4gb3IgV2ViU29ja2V0SW5pdCddID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09ICdPYmplY3QnICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldEluaXQoVilcbiAgfVxuXG4gIHJldHVybiB7IHByb3RvY29sczogd2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+J10oVikgfVxufVxuXG53ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRTZW5kRGF0YSA9IGZ1bmN0aW9uIChWKSB7XG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSAnT2JqZWN0Jykge1xuICAgIGlmIChpc0Jsb2JMaWtlKFYpKSB7XG4gICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihWLCB7IHN0cmljdDogZmFsc2UgfSlcbiAgICB9XG5cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KFYpIHx8IHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoVikpIHtcbiAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CdWZmZXJTb3VyY2UoVilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJTb2NrZXRcbn1cbiJdLCJuYW1lcyI6WyJ3ZWJpZGwiLCJyZXF1aXJlIiwiRE9NRXhjZXB0aW9uIiwiVVJMU2VyaWFsaXplciIsImdldEdsb2JhbE9yaWdpbiIsInN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMiLCJzdGF0ZXMiLCJvcGNvZGVzIiwiZW1wdHlCdWZmZXIiLCJrV2ViU29ja2V0VVJMIiwia1JlYWR5U3RhdGUiLCJrQ29udHJvbGxlciIsImtCaW5hcnlUeXBlIiwia1Jlc3BvbnNlIiwia1NlbnRDbG9zZSIsImtCeXRlUGFyc2VyIiwiaXNFc3RhYmxpc2hlZCIsImlzQ2xvc2luZyIsImlzVmFsaWRTdWJwcm90b2NvbCIsImZhaWxXZWJzb2NrZXRDb25uZWN0aW9uIiwiZmlyZUV2ZW50IiwiZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbiIsIldlYnNvY2tldEZyYW1lU2VuZCIsIkJ5dGVQYXJzZXIiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiaXNCbG9iTGlrZSIsImdldEdsb2JhbERpc3BhdGNoZXIiLCJ0eXBlcyIsImV4cGVyaW1lbnRhbFdhcm5lZCIsIldlYlNvY2tldCIsIkV2ZW50VGFyZ2V0IiwiZXZlbnRzIiwiYnVmZmVyZWRBbW91bnQiLCJwcm90b2NvbCIsImV4dGVuc2lvbnMiLCJjb25zdHJ1Y3RvciIsInVybCIsInByb3RvY29scyIsIm9wZW4iLCJlcnJvciIsImNsb3NlIiwibWVzc2FnZSIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJoZWFkZXIiLCJwcm9jZXNzIiwiZW1pdFdhcm5pbmciLCJjb2RlIiwib3B0aW9ucyIsImNvbnZlcnRlcnMiLCJVU1ZTdHJpbmciLCJiYXNlVVJMIiwidXJsUmVjb3JkIiwiVVJMIiwiZSIsImhhc2giLCJocmVmIiwiZW5kc1dpdGgiLCJsZW5ndGgiLCJTZXQiLCJtYXAiLCJwIiwidG9Mb3dlckNhc2UiLCJzaXplIiwiZXZlcnkiLCJyZXNwb25zZSIsIm9uQ29ubmVjdGlvbkVzdGFibGlzaGVkIiwiQ09OTkVDVElORyIsInVuZGVmaW5lZCIsInJlYXNvbiIsImJyYW5kQ2hlY2siLCJjbGFtcCIsInJlYXNvbkJ5dGVMZW5ndGgiLCJCdWZmZXIiLCJieXRlTGVuZ3RoIiwiQ0xPU0lORyIsIkNMT1NFRCIsImZyYW1lIiwiZnJhbWVEYXRhIiwiYWxsb2NVbnNhZmUiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGUiLCJzb2NrZXQiLCJjcmVhdGVGcmFtZSIsIkNMT1NFIiwiZXJyIiwic2VuZCIsImRhdGEiLCJXZWJTb2NrZXRTZW5kRGF0YSIsInZhbHVlIiwiZnJvbSIsImJ1ZmZlciIsIlRFWFQiLCJpc0FycmF5QnVmZmVyIiwiQklOQVJZIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJhYiIsImJ5dGVPZmZzZXQiLCJhcnJheUJ1ZmZlciIsInRoZW4iLCJyZWFkeVN0YXRlIiwib25vcGVuIiwiZm4iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uZXJyb3IiLCJvbmNsb3NlIiwib25tZXNzYWdlIiwiYmluYXJ5VHlwZSIsInR5cGUiLCJwYXJzZXIiLCJvbiIsIm9uUGFyc2VyRHJhaW4iLCJ3cyIsInJlc3VtZSIsIk9QRU4iLCJoZWFkZXJzTGlzdCIsImdldCIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInNlcXVlbmNlQ29udmVydGVyIiwiRE9NU3RyaW5nIiwiViIsInV0aWwiLCJUeXBlIiwiaXRlcmF0b3IiLCJXZWJTb2NrZXRJbml0IiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImtleSIsImNvbnZlcnRlciIsImRlZmF1bHRWYWx1ZSIsIm51bGxhYmxlQ29udmVydGVyIiwiSGVhZGVyc0luaXQiLCJCbG9iIiwic3RyaWN0IiwiaXNBbnlBcnJheUJ1ZmZlciIsIkJ1ZmZlclNvdXJjZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/lib/websocket/websocket.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst WritableStream = (__webpack_require__(/*! node:stream */ \"node:stream\").Writable);\nconst inherits = (__webpack_require__(/*! node:util */ \"node:util\").inherits);\nconst StreamSearch = __webpack_require__(/*! ../../streamsearch/sbmh */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js\");\nconst PartStream = __webpack_require__(/*! ./PartStream */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js\");\nconst HeaderParser = __webpack_require__(/*! ./HeaderParser */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js\");\nconst DASH = 45;\nconst B_ONEDASH = Buffer.from(\"-\");\nconst B_CRLF = Buffer.from(\"\\r\\n\");\nconst EMPTY_FN = function() {};\nfunction Dicer(cfg) {\n    if (!(this instanceof Dicer)) {\n        return new Dicer(cfg);\n    }\n    WritableStream.call(this, cfg);\n    if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== \"string\") {\n        throw new TypeError(\"Boundary required\");\n    }\n    if (typeof cfg.boundary === \"string\") {\n        this.setBoundary(cfg.boundary);\n    } else {\n        this._bparser = undefined;\n    }\n    this._headerFirst = cfg.headerFirst;\n    this._dashes = 0;\n    this._parts = 0;\n    this._finished = false;\n    this._realFinish = false;\n    this._isPreamble = true;\n    this._justMatched = false;\n    this._firstWrite = true;\n    this._inHeader = true;\n    this._part = undefined;\n    this._cb = undefined;\n    this._ignoreData = false;\n    this._partOpts = {\n        highWaterMark: cfg.partHwm\n    };\n    this._pause = false;\n    const self = this;\n    this._hparser = new HeaderParser(cfg);\n    this._hparser.on(\"header\", function(header) {\n        self._inHeader = false;\n        self._part.emit(\"header\", header);\n    });\n}\ninherits(Dicer, WritableStream);\nDicer.prototype.emit = function(ev) {\n    if (ev === \"finish\" && !this._realFinish) {\n        if (!this._finished) {\n            const self = this;\n            process.nextTick(function() {\n                self.emit(\"error\", new Error(\"Unexpected end of multipart data\"));\n                if (self._part && !self._ignoreData) {\n                    const type = self._isPreamble ? \"Preamble\" : \"Part\";\n                    self._part.emit(\"error\", new Error(type + \" terminated early due to unexpected end of multipart data\"));\n                    self._part.push(null);\n                    process.nextTick(function() {\n                        self._realFinish = true;\n                        self.emit(\"finish\");\n                        self._realFinish = false;\n                    });\n                    return;\n                }\n                self._realFinish = true;\n                self.emit(\"finish\");\n                self._realFinish = false;\n            });\n        }\n    } else {\n        WritableStream.prototype.emit.apply(this, arguments);\n    }\n};\nDicer.prototype._write = function(data, encoding, cb) {\n    // ignore unexpected data (e.g. extra trailer data after finished)\n    if (!this._hparser && !this._bparser) {\n        return cb();\n    }\n    if (this._headerFirst && this._isPreamble) {\n        if (!this._part) {\n            this._part = new PartStream(this._partOpts);\n            if (this._events.preamble) {\n                this.emit(\"preamble\", this._part);\n            } else {\n                this._ignore();\n            }\n        }\n        const r = this._hparser.push(data);\n        if (!this._inHeader && r !== undefined && r < data.length) {\n            data = data.slice(r);\n        } else {\n            return cb();\n        }\n    }\n    // allows for \"easier\" testing\n    if (this._firstWrite) {\n        this._bparser.push(B_CRLF);\n        this._firstWrite = false;\n    }\n    this._bparser.push(data);\n    if (this._pause) {\n        this._cb = cb;\n    } else {\n        cb();\n    }\n};\nDicer.prototype.reset = function() {\n    this._part = undefined;\n    this._bparser = undefined;\n    this._hparser = undefined;\n};\nDicer.prototype.setBoundary = function(boundary) {\n    const self = this;\n    this._bparser = new StreamSearch(\"\\r\\n--\" + boundary);\n    this._bparser.on(\"info\", function(isMatch, data, start, end) {\n        self._oninfo(isMatch, data, start, end);\n    });\n};\nDicer.prototype._ignore = function() {\n    if (this._part && !this._ignoreData) {\n        this._ignoreData = true;\n        this._part.on(\"error\", EMPTY_FN);\n        // we must perform some kind of read on the stream even though we are\n        // ignoring the data, otherwise node's Readable stream will not emit 'end'\n        // after pushing null to the stream\n        this._part.resume();\n    }\n};\nDicer.prototype._oninfo = function(isMatch, data, start, end) {\n    let buf;\n    const self = this;\n    let i = 0;\n    let r;\n    let shouldWriteMore = true;\n    if (!this._part && this._justMatched && data) {\n        while(this._dashes < 2 && start + i < end){\n            if (data[start + i] === DASH) {\n                ++i;\n                ++this._dashes;\n            } else {\n                if (this._dashes) {\n                    buf = B_ONEDASH;\n                }\n                this._dashes = 0;\n                break;\n            }\n        }\n        if (this._dashes === 2) {\n            if (start + i < end && this._events.trailer) {\n                this.emit(\"trailer\", data.slice(start + i, end));\n            }\n            this.reset();\n            this._finished = true;\n            // no more parts will be added\n            if (self._parts === 0) {\n                self._realFinish = true;\n                self.emit(\"finish\");\n                self._realFinish = false;\n            }\n        }\n        if (this._dashes) {\n            return;\n        }\n    }\n    if (this._justMatched) {\n        this._justMatched = false;\n    }\n    if (!this._part) {\n        this._part = new PartStream(this._partOpts);\n        this._part._read = function(n) {\n            self._unpause();\n        };\n        if (this._isPreamble && this._events.preamble) {\n            this.emit(\"preamble\", this._part);\n        } else if (this._isPreamble !== true && this._events.part) {\n            this.emit(\"part\", this._part);\n        } else {\n            this._ignore();\n        }\n        if (!this._isPreamble) {\n            this._inHeader = true;\n        }\n    }\n    if (data && start < end && !this._ignoreData) {\n        if (this._isPreamble || !this._inHeader) {\n            if (buf) {\n                shouldWriteMore = this._part.push(buf);\n            }\n            shouldWriteMore = this._part.push(data.slice(start, end));\n            if (!shouldWriteMore) {\n                this._pause = true;\n            }\n        } else if (!this._isPreamble && this._inHeader) {\n            if (buf) {\n                this._hparser.push(buf);\n            }\n            r = this._hparser.push(data.slice(start, end));\n            if (!this._inHeader && r !== undefined && r < end) {\n                this._oninfo(false, data, start + r, end);\n            }\n        }\n    }\n    if (isMatch) {\n        this._hparser.reset();\n        if (this._isPreamble) {\n            this._isPreamble = false;\n        } else {\n            if (start !== end) {\n                ++this._parts;\n                this._part.on(\"end\", function() {\n                    if (--self._parts === 0) {\n                        if (self._finished) {\n                            self._realFinish = true;\n                            self.emit(\"finish\");\n                            self._realFinish = false;\n                        } else {\n                            self._unpause();\n                        }\n                    }\n                });\n            }\n        }\n        this._part.push(null);\n        this._part = undefined;\n        this._ignoreData = false;\n        this._justMatched = true;\n        this._dashes = 0;\n    }\n};\nDicer.prototype._unpause = function() {\n    if (!this._pause) {\n        return;\n    }\n    this._pause = false;\n    if (this._cb) {\n        const cb = this._cb;\n        this._cb = undefined;\n        cb();\n    }\n};\nmodule.exports = Dicer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2RlcHMvZGljZXIvbGliL0RpY2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsaUJBQWlCQyxnRUFBK0I7QUFDdEQsTUFBTUUsV0FBV0YsNERBQTZCO0FBRTlDLE1BQU1HLGVBQWVILG1CQUFPQSxDQUFDO0FBRTdCLE1BQU1JLGFBQWFKLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1LLGVBQWVMLG1CQUFPQSxDQUFDO0FBRTdCLE1BQU1NLE9BQU87QUFDYixNQUFNQyxZQUFZQyxPQUFPQyxJQUFJLENBQUM7QUFDOUIsTUFBTUMsU0FBU0YsT0FBT0MsSUFBSSxDQUFDO0FBQzNCLE1BQU1FLFdBQVcsWUFBYTtBQUU5QixTQUFTQyxNQUFPQyxHQUFHO0lBQ2pCLElBQUksQ0FBRSxLQUFJLFlBQVlELEtBQUksR0FBSTtRQUFFLE9BQU8sSUFBSUEsTUFBTUM7SUFBSztJQUN0RGQsZUFBZWUsSUFBSSxDQUFDLElBQUksRUFBRUQ7SUFFMUIsSUFBSSxDQUFDQSxPQUFRLENBQUNBLElBQUlFLFdBQVcsSUFBSSxPQUFPRixJQUFJRyxRQUFRLEtBQUssVUFBVztRQUFFLE1BQU0sSUFBSUMsVUFBVTtJQUFxQjtJQUUvRyxJQUFJLE9BQU9KLElBQUlHLFFBQVEsS0FBSyxVQUFVO1FBQUUsSUFBSSxDQUFDRSxXQUFXLENBQUNMLElBQUlHLFFBQVE7SUFBRSxPQUFPO1FBQUUsSUFBSSxDQUFDRyxRQUFRLEdBQUdDO0lBQVU7SUFFMUcsSUFBSSxDQUFDQyxZQUFZLEdBQUdSLElBQUlFLFdBQVc7SUFFbkMsSUFBSSxDQUFDTyxPQUFPLEdBQUc7SUFDZixJQUFJLENBQUNDLE1BQU0sR0FBRztJQUNkLElBQUksQ0FBQ0MsU0FBUyxHQUFHO0lBQ2pCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO0lBQ25CLElBQUksQ0FBQ0MsV0FBVyxHQUFHO0lBQ25CLElBQUksQ0FBQ0MsWUFB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QUksSUFBSSxDQUFDTCxHQUFHLEVBQUU7UUFDWixNQUFNdUIsS0FBSyxJQUFJLENBQUN2QixHQUFHO1FBQ25CLElBQUksQ0FBQ0EsR0FBRyxHQUFHWDtRQUNYa0M7SUFDRjtBQUNGO0FBRUFxQixPQUFPQyxPQUFPLEdBQUdoRSIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2RlcHMvZGljZXIvbGliL0RpY2VyLmpzP2ViNmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFdyaXRhYmxlU3RyZWFtID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKS5Xcml0YWJsZVxuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCdub2RlOnV0aWwnKS5pbmhlcml0c1xuXG5jb25zdCBTdHJlYW1TZWFyY2ggPSByZXF1aXJlKCcuLi8uLi9zdHJlYW1zZWFyY2gvc2JtaCcpXG5cbmNvbnN0IFBhcnRTdHJlYW0gPSByZXF1aXJlKCcuL1BhcnRTdHJlYW0nKVxuY29uc3QgSGVhZGVyUGFyc2VyID0gcmVxdWlyZSgnLi9IZWFkZXJQYXJzZXInKVxuXG5jb25zdCBEQVNIID0gNDVcbmNvbnN0IEJfT05FREFTSCA9IEJ1ZmZlci5mcm9tKCctJylcbmNvbnN0IEJfQ1JMRiA9IEJ1ZmZlci5mcm9tKCdcXHJcXG4nKVxuY29uc3QgRU1QVFlfRk4gPSBmdW5jdGlvbiAoKSB7fVxuXG5mdW5jdGlvbiBEaWNlciAoY2ZnKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEaWNlcikpIHsgcmV0dXJuIG5ldyBEaWNlcihjZmcpIH1cbiAgV3JpdGFibGVTdHJlYW0uY2FsbCh0aGlzLCBjZmcpXG5cbiAgaWYgKCFjZmcgfHwgKCFjZmcuaGVhZGVyRmlyc3QgJiYgdHlwZW9mIGNmZy5ib3VuZGFyeSAhPT0gJ3N0cmluZycpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvdW5kYXJ5IHJlcXVpcmVkJykgfVxuXG4gIGlmICh0eXBlb2YgY2ZnLmJvdW5kYXJ5ID09PSAnc3RyaW5nJykgeyB0aGlzLnNldEJvdW5kYXJ5KGNmZy5ib3VuZGFyeSkgfSBlbHNlIHsgdGhpcy5fYnBhcnNlciA9IHVuZGVmaW5lZCB9XG5cbiAgdGhpcy5faGVhZGVyRmlyc3QgPSBjZmcuaGVhZGVyRmlyc3RcblxuICB0aGlzLl9kYXNoZXMgPSAwXG4gIHRoaXMuX3BhcnRzID0gMFxuICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlXG4gIHRoaXMuX3JlYWxGaW5pc2ggPSBmYWxzZVxuICB0aGlzLl9pc1ByZWFtYmxlID0gdHJ1ZVxuICB0aGlzLl9qdXN0TWF0Y2hlZCA9IGZhbHNlXG4gIHRoaXMuX2ZpcnN0V3JpdGUgPSB0cnVlXG4gIHRoaXMuX2luSGVhZGVyID0gdHJ1ZVxuICB0aGlzLl9wYXJ0ID0gdW5kZWZpbmVkXG4gIHRoaXMuX2NiID0gdW5kZWZpbmVkXG4gIHRoaXMuX2lnbm9yZURhdGEgPSBmYWxzZVxuICB0aGlzLl9wYXJ0T3B0cyA9IHsgaGlnaFdhdGVyTWFyazogY2ZnLnBhcnRId20gfVxuICB0aGlzLl9wYXVzZSA9IGZhbHNlXG5cbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgdGhpcy5faHBhcnNlciA9IG5ldyBIZWFkZXJQYXJzZXIoY2ZnKVxuICB0aGlzLl9ocGFyc2VyLm9uKCdoZWFkZXInLCBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgc2VsZi5faW5IZWFkZXIgPSBmYWxzZVxuICAgIHNlbGYuX3BhcnQuZW1pdCgnaGVhZGVyJywgaGVhZGVyKVxuICB9KVxufVxuaW5oZXJpdHMoRGljZXIsIFdyaXRhYmxlU3RyZWFtKVxuXG5EaWNlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldikge1xuICBpZiAoZXYgPT09ICdmaW5pc2gnICYmICF0aGlzLl9yZWFsRmluaXNoKSB7XG4gICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBtdWx0aXBhcnQgZGF0YScpKVxuICAgICAgICBpZiAoc2VsZi5fcGFydCAmJiAhc2VsZi5faWdub3JlRGF0YSkge1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSAoc2VsZi5faXNQcmVhbWJsZSA/ICdQcmVhbWJsZScgOiAnUGFydCcpXG4gICAgICAgICAgc2VsZi5fcGFydC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcih0eXBlICsgJyB0ZXJtaW5hdGVkIGVhcmx5IGR1ZSB0byB1bmV4cGVjdGVkIGVuZCBvZiBtdWx0aXBhcnQgZGF0YScpKVxuICAgICAgICAgIHNlbGYuX3BhcnQucHVzaChudWxsKVxuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5fcmVhbEZpbmlzaCA9IHRydWVcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJylcbiAgICAgICAgICAgIHNlbGYuX3JlYWxGaW5pc2ggPSBmYWxzZVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fcmVhbEZpbmlzaCA9IHRydWVcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKVxuICAgICAgICBzZWxmLl9yZWFsRmluaXNoID0gZmFsc2VcbiAgICAgIH0pXG4gICAgfVxuICB9IGVsc2UgeyBXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbn1cblxuRGljZXIucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2IpIHtcbiAgLy8gaWdub3JlIHVuZXhwZWN0ZWQgZGF0YSAoZS5nLiBleHRyYSB0cmFpbGVyIGRhdGEgYWZ0ZXIgZmluaXNoZWQpXG4gIGlmICghdGhpcy5faHBhcnNlciAmJiAhdGhpcy5fYnBhcnNlcikgeyByZXR1cm4gY2IoKSB9XG5cbiAgaWYgKHRoaXMuX2hlYWRlckZpcnN0ICYmIHRoaXMuX2lzUHJlYW1ibGUpIHtcbiAgICBpZiAoIXRoaXMuX3BhcnQpIHtcbiAgICAgIHRoaXMuX3BhcnQgPSBuZXcgUGFydFN0cmVhbSh0aGlzLl9wYXJ0T3B0cylcbiAgICAgIGlmICh0aGlzLl9ldmVudHMucHJlYW1ibGUpIHsgdGhpcy5lbWl0KCdwcmVhbWJsZScsIHRoaXMuX3BhcnQpIH0gZWxzZSB7IHRoaXMuX2lnbm9yZSgpIH1cbiAgICB9XG4gICAgY29uc3QgciA9IHRoaXMuX2hwYXJzZXIucHVzaChkYXRhKVxuICAgIGlmICghdGhpcy5faW5IZWFkZXIgJiYgciAhPT0gdW5kZWZpbmVkICYmIHIgPCBkYXRhLmxlbmd0aCkgeyBkYXRhID0gZGF0YS5zbGljZShyKSB9IGVsc2UgeyByZXR1cm4gY2IoKSB9XG4gIH1cblxuICAvLyBhbGxvd3MgZm9yIFwiZWFzaWVyXCIgdGVzdGluZ1xuICBpZiAodGhpcy5fZmlyc3RXcml0ZSkge1xuICAgIHRoaXMuX2JwYXJzZXIucHVzaChCX0NSTEYpXG4gICAgdGhpcy5fZmlyc3RXcml0ZSA9IGZhbHNlXG4gIH1cblxuICB0aGlzLl9icGFyc2VyLnB1c2goZGF0YSlcblxuICBpZiAodGhpcy5fcGF1c2UpIHsgdGhpcy5fY2IgPSBjYiB9IGVsc2UgeyBjYigpIH1cbn1cblxuRGljZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9wYXJ0ID0gdW5kZWZpbmVkXG4gIHRoaXMuX2JwYXJzZXIgPSB1bmRlZmluZWRcbiAgdGhpcy5faHBhcnNlciA9IHVuZGVmaW5lZFxufVxuXG5EaWNlci5wcm90b3R5cGUuc2V0Qm91bmRhcnkgPSBmdW5jdGlvbiAoYm91bmRhcnkpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgdGhpcy5fYnBhcnNlciA9IG5ldyBTdHJlYW1TZWFyY2goJ1xcclxcbi0tJyArIGJvdW5kYXJ5KVxuICB0aGlzLl9icGFyc2VyLm9uKCdpbmZvJywgZnVuY3Rpb24gKGlzTWF0Y2gsIGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBzZWxmLl9vbmluZm8oaXNNYXRjaCwgZGF0YSwgc3RhcnQsIGVuZClcbiAgfSlcbn1cblxuRGljZXIucHJvdG90eXBlLl9pZ25vcmUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9wYXJ0ICYmICF0aGlzLl9pZ25vcmVEYXRhKSB7XG4gICAgdGhpcy5faWdub3JlRGF0YSA9IHRydWVcbiAgICB0aGlzLl9wYXJ0Lm9uKCdlcnJvcicsIEVNUFRZX0ZOKVxuICAgIC8vIHdlIG11c3QgcGVyZm9ybSBzb21lIGtpbmQgb2YgcmVhZCBvbiB0aGUgc3RyZWFtIGV2ZW4gdGhvdWdoIHdlIGFyZVxuICAgIC8vIGlnbm9yaW5nIHRoZSBkYXRhLCBvdGhlcndpc2Ugbm9kZSdzIFJlYWRhYmxlIHN0cmVhbSB3aWxsIG5vdCBlbWl0ICdlbmQnXG4gICAgLy8gYWZ0ZXIgcHVzaGluZyBudWxsIHRvIHRoZSBzdHJlYW1cbiAgICB0aGlzLl9wYXJ0LnJlc3VtZSgpXG4gIH1cbn1cblxuRGljZXIucHJvdG90eXBlLl9vbmluZm8gPSBmdW5jdGlvbiAoaXNNYXRjaCwgZGF0YSwgc3RhcnQsIGVuZCkge1xuICBsZXQgYnVmOyBjb25zdCBzZWxmID0gdGhpczsgbGV0IGkgPSAwOyBsZXQgcjsgbGV0IHNob3VsZFdyaXRlTW9yZSA9IHRydWVcblxuICBpZiAoIXRoaXMuX3BhcnQgJiYgdGhpcy5fanVzdE1hdGNoZWQgJiYgZGF0YSkge1xuICAgIHdoaWxlICh0aGlzLl9kYXNoZXMgPCAyICYmIChzdGFydCArIGkpIDwgZW5kKSB7XG4gICAgICBpZiAoZGF0YVtzdGFydCArIGldID09PSBEQVNIKSB7XG4gICAgICAgICsraVxuICAgICAgICArK3RoaXMuX2Rhc2hlc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rhc2hlcykgeyBidWYgPSBCX09ORURBU0ggfVxuICAgICAgICB0aGlzLl9kYXNoZXMgPSAwXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9kYXNoZXMgPT09IDIpIHtcbiAgICAgIGlmICgoc3RhcnQgKyBpKSA8IGVuZCAmJiB0aGlzLl9ldmVudHMudHJhaWxlcikgeyB0aGlzLmVtaXQoJ3RyYWlsZXInLCBkYXRhLnNsaWNlKHN0YXJ0ICsgaSwgZW5kKSkgfVxuICAgICAgdGhpcy5yZXNldCgpXG4gICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWVcbiAgICAgIC8vIG5vIG1vcmUgcGFydHMgd2lsbCBiZSBhZGRlZFxuICAgICAgaWYgKHNlbGYuX3BhcnRzID09PSAwKSB7XG4gICAgICAgIHNlbGYuX3JlYWxGaW5pc2ggPSB0cnVlXG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJylcbiAgICAgICAgc2VsZi5fcmVhbEZpbmlzaCA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9kYXNoZXMpIHsgcmV0dXJuIH1cbiAgfVxuICBpZiAodGhpcy5fanVzdE1hdGNoZWQpIHsgdGhpcy5fanVzdE1hdGNoZWQgPSBmYWxzZSB9XG4gIGlmICghdGhpcy5fcGFydCkge1xuICAgIHRoaXMuX3BhcnQgPSBuZXcgUGFydFN0cmVhbSh0aGlzLl9wYXJ0T3B0cylcbiAgICB0aGlzLl9wYXJ0Ll9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgIHNlbGYuX3VucGF1c2UoKVxuICAgIH1cbiAgICBpZiAodGhpcy5faXNQcmVhbWJsZSAmJiB0aGlzLl9ldmVudHMucHJlYW1ibGUpIHsgdGhpcy5lbWl0KCdwcmVhbWJsZScsIHRoaXMuX3BhcnQpIH0gZWxzZSBpZiAodGhpcy5faXNQcmVhbWJsZSAhPT0gdHJ1ZSAmJiB0aGlzLl9ldmVudHMucGFydCkgeyB0aGlzLmVtaXQoJ3BhcnQnLCB0aGlzLl9wYXJ0KSB9IGVsc2UgeyB0aGlzLl9pZ25vcmUoKSB9XG4gICAgaWYgKCF0aGlzLl9pc1ByZWFtYmxlKSB7IHRoaXMuX2luSGVhZGVyID0gdHJ1ZSB9XG4gIH1cbiAgaWYgKGRhdGEgJiYgc3RhcnQgPCBlbmQgJiYgIXRoaXMuX2lnbm9yZURhdGEpIHtcbiAgICBpZiAodGhpcy5faXNQcmVhbWJsZSB8fCAhdGhpcy5faW5IZWFkZXIpIHtcbiAgICAgIGlmIChidWYpIHsgc2hvdWxkV3JpdGVNb3JlID0gdGhpcy5fcGFydC5wdXNoKGJ1ZikgfVxuICAgICAgc2hvdWxkV3JpdGVNb3JlID0gdGhpcy5fcGFydC5wdXNoKGRhdGEuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gICAgICBpZiAoIXNob3VsZFdyaXRlTW9yZSkgeyB0aGlzLl9wYXVzZSA9IHRydWUgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzUHJlYW1ibGUgJiYgdGhpcy5faW5IZWFkZXIpIHtcbiAgICAgIGlmIChidWYpIHsgdGhpcy5faHBhcnNlci5wdXNoKGJ1ZikgfVxuICAgICAgciA9IHRoaXMuX2hwYXJzZXIucHVzaChkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICAgICAgaWYgKCF0aGlzLl9pbkhlYWRlciAmJiByICE9PSB1bmRlZmluZWQgJiYgciA8IGVuZCkgeyB0aGlzLl9vbmluZm8oZmFsc2UsIGRhdGEsIHN0YXJ0ICsgciwgZW5kKSB9XG4gICAgfVxuICB9XG4gIGlmIChpc01hdGNoKSB7XG4gICAgdGhpcy5faHBhcnNlci5yZXNldCgpXG4gICAgaWYgKHRoaXMuX2lzUHJlYW1ibGUpIHsgdGhpcy5faXNQcmVhbWJsZSA9IGZhbHNlIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgICArK3RoaXMuX3BhcnRzXG4gICAgICAgIHRoaXMuX3BhcnQub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoLS1zZWxmLl9wYXJ0cyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgIHNlbGYuX3JlYWxGaW5pc2ggPSB0cnVlXG4gICAgICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJylcbiAgICAgICAgICAgICAgc2VsZi5fcmVhbEZpbmlzaCA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLl91bnBhdXNlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3BhcnQucHVzaChudWxsKVxuICAgIHRoaXMuX3BhcnQgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9pZ25vcmVEYXRhID0gZmFsc2VcbiAgICB0aGlzLl9qdXN0TWF0Y2hlZCA9IHRydWVcbiAgICB0aGlzLl9kYXNoZXMgPSAwXG4gIH1cbn1cblxuRGljZXIucHJvdG90eXBlLl91bnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX3BhdXNlKSB7IHJldHVybiB9XG5cbiAgdGhpcy5fcGF1c2UgPSBmYWxzZVxuICBpZiAodGhpcy5fY2IpIHtcbiAgICBjb25zdCBjYiA9IHRoaXMuX2NiXG4gICAgdGhpcy5fY2IgPSB1bmRlZmluZWRcbiAgICBjYigpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaWNlclxuIl0sIm5hbWVzIjpbIldyaXRhYmxlU3RyZWFtIiwicmVxdWlyZSIsIldyaXRhYmxlIiwiaW5oZXJpdHMiLCJTdHJlYW1TZWFyY2giLCJQYXJ0U3RyZWFtIiwiSGVhZGVyUGFyc2VyIiwiREFTSCIsIkJfT05FREFTSCIsIkJ1ZmZlciIsImZyb20iLCJCX0NSTEYiLCJFTVBUWV9GTiIsIkRpY2VyIiwiY2ZnIiwiY2FsbCIsImhlYWRlckZpcnN0IiwiYm91bmRhcnkiLCJUeXBlRXJyb3IiLCJzZXRCb3VuZGFyeSIsIl9icGFyc2VyIiwidW5kZWZpbmVkIiwiX2hlYWRlckZpcnN0IiwiX2Rhc2hlcyIsIl9wYXJ0cyIsIl9maW5pc2hlZCIsIl9yZWFsRmluaXNoIiwiX2lzUHJlYW1ibGUiLCJfanVzdE1hdGNoZWQiLCJfZmlyc3RXcml0ZSIsIl9pbkhlYWRlciIsIl9wYXJ0IiwiX2NiIiwiX2lnbm9yZURhdGEiLCJfcGFydE9wdHMiLCJoaWdoV2F0ZXJNYXJrIiwicGFydEh3bSIsIl9wYXVzZSIsInNlbGYiLCJfaHBhcnNlciIsIm9uIiwiaGVhZGVyIiwiZW1pdCIsInByb3RvdHlwZSIsImV2IiwicHJvY2VzcyIsIm5leHRUaWNrIiwiRXJyb3IiLCJ0eXBlIiwicHVzaCIsImFwcGx5IiwiYXJndW1lbnRzIiwiX3dyaXRlIiwiZGF0YSIsImVuY29kaW5nIiwiY2IiLCJfZXZlbnRzIiwicHJlYW1ibGUiLCJfaWdub3JlIiwiciIsImxlbmd0aCIsInNsaWNlIiwicmVzZXQiLCJpc01hdGNoIiwic3RhcnQiLCJlbmQiLCJfb25pbmZvIiwicmVzdW1lIiwiYnVmIiwiaSIsInNob3VsZFdyaXRlTW9yZSIsInRyYWlsZXIiLCJfcmVhZCIsIm4iLCJfdW5wYXVzZSIsInBhcnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = (__webpack_require__(/*! node:events */ \"node:events\").EventEmitter);\nconst inherits = (__webpack_require__(/*! node:util */ \"node:util\").inherits);\nconst getLimit = __webpack_require__(/*! ../../../lib/utils/getLimit */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/getLimit.js\");\nconst StreamSearch = __webpack_require__(/*! ../../streamsearch/sbmh */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js\");\nconst B_DCRLF = Buffer.from(\"\\r\\n\\r\\n\");\nconst RE_CRLF = /\\r\\n/g;\nconst RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/ // eslint-disable-line no-control-regex\n;\nfunction HeaderParser(cfg) {\n    EventEmitter.call(this);\n    cfg = cfg || {};\n    const self = this;\n    this.nread = 0;\n    this.maxed = false;\n    this.npairs = 0;\n    this.maxHeaderPairs = getLimit(cfg, \"maxHeaderPairs\", 2000);\n    this.maxHeaderSize = getLimit(cfg, \"maxHeaderSize\", 80 * 1024);\n    this.buffer = \"\";\n    this.header = {};\n    this.finished = false;\n    this.ss = new StreamSearch(B_DCRLF);\n    this.ss.on(\"info\", function(isMatch, data, start, end) {\n        if (data && !self.maxed) {\n            if (self.nread + end - start >= self.maxHeaderSize) {\n                end = self.maxHeaderSize - self.nread + start;\n                self.nread = self.maxHeaderSize;\n                self.maxed = true;\n            } else {\n                self.nread += end - start;\n            }\n            self.buffer += data.toString(\"binary\", start, end);\n        }\n        if (isMatch) {\n            self._finish();\n        }\n    });\n}\ninherits(HeaderParser, EventEmitter);\nHeaderParser.prototype.push = function(data) {\n    const r = this.ss.push(data);\n    if (this.finished) {\n        return r;\n    }\n};\nHeaderParser.prototype.reset = function() {\n    this.finished = false;\n    this.buffer = \"\";\n    this.header = {};\n    this.ss.reset();\n};\nHeaderParser.prototype._finish = function() {\n    if (this.buffer) {\n        this._parseHeader();\n    }\n    this.ss.matches = this.ss.maxMatches;\n    const header = this.header;\n    this.header = {};\n    this.buffer = \"\";\n    this.finished = true;\n    this.nread = this.npairs = 0;\n    this.maxed = false;\n    this.emit(\"header\", header);\n};\nHeaderParser.prototype._parseHeader = function() {\n    if (this.npairs === this.maxHeaderPairs) {\n        return;\n    }\n    const lines = this.buffer.split(RE_CRLF);\n    const len = lines.length;\n    let m, h;\n    for(var i = 0; i < len; ++i){\n        if (lines[i].length === 0) {\n            continue;\n        }\n        if (lines[i][0] === \"\t\" || lines[i][0] === \" \") {\n            // folded header content\n            // RFC2822 says to just remove the CRLF and not the whitespace following\n            // it, so we follow the RFC and include the leading whitespace ...\n            if (h) {\n                this.header[h][this.header[h].length - 1] += lines[i];\n                continue;\n            }\n        }\n        const posColon = lines[i].indexOf(\":\");\n        if (posColon === -1 || posColon === 0) {\n            return;\n        }\n        m = RE_HDR.exec(lines[i]);\n        h = m[1].toLowerCase();\n        this.header[h] = this.header[h] || [];\n        this.header[h].push(m[2] || \"\");\n        if (++this.npairs === this.maxHeaderPairs) {\n            break;\n        }\n    }\n};\nmodule.exports = HeaderParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2RlcHMvZGljZXIvbGliL0hlYWRlclBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGVBQWVDLG9FQUFtQztBQUN4RCxNQUFNQyxXQUFXRCw0REFBNkI7QUFDOUMsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUM7QUFFekIsTUFBTUcsZUFBZUgsbUJBQU9BLENBQUM7QUFFN0IsTUFBTUksVUFBVUMsT0FBT0MsSUFBSSxDQUFDO0FBQzVCLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsU0FBUyxrQ0FBa0MsdUNBQXVDOztBQUV4RixTQUFTQyxhQUFjQyxHQUFHO0lBQ3hCWCxhQUFhWSxJQUFJLENBQUMsSUFBSTtJQUV0QkQsTUFBTUEsT0FBTyxDQUFDO0lBQ2QsTUFBTUUsT0FBTyxJQUFJO0lBQ2pCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0lBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLE1BQU0sR0FBRztJQUNkLElBQUksQ0FBQ0MsY0FBYyxHQUFHZCxTQUFTUSxLQUFLLGtCQUFrQjtJQUN0RCxJQUFJLENBQUNPLGFBQWEsR0FBR2YsU0FBU1EsS0FBSyxpQkFBaUIsS0FBSztJQUN6RCxJQUFJLENBQUNRLE1BQU0sR0FBRztJQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUM7SUFDZixJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNoQixJQUFJLENBQUNDLEVBQUUsR0FBRyxJQUFJbEIsYUFBYUM7SUFDM0IsSUFBSSxDQUFDaUIsRUFBRSxDQUFDQyxFQUFFLENBQUMsUUFBUSxTQUFVQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxHQUFHO1FBQ3BELElBQUlGLFFBQVEsQ0FBQ1osS0FBS0UsS0FBSyxFQUFFO1lBQ3ZCLElBQUlGLEtBQUtDLEtBQUssR0FBR2EsTUFBTUQsU0FBU2IsS0FBS0ssYUFBYSxFQUFFO2dCQUNsRFMsTUFBTWQsS0FBS0ssYUFBYSxHQUFHTCxLQUFLQyxLQUFLLEdBQUdZO2dCQUN4Q2IsS0FBS0MsS0FBSyxHQUFHRCxLQUFLSyxhQUFhO2dCQUMvQkwsS0FBS0UsS0FBSyxHQUFHO1lBQ2YsT0FBTztnQkFBRUYsS0FBS0MsS0FBSyxJQUFLYSxNQUFNRDtZQUFPO1lBRXJDYixLQUFLTSxNQUFNLElBQUlNLEtBQUtHLFFBQVEsQ0FBQyxVQUFVRixPQUFPQztRQUNoRDtRQUNBLElBQUlILFNBQVM7WUFBRVgsS0FBS2dCLE9BQU87UUFBRztJQUNoQztBQUNGO0FBQ0EzQixTQUFTUSxjQUFjVjtBQUV2QlUsYUFBYW9CLFNBQVMsQ0FBQ0MsSUFBSSxHQUFHLFNBQVVOLElBQUk7SUFDMUMsTUFBTU8sSUFBSSxJQUFJLENBQUNWLEVBQUUsQ0FBQ1MsSUFBSSxDQUFDTjtJQUN2QixJQUFJLElBQUksQ0FBQ0osUUFBUSxFQUFFO1FBQUUsT0FBT1c7SUFBRTtBQUNoQztBQUVBdEIsYUFBYW9CLFNBQVMsQ0FBQ0csS0FBSyxHQUFHO0lBQzdCLElBQUksQ0FBQ1osUUFBUSxHQUFHO0lBQ2hCLElBQUksQ0FBQ0YsTUFBTSxHQUFHO0lBQ2QsSUFBSSxDQUFDQyxNQUFNLEdBQUcsQ0FBQztJQUNmLElBQUksQ0FBQ0UsRUFBRSxDQUFDVyxLQUFLO0FBQ2Y7QUFFQXZCLGFBQWFvQixTQUFTLENBQUNELE9BQU8sR0FBRztJQUMvQixJQUFJLElBQUksQ0FBQ1YsTUFBTSxFQUFFO1FBQUUsSUFBSSxDQUFDZSxZQUFZO0lBQUc7SUFDdkMsSUFBSSxDQUFDWixFQUFFLENBQUNhLE9BQU8sR0FBRyxJQUFJLENBQUNiLEVBQUUsQ0FBQ2MsVUFBVTtJQUNwQyxNQUFNaEIsU0FBUyxJQUFJLENBQUNBLE1BQU07SUFDMUIsSUFBSSxDQUFDQSxNQUFNLEdBQUcsQ0FBQztJQUNmLElBQUksQ0FBQ0QsTUFBTSxHQUFHO0lBQ2QsSUFBSSxDQUFDRSxRQUFRLEdBQUc7SUFDaEIsSUFBSSxDQUFDUCxLQUFLLEdBQUcsSUFBSSxDQUFDRSxNQUFNLEdBQUc7SUFDM0IsSUFBSSxDQUFDRCxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNzQixJQUFJLENBQUMsVUFBVWpCO0FBQ3RCO0FBRUFWLGFBQWFvQixTQUFTLENBQUNJLFlBQVksR0FBRztJQUNwQyxJQUFJLElBQUksQ0FBQ2xCLE1BQU0sS0FBSyxJQUFJLENBQUNDLGNBQWMsRUFBRTtRQUFFO0lBQU87SUFFbEQsTUFBTXFCLFFBQVEsSUFBSSxDQUFDbkIsTUFBTSxDQUFDb0IsS0FBSyxDQUFDL0I7SUFDaEMsTUFBTWdDLE1BQU1GLE1BQU1HLE1BQU07SUFDeEIsSUFBSUMsR0FBR0M7SUFFUCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosS0FBSyxFQUFFSSxFQUFHO1FBQzVCLElBQUlOLEtBQUssQ0FBQ00sRUFBRSxDQUFDSCxNQUFNLEtBQUssR0FBRztZQUFFO1FBQVM7UUFDdEMsSUFBSUgsS0FBSyxDQUFDTSxFQUFFLENBQUMsRUFBRSxLQUFLLE9BQVFOLEtBQUssQ0FBQ00sRUFBRSxDQUFDLEVBQUUsS0FBSyxLQUFLO1lBQy9DLHdCQUF3QjtZQUN4Qix3RUFBd0U7WUFDeEUsa0VBQWtFO1lBQ2xFLElBQUlELEdBQUc7Z0JBQ0wsSUFBSSxDQUFDdkIsTUFBTSxDQUFDdUIsRUFBRSxDQUFDLElBQUksQ0FBQ3ZCLE1BQU0sQ0FBQ3VCLEVBQUUsQ0FBQ0YsTUFBTSxHQUFHLEVBQUUsSUFBSUgsS0FBSyxDQUFDTSxFQUFFO2dCQUNyRDtZQUNGO1FBQ0Y7UUFFQSxNQUFNQyxXQUFXUCxLQUFLLENBQUNNLEVBQUUsQ0FBQ0UsT0FBTyxDQUFDO1FBQ2xDLElBQ0VELGFBQWEsQ0FBQyxLQUNkQSxhQUFhLEdBQ2I7WUFDQTtRQUNGO1FBQ0FILElBQUlqQyxPQUFPc0MsSUFBSSxDQUFDVCxLQUFLLENBQUNNLEVBQUU7UUFDeEJELElBQUlELENBQUMsQ0FBQyxFQUFFLENBQUNNLFdBQVc7UUFDcEIsSUFBSSxDQUFDNUIsTUFBTSxDQUFDdUIsRUFBRSxHQUFHLElBQUksQ0FBQ3ZCLE1BQU0sQ0FBQ3VCLEVBQUUsSUFBSSxFQUFFO1FBQ3JDLElBQUksQ0FBQ3ZCLE1BQU0sQ0FBQ3VCLEVBQUUsQ0FBQ1osSUFBSSxDQUFFVyxDQUFDLENBQUMsRUFBRSxJQUFJO1FBQzdCLElBQUksRUFBRSxJQUFJLENBQUMxQixNQUFNLEtBQUssSUFBSSxDQUFDQyxjQUFjLEVBQUU7WUFBRTtRQUFNO0lBQ3JEO0FBQ0Y7QUFFQWdDLE9BQU9DLE9BQU8sR0FBR3hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL25vZGVfbW9kdWxlcy9AZmFzdGlmeS9idXNib3kvZGVwcy9kaWNlci9saWIvSGVhZGVyUGFyc2VyLmpzP2Y5NWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBpbmhlcml0cyA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpLmluaGVyaXRzXG5jb25zdCBnZXRMaW1pdCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi91dGlscy9nZXRMaW1pdCcpXG5cbmNvbnN0IFN0cmVhbVNlYXJjaCA9IHJlcXVpcmUoJy4uLy4uL3N0cmVhbXNlYXJjaC9zYm1oJylcblxuY29uc3QgQl9EQ1JMRiA9IEJ1ZmZlci5mcm9tKCdcXHJcXG5cXHJcXG4nKVxuY29uc3QgUkVfQ1JMRiA9IC9cXHJcXG4vZ1xuY29uc3QgUkVfSERSID0gL14oW146XSspOlsgXFx0XT8oW1xceDAwLVxceEZGXSspPyQvIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuXG5mdW5jdGlvbiBIZWFkZXJQYXJzZXIgKGNmZykge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuXG4gIGNmZyA9IGNmZyB8fCB7fVxuICBjb25zdCBzZWxmID0gdGhpc1xuICB0aGlzLm5yZWFkID0gMFxuICB0aGlzLm1heGVkID0gZmFsc2VcbiAgdGhpcy5ucGFpcnMgPSAwXG4gIHRoaXMubWF4SGVhZGVyUGFpcnMgPSBnZXRMaW1pdChjZmcsICdtYXhIZWFkZXJQYWlycycsIDIwMDApXG4gIHRoaXMubWF4SGVhZGVyU2l6ZSA9IGdldExpbWl0KGNmZywgJ21heEhlYWRlclNpemUnLCA4MCAqIDEwMjQpXG4gIHRoaXMuYnVmZmVyID0gJydcbiAgdGhpcy5oZWFkZXIgPSB7fVxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2VcbiAgdGhpcy5zcyA9IG5ldyBTdHJlYW1TZWFyY2goQl9EQ1JMRilcbiAgdGhpcy5zcy5vbignaW5mbycsIGZ1bmN0aW9uIChpc01hdGNoLCBkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKGRhdGEgJiYgIXNlbGYubWF4ZWQpIHtcbiAgICAgIGlmIChzZWxmLm5yZWFkICsgZW5kIC0gc3RhcnQgPj0gc2VsZi5tYXhIZWFkZXJTaXplKSB7XG4gICAgICAgIGVuZCA9IHNlbGYubWF4SGVhZGVyU2l6ZSAtIHNlbGYubnJlYWQgKyBzdGFydFxuICAgICAgICBzZWxmLm5yZWFkID0gc2VsZi5tYXhIZWFkZXJTaXplXG4gICAgICAgIHNlbGYubWF4ZWQgPSB0cnVlXG4gICAgICB9IGVsc2UgeyBzZWxmLm5yZWFkICs9IChlbmQgLSBzdGFydCkgfVxuXG4gICAgICBzZWxmLmJ1ZmZlciArPSBkYXRhLnRvU3RyaW5nKCdiaW5hcnknLCBzdGFydCwgZW5kKVxuICAgIH1cbiAgICBpZiAoaXNNYXRjaCkgeyBzZWxmLl9maW5pc2goKSB9XG4gIH0pXG59XG5pbmhlcml0cyhIZWFkZXJQYXJzZXIsIEV2ZW50RW1pdHRlcilcblxuSGVhZGVyUGFyc2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgciA9IHRoaXMuc3MucHVzaChkYXRhKVxuICBpZiAodGhpcy5maW5pc2hlZCkgeyByZXR1cm4gciB9XG59XG5cbkhlYWRlclBhcnNlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZVxuICB0aGlzLmJ1ZmZlciA9ICcnXG4gIHRoaXMuaGVhZGVyID0ge31cbiAgdGhpcy5zcy5yZXNldCgpXG59XG5cbkhlYWRlclBhcnNlci5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYnVmZmVyKSB7IHRoaXMuX3BhcnNlSGVhZGVyKCkgfVxuICB0aGlzLnNzLm1hdGNoZXMgPSB0aGlzLnNzLm1heE1hdGNoZXNcbiAgY29uc3QgaGVhZGVyID0gdGhpcy5oZWFkZXJcbiAgdGhpcy5oZWFkZXIgPSB7fVxuICB0aGlzLmJ1ZmZlciA9ICcnXG4gIHRoaXMuZmluaXNoZWQgPSB0cnVlXG4gIHRoaXMubnJlYWQgPSB0aGlzLm5wYWlycyA9IDBcbiAgdGhpcy5tYXhlZCA9IGZhbHNlXG4gIHRoaXMuZW1pdCgnaGVhZGVyJywgaGVhZGVyKVxufVxuXG5IZWFkZXJQYXJzZXIucHJvdG90eXBlLl9wYXJzZUhlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubnBhaXJzID09PSB0aGlzLm1heEhlYWRlclBhaXJzKSB7IHJldHVybiB9XG5cbiAgY29uc3QgbGluZXMgPSB0aGlzLmJ1ZmZlci5zcGxpdChSRV9DUkxGKVxuICBjb25zdCBsZW4gPSBsaW5lcy5sZW5ndGhcbiAgbGV0IG0sIGhcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdmFyXG4gICAgaWYgKGxpbmVzW2ldLmxlbmd0aCA9PT0gMCkgeyBjb250aW51ZSB9XG4gICAgaWYgKGxpbmVzW2ldWzBdID09PSAnXFx0JyB8fCBsaW5lc1tpXVswXSA9PT0gJyAnKSB7XG4gICAgICAvLyBmb2xkZWQgaGVhZGVyIGNvbnRlbnRcbiAgICAgIC8vIFJGQzI4MjIgc2F5cyB0byBqdXN0IHJlbW92ZSB0aGUgQ1JMRiBhbmQgbm90IHRoZSB3aGl0ZXNwYWNlIGZvbGxvd2luZ1xuICAgICAgLy8gaXQsIHNvIHdlIGZvbGxvdyB0aGUgUkZDIGFuZCBpbmNsdWRlIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2UgLi4uXG4gICAgICBpZiAoaCkge1xuICAgICAgICB0aGlzLmhlYWRlcltoXVt0aGlzLmhlYWRlcltoXS5sZW5ndGggLSAxXSArPSBsaW5lc1tpXVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBvc0NvbG9uID0gbGluZXNbaV0uaW5kZXhPZignOicpXG4gICAgaWYgKFxuICAgICAgcG9zQ29sb24gPT09IC0xIHx8XG4gICAgICBwb3NDb2xvbiA9PT0gMFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIG0gPSBSRV9IRFIuZXhlYyhsaW5lc1tpXSlcbiAgICBoID0gbVsxXS50b0xvd2VyQ2FzZSgpXG4gICAgdGhpcy5oZWFkZXJbaF0gPSB0aGlzLmhlYWRlcltoXSB8fCBbXVxuICAgIHRoaXMuaGVhZGVyW2hdLnB1c2goKG1bMl0gfHwgJycpKVxuICAgIGlmICgrK3RoaXMubnBhaXJzID09PSB0aGlzLm1heEhlYWRlclBhaXJzKSB7IGJyZWFrIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYWRlclBhcnNlclxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsInJlcXVpcmUiLCJpbmhlcml0cyIsImdldExpbWl0IiwiU3RyZWFtU2VhcmNoIiwiQl9EQ1JMRiIsIkJ1ZmZlciIsImZyb20iLCJSRV9DUkxGIiwiUkVfSERSIiwiSGVhZGVyUGFyc2VyIiwiY2ZnIiwiY2FsbCIsInNlbGYiLCJucmVhZCIsIm1heGVkIiwibnBhaXJzIiwibWF4SGVhZGVyUGFpcnMiLCJtYXhIZWFkZXJTaXplIiwiYnVmZmVyIiwiaGVhZGVyIiwiZmluaXNoZWQiLCJzcyIsIm9uIiwiaXNNYXRjaCIsImRhdGEiLCJzdGFydCIsImVuZCIsInRvU3RyaW5nIiwiX2ZpbmlzaCIsInByb3RvdHlwZSIsInB1c2giLCJyIiwicmVzZXQiLCJfcGFyc2VIZWFkZXIiLCJtYXRjaGVzIiwibWF4TWF0Y2hlcyIsImVtaXQiLCJsaW5lcyIsInNwbGl0IiwibGVuIiwibGVuZ3RoIiwibSIsImgiLCJpIiwicG9zQ29sb24iLCJpbmRleE9mIiwiZXhlYyIsInRvTG93ZXJDYXNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst inherits = (__webpack_require__(/*! node:util */ \"node:util\").inherits);\nconst ReadableStream = (__webpack_require__(/*! node:stream */ \"node:stream\").Readable);\nfunction PartStream(opts) {\n    ReadableStream.call(this, opts);\n}\ninherits(PartStream, ReadableStream);\nPartStream.prototype._read = function(n) {};\nmodule.exports = PartStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2RlcHMvZGljZXIvbGliL1BhcnRTdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxXQUFXQyw0REFBNkI7QUFDOUMsTUFBTUMsaUJBQWlCRCxnRUFBK0I7QUFFdEQsU0FBU0csV0FBWUMsSUFBSTtJQUN2QkgsZUFBZUksSUFBSSxDQUFDLElBQUksRUFBRUQ7QUFDNUI7QUFDQUwsU0FBU0ksWUFBWUY7QUFFckJFLFdBQVdHLFNBQVMsQ0FBQ0MsS0FBSyxHQUFHLFNBQVVDLENBQUMsR0FBRztBQUUzQ0MsT0FBT0MsT0FBTyxHQUFHUCIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2RlcHMvZGljZXIvbGliL1BhcnRTdHJlYW0uanM/YmE2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCdub2RlOnV0aWwnKS5pbmhlcml0c1xuY29uc3QgUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpLlJlYWRhYmxlXG5cbmZ1bmN0aW9uIFBhcnRTdHJlYW0gKG9wdHMpIHtcbiAgUmVhZGFibGVTdHJlYW0uY2FsbCh0aGlzLCBvcHRzKVxufVxuaW5oZXJpdHMoUGFydFN0cmVhbSwgUmVhZGFibGVTdHJlYW0pXG5cblBhcnRTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHt9XG5cbm1vZHVsZS5leHBvcnRzID0gUGFydFN0cmVhbVxuIl0sIm5hbWVzIjpbImluaGVyaXRzIiwicmVxdWlyZSIsIlJlYWRhYmxlU3RyZWFtIiwiUmVhZGFibGUiLCJQYXJ0U3RyZWFtIiwib3B0cyIsImNhbGwiLCJwcm90b3R5cGUiLCJfcmVhZCIsIm4iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/undici/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * Copyright Brian White. All rights reserved.\n *\n * @see https://github.com/mscdex/streamsearch\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n * Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n * by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n */ const EventEmitter = (__webpack_require__(/*! node:events */ \"node:events\").EventEmitter);\nconst inherits = (__webpack_require__(/*! node:util */ \"node:util\").inherits);\nfunction SBMH(needle) {\n    if (typeof needle === \"string\") {\n        needle = Buffer.from(needle);\n    }\n    if (!Buffer.isBuffer(needle)) {\n        throw new TypeError(\"The needle has to be a String or a Buffer.\");\n    }\n    const needleLength = needle.length;\n    if (needleLength === 0) {\n        throw new Error(\"The needle cannot be an empty String/Buffer.\");\n    }\n    if (needleLength > 256) {\n        throw new Error(\"The needle cannot have a length bigger than 256.\");\n    }\n    this.maxMatches = Infinity;\n    this.matches = 0;\n    this._occ = new Array(256).fill(needleLength) // Initialize occurrence table.\n    ;\n    this._lookbehind_size = 0;\n    this._needle = needle;\n    this._bufpos = 0;\n    this._lookbehind = Buffer.alloc(needleLength);\n    // Populate occurrence table with analysis of the needle,\n    // ignoring last letter.\n    for(var i = 0; i < needleLength - 1; ++i){\n        this._occ[needle[i]] = needleLength - 1 - i;\n    }\n}\ninherits(SBMH, EventEmitter);\nSBMH.prototype.reset = function() {\n    this._lookbehind_size = 0;\n    this.matches = 0;\n    this._bufpos = 0;\n};\nSBMH.prototype.push = function(chunk, pos) {\n    if (!Buffer.isBuffer(chunk)) {\n        chunk = Buffer.from(chunk, \"binary\");\n    }\n    const chlen = chunk.length;\n    this._bufpos = pos || 0;\n    let r;\n    while(r !== chlen && this.matches < this.maxMatches){\n        r = this._sbmh_feed(chunk);\n    }\n    return r;\n};\nSBMH.prototype._sbmh_feed = function(data) {\n    const len = data.length;\n    const needle = this._needle;\n    const needleLength = needle.length;\n    const lastNeedleChar = needle[needleLength - 1];\n    // Positive: points to a position in `data`\n    //           pos == 3 points to data[3]\n    // Negative: points to a position in the lookbehind buffer\n    //           pos == -2 points to lookbehind[lookbehind_size - 2]\n    let pos = -this._lookbehind_size;\n    let ch;\n    if (pos < 0) {\n        // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n        // search with character lookup code that considers both the\n        // lookbehind buffer and the current round's haystack data.\n        //\n        // Loop until\n        //   there is a match.\n        // or until\n        //   we've moved past the position that requires the\n        //   lookbehind buffer. In this case we switch to the\n        //   optimized loop.\n        // or until\n        //   the character to look at lies outside the haystack.\n        while(pos < 0 && pos <= len - needleLength){\n            ch = this._sbmh_lookup_char(data, pos + needleLength - 1);\n            if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {\n                this._lookbehind_size = 0;\n                ++this.matches;\n                this.emit(\"info\", true);\n                return this._bufpos = pos + needleLength;\n            }\n            pos += this._occ[ch];\n        }\n        // No match.\n        if (pos < 0) {\n            // There's too few data for Boyer-Moore-Horspool to run,\n            // so let's use a different algorithm to skip as much as\n            // we can.\n            // Forward pos until\n            //   the trailing part of lookbehind + data\n            //   looks like the beginning of the needle\n            // or until\n            //   pos == 0\n            while(pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)){\n                ++pos;\n            }\n        }\n        if (pos >= 0) {\n            // Discard lookbehind buffer.\n            this.emit(\"info\", false, this._lookbehind, 0, this._lookbehind_size);\n            this._lookbehind_size = 0;\n        } else {\n            // Cut off part of the lookbehind buffer that has\n            // been processed and append the entire haystack\n            // into it.\n            const bytesToCutOff = this._lookbehind_size + pos;\n            if (bytesToCutOff > 0) {\n                // The cut off data is guaranteed not to contain the needle.\n                this.emit(\"info\", false, this._lookbehind, 0, bytesToCutOff);\n            }\n            this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);\n            this._lookbehind_size -= bytesToCutOff;\n            data.copy(this._lookbehind, this._lookbehind_size);\n            this._lookbehind_size += len;\n            this._bufpos = len;\n            return len;\n        }\n    }\n    pos += (pos >= 0) * this._bufpos;\n    // Lookbehind buffer is now empty. We only need to check if the\n    // needle is in the haystack.\n    if (data.indexOf(needle, pos) !== -1) {\n        pos = data.indexOf(needle, pos);\n        ++this.matches;\n        if (pos > 0) {\n            this.emit(\"info\", true, data, this._bufpos, pos);\n        } else {\n            this.emit(\"info\", true);\n        }\n        return this._bufpos = pos + needleLength;\n    } else {\n        pos = len - needleLength;\n    }\n    // There was no match. If there's trailing haystack data that we cannot\n    // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n    // data is less than the needle size) then match using a modified\n    // algorithm that starts matching from the beginning instead of the end.\n    // Whatever trailing data is left after running this algorithm is added to\n    // the lookbehind buffer.\n    while(pos < len && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos, pos + len - pos), needle.subarray(0, len - pos)) !== 0)){\n        ++pos;\n    }\n    if (pos < len) {\n        data.copy(this._lookbehind, 0, pos, pos + (len - pos));\n        this._lookbehind_size = len - pos;\n    }\n    // Everything until pos is guaranteed not to contain needle data.\n    if (pos > 0) {\n        this.emit(\"info\", false, data, this._bufpos, pos < len ? pos : len);\n    }\n    this._bufpos = len;\n    return len;\n};\nSBMH.prototype._sbmh_lookup_char = function(data, pos) {\n    return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];\n};\nSBMH.prototype._sbmh_memcmp = function(data, pos, len) {\n    for(var i = 0; i < len; ++i){\n        if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {\n            return false;\n        }\n    }\n    return true;\n};\nmodule.exports = SBMH;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2RlcHMvc3RyZWFtc2VhcmNoL3NibWguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCQyxHQUNELE1BQU1BLGVBQWVDLG9FQUFtQztBQUN4RCxNQUFNQyxXQUFXRCw0REFBNkI7QUFFOUMsU0FBU0UsS0FBTUMsTUFBTTtJQUNuQixJQUFJLE9BQU9BLFdBQVcsVUFBVTtRQUM5QkEsU0FBU0MsT0FBT0MsSUFBSSxDQUFDRjtJQUN2QjtJQUVBLElBQUksQ0FBQ0MsT0FBT0UsUUFBUSxDQUFDSCxTQUFTO1FBQzVCLE1BQU0sSUFBSUksVUFBVTtJQUN0QjtJQUVBLE1BQU1DLGVBQWVMLE9BQU9NLE1BQU07SUFFbEMsSUFBSUQsaUJBQWlCLEdBQUc7UUFDdEIsTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBRUEsSUFBSUYsZUFBZSxLQUFLO1FBQ3RCLE1BQU0sSUFBSUUsTUFBTTtJQUNsQjtJQUVBLElBQUksQ0FBQ0MsVUFBVSxHQUFHQztJQUNsQixJQUFJLENBQUNDLE9BQU8sR0FBRztJQUVmLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlDLE1BQU0sS0FDbkJDLElBQUksQ0FBQ1IsY0FBYywrQkFBK0I7O0lBQ3JELElBQUksQ0FBQ1MsZ0JBQWdCLEdBQUc7SUFDeEIsSUFBSSxDQUFDQyxPQUFPLEdBQUdmO0lBQ2YsSUFBSSxDQUFDZ0IsT0FBTyxHQUFHO0lBRWYsSUFBSSxDQUFDQyxXQUFXLEdBQUdoQixPQUFPaUIsS0FBSyxDQUFDYjtJQUVoQyx5REFBeUQ7SUFDekQsd0JBQXdCO0lBQ3hCLElBQUssSUFBSWMsSUFBSSxHQUFHQSxJQUFJZCxlQUFlLEdBQUcsRUFBRWMsRUFBRztRQUN6QyxJQUFJLENBQUNSLElBQUksQ0FBQ1gsTUFBTSxDQUFDbUIsRUFBRSxDQUFDLEdBQUdkLGVBQWUsSUFBSWM7SUFDNUM7QUFD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ZixLQUFLQSxNQUFNSyxNQUFNTCxNQUMvQnhCLE9BQU91QyxRQUFRLENBQUMsR0FBR1YsTUFBTUwsVUFDckIsQ0FDUixFQUVGO1FBQ0EsRUFBRUE7SUFDSjtJQUNBLElBQUlBLE1BQU1LLEtBQUs7UUFDYkQsS0FBS1EsSUFBSSxDQUFDLElBQUksQ0FBQ25CLFdBQVcsRUFBRSxHQUFHTyxLQUFLQSxNQUFPSyxDQUFBQSxNQUFNTCxHQUFFO1FBQ25ELElBQUksQ0FBQ1YsZ0JBQWdCLEdBQUdlLE1BQU1MO0lBQ2hDO0lBRUEsaUVBQWlFO0lBQ2pFLElBQUlBLE1BQU0sR0FBRztRQUFFLElBQUksQ0FBQ1UsSUFBSSxDQUFDLFFBQVEsT0FBT04sTUFBTSxJQUFJLENBQUNaLE9BQU8sRUFBRVEsTUFBTUssTUFBTUwsTUFBTUs7SUFBSztJQUVuRixJQUFJLENBQUNiLE9BQU8sR0FBR2E7SUFDZixPQUFPQTtBQUNUO0FBRUE5QixLQUFLcUIsU0FBUyxDQUFDWSxpQkFBaUIsR0FBRyxTQUFVSixJQUFJLEVBQUVKLEdBQUc7SUFDcEQsT0FBTyxNQUFPLElBQ1YsSUFBSSxDQUFDUCxXQUFXLENBQUMsSUFBSSxDQUFDSCxnQkFBZ0IsR0FBR1UsSUFBSSxHQUM3Q0ksSUFBSSxDQUFDSixJQUFJO0FBQ2Y7QUFFQXpCLEtBQUtxQixTQUFTLENBQUNhLFlBQVksR0FBRyxTQUFVTCxJQUFJLEVBQUVKLEdBQUcsRUFBRUssR0FBRztJQUNwRCxJQUFLLElBQUlWLElBQUksR0FBR0EsSUFBSVUsS0FBSyxFQUFFVixFQUFHO1FBQzVCLElBQUksSUFBSSxDQUFDYSxpQkFBaUIsQ0FBQ0osTUFBTUosTUFBTUwsT0FBTyxJQUFJLENBQUNKLE9BQU8sQ0FBQ0ksRUFBRSxFQUFFO1lBQUUsT0FBTztRQUFNO0lBQ2hGO0lBQ0EsT0FBTztBQUNUO0FBRUFxQixPQUFPQyxPQUFPLEdBQUcxQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2RlcHMvc3RyZWFtc2VhcmNoL3NibWguanM/NDhhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBDb3B5cmlnaHQgQnJpYW4gV2hpdGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbXNjZGV4L3N0cmVhbXNlYXJjaFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4gKiBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuICogcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4gKiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4gKiBJTiBUSEUgU09GVFdBUkUuXG4gKlxuICogQmFzZWQgaGVhdmlseSBvbiB0aGUgU3RyZWFtaW5nIEJveWVyLU1vb3JlLUhvcnNwb29sIEMrKyBpbXBsZW1lbnRhdGlvblxuICogYnkgSG9uZ2xpIExhaSBhdDogaHR0cHM6Ly9naXRodWIuY29tL0Zvb0JhcldpZGdldC9ib3llci1tb29yZS1ob3JzcG9vbFxuICovXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdub2RlOmV2ZW50cycpLkV2ZW50RW1pdHRlclxuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCdub2RlOnV0aWwnKS5pbmhlcml0c1xuXG5mdW5jdGlvbiBTQk1IIChuZWVkbGUpIHtcbiAgaWYgKHR5cGVvZiBuZWVkbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgbmVlZGxlID0gQnVmZmVyLmZyb20obmVlZGxlKVxuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobmVlZGxlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBuZWVkbGUgaGFzIHRvIGJlIGEgU3RyaW5nIG9yIGEgQnVmZmVyLicpXG4gIH1cblxuICBjb25zdCBuZWVkbGVMZW5ndGggPSBuZWVkbGUubGVuZ3RoXG5cbiAgaWYgKG5lZWRsZUxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIG5lZWRsZSBjYW5ub3QgYmUgYW4gZW1wdHkgU3RyaW5nL0J1ZmZlci4nKVxuICB9XG5cbiAgaWYgKG5lZWRsZUxlbmd0aCA+IDI1Nikge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIG5lZWRsZSBjYW5ub3QgaGF2ZSBhIGxlbmd0aCBiaWdnZXIgdGhhbiAyNTYuJylcbiAgfVxuXG4gIHRoaXMubWF4TWF0Y2hlcyA9IEluZmluaXR5XG4gIHRoaXMubWF0Y2hlcyA9IDBcblxuICB0aGlzLl9vY2MgPSBuZXcgQXJyYXkoMjU2KVxuICAgIC5maWxsKG5lZWRsZUxlbmd0aCkgLy8gSW5pdGlhbGl6ZSBvY2N1cnJlbmNlIHRhYmxlLlxuICB0aGlzLl9sb29rYmVoaW5kX3NpemUgPSAwXG4gIHRoaXMuX25lZWRsZSA9IG5lZWRsZVxuICB0aGlzLl9idWZwb3MgPSAwXG5cbiAgdGhpcy5fbG9va2JlaGluZCA9IEJ1ZmZlci5hbGxvYyhuZWVkbGVMZW5ndGgpXG5cbiAgLy8gUG9wdWxhdGUgb2NjdXJyZW5jZSB0YWJsZSB3aXRoIGFuYWx5c2lzIG9mIHRoZSBuZWVkbGUsXG4gIC8vIGlnbm9yaW5nIGxhc3QgbGV0dGVyLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5lZWRsZUxlbmd0aCAtIDE7ICsraSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXZhclxuICAgIHRoaXMuX29jY1tuZWVkbGVbaV1dID0gbmVlZGxlTGVuZ3RoIC0gMSAtIGlcbiAgfVxufVxuaW5oZXJpdHMoU0JNSCwgRXZlbnRFbWl0dGVyKVxuXG5TQk1ILnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fbG9va2JlaGluZF9zaXplID0gMFxuICB0aGlzLm1hdGNoZXMgPSAwXG4gIHRoaXMuX2J1ZnBvcyA9IDBcbn1cblxuU0JNSC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgcG9zKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssICdiaW5hcnknKVxuICB9XG4gIGNvbnN0IGNobGVuID0gY2h1bmsubGVuZ3RoXG4gIHRoaXMuX2J1ZnBvcyA9IHBvcyB8fCAwXG4gIGxldCByXG4gIHdoaWxlIChyICE9PSBjaGxlbiAmJiB0aGlzLm1hdGNoZXMgPCB0aGlzLm1heE1hdGNoZXMpIHsgciA9IHRoaXMuX3NibWhfZmVlZChjaHVuaykgfVxuICByZXR1cm4gclxufVxuXG5TQk1ILnByb3RvdHlwZS5fc2JtaF9mZWVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGhcbiAgY29uc3QgbmVlZGxlID0gdGhpcy5fbmVlZGxlXG4gIGNvbnN0IG5lZWRsZUxlbmd0aCA9IG5lZWRsZS5sZW5ndGhcbiAgY29uc3QgbGFzdE5lZWRsZUNoYXIgPSBuZWVkbGVbbmVlZGxlTGVuZ3RoIC0gMV1cblxuICAvLyBQb3NpdGl2ZTogcG9pbnRzIHRvIGEgcG9zaXRpb24gaW4gYGRhdGFgXG4gIC8vICAgICAgICAgICBwb3MgPT0gMyBwb2ludHMgdG8gZGF0YVszXVxuICAvLyBOZWdhdGl2ZTogcG9pbnRzIHRvIGEgcG9zaXRpb24gaW4gdGhlIGxvb2tiZWhpbmQgYnVmZmVyXG4gIC8vICAgICAgICAgICBwb3MgPT0gLTIgcG9pbnRzIHRvIGxvb2tiZWhpbmRbbG9va2JlaGluZF9zaXplIC0gMl1cbiAgbGV0IHBvcyA9IC10aGlzLl9sb29rYmVoaW5kX3NpemVcbiAgbGV0IGNoXG5cbiAgaWYgKHBvcyA8IDApIHtcbiAgICAvLyBMb29rYmVoaW5kIGJ1ZmZlciBpcyBub3QgZW1wdHkuIFBlcmZvcm0gQm95ZXItTW9vcmUtSG9yc3Bvb2xcbiAgICAvLyBzZWFyY2ggd2l0aCBjaGFyYWN0ZXIgbG9va3VwIGNvZGUgdGhhdCBjb25zaWRlcnMgYm90aCB0aGVcbiAgICAvLyBsb29rYmVoaW5kIGJ1ZmZlciBhbmQgdGhlIGN1cnJlbnQgcm91bmQncyBoYXlzdGFjayBkYXRhLlxuICAgIC8vXG4gICAgLy8gTG9vcCB1bnRpbFxuICAgIC8vICAgdGhlcmUgaXMgYSBtYXRjaC5cbiAgICAvLyBvciB1bnRpbFxuICAgIC8vICAgd2UndmUgbW92ZWQgcGFzdCB0aGUgcG9zaXRpb24gdGhhdCByZXF1aXJlcyB0aGVcbiAgICAvLyAgIGxvb2tiZWhpbmQgYnVmZmVyLiBJbiB0aGlzIGNhc2Ugd2Ugc3dpdGNoIHRvIHRoZVxuICAgIC8vICAgb3B0aW1pemVkIGxvb3AuXG4gICAgLy8gb3IgdW50aWxcbiAgICAvLyAgIHRoZSBjaGFyYWN0ZXIgdG8gbG9vayBhdCBsaWVzIG91dHNpZGUgdGhlIGhheXN0YWNrLlxuICAgIHdoaWxlIChwb3MgPCAwICYmIHBvcyA8PSBsZW4gLSBuZWVkbGVMZW5ndGgpIHtcbiAgICAgIGNoID0gdGhpcy5fc2JtaF9sb29rdXBfY2hhcihkYXRhLCBwb3MgKyBuZWVkbGVMZW5ndGggLSAxKVxuXG4gICAgICBpZiAoXG4gICAgICAgIGNoID09PSBsYXN0TmVlZGxlQ2hhciAmJlxuICAgICAgICB0aGlzLl9zYm1oX21lbWNtcChkYXRhLCBwb3MsIG5lZWRsZUxlbmd0aCAtIDEpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fbG9va2JlaGluZF9zaXplID0gMFxuICAgICAgICArK3RoaXMubWF0Y2hlc1xuICAgICAgICB0aGlzLmVtaXQoJ2luZm8nLCB0cnVlKVxuXG4gICAgICAgIHJldHVybiAodGhpcy5fYnVmcG9zID0gcG9zICsgbmVlZGxlTGVuZ3RoKVxuICAgICAgfVxuICAgICAgcG9zICs9IHRoaXMuX29jY1tjaF1cbiAgICB9XG5cbiAgICAvLyBObyBtYXRjaC5cblxuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAvLyBUaGVyZSdzIHRvbyBmZXcgZGF0YSBmb3IgQm95ZXItTW9vcmUtSG9yc3Bvb2wgdG8gcnVuLFxuICAgICAgLy8gc28gbGV0J3MgdXNlIGEgZGlmZmVyZW50IGFsZ29yaXRobSB0byBza2lwIGFzIG11Y2ggYXNcbiAgICAgIC8vIHdlIGNhbi5cbiAgICAgIC8vIEZvcndhcmQgcG9zIHVudGlsXG4gICAgICAvLyAgIHRoZSB0cmFpbGluZyBwYXJ0IG9mIGxvb2tiZWhpbmQgKyBkYXRhXG4gICAgICAvLyAgIGxvb2tzIGxpa2UgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmVlZGxlXG4gICAgICAvLyBvciB1bnRpbFxuICAgICAgLy8gICBwb3MgPT0gMFxuICAgICAgd2hpbGUgKHBvcyA8IDAgJiYgIXRoaXMuX3NibWhfbWVtY21wKGRhdGEsIHBvcywgbGVuIC0gcG9zKSkgeyArK3BvcyB9XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBEaXNjYXJkIGxvb2tiZWhpbmQgYnVmZmVyLlxuICAgICAgdGhpcy5lbWl0KCdpbmZvJywgZmFsc2UsIHRoaXMuX2xvb2tiZWhpbmQsIDAsIHRoaXMuX2xvb2tiZWhpbmRfc2l6ZSlcbiAgICAgIHRoaXMuX2xvb2tiZWhpbmRfc2l6ZSA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3V0IG9mZiBwYXJ0IG9mIHRoZSBsb29rYmVoaW5kIGJ1ZmZlciB0aGF0IGhhc1xuICAgICAgLy8gYmVlbiBwcm9jZXNzZWQgYW5kIGFwcGVuZCB0aGUgZW50aXJlIGhheXN0YWNrXG4gICAgICAvLyBpbnRvIGl0LlxuICAgICAgY29uc3QgYnl0ZXNUb0N1dE9mZiA9IHRoaXMuX2xvb2tiZWhpbmRfc2l6ZSArIHBvc1xuICAgICAgaWYgKGJ5dGVzVG9DdXRPZmYgPiAwKSB7XG4gICAgICAgIC8vIFRoZSBjdXQgb2ZmIGRhdGEgaXMgZ3VhcmFudGVlZCBub3QgdG8gY29udGFpbiB0aGUgbmVlZGxlLlxuICAgICAgICB0aGlzLmVtaXQoJ2luZm8nLCBmYWxzZSwgdGhpcy5fbG9va2JlaGluZCwgMCwgYnl0ZXNUb0N1dE9mZilcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbG9va2JlaGluZC5jb3B5KHRoaXMuX2xvb2tiZWhpbmQsIDAsIGJ5dGVzVG9DdXRPZmYsXG4gICAgICAgIHRoaXMuX2xvb2tiZWhpbmRfc2l6ZSAtIGJ5dGVzVG9DdXRPZmYpXG4gICAgICB0aGlzLl9sb29rYmVoaW5kX3NpemUgLT0gYnl0ZXNUb0N1dE9mZlxuXG4gICAgICBkYXRhLmNvcHkodGhpcy5fbG9va2JlaGluZCwgdGhpcy5fbG9va2JlaGluZF9zaXplKVxuICAgICAgdGhpcy5fbG9va2JlaGluZF9zaXplICs9IGxlblxuXG4gICAgICB0aGlzLl9idWZwb3MgPSBsZW5cbiAgICAgIHJldHVybiBsZW5cbiAgICB9XG4gIH1cblxuICBwb3MgKz0gKHBvcyA+PSAwKSAqIHRoaXMuX2J1ZnBvc1xuXG4gIC8vIExvb2tiZWhpbmQgYnVmZmVyIGlzIG5vdyBlbXB0eS4gV2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIHRoZVxuICAvLyBuZWVkbGUgaXMgaW4gdGhlIGhheXN0YWNrLlxuICBpZiAoZGF0YS5pbmRleE9mKG5lZWRsZSwgcG9zKSAhPT0gLTEpIHtcbiAgICBwb3MgPSBkYXRhLmluZGV4T2YobmVlZGxlLCBwb3MpXG4gICAgKyt0aGlzLm1hdGNoZXNcbiAgICBpZiAocG9zID4gMCkgeyB0aGlzLmVtaXQoJ2luZm8nLCB0cnVlLCBkYXRhLCB0aGlzLl9idWZwb3MsIHBvcykgfSBlbHNlIHsgdGhpcy5lbWl0KCdpbmZvJywgdHJ1ZSkgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9idWZwb3MgPSBwb3MgKyBuZWVkbGVMZW5ndGgpXG4gIH0gZWxzZSB7XG4gICAgcG9zID0gbGVuIC0gbmVlZGxlTGVuZ3RoXG4gIH1cblxuICAvLyBUaGVyZSB3YXMgbm8gbWF0Y2guIElmIHRoZXJlJ3MgdHJhaWxpbmcgaGF5c3RhY2sgZGF0YSB0aGF0IHdlIGNhbm5vdFxuICAvLyBtYXRjaCB5ZXQgdXNpbmcgdGhlIEJveWVyLU1vb3JlLUhvcnNwb29sIGFsZ29yaXRobSAoYmVjYXVzZSB0aGUgdHJhaWxpbmdcbiAgLy8gZGF0YSBpcyBsZXNzIHRoYW4gdGhlIG5lZWRsZSBzaXplKSB0aGVuIG1hdGNoIHVzaW5nIGEgbW9kaWZpZWRcbiAgLy8gYWxnb3JpdGhtIHRoYXQgc3RhcnRzIG1hdGNoaW5nIGZyb20gdGhlIGJlZ2lubmluZyBpbnN0ZWFkIG9mIHRoZSBlbmQuXG4gIC8vIFdoYXRldmVyIHRyYWlsaW5nIGRhdGEgaXMgbGVmdCBhZnRlciBydW5uaW5nIHRoaXMgYWxnb3JpdGhtIGlzIGFkZGVkIHRvXG4gIC8vIHRoZSBsb29rYmVoaW5kIGJ1ZmZlci5cbiAgd2hpbGUgKFxuICAgIHBvcyA8IGxlbiAmJlxuICAgIChcbiAgICAgIGRhdGFbcG9zXSAhPT0gbmVlZGxlWzBdIHx8XG4gICAgICAoXG4gICAgICAgIChCdWZmZXIuY29tcGFyZShcbiAgICAgICAgICBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuIC0gcG9zKSxcbiAgICAgICAgICBuZWVkbGUuc3ViYXJyYXkoMCwgbGVuIC0gcG9zKVxuICAgICAgICApICE9PSAwKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgKytwb3NcbiAgfVxuICBpZiAocG9zIDwgbGVuKSB7XG4gICAgZGF0YS5jb3B5KHRoaXMuX2xvb2tiZWhpbmQsIDAsIHBvcywgcG9zICsgKGxlbiAtIHBvcykpXG4gICAgdGhpcy5fbG9va2JlaGluZF9zaXplID0gbGVuIC0gcG9zXG4gIH1cblxuICAvLyBFdmVyeXRoaW5nIHVudGlsIHBvcyBpcyBndWFyYW50ZWVkIG5vdCB0byBjb250YWluIG5lZWRsZSBkYXRhLlxuICBpZiAocG9zID4gMCkgeyB0aGlzLmVtaXQoJ2luZm8nLCBmYWxzZSwgZGF0YSwgdGhpcy5fYnVmcG9zLCBwb3MgPCBsZW4gPyBwb3MgOiBsZW4pIH1cblxuICB0aGlzLl9idWZwb3MgPSBsZW5cbiAgcmV0dXJuIGxlblxufVxuXG5TQk1ILnByb3RvdHlwZS5fc2JtaF9sb29rdXBfY2hhciA9IGZ1bmN0aW9uIChkYXRhLCBwb3MpIHtcbiAgcmV0dXJuIChwb3MgPCAwKVxuICAgID8gdGhpcy5fbG9va2JlaGluZFt0aGlzLl9sb29rYmVoaW5kX3NpemUgKyBwb3NdXG4gICAgOiBkYXRhW3Bvc11cbn1cblxuU0JNSC5wcm90b3R5cGUuX3NibWhfbWVtY21wID0gZnVuY3Rpb24gKGRhdGEsIHBvcywgbGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby12YXJcbiAgICBpZiAodGhpcy5fc2JtaF9sb29rdXBfY2hhcihkYXRhLCBwb3MgKyBpKSAhPT0gdGhpcy5fbmVlZGxlW2ldKSB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTQk1IXG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsImluaGVyaXRzIiwiU0JNSCIsIm5lZWRsZSIsIkJ1ZmZlciIsImZyb20iLCJpc0J1ZmZlciIsIlR5cGVFcnJvciIsIm5lZWRsZUxlbmd0aCIsImxlbmd0aCIsIkVycm9yIiwibWF4TWF0Y2hlcyIsIkluZmluaXR5IiwibWF0Y2hlcyIsIl9vY2MiLCJBcnJheSIsImZpbGwiLCJfbG9va2JlaGluZF9zaXplIiwiX25lZWRsZSIsIl9idWZwb3MiLCJfbG9va2JlaGluZCIsImFsbG9jIiwiaSIsInByb3RvdHlwZSIsInJlc2V0IiwicHVzaCIsImNodW5rIiwicG9zIiwiY2hsZW4iLCJyIiwiX3NibWhfZmVlZCIsImRhdGEiLCJsZW4iLCJsYXN0TmVlZGxlQ2hhciIsImNoIiwiX3NibWhfbG9va3VwX2NoYXIiLCJfc2JtaF9tZW1jbXAiLCJlbWl0IiwiYnl0ZXNUb0N1dE9mZiIsImNvcHkiLCJpbmRleE9mIiwiY29tcGFyZSIsInN1YmFycmF5IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/main.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/undici/node_modules/@fastify/busboy/lib/main.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst WritableStream = (__webpack_require__(/*! node:stream */ \"node:stream\").Writable);\nconst { inherits } = __webpack_require__(/*! node:util */ \"node:util\");\nconst Dicer = __webpack_require__(/*! ../deps/dicer/lib/Dicer */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js\");\nconst MultipartParser = __webpack_require__(/*! ./types/multipart */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/types/multipart.js\");\nconst UrlencodedParser = __webpack_require__(/*! ./types/urlencoded */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/types/urlencoded.js\");\nconst parseParams = __webpack_require__(/*! ./utils/parseParams */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/parseParams.js\");\nfunction Busboy(opts) {\n    if (!(this instanceof Busboy)) {\n        return new Busboy(opts);\n    }\n    if (typeof opts !== \"object\") {\n        throw new TypeError(\"Busboy expected an options-Object.\");\n    }\n    if (typeof opts.headers !== \"object\") {\n        throw new TypeError(\"Busboy expected an options-Object with headers-attribute.\");\n    }\n    if (typeof opts.headers[\"content-type\"] !== \"string\") {\n        throw new TypeError(\"Missing Content-Type-header.\");\n    }\n    const { headers, ...streamOptions } = opts;\n    this.opts = {\n        autoDestroy: false,\n        ...streamOptions\n    };\n    WritableStream.call(this, this.opts);\n    this._done = false;\n    this._parser = this.getParserByHeaders(headers);\n    this._finished = false;\n}\ninherits(Busboy, WritableStream);\nBusboy.prototype.emit = function(ev) {\n    if (ev === \"finish\") {\n        if (!this._done) {\n            this._parser?.end();\n            return;\n        } else if (this._finished) {\n            return;\n        }\n        this._finished = true;\n    }\n    WritableStream.prototype.emit.apply(this, arguments);\n};\nBusboy.prototype.getParserByHeaders = function(headers) {\n    const parsed = parseParams(headers[\"content-type\"]);\n    const cfg = {\n        defCharset: this.opts.defCharset,\n        fileHwm: this.opts.fileHwm,\n        headers,\n        highWaterMark: this.opts.highWaterMark,\n        isPartAFile: this.opts.isPartAFile,\n        limits: this.opts.limits,\n        parsedConType: parsed,\n        preservePath: this.opts.preservePath\n    };\n    if (MultipartParser.detect.test(parsed[0])) {\n        return new MultipartParser(this, cfg);\n    }\n    if (UrlencodedParser.detect.test(parsed[0])) {\n        return new UrlencodedParser(this, cfg);\n    }\n    throw new Error(\"Unsupported Content-Type.\");\n};\nBusboy.prototype._write = function(chunk, encoding, cb) {\n    this._parser.write(chunk, cb);\n};\nmodule.exports = Busboy;\nmodule.exports[\"default\"] = Busboy;\nmodule.exports.Busboy = Busboy;\nmodule.exports.Dicer = Dicer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2xpYi9tYWluLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsaUJBQWlCQyxnRUFBK0I7QUFDdEQsTUFBTSxFQUFFRSxRQUFRLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDN0IsTUFBTUcsUUFBUUgsbUJBQU9BLENBQUM7QUFFdEIsTUFBTUksa0JBQWtCSixtQkFBT0EsQ0FBQztBQUNoQyxNQUFNSyxtQkFBbUJMLG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU1NLGNBQWNOLG1CQUFPQSxDQUFDO0FBRTVCLFNBQVNPLE9BQVFDLElBQUk7SUFDbkIsSUFBSSxDQUFFLEtBQUksWUFBWUQsTUFBSyxHQUFJO1FBQUUsT0FBTyxJQUFJQSxPQUFPQztJQUFNO0lBRXpELElBQUksT0FBT0EsU0FBUyxVQUFVO1FBQzVCLE1BQU0sSUFBSUMsVUFBVTtJQUN0QjtJQUNBLElBQUksT0FBT0QsS0FBS0UsT0FBTyxLQUFLLFVBQVU7UUFDcEMsTUFBTSxJQUFJRCxVQUFVO0lBQ3RCO0lBQ0EsSUFBSSxPQUFPRCxLQUFLRSxPQUFPLENBQUMsZUFBZSxLQUFLLFVBQVU7UUFDcEQsTUFBTSxJQUFJRCxVQUFVO0lBQ3RCO0lBRUEsTUFBTSxFQUNKQyxPQUFPLEVBQ1AsR0FBR0MsZUFDSixHQUFHSDtJQUVKLElBQUksQ0FBQ0EsSUFBSSxHQUFHO1FBQ1ZJLGFBQWE7UUFDYixHQUFHRCxhQUFhO0lBQ2xCO0lBQ0FaLGVBQWVjLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDTCxJQUFJO0lBRW5DLElBQUksQ0FBQ00sS0FBSyxHQUFHO0lBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQ047SUFDdkMsSUFBSSxDQUFDTyxTQUFTLEdBQUc7QUFDbkI7QUFDQWYsU0FBU0ssUUFBUVI7QUFFakJRLE9BQU9XLFNBQVMsQ0FBQ0MsSUFBSSxHQUFHLFNBQVVDLEVBQUU7SUFDbEMsSUFBSUEsT0FBTyxVQUFVO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUNOLEtBQUssRUFBRTtZQUNmLElBQUksQ0FBQ0MsT0FBTyxFQUFFTTtZQUNkO1FBQ0YsT0FBTyxJQUFJLElBQUksQ0FBQ0osU0FBUyxFQUFFO1lBQ3pCO1FBQ0Y7UUFDQSxJQUFJLENBQUNBLFNBQVMsR0FBRztJQUNuQjtJQUNBbEIsZUFBZW1CLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDRyxLQUFLLENBQUMsSUFBSSxFQUFFQztBQUM1QztBQUVBaEIsT0FBT1csU0FBUyxDQUFDRixrQkFBa0IsR0FBRyxTQUFVTixPQUFPO0lBQ3JELE1BQU1jLFNBQVNsQixZQUFZSSxPQUFPLENBQUMsZUFBZTtJQUVsRCxNQUFNZSxNQUFNO1FBQ1ZDLFlBQVksSUFBSSxDQUFDbEIsSUFBSSxDQUFDa0IsVUFBVTtRQUNoQ0MsU0FBUyxJQUFJLENBQUNuQixJQUFJLENBQUNtQixPQUFPO1FBQzFCakI7UUFDQWtCLGVBQWUsSUFBSSxDQUFDcEIsSUFBSSxDQUFDb0IsYUFBYTtRQUN0Q0MsYUFBYSxJQUFJLENBQUNyQixJQUFJLENBQUNxQixXQUFXO1FBQ2xDQyxRQUFRLElBQUksQ0FBQ3RCLElBQUksQ0FBQ3NCLE1BQU07UUFDeEJDLGVBQWVQO1FBQ2ZRLGNBQWMsSUFBSSxDQUFDeEIsSUFBSSxDQUFDd0IsWUFBWTtJQUN0QztJQUVBLElBQUk1QixnQkFBZ0I2QixNQUFNLENBQUNDLElBQUksQ0FBQ1YsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUMxQyxPQUFPLElBQUlwQixnQkFBZ0IsSUFBSSxFQUFFcUI7SUFDbkM7SUFDQSxJQUFJcEIsaUJBQWlCNEIsTUFBTSxDQUFDQyxJQUFJLENBQUNWLE1BQU0sQ0FBQyxFQUFFLEdBQUc7UUFDM0MsT0FBTyxJQUFJbkIsaUJBQWlCLElBQUksRUFBRW9CO0lBQ3BDO0lBQ0EsTUFBTSxJQUFJVSxNQUFNO0FBQ2xCO0FBRUE1QixPQUFPVyxTQUFTLENBQUNrQixNQUFNLEdBQUcsU0FBVUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLEVBQUU7SUFDckQsSUFBSSxDQUFDeEIsT0FBTyxDQUFDeUIsS0FBSyxDQUFDSCxPQUFPRTtBQUM1QjtBQUVBRSxPQUFPQyxPQUFPLEdBQUduQztBQUNqQmtDLHlCQUFzQixHQUFHbEM7QUFDekJrQyxxQkFBcUIsR0FBR2xDO0FBRXhCa0Msb0JBQW9CLEdBQUd0QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2xpYi9tYWluLmpzPzk4NzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFdyaXRhYmxlU3RyZWFtID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKS5Xcml0YWJsZVxuY29uc3QgeyBpbmhlcml0cyB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IERpY2VyID0gcmVxdWlyZSgnLi4vZGVwcy9kaWNlci9saWIvRGljZXInKVxuXG5jb25zdCBNdWx0aXBhcnRQYXJzZXIgPSByZXF1aXJlKCcuL3R5cGVzL211bHRpcGFydCcpXG5jb25zdCBVcmxlbmNvZGVkUGFyc2VyID0gcmVxdWlyZSgnLi90eXBlcy91cmxlbmNvZGVkJylcbmNvbnN0IHBhcnNlUGFyYW1zID0gcmVxdWlyZSgnLi91dGlscy9wYXJzZVBhcmFtcycpXG5cbmZ1bmN0aW9uIEJ1c2JveSAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVzYm95KSkgeyByZXR1cm4gbmV3IEJ1c2JveShvcHRzKSB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1c2JveSBleHBlY3RlZCBhbiBvcHRpb25zLU9iamVjdC4nKVxuICB9XG4gIGlmICh0eXBlb2Ygb3B0cy5oZWFkZXJzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1c2JveSBleHBlY3RlZCBhbiBvcHRpb25zLU9iamVjdCB3aXRoIGhlYWRlcnMtYXR0cmlidXRlLicpXG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgQ29udGVudC1UeXBlLWhlYWRlci4nKVxuICB9XG5cbiAgY29uc3Qge1xuICAgIGhlYWRlcnMsXG4gICAgLi4uc3RyZWFtT3B0aW9uc1xuICB9ID0gb3B0c1xuXG4gIHRoaXMub3B0cyA9IHtcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXG4gICAgLi4uc3RyZWFtT3B0aW9uc1xuICB9XG4gIFdyaXRhYmxlU3RyZWFtLmNhbGwodGhpcywgdGhpcy5vcHRzKVxuXG4gIHRoaXMuX2RvbmUgPSBmYWxzZVxuICB0aGlzLl9wYXJzZXIgPSB0aGlzLmdldFBhcnNlckJ5SGVhZGVycyhoZWFkZXJzKVxuICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlXG59XG5pbmhlcml0cyhCdXNib3ksIFdyaXRhYmxlU3RyZWFtKVxuXG5CdXNib3kucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgaWYgKGV2ID09PSAnZmluaXNoJykge1xuICAgIGlmICghdGhpcy5fZG9uZSkge1xuICAgICAgdGhpcy5fcGFyc2VyPy5lbmQoKVxuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIGlmICh0aGlzLl9maW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZVxuICB9XG4gIFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVzYm95LnByb3RvdHlwZS5nZXRQYXJzZXJCeUhlYWRlcnMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZVBhcmFtcyhoZWFkZXJzWydjb250ZW50LXR5cGUnXSlcblxuICBjb25zdCBjZmcgPSB7XG4gICAgZGVmQ2hhcnNldDogdGhpcy5vcHRzLmRlZkNoYXJzZXQsXG4gICAgZmlsZUh3bTogdGhpcy5vcHRzLmZpbGVId20sXG4gICAgaGVhZGVycyxcbiAgICBoaWdoV2F0ZXJNYXJrOiB0aGlzLm9wdHMuaGlnaFdhdGVyTWFyayxcbiAgICBpc1BhcnRBRmlsZTogdGhpcy5vcHRzLmlzUGFydEFGaWxlLFxuICAgIGxpbWl0czogdGhpcy5vcHRzLmxpbWl0cyxcbiAgICBwYXJzZWRDb25UeXBlOiBwYXJzZWQsXG4gICAgcHJlc2VydmVQYXRoOiB0aGlzLm9wdHMucHJlc2VydmVQYXRoXG4gIH1cblxuICBpZiAoTXVsdGlwYXJ0UGFyc2VyLmRldGVjdC50ZXN0KHBhcnNlZFswXSkpIHtcbiAgICByZXR1cm4gbmV3IE11bHRpcGFydFBhcnNlcih0aGlzLCBjZmcpXG4gIH1cbiAgaWYgKFVybGVuY29kZWRQYXJzZXIuZGV0ZWN0LnRlc3QocGFyc2VkWzBdKSkge1xuICAgIHJldHVybiBuZXcgVXJsZW5jb2RlZFBhcnNlcih0aGlzLCBjZmcpXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBDb250ZW50LVR5cGUuJylcbn1cblxuQnVzYm95LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLl9wYXJzZXIud3JpdGUoY2h1bmssIGNiKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1c2JveVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEJ1c2JveVxubW9kdWxlLmV4cG9ydHMuQnVzYm95ID0gQnVzYm95XG5cbm1vZHVsZS5leHBvcnRzLkRpY2VyID0gRGljZXJcbiJdLCJuYW1lcyI6WyJXcml0YWJsZVN0cmVhbSIsInJlcXVpcmUiLCJXcml0YWJsZSIsImluaGVyaXRzIiwiRGljZXIiLCJNdWx0aXBhcnRQYXJzZXIiLCJVcmxlbmNvZGVkUGFyc2VyIiwicGFyc2VQYXJhbXMiLCJCdXNib3kiLCJvcHRzIiwiVHlwZUVycm9yIiwiaGVhZGVycyIsInN0cmVhbU9wdGlvbnMiLCJhdXRvRGVzdHJveSIsImNhbGwiLCJfZG9uZSIsIl9wYXJzZXIiLCJnZXRQYXJzZXJCeUhlYWRlcnMiLCJfZmluaXNoZWQiLCJwcm90b3R5cGUiLCJlbWl0IiwiZXYiLCJlbmQiLCJhcHBseSIsImFyZ3VtZW50cyIsInBhcnNlZCIsImNmZyIsImRlZkNoYXJzZXQiLCJmaWxlSHdtIiwiaGlnaFdhdGVyTWFyayIsImlzUGFydEFGaWxlIiwibGltaXRzIiwicGFyc2VkQ29uVHlwZSIsInByZXNlcnZlUGF0aCIsImRldGVjdCIsInRlc3QiLCJFcnJvciIsIl93cml0ZSIsImNodW5rIiwiZW5jb2RpbmciLCJjYiIsIndyaXRlIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/main.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/types/multipart.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/undici/node_modules/@fastify/busboy/lib/types/multipart.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// TODO:\n//  * support 1 nested multipart level\n//    (see second multipart example here:\n//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)\n//  * support limits.fieldNameSize\n//     -- this will require modifications to utils.parseParams\nconst { Readable } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { inherits } = __webpack_require__(/*! node:util */ \"node:util\");\nconst Dicer = __webpack_require__(/*! ../../deps/dicer/lib/Dicer */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js\");\nconst parseParams = __webpack_require__(/*! ../utils/parseParams */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/parseParams.js\");\nconst decodeText = __webpack_require__(/*! ../utils/decodeText */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/decodeText.js\");\nconst basename = __webpack_require__(/*! ../utils/basename */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/basename.js\");\nconst getLimit = __webpack_require__(/*! ../utils/getLimit */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/getLimit.js\");\nconst RE_BOUNDARY = /^boundary$/i;\nconst RE_FIELD = /^form-data$/i;\nconst RE_CHARSET = /^charset$/i;\nconst RE_FILENAME = /^filename$/i;\nconst RE_NAME = /^name$/i;\nMultipart.detect = /^multipart\\/form-data/i;\nfunction Multipart(boy, cfg) {\n    let i;\n    let len;\n    const self = this;\n    let boundary;\n    const limits = cfg.limits;\n    const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName)=>contentType === \"application/octet-stream\" || fileName !== undefined);\n    const parsedConType = cfg.parsedConType || [];\n    const defCharset = cfg.defCharset || \"utf8\";\n    const preservePath = cfg.preservePath;\n    const fileOpts = {\n        highWaterMark: cfg.fileHwm\n    };\n    for(i = 0, len = parsedConType.length; i < len; ++i){\n        if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {\n            boundary = parsedConType[i][1];\n            break;\n        }\n    }\n    function checkFinished() {\n        if (nends === 0 && finished && !boy._done) {\n            finished = false;\n            self.end();\n        }\n    }\n    if (typeof boundary !== \"string\") {\n        throw new Error(\"Multipart: Boundary not found\");\n    }\n    const fieldSizeLimit = getLimit(limits, \"fieldSize\", 1 * 1024 * 1024);\n    const fileSizeLimit = getLimit(limits, \"fileSize\", Infinity);\n    const filesLimit = getLimit(limits, \"files\", Infinity);\n    const fieldsLimit = getLimit(limits, \"fields\", Infinity);\n    const partsLimit = getLimit(limits, \"parts\", Infinity);\n    const headerPairsLimit = getLimit(limits, \"headerPairs\", 2000);\n    const headerSizeLimit = getLimit(limits, \"headerSize\", 80 * 1024);\n    let nfiles = 0;\n    let nfields = 0;\n    let nends = 0;\n    let curFile;\n    let curField;\n    let finished = false;\n    this._needDrain = false;\n    this._pause = false;\n    this._cb = undefined;\n    this._nparts = 0;\n    this._boy = boy;\n    const parserCfg = {\n        boundary,\n        maxHeaderPairs: headerPairsLimit,\n        maxHeaderSize: headerSizeLimit,\n        partHwm: fileOpts.highWaterMark,\n        highWaterMark: cfg.highWaterMark\n    };\n    this.parser = new Dicer(parserCfg);\n    this.parser.on(\"drain\", function() {\n        self._needDrain = false;\n        if (self._cb && !self._pause) {\n            const cb = self._cb;\n            self._cb = undefined;\n            cb();\n        }\n    }).on(\"part\", function onPart(part) {\n        if (++self._nparts > partsLimit) {\n            self.parser.removeListener(\"part\", onPart);\n            self.parser.on(\"part\", skipPart);\n            boy.hitPartsLimit = true;\n            boy.emit(\"partsLimit\");\n            return skipPart(part);\n        }\n        // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let\n        // us emit 'end' early since we know the part has ended if we are already\n        // seeing the next part\n        if (curField) {\n            const field = curField;\n            field.emit(\"end\");\n            field.removeAllListeners(\"end\");\n        }\n        part.on(\"header\", function(header) {\n            let contype;\n            let fieldname;\n            let parsed;\n            let charset;\n            let encoding;\n            let filename;\n            let nsize = 0;\n            if (header[\"content-type\"]) {\n                parsed = parseParams(header[\"content-type\"][0]);\n                if (parsed[0]) {\n                    contype = parsed[0].toLowerCase();\n                    for(i = 0, len = parsed.length; i < len; ++i){\n                        if (RE_CHARSET.test(parsed[i][0])) {\n                            charset = parsed[i][1].toLowerCase();\n                            break;\n                        }\n                    }\n                }\n            }\n            if (contype === undefined) {\n                contype = \"text/plain\";\n            }\n            if (charset === undefined) {\n                charset = defCharset;\n            }\n            if (header[\"content-disposition\"]) {\n                parsed = parseParams(header[\"content-disposition\"][0]);\n                if (!RE_FIELD.test(parsed[0])) {\n                    return skipPart(part);\n                }\n                for(i = 0, len = parsed.length; i < len; ++i){\n                    if (RE_NAME.test(parsed[i][0])) {\n                        fieldname = parsed[i][1];\n                    } else if (RE_FILENAME.test(parsed[i][0])) {\n                        filename = parsed[i][1];\n                        if (!preservePath) {\n                            filename = basename(filename);\n                        }\n                    }\n                }\n            } else {\n                return skipPart(part);\n            }\n            if (header[\"content-transfer-encoding\"]) {\n                encoding = header[\"content-transfer-encoding\"][0].toLowerCase();\n            } else {\n                encoding = \"7bit\";\n            }\n            let onData, onEnd;\n            if (isPartAFile(fieldname, contype, filename)) {\n                // file/binary field\n                if (nfiles === filesLimit) {\n                    if (!boy.hitFilesLimit) {\n                        boy.hitFilesLimit = true;\n                        boy.emit(\"filesLimit\");\n                    }\n                    return skipPart(part);\n                }\n                ++nfiles;\n                if (!boy._events.file) {\n                    self.parser._ignore();\n                    return;\n                }\n                ++nends;\n                const file = new FileStream(fileOpts);\n                curFile = file;\n                file.on(\"end\", function() {\n                    --nends;\n                    self._pause = false;\n                    checkFinished();\n                    if (self._cb && !self._needDrain) {\n                        const cb = self._cb;\n                        self._cb = undefined;\n                        cb();\n                    }\n                });\n                file._read = function(n) {\n                    if (!self._pause) {\n                        return;\n                    }\n                    self._pause = false;\n                    if (self._cb && !self._needDrain) {\n                        const cb = self._cb;\n                        self._cb = undefined;\n                        cb();\n                    }\n                };\n                boy.emit(\"file\", fieldname, file, filename, encoding, contype);\n                onData = function(data) {\n                    if ((nsize += data.length) > fileSizeLimit) {\n                        const extralen = fileSizeLimit - nsize + data.length;\n                        if (extralen > 0) {\n                            file.push(data.slice(0, extralen));\n                        }\n                        file.truncated = true;\n                        file.bytesRead = fileSizeLimit;\n                        part.removeAllListeners(\"data\");\n                        file.emit(\"limit\");\n                        return;\n                    } else if (!file.push(data)) {\n                        self._pause = true;\n                    }\n                    file.bytesRead = nsize;\n                };\n                onEnd = function() {\n                    curFile = undefined;\n                    file.push(null);\n                };\n            } else {\n                // non-file field\n                if (nfields === fieldsLimit) {\n                    if (!boy.hitFieldsLimit) {\n                        boy.hitFieldsLimit = true;\n                        boy.emit(\"fieldsLimit\");\n                    }\n                    return skipPart(part);\n                }\n                ++nfields;\n                ++nends;\n                let buffer = \"\";\n                let truncated = false;\n                curField = part;\n                onData = function(data) {\n                    if ((nsize += data.length) > fieldSizeLimit) {\n                        const extralen = fieldSizeLimit - (nsize - data.length);\n                        buffer += data.toString(\"binary\", 0, extralen);\n                        truncated = true;\n                        part.removeAllListeners(\"data\");\n                    } else {\n                        buffer += data.toString(\"binary\");\n                    }\n                };\n                onEnd = function() {\n                    curField = undefined;\n                    if (buffer.length) {\n                        buffer = decodeText(buffer, \"binary\", charset);\n                    }\n                    boy.emit(\"field\", fieldname, buffer, false, truncated, encoding, contype);\n                    --nends;\n                    checkFinished();\n                };\n            }\n            /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become\n         broken. Streams2/streams3 is a huge black box of confusion, but\n         somehow overriding the sync state seems to fix things again (and still\n         seems to work for previous node versions).\n      */ part._readableState.sync = false;\n            part.on(\"data\", onData);\n            part.on(\"end\", onEnd);\n        }).on(\"error\", function(err) {\n            if (curFile) {\n                curFile.emit(\"error\", err);\n            }\n        });\n    }).on(\"error\", function(err) {\n        boy.emit(\"error\", err);\n    }).on(\"finish\", function() {\n        finished = true;\n        checkFinished();\n    });\n}\nMultipart.prototype.write = function(chunk, cb) {\n    const r = this.parser.write(chunk);\n    if (r && !this._pause) {\n        cb();\n    } else {\n        this._needDrain = !r;\n        this._cb = cb;\n    }\n};\nMultipart.prototype.end = function() {\n    const self = this;\n    if (self.parser.writable) {\n        self.parser.end();\n    } else if (!self._boy._done) {\n        process.nextTick(function() {\n            self._boy._done = true;\n            self._boy.emit(\"finish\");\n        });\n    }\n};\nfunction skipPart(part) {\n    part.resume();\n}\nfunction FileStream(opts) {\n    Readable.call(this, opts);\n    this.bytesRead = 0;\n    this.truncated = false;\n}\ninherits(FileStream, Readable);\nFileStream.prototype._read = function(n) {};\nmodule.exports = Multipart;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2xpYi90eXBlcy9tdWx0aXBhcnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxRQUFRO0FBQ1Isc0NBQXNDO0FBQ3RDLHlDQUF5QztBQUN6QyxnRkFBZ0Y7QUFDaEYsa0NBQWtDO0FBQ2xDLDhEQUE4RDtBQUU5RCxNQUFNLEVBQUVBLFFBQVEsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM3QixNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUU3QixNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQztBQUV0QixNQUFNRyxjQUFjSCxtQkFBT0EsQ0FBQztBQUM1QixNQUFNSSxhQUFhSixtQkFBT0EsQ0FBQztBQUMzQixNQUFNSyxXQUFXTCxtQkFBT0EsQ0FBQztBQUN6QixNQUFNTSxXQUFXTixtQkFBT0EsQ0FBQztBQUV6QixNQUFNTyxjQUFjO0FBQ3BCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLFVBQVU7QUFFaEJDLFVBQVVDLE1BQU0sR0FBRztBQUNuQixTQUFTRCxVQUFXRSxHQUFHLEVBQUVDLEdBQUc7SUFDMUIsSUFBSUM7SUFDSixJQUFJQztJQUNKLE1BQU1DLE9BQU8sSUFBSTtJQUNqQixJQUFJQztJQUNKLE1BQU1DLFNBQVNMLElBQUlLLE1BQU07SUFDekIsTUFBTUMsY0FBY04sSUFBSU0sV0FBVyxJQUFLLEVBQUNDLFdBQVdDLGFBQWFDLFdBQWNELGdCQUFnQiw4QkFBOEJDLGFBQWFDLFNBQVM7SUFDbkosTUFBTUMsZ0JBQWdCWCxJQUFJVyxhQUFhLElBQUksRUFBRTtJQUM3QyxNQUFNQyxhQUFhWixJQUFJWSxVQUFVLElBQUk7SUFDckMsTUFBTUMsZUFBZWIsSUFBSWEsWUFBWTtJQUNyQyxNQUFNQyxXQUFXO1FBQUVDLGVBQWVmLElBQUlnQixPQUFPO0lBQUM7SUFF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LElBQUksQ0FBQ1gsVUFBVSxHQUFHLENBQUNxRDtRQUNuQixJQUFJLENBQUNuRCxHQUFHLEdBQUdTO0lBQ2I7QUFDRjtBQUVBckQsVUFBVTRGLFNBQVMsQ0FBQ2hFLEdBQUcsR0FBRztJQUN4QixNQUFNdEIsT0FBTyxJQUFJO0lBRWpCLElBQUlBLEtBQUs2QyxNQUFNLENBQUM2QyxRQUFRLEVBQUU7UUFDeEIxRixLQUFLNkMsTUFBTSxDQUFDdkIsR0FBRztJQUNqQixPQUFPLElBQUksQ0FBQ3RCLEtBQUt3QyxJQUFJLENBQUNuQixLQUFLLEVBQUU7UUFDM0JzRSxRQUFRQyxRQUFRLENBQUM7WUFDZjVGLEtBQUt3QyxJQUFJLENBQUNuQixLQUFLLEdBQUc7WUFDbEJyQixLQUFLd0MsSUFBSSxDQUFDYSxJQUFJLENBQUM7UUFDakI7SUFDRjtBQUNGO0FBRUEsU0FBU0YsU0FBVUYsSUFBSTtJQUNyQkEsS0FBSzRDLE1BQU07QUFDYjtBQUVBLFNBQVN0QixXQUFZdUIsSUFBSTtJQUN2QmpILFNBQVNrSCxJQUFJLENBQUMsSUFBSSxFQUFFRDtJQUVwQixJQUFJLENBQUNmLFNBQVMsR0FBRztJQUVqQixJQUFJLENBQUNELFNBQVMsR0FBRztBQUNuQjtBQUVBL0YsU0FBU3dGLFlBQVkxRjtBQUVyQjBGLFdBQVdlLFNBQVMsQ0FBQ2QsS0FBSyxHQUFHLFNBQVVDLENBQUMsR0FBRztBQUUzQ3VCLE9BQU9DLE9BQU8sR0FBR3ZHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL25vZGVfbW9kdWxlcy9AZmFzdGlmeS9idXNib3kvbGliL3R5cGVzL211bHRpcGFydC5qcz83M2M3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBUT0RPOlxuLy8gICogc3VwcG9ydCAxIG5lc3RlZCBtdWx0aXBhcnQgbGV2ZWxcbi8vICAgIChzZWUgc2Vjb25kIG11bHRpcGFydCBleGFtcGxlIGhlcmU6XG4vLyAgICAgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDQwMS9pbnRlcmFjdC9mb3Jtcy5odG1sI2RpZHgtbXVsdGlwYXJ0Zm9ybS1kYXRhKVxuLy8gICogc3VwcG9ydCBsaW1pdHMuZmllbGROYW1lU2l6ZVxuLy8gICAgIC0tIHRoaXMgd2lsbCByZXF1aXJlIG1vZGlmaWNhdGlvbnMgdG8gdXRpbHMucGFyc2VQYXJhbXNcblxuY29uc3QgeyBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBpbmhlcml0cyB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcblxuY29uc3QgRGljZXIgPSByZXF1aXJlKCcuLi8uLi9kZXBzL2RpY2VyL2xpYi9EaWNlcicpXG5cbmNvbnN0IHBhcnNlUGFyYW1zID0gcmVxdWlyZSgnLi4vdXRpbHMvcGFyc2VQYXJhbXMnKVxuY29uc3QgZGVjb2RlVGV4dCA9IHJlcXVpcmUoJy4uL3V0aWxzL2RlY29kZVRleHQnKVxuY29uc3QgYmFzZW5hbWUgPSByZXF1aXJlKCcuLi91dGlscy9iYXNlbmFtZScpXG5jb25zdCBnZXRMaW1pdCA9IHJlcXVpcmUoJy4uL3V0aWxzL2dldExpbWl0JylcblxuY29uc3QgUkVfQk9VTkRBUlkgPSAvXmJvdW5kYXJ5JC9pXG5jb25zdCBSRV9GSUVMRCA9IC9eZm9ybS1kYXRhJC9pXG5jb25zdCBSRV9DSEFSU0VUID0gL15jaGFyc2V0JC9pXG5jb25zdCBSRV9GSUxFTkFNRSA9IC9eZmlsZW5hbWUkL2lcbmNvbnN0IFJFX05BTUUgPSAvXm5hbWUkL2lcblxuTXVsdGlwYXJ0LmRldGVjdCA9IC9ebXVsdGlwYXJ0XFwvZm9ybS1kYXRhL2lcbmZ1bmN0aW9uIE11bHRpcGFydCAoYm95LCBjZmcpIHtcbiAgbGV0IGlcbiAgbGV0IGxlblxuICBjb25zdCBzZWxmID0gdGhpc1xuICBsZXQgYm91bmRhcnlcbiAgY29uc3QgbGltaXRzID0gY2ZnLmxpbWl0c1xuICBjb25zdCBpc1BhcnRBRmlsZSA9IGNmZy5pc1BhcnRBRmlsZSB8fCAoKGZpZWxkTmFtZSwgY29udGVudFR5cGUsIGZpbGVOYW1lKSA9PiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIHx8IGZpbGVOYW1lICE9PSB1bmRlZmluZWQpKVxuICBjb25zdCBwYXJzZWRDb25UeXBlID0gY2ZnLnBhcnNlZENvblR5cGUgfHwgW11cbiAgY29uc3QgZGVmQ2hhcnNldCA9IGNmZy5kZWZDaGFyc2V0IHx8ICd1dGY4J1xuICBjb25zdCBwcmVzZXJ2ZVBhdGggPSBjZmcucHJlc2VydmVQYXRoXG4gIGNvbnN0IGZpbGVPcHRzID0geyBoaWdoV2F0ZXJNYXJrOiBjZmcuZmlsZUh3bSB9XG5cbiAgZm9yIChpID0gMCwgbGVuID0gcGFyc2VkQ29uVHlwZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZENvblR5cGVbaV0pICYmXG4gICAgICBSRV9CT1VOREFSWS50ZXN0KHBhcnNlZENvblR5cGVbaV1bMF0pKSB7XG4gICAgICBib3VuZGFyeSA9IHBhcnNlZENvblR5cGVbaV1bMV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tGaW5pc2hlZCAoKSB7XG4gICAgaWYgKG5lbmRzID09PSAwICYmIGZpbmlzaGVkICYmICFib3kuX2RvbmUpIHtcbiAgICAgIGZpbmlzaGVkID0gZmFsc2VcbiAgICAgIHNlbGYuZW5kKClcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGJvdW5kYXJ5ICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGFydDogQm91bmRhcnkgbm90IGZvdW5kJykgfVxuXG4gIGNvbnN0IGZpZWxkU2l6ZUxpbWl0ID0gZ2V0TGltaXQobGltaXRzLCAnZmllbGRTaXplJywgMSAqIDEwMjQgKiAxMDI0KVxuICBjb25zdCBmaWxlU2l6ZUxpbWl0ID0gZ2V0TGltaXQobGltaXRzLCAnZmlsZVNpemUnLCBJbmZpbml0eSlcbiAgY29uc3QgZmlsZXNMaW1pdCA9IGdldExpbWl0KGxpbWl0cywgJ2ZpbGVzJywgSW5maW5pdHkpXG4gIGNvbnN0IGZpZWxkc0xpbWl0ID0gZ2V0TGltaXQobGltaXRzLCAnZmllbGRzJywgSW5maW5pdHkpXG4gIGNvbnN0IHBhcnRzTGltaXQgPSBnZXRMaW1pdChsaW1pdHMsICdwYXJ0cycsIEluZmluaXR5KVxuICBjb25zdCBoZWFkZXJQYWlyc0xpbWl0ID0gZ2V0TGltaXQobGltaXRzLCAnaGVhZGVyUGFpcnMnLCAyMDAwKVxuICBjb25zdCBoZWFkZXJTaXplTGltaXQgPSBnZXRMaW1pdChsaW1pdHMsICdoZWFkZXJTaXplJywgODAgKiAxMDI0KVxuXG4gIGxldCBuZmlsZXMgPSAwXG4gIGxldCBuZmllbGRzID0gMFxuICBsZXQgbmVuZHMgPSAwXG4gIGxldCBjdXJGaWxlXG4gIGxldCBjdXJGaWVsZFxuICBsZXQgZmluaXNoZWQgPSBmYWxzZVxuXG4gIHRoaXMuX25lZWREcmFpbiA9IGZhbHNlXG4gIHRoaXMuX3BhdXNlID0gZmFsc2VcbiAgdGhpcy5fY2IgPSB1bmRlZmluZWRcbiAgdGhpcy5fbnBhcnRzID0gMFxuICB0aGlzLl9ib3kgPSBib3lcblxuICBjb25zdCBwYXJzZXJDZmcgPSB7XG4gICAgYm91bmRhcnksXG4gICAgbWF4SGVhZGVyUGFpcnM6IGhlYWRlclBhaXJzTGltaXQsXG4gICAgbWF4SGVhZGVyU2l6ZTogaGVhZGVyU2l6ZUxpbWl0LFxuICAgIHBhcnRId206IGZpbGVPcHRzLmhpZ2hXYXRlck1hcmssXG4gICAgaGlnaFdhdGVyTWFyazogY2ZnLmhpZ2hXYXRlck1hcmtcbiAgfVxuXG4gIHRoaXMucGFyc2VyID0gbmV3IERpY2VyKHBhcnNlckNmZylcbiAgdGhpcy5wYXJzZXIub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX25lZWREcmFpbiA9IGZhbHNlXG4gICAgaWYgKHNlbGYuX2NiICYmICFzZWxmLl9wYXVzZSkge1xuICAgICAgY29uc3QgY2IgPSBzZWxmLl9jYlxuICAgICAgc2VsZi5fY2IgPSB1bmRlZmluZWRcbiAgICAgIGNiKClcbiAgICB9XG4gIH0pLm9uKCdwYXJ0JywgZnVuY3Rpb24gb25QYXJ0IChwYXJ0KSB7XG4gICAgaWYgKCsrc2VsZi5fbnBhcnRzID4gcGFydHNMaW1pdCkge1xuICAgICAgc2VsZi5wYXJzZXIucmVtb3ZlTGlzdGVuZXIoJ3BhcnQnLCBvblBhcnQpXG4gICAgICBzZWxmLnBhcnNlci5vbigncGFydCcsIHNraXBQYXJ0KVxuICAgICAgYm95LmhpdFBhcnRzTGltaXQgPSB0cnVlXG4gICAgICBib3kuZW1pdCgncGFydHNMaW1pdCcpXG4gICAgICByZXR1cm4gc2tpcFBhcnQocGFydClcbiAgICB9XG5cbiAgICAvLyBoYWNrIGJlY2F1c2Ugc3RyZWFtczIgX2Fsd2F5c18gZG9lc24ndCBlbWl0ICdlbmQnIHVudGlsIG5leHRUaWNrLCBzbyBsZXRcbiAgICAvLyB1cyBlbWl0ICdlbmQnIGVhcmx5IHNpbmNlIHdlIGtub3cgdGhlIHBhcnQgaGFzIGVuZGVkIGlmIHdlIGFyZSBhbHJlYWR5XG4gICAgLy8gc2VlaW5nIHRoZSBuZXh0IHBhcnRcbiAgICBpZiAoY3VyRmllbGQpIHtcbiAgICAgIGNvbnN0IGZpZWxkID0gY3VyRmllbGRcbiAgICAgIGZpZWxkLmVtaXQoJ2VuZCcpXG4gICAgICBmaWVsZC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpXG4gICAgfVxuXG4gICAgcGFydC5vbignaGVhZGVyJywgZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgbGV0IGNvbnR5cGVcbiAgICAgIGxldCBmaWVsZG5hbWVcbiAgICAgIGxldCBwYXJzZWRcbiAgICAgIGxldCBjaGFyc2V0XG4gICAgICBsZXQgZW5jb2RpbmdcbiAgICAgIGxldCBmaWxlbmFtZVxuICAgICAgbGV0IG5zaXplID0gMFxuXG4gICAgICBpZiAoaGVhZGVyWydjb250ZW50LXR5cGUnXSkge1xuICAgICAgICBwYXJzZWQgPSBwYXJzZVBhcmFtcyhoZWFkZXJbJ2NvbnRlbnQtdHlwZSddWzBdKVxuICAgICAgICBpZiAocGFyc2VkWzBdKSB7XG4gICAgICAgICAgY29udHlwZSA9IHBhcnNlZFswXS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcGFyc2VkLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoUkVfQ0hBUlNFVC50ZXN0KHBhcnNlZFtpXVswXSkpIHtcbiAgICAgICAgICAgICAgY2hhcnNldCA9IHBhcnNlZFtpXVsxXS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250eXBlID09PSB1bmRlZmluZWQpIHsgY29udHlwZSA9ICd0ZXh0L3BsYWluJyB9XG4gICAgICBpZiAoY2hhcnNldCA9PT0gdW5kZWZpbmVkKSB7IGNoYXJzZXQgPSBkZWZDaGFyc2V0IH1cblxuICAgICAgaWYgKGhlYWRlclsnY29udGVudC1kaXNwb3NpdGlvbiddKSB7XG4gICAgICAgIHBhcnNlZCA9IHBhcnNlUGFyYW1zKGhlYWRlclsnY29udGVudC1kaXNwb3NpdGlvbiddWzBdKVxuICAgICAgICBpZiAoIVJFX0ZJRUxELnRlc3QocGFyc2VkWzBdKSkgeyByZXR1cm4gc2tpcFBhcnQocGFydCkgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYXJzZWQubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBpZiAoUkVfTkFNRS50ZXN0KHBhcnNlZFtpXVswXSkpIHtcbiAgICAgICAgICAgIGZpZWxkbmFtZSA9IHBhcnNlZFtpXVsxXVxuICAgICAgICAgIH0gZWxzZSBpZiAoUkVfRklMRU5BTUUudGVzdChwYXJzZWRbaV1bMF0pKSB7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IHBhcnNlZFtpXVsxXVxuICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZVBhdGgpIHsgZmlsZW5hbWUgPSBiYXNlbmFtZShmaWxlbmFtZSkgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgcmV0dXJuIHNraXBQYXJ0KHBhcnQpIH1cblxuICAgICAgaWYgKGhlYWRlclsnY29udGVudC10cmFuc2Zlci1lbmNvZGluZyddKSB7IGVuY29kaW5nID0gaGVhZGVyWydjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nJ11bMF0udG9Mb3dlckNhc2UoKSB9IGVsc2UgeyBlbmNvZGluZyA9ICc3Yml0JyB9XG5cbiAgICAgIGxldCBvbkRhdGEsXG4gICAgICAgIG9uRW5kXG5cbiAgICAgIGlmIChpc1BhcnRBRmlsZShmaWVsZG5hbWUsIGNvbnR5cGUsIGZpbGVuYW1lKSkge1xuICAgICAgICAvLyBmaWxlL2JpbmFyeSBmaWVsZFxuICAgICAgICBpZiAobmZpbGVzID09PSBmaWxlc0xpbWl0KSB7XG4gICAgICAgICAgaWYgKCFib3kuaGl0RmlsZXNMaW1pdCkge1xuICAgICAgICAgICAgYm95LmhpdEZpbGVzTGltaXQgPSB0cnVlXG4gICAgICAgICAgICBib3kuZW1pdCgnZmlsZXNMaW1pdCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBza2lwUGFydChwYXJ0KVxuICAgICAgICB9XG5cbiAgICAgICAgKytuZmlsZXNcblxuICAgICAgICBpZiAoIWJveS5fZXZlbnRzLmZpbGUpIHtcbiAgICAgICAgICBzZWxmLnBhcnNlci5faWdub3JlKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgICsrbmVuZHNcbiAgICAgICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlU3RyZWFtKGZpbGVPcHRzKVxuICAgICAgICBjdXJGaWxlID0gZmlsZVxuICAgICAgICBmaWxlLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLS1uZW5kc1xuICAgICAgICAgIHNlbGYuX3BhdXNlID0gZmFsc2VcbiAgICAgICAgICBjaGVja0ZpbmlzaGVkKClcbiAgICAgICAgICBpZiAoc2VsZi5fY2IgJiYgIXNlbGYuX25lZWREcmFpbikge1xuICAgICAgICAgICAgY29uc3QgY2IgPSBzZWxmLl9jYlxuICAgICAgICAgICAgc2VsZi5fY2IgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIGNiKClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGZpbGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgIGlmICghc2VsZi5fcGF1c2UpIHsgcmV0dXJuIH1cbiAgICAgICAgICBzZWxmLl9wYXVzZSA9IGZhbHNlXG4gICAgICAgICAgaWYgKHNlbGYuX2NiICYmICFzZWxmLl9uZWVkRHJhaW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNiID0gc2VsZi5fY2JcbiAgICAgICAgICAgIHNlbGYuX2NiID0gdW5kZWZpbmVkXG4gICAgICAgICAgICBjYigpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJveS5lbWl0KCdmaWxlJywgZmllbGRuYW1lLCBmaWxlLCBmaWxlbmFtZSwgZW5jb2RpbmcsIGNvbnR5cGUpXG5cbiAgICAgICAgb25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBpZiAoKG5zaXplICs9IGRhdGEubGVuZ3RoKSA+IGZpbGVTaXplTGltaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhbGVuID0gZmlsZVNpemVMaW1pdCAtIG5zaXplICsgZGF0YS5sZW5ndGhcbiAgICAgICAgICAgIGlmIChleHRyYWxlbiA+IDApIHsgZmlsZS5wdXNoKGRhdGEuc2xpY2UoMCwgZXh0cmFsZW4pKSB9XG4gICAgICAgICAgICBmaWxlLnRydW5jYXRlZCA9IHRydWVcbiAgICAgICAgICAgIGZpbGUuYnl0ZXNSZWFkID0gZmlsZVNpemVMaW1pdFxuICAgICAgICAgICAgcGFydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKVxuICAgICAgICAgICAgZmlsZS5lbWl0KCdsaW1pdCcpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9IGVsc2UgaWYgKCFmaWxlLnB1c2goZGF0YSkpIHsgc2VsZi5fcGF1c2UgPSB0cnVlIH1cblxuICAgICAgICAgIGZpbGUuYnl0ZXNSZWFkID0gbnNpemVcbiAgICAgICAgfVxuXG4gICAgICAgIG9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGN1ckZpbGUgPSB1bmRlZmluZWRcbiAgICAgICAgICBmaWxlLnB1c2gobnVsbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm9uLWZpbGUgZmllbGRcbiAgICAgICAgaWYgKG5maWVsZHMgPT09IGZpZWxkc0xpbWl0KSB7XG4gICAgICAgICAgaWYgKCFib3kuaGl0RmllbGRzTGltaXQpIHtcbiAgICAgICAgICAgIGJveS5oaXRGaWVsZHNMaW1pdCA9IHRydWVcbiAgICAgICAgICAgIGJveS5lbWl0KCdmaWVsZHNMaW1pdCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBza2lwUGFydChwYXJ0KVxuICAgICAgICB9XG5cbiAgICAgICAgKytuZmllbGRzXG4gICAgICAgICsrbmVuZHNcbiAgICAgICAgbGV0IGJ1ZmZlciA9ICcnXG4gICAgICAgIGxldCB0cnVuY2F0ZWQgPSBmYWxzZVxuICAgICAgICBjdXJGaWVsZCA9IHBhcnRcblxuICAgICAgICBvbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIGlmICgobnNpemUgKz0gZGF0YS5sZW5ndGgpID4gZmllbGRTaXplTGltaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhbGVuID0gKGZpZWxkU2l6ZUxpbWl0IC0gKG5zaXplIC0gZGF0YS5sZW5ndGgpKVxuICAgICAgICAgICAgYnVmZmVyICs9IGRhdGEudG9TdHJpbmcoJ2JpbmFyeScsIDAsIGV4dHJhbGVuKVxuICAgICAgICAgICAgdHJ1bmNhdGVkID0gdHJ1ZVxuICAgICAgICAgICAgcGFydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKVxuICAgICAgICAgIH0gZWxzZSB7IGJ1ZmZlciArPSBkYXRhLnRvU3RyaW5nKCdiaW5hcnknKSB9XG4gICAgICAgIH1cblxuICAgICAgICBvbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjdXJGaWVsZCA9IHVuZGVmaW5lZFxuICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoKSB7IGJ1ZmZlciA9IGRlY29kZVRleHQoYnVmZmVyLCAnYmluYXJ5JywgY2hhcnNldCkgfVxuICAgICAgICAgIGJveS5lbWl0KCdmaWVsZCcsIGZpZWxkbmFtZSwgYnVmZmVyLCBmYWxzZSwgdHJ1bmNhdGVkLCBlbmNvZGluZywgY29udHlwZSlcbiAgICAgICAgICAtLW5lbmRzXG4gICAgICAgICAgY2hlY2tGaW5pc2hlZCgpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogQXMgb2Ygbm9kZUAyZWZlNGFiNzYxNjY2ICh2MC4xMC4yOSsvdjAuMTEuMTQrKSwgYnVzYm95IGhhZCBiZWNvbWVcbiAgICAgICAgIGJyb2tlbi4gU3RyZWFtczIvc3RyZWFtczMgaXMgYSBodWdlIGJsYWNrIGJveCBvZiBjb25mdXNpb24sIGJ1dFxuICAgICAgICAgc29tZWhvdyBvdmVycmlkaW5nIHRoZSBzeW5jIHN0YXRlIHNlZW1zIHRvIGZpeCB0aGluZ3MgYWdhaW4gKGFuZCBzdGlsbFxuICAgICAgICAgc2VlbXMgdG8gd29yayBmb3IgcHJldmlvdXMgbm9kZSB2ZXJzaW9ucykuXG4gICAgICAqL1xuICAgICAgcGFydC5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2VcblxuICAgICAgcGFydC5vbignZGF0YScsIG9uRGF0YSlcbiAgICAgIHBhcnQub24oJ2VuZCcsIG9uRW5kKVxuICAgIH0pLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChjdXJGaWxlKSB7IGN1ckZpbGUuZW1pdCgnZXJyb3InLCBlcnIpIH1cbiAgICB9KVxuICB9KS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgYm95LmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9KS5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIGZpbmlzaGVkID0gdHJ1ZVxuICAgIGNoZWNrRmluaXNoZWQoKVxuICB9KVxufVxuXG5NdWx0aXBhcnQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBjYikge1xuICBjb25zdCByID0gdGhpcy5wYXJzZXIud3JpdGUoY2h1bmspXG4gIGlmIChyICYmICF0aGlzLl9wYXVzZSkge1xuICAgIGNiKClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9uZWVkRHJhaW4gPSAhclxuICAgIHRoaXMuX2NiID0gY2JcbiAgfVxufVxuXG5NdWx0aXBhcnQucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcblxuICBpZiAoc2VsZi5wYXJzZXIud3JpdGFibGUpIHtcbiAgICBzZWxmLnBhcnNlci5lbmQoKVxuICB9IGVsc2UgaWYgKCFzZWxmLl9ib3kuX2RvbmUpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX2JveS5fZG9uZSA9IHRydWVcbiAgICAgIHNlbGYuX2JveS5lbWl0KCdmaW5pc2gnKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gc2tpcFBhcnQgKHBhcnQpIHtcbiAgcGFydC5yZXN1bWUoKVxufVxuXG5mdW5jdGlvbiBGaWxlU3RyZWFtIChvcHRzKSB7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0cylcblxuICB0aGlzLmJ5dGVzUmVhZCA9IDBcblxuICB0aGlzLnRydW5jYXRlZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKEZpbGVTdHJlYW0sIFJlYWRhYmxlKVxuXG5GaWxlU3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpcGFydFxuIl0sIm5hbWVzIjpbIlJlYWRhYmxlIiwicmVxdWlyZSIsImluaGVyaXRzIiwiRGljZXIiLCJwYXJzZVBhcmFtcyIsImRlY29kZVRleHQiLCJiYXNlbmFtZSIsImdldExpbWl0IiwiUkVfQk9VTkRBUlkiLCJSRV9GSUVMRCIsIlJFX0NIQVJTRVQiLCJSRV9GSUxFTkFNRSIsIlJFX05BTUUiLCJNdWx0aXBhcnQiLCJkZXRlY3QiLCJib3kiLCJjZmciLCJpIiwibGVuIiwic2VsZiIsImJvdW5kYXJ5IiwibGltaXRzIiwiaXNQYXJ0QUZpbGUiLCJmaWVsZE5hbWUiLCJjb250ZW50VHlwZSIsImZpbGVOYW1lIiwidW5kZWZpbmVkIiwicGFyc2VkQ29uVHlwZSIsImRlZkNoYXJzZXQiLCJwcmVzZXJ2ZVBhdGgiLCJmaWxlT3B0cyIsImhpZ2hXYXRlck1hcmsiLCJmaWxlSHdtIiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwidGVzdCIsImNoZWNrRmluaXNoZWQiLCJuZW5kcyIsImZpbmlzaGVkIiwiX2RvbmUiLCJlbmQiLCJFcnJvciIsImZpZWxkU2l6ZUxpbWl0IiwiZmlsZVNpemVMaW1pdCIsIkluZmluaXR5IiwiZmlsZXNMaW1pdCIsImZpZWxkc0xpbWl0IiwicGFydHNMaW1pdCIsImhlYWRlclBhaXJzTGltaXQiLCJoZWFkZXJTaXplTGltaXQiLCJuZmlsZXMiLCJuZmllbGRzIiwiY3VyRmlsZSIsImN1ckZpZWxkIiwiX25lZWREcmFpbiIsIl9wYXVzZSIsIl9jYiIsIl9ucGFydHMiLCJfYm95IiwicGFyc2VyQ2ZnIiwibWF4SGVhZGVyUGFpcnMiLCJtYXhIZWFkZXJTaXplIiwicGFydEh3bSIsInBhcnNlciIsIm9uIiwiY2IiLCJvblBhcnQiLCJwYXJ0IiwicmVtb3ZlTGlzdGVuZXIiLCJza2lwUGFydCIsImhpdFBhcnRzTGltaXQiLCJlbWl0IiwiZmllbGQiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJoZWFkZXIiLCJjb250eXBlIiwiZmllbGRuYW1lIiwicGFyc2VkIiwiY2hhcnNldCIsImVuY29kaW5nIiwiZmlsZW5hbWUiLCJuc2l6ZSIsInRvTG93ZXJDYXNlIiwib25EYXRhIiwib25FbmQiLCJoaXRGaWxlc0xpbWl0IiwiX2V2ZW50cyIsImZpbGUiLCJfaWdub3JlIiwiRmlsZVN0cmVhbSIsIl9yZWFkIiwibiIsImRhdGEiLCJleHRyYWxlbiIsInB1c2giLCJzbGljZSIsInRydW5jYXRlZCIsImJ5dGVzUmVhZCIsImhpdEZpZWxkc0xpbWl0IiwiYnVmZmVyIiwidG9TdHJpbmciLCJfcmVhZGFibGVTdGF0ZSIsInN5bmMiLCJlcnIiLCJwcm90b3R5cGUiLCJ3cml0ZSIsImNodW5rIiwiciIsIndyaXRhYmxlIiwicHJvY2VzcyIsIm5leHRUaWNrIiwicmVzdW1lIiwib3B0cyIsImNhbGwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/types/multipart.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/types/urlencoded.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/undici/node_modules/@fastify/busboy/lib/types/urlencoded.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Decoder = __webpack_require__(/*! ../utils/Decoder */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/Decoder.js\");\nconst decodeText = __webpack_require__(/*! ../utils/decodeText */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/decodeText.js\");\nconst getLimit = __webpack_require__(/*! ../utils/getLimit */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/getLimit.js\");\nconst RE_CHARSET = /^charset$/i;\nUrlEncoded.detect = /^application\\/x-www-form-urlencoded/i;\nfunction UrlEncoded(boy, cfg) {\n    const limits = cfg.limits;\n    const parsedConType = cfg.parsedConType;\n    this.boy = boy;\n    this.fieldSizeLimit = getLimit(limits, \"fieldSize\", 1 * 1024 * 1024);\n    this.fieldNameSizeLimit = getLimit(limits, \"fieldNameSize\", 100);\n    this.fieldsLimit = getLimit(limits, \"fields\", Infinity);\n    let charset;\n    for(var i = 0, len = parsedConType.length; i < len; ++i){\n        if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {\n            charset = parsedConType[i][1].toLowerCase();\n            break;\n        }\n    }\n    if (charset === undefined) {\n        charset = cfg.defCharset || \"utf8\";\n    }\n    this.decoder = new Decoder();\n    this.charset = charset;\n    this._fields = 0;\n    this._state = \"key\";\n    this._checkingBytes = true;\n    this._bytesKey = 0;\n    this._bytesVal = 0;\n    this._key = \"\";\n    this._val = \"\";\n    this._keyTrunc = false;\n    this._valTrunc = false;\n    this._hitLimit = false;\n}\nUrlEncoded.prototype.write = function(data, cb) {\n    if (this._fields === this.fieldsLimit) {\n        if (!this.boy.hitFieldsLimit) {\n            this.boy.hitFieldsLimit = true;\n            this.boy.emit(\"fieldsLimit\");\n        }\n        return cb();\n    }\n    let idxeq;\n    let idxamp;\n    let i;\n    let p = 0;\n    const len = data.length;\n    while(p < len){\n        if (this._state === \"key\") {\n            idxeq = idxamp = undefined;\n            for(i = p; i < len; ++i){\n                if (!this._checkingBytes) {\n                    ++p;\n                }\n                if (data[i] === 0x3D /* = */ ) {\n                    idxeq = i;\n                    break;\n                } else if (data[i] === 0x26 /* & */ ) {\n                    idxamp = i;\n                    break;\n                }\n                if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {\n                    this._hitLimit = true;\n                    break;\n                } else if (this._checkingBytes) {\n                    ++this._bytesKey;\n                }\n            }\n            if (idxeq !== undefined) {\n                // key with assignment\n                if (idxeq > p) {\n                    this._key += this.decoder.write(data.toString(\"binary\", p, idxeq));\n                }\n                this._state = \"val\";\n                this._hitLimit = false;\n                this._checkingBytes = true;\n                this._val = \"\";\n                this._bytesVal = 0;\n                this._valTrunc = false;\n                this.decoder.reset();\n                p = idxeq + 1;\n            } else if (idxamp !== undefined) {\n                // key with no assignment\n                ++this._fields;\n                let key;\n                const keyTrunc = this._keyTrunc;\n                if (idxamp > p) {\n                    key = this._key += this.decoder.write(data.toString(\"binary\", p, idxamp));\n                } else {\n                    key = this._key;\n                }\n                this._hitLimit = false;\n                this._checkingBytes = true;\n                this._key = \"\";\n                this._bytesKey = 0;\n                this._keyTrunc = false;\n                this.decoder.reset();\n                if (key.length) {\n                    this.boy.emit(\"field\", decodeText(key, \"binary\", this.charset), \"\", keyTrunc, false);\n                }\n                p = idxamp + 1;\n                if (this._fields === this.fieldsLimit) {\n                    return cb();\n                }\n            } else if (this._hitLimit) {\n                // we may not have hit the actual limit if there are encoded bytes...\n                if (i > p) {\n                    this._key += this.decoder.write(data.toString(\"binary\", p, i));\n                }\n                p = i;\n                if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {\n                    // yep, we actually did hit the limit\n                    this._checkingBytes = false;\n                    this._keyTrunc = true;\n                }\n            } else {\n                if (p < len) {\n                    this._key += this.decoder.write(data.toString(\"binary\", p));\n                }\n                p = len;\n            }\n        } else {\n            idxamp = undefined;\n            for(i = p; i < len; ++i){\n                if (!this._checkingBytes) {\n                    ++p;\n                }\n                if (data[i] === 0x26 /* & */ ) {\n                    idxamp = i;\n                    break;\n                }\n                if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {\n                    this._hitLimit = true;\n                    break;\n                } else if (this._checkingBytes) {\n                    ++this._bytesVal;\n                }\n            }\n            if (idxamp !== undefined) {\n                ++this._fields;\n                if (idxamp > p) {\n                    this._val += this.decoder.write(data.toString(\"binary\", p, idxamp));\n                }\n                this.boy.emit(\"field\", decodeText(this._key, \"binary\", this.charset), decodeText(this._val, \"binary\", this.charset), this._keyTrunc, this._valTrunc);\n                this._state = \"key\";\n                this._hitLimit = false;\n                this._checkingBytes = true;\n                this._key = \"\";\n                this._bytesKey = 0;\n                this._keyTrunc = false;\n                this.decoder.reset();\n                p = idxamp + 1;\n                if (this._fields === this.fieldsLimit) {\n                    return cb();\n                }\n            } else if (this._hitLimit) {\n                // we may not have hit the actual limit if there are encoded bytes...\n                if (i > p) {\n                    this._val += this.decoder.write(data.toString(\"binary\", p, i));\n                }\n                p = i;\n                if (this._val === \"\" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {\n                    // yep, we actually did hit the limit\n                    this._checkingBytes = false;\n                    this._valTrunc = true;\n                }\n            } else {\n                if (p < len) {\n                    this._val += this.decoder.write(data.toString(\"binary\", p));\n                }\n                p = len;\n            }\n        }\n    }\n    cb();\n};\nUrlEncoded.prototype.end = function() {\n    if (this.boy._done) {\n        return;\n    }\n    if (this._state === \"key\" && this._key.length > 0) {\n        this.boy.emit(\"field\", decodeText(this._key, \"binary\", this.charset), \"\", this._keyTrunc, false);\n    } else if (this._state === \"val\") {\n        this.boy.emit(\"field\", decodeText(this._key, \"binary\", this.charset), decodeText(this._val, \"binary\", this.charset), this._keyTrunc, this._valTrunc);\n    }\n    this.boy._done = true;\n    this.boy.emit(\"finish\");\n};\nmodule.exports = UrlEncoded;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2xpYi90eXBlcy91cmxlbmNvZGVkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsVUFBVUMsbUJBQU9BLENBQUM7QUFDeEIsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUM7QUFDM0IsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUM7QUFFekIsTUFBTUcsYUFBYTtBQUVuQkMsV0FBV0MsTUFBTSxHQUFHO0FBQ3BCLFNBQVNELFdBQVlFLEdBQUcsRUFBRUMsR0FBRztJQUMzQixNQUFNQyxTQUFTRCxJQUFJQyxNQUFNO0lBQ3pCLE1BQU1DLGdCQUFnQkYsSUFBSUUsYUFBYTtJQUN2QyxJQUFJLENBQUNILEdBQUcsR0FBR0E7SUFFWCxJQUFJLENBQUNJLGNBQWMsR0FBR1IsU0FBU00sUUFBUSxhQUFhLElBQUksT0FBTztJQUMvRCxJQUFJLENBQUNHLGtCQUFrQixHQUFHVCxTQUFTTSxRQUFRLGlCQUFpQjtJQUM1RCxJQUFJLENBQUNJLFdBQVcsR0FBR1YsU0FBU00sUUFBUSxVQUFVSztJQUU5QyxJQUFJQztJQUNKLElBQUssSUFBSUMsSUFBSSxHQUFHQyxNQUFNUCxjQUFjUSxNQUFNLEVBQUVGLElBQUlDLEtBQUssRUFBRUQsRUFBRztRQUN4RCxJQUFJRyxNQUFNQyxPQUFPLENBQUNWLGFBQWEsQ0FBQ00sRUFBRSxLQUM5QlosV0FBV2lCLElBQUksQ0FBQ1gsYUFBYSxDQUFDTSxFQUFFLENBQUMsRUFBRSxHQUFHO1lBQ3hDRCxVQUFVTCxhQUFhLENBQUNNLEVBQUUsQ0FBQyxFQUFFLENBQUNNLFdBQVc7WUFDekM7UUFDRjtJQUNGO0lBRUEsSUFBSVAsWUFBWVEsV0FBVztRQUFFUixVQUFVUCxJQUFJZ0IsVUFBVSxJQUFJO0lBQU87SUFFaEUsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSXpCO0lBQ25CLElBQUksQ0FBQ2UsT0FBTyxHQUFHQTtJQUNmLElBQUks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R0FBRyxDQUFDa0MsSUFBSSxDQUFDLFNBQVN2QyxXQUFXLElBQUksQ0FBQzZCLElBQUksRUFBRSxVQUFVLElBQUksQ0FBQ2hCLE9BQU8sR0FDakUsSUFDQSxJQUFJLENBQUNrQixTQUFTLEVBQ2Q7SUFDSixPQUFPLElBQUksSUFBSSxDQUFDTixNQUFNLEtBQUssT0FBTztRQUNoQyxJQUFJLENBQUNwQixHQUFHLENBQUNrQyxJQUFJLENBQUMsU0FBU3ZDLFdBQVcsSUFBSSxDQUFDNkIsSUFBSSxFQUFFLFVBQVUsSUFBSSxDQUFDaEIsT0FBTyxHQUNqRWIsV0FBVyxJQUFJLENBQUM4QixJQUFJLEVBQUUsVUFBVSxJQUFJLENBQUNqQixPQUFPLEdBQzVDLElBQUksQ0FBQ2tCLFNBQVMsRUFDZCxJQUFJLENBQUNDLFNBQVM7SUFDbEI7SUFDQSxJQUFJLENBQUMzQixHQUFHLENBQUMyQyxLQUFLLEdBQUc7SUFDakIsSUFBSSxDQUFDM0MsR0FBRyxDQUFDa0MsSUFBSSxDQUFDO0FBQ2hCO0FBRUFVLE9BQU9DLE9BQU8sR0FBRy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL25vZGVfbW9kdWxlcy9AZmFzdGlmeS9idXNib3kvbGliL3R5cGVzL3VybGVuY29kZWQuanM/YjAzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRGVjb2RlciA9IHJlcXVpcmUoJy4uL3V0aWxzL0RlY29kZXInKVxuY29uc3QgZGVjb2RlVGV4dCA9IHJlcXVpcmUoJy4uL3V0aWxzL2RlY29kZVRleHQnKVxuY29uc3QgZ2V0TGltaXQgPSByZXF1aXJlKCcuLi91dGlscy9nZXRMaW1pdCcpXG5cbmNvbnN0IFJFX0NIQVJTRVQgPSAvXmNoYXJzZXQkL2lcblxuVXJsRW5jb2RlZC5kZXRlY3QgPSAvXmFwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkL2lcbmZ1bmN0aW9uIFVybEVuY29kZWQgKGJveSwgY2ZnKSB7XG4gIGNvbnN0IGxpbWl0cyA9IGNmZy5saW1pdHNcbiAgY29uc3QgcGFyc2VkQ29uVHlwZSA9IGNmZy5wYXJzZWRDb25UeXBlXG4gIHRoaXMuYm95ID0gYm95XG5cbiAgdGhpcy5maWVsZFNpemVMaW1pdCA9IGdldExpbWl0KGxpbWl0cywgJ2ZpZWxkU2l6ZScsIDEgKiAxMDI0ICogMTAyNClcbiAgdGhpcy5maWVsZE5hbWVTaXplTGltaXQgPSBnZXRMaW1pdChsaW1pdHMsICdmaWVsZE5hbWVTaXplJywgMTAwKVxuICB0aGlzLmZpZWxkc0xpbWl0ID0gZ2V0TGltaXQobGltaXRzLCAnZmllbGRzJywgSW5maW5pdHkpXG5cbiAgbGV0IGNoYXJzZXRcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnNlZENvblR5cGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby12YXJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRDb25UeXBlW2ldKSAmJlxuICAgICAgICBSRV9DSEFSU0VULnRlc3QocGFyc2VkQ29uVHlwZVtpXVswXSkpIHtcbiAgICAgIGNoYXJzZXQgPSBwYXJzZWRDb25UeXBlW2ldWzFdLnRvTG93ZXJDYXNlKClcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKGNoYXJzZXQgPT09IHVuZGVmaW5lZCkgeyBjaGFyc2V0ID0gY2ZnLmRlZkNoYXJzZXQgfHwgJ3V0ZjgnIH1cblxuICB0aGlzLmRlY29kZXIgPSBuZXcgRGVjb2RlcigpXG4gIHRoaXMuY2hhcnNldCA9IGNoYXJzZXRcbiAgdGhpcy5fZmllbGRzID0gMFxuICB0aGlzLl9zdGF0ZSA9ICdrZXknXG4gIHRoaXMuX2NoZWNraW5nQnl0ZXMgPSB0cnVlXG4gIHRoaXMuX2J5dGVzS2V5ID0gMFxuICB0aGlzLl9ieXRlc1ZhbCA9IDBcbiAgdGhpcy5fa2V5ID0gJydcbiAgdGhpcy5fdmFsID0gJydcbiAgdGhpcy5fa2V5VHJ1bmMgPSBmYWxzZVxuICB0aGlzLl92YWxUcnVuYyA9IGZhbHNlXG4gIHRoaXMuX2hpdExpbWl0ID0gZmFsc2Vcbn1cblxuVXJsRW5jb2RlZC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgY2IpIHtcbiAgaWYgKHRoaXMuX2ZpZWxkcyA9PT0gdGhpcy5maWVsZHNMaW1pdCkge1xuICAgIGlmICghdGhpcy5ib3kuaGl0RmllbGRzTGltaXQpIHtcbiAgICAgIHRoaXMuYm95LmhpdEZpZWxkc0xpbWl0ID0gdHJ1ZVxuICAgICAgdGhpcy5ib3kuZW1pdCgnZmllbGRzTGltaXQnKVxuICAgIH1cbiAgICByZXR1cm4gY2IoKVxuICB9XG5cbiAgbGV0IGlkeGVxOyBsZXQgaWR4YW1wOyBsZXQgaTsgbGV0IHAgPSAwOyBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aFxuXG4gIHdoaWxlIChwIDwgbGVuKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSAna2V5Jykge1xuICAgICAgaWR4ZXEgPSBpZHhhbXAgPSB1bmRlZmluZWRcbiAgICAgIGZvciAoaSA9IHA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAoIXRoaXMuX2NoZWNraW5nQnl0ZXMpIHsgKytwIH1cbiAgICAgICAgaWYgKGRhdGFbaV0gPT09IDB4M0QvKiA9ICovKSB7XG4gICAgICAgICAgaWR4ZXEgPSBpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhW2ldID09PSAweDI2LyogJiAqLykge1xuICAgICAgICAgIGlkeGFtcCA9IGlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jaGVja2luZ0J5dGVzICYmIHRoaXMuX2J5dGVzS2V5ID09PSB0aGlzLmZpZWxkTmFtZVNpemVMaW1pdCkge1xuICAgICAgICAgIHRoaXMuX2hpdExpbWl0ID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY2hlY2tpbmdCeXRlcykgeyArK3RoaXMuX2J5dGVzS2V5IH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlkeGVxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8ga2V5IHdpdGggYXNzaWdubWVudFxuICAgICAgICBpZiAoaWR4ZXEgPiBwKSB7IHRoaXMuX2tleSArPSB0aGlzLmRlY29kZXIud3JpdGUoZGF0YS50b1N0cmluZygnYmluYXJ5JywgcCwgaWR4ZXEpKSB9XG4gICAgICAgIHRoaXMuX3N0YXRlID0gJ3ZhbCdcblxuICAgICAgICB0aGlzLl9oaXRMaW1pdCA9IGZhbHNlXG4gICAgICAgIHRoaXMuX2NoZWNraW5nQnl0ZXMgPSB0cnVlXG4gICAgICAgIHRoaXMuX3ZhbCA9ICcnXG4gICAgICAgIHRoaXMuX2J5dGVzVmFsID0gMFxuICAgICAgICB0aGlzLl92YWxUcnVuYyA9IGZhbHNlXG4gICAgICAgIHRoaXMuZGVjb2Rlci5yZXNldCgpXG5cbiAgICAgICAgcCA9IGlkeGVxICsgMVxuICAgICAgfSBlbHNlIGlmIChpZHhhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBrZXkgd2l0aCBubyBhc3NpZ25tZW50XG4gICAgICAgICsrdGhpcy5fZmllbGRzXG4gICAgICAgIGxldCBrZXk7IGNvbnN0IGtleVRydW5jID0gdGhpcy5fa2V5VHJ1bmNcbiAgICAgICAgaWYgKGlkeGFtcCA+IHApIHsga2V5ID0gKHRoaXMuX2tleSArPSB0aGlzLmRlY29kZXIud3JpdGUoZGF0YS50b1N0cmluZygnYmluYXJ5JywgcCwgaWR4YW1wKSkpIH0gZWxzZSB7IGtleSA9IHRoaXMuX2tleSB9XG5cbiAgICAgICAgdGhpcy5faGl0TGltaXQgPSBmYWxzZVxuICAgICAgICB0aGlzLl9jaGVja2luZ0J5dGVzID0gdHJ1ZVxuICAgICAgICB0aGlzLl9rZXkgPSAnJ1xuICAgICAgICB0aGlzLl9ieXRlc0tleSA9IDBcbiAgICAgICAgdGhpcy5fa2V5VHJ1bmMgPSBmYWxzZVxuICAgICAgICB0aGlzLmRlY29kZXIucmVzZXQoKVxuXG4gICAgICAgIGlmIChrZXkubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5ib3kuZW1pdCgnZmllbGQnLCBkZWNvZGVUZXh0KGtleSwgJ2JpbmFyeScsIHRoaXMuY2hhcnNldCksXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIGtleVRydW5jLFxuICAgICAgICAgICAgZmFsc2UpXG4gICAgICAgIH1cblxuICAgICAgICBwID0gaWR4YW1wICsgMVxuICAgICAgICBpZiAodGhpcy5fZmllbGRzID09PSB0aGlzLmZpZWxkc0xpbWl0KSB7IHJldHVybiBjYigpIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faGl0TGltaXQpIHtcbiAgICAgICAgLy8gd2UgbWF5IG5vdCBoYXZlIGhpdCB0aGUgYWN0dWFsIGxpbWl0IGlmIHRoZXJlIGFyZSBlbmNvZGVkIGJ5dGVzLi4uXG4gICAgICAgIGlmIChpID4gcCkgeyB0aGlzLl9rZXkgKz0gdGhpcy5kZWNvZGVyLndyaXRlKGRhdGEudG9TdHJpbmcoJ2JpbmFyeScsIHAsIGkpKSB9XG4gICAgICAgIHAgPSBpXG4gICAgICAgIGlmICgodGhpcy5fYnl0ZXNLZXkgPSB0aGlzLl9rZXkubGVuZ3RoKSA9PT0gdGhpcy5maWVsZE5hbWVTaXplTGltaXQpIHtcbiAgICAgICAgICAvLyB5ZXAsIHdlIGFjdHVhbGx5IGRpZCBoaXQgdGhlIGxpbWl0XG4gICAgICAgICAgdGhpcy5fY2hlY2tpbmdCeXRlcyA9IGZhbHNlXG4gICAgICAgICAgdGhpcy5fa2V5VHJ1bmMgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwIDwgbGVuKSB7IHRoaXMuX2tleSArPSB0aGlzLmRlY29kZXIud3JpdGUoZGF0YS50b1N0cmluZygnYmluYXJ5JywgcCkpIH1cbiAgICAgICAgcCA9IGxlblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZHhhbXAgPSB1bmRlZmluZWRcbiAgICAgIGZvciAoaSA9IHA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAoIXRoaXMuX2NoZWNraW5nQnl0ZXMpIHsgKytwIH1cbiAgICAgICAgaWYgKGRhdGFbaV0gPT09IDB4MjYvKiAmICovKSB7XG4gICAgICAgICAgaWR4YW1wID0gaVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NoZWNraW5nQnl0ZXMgJiYgdGhpcy5fYnl0ZXNWYWwgPT09IHRoaXMuZmllbGRTaXplTGltaXQpIHtcbiAgICAgICAgICB0aGlzLl9oaXRMaW1pdCA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2NoZWNraW5nQnl0ZXMpIHsgKyt0aGlzLl9ieXRlc1ZhbCB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpZHhhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICArK3RoaXMuX2ZpZWxkc1xuICAgICAgICBpZiAoaWR4YW1wID4gcCkgeyB0aGlzLl92YWwgKz0gdGhpcy5kZWNvZGVyLndyaXRlKGRhdGEudG9TdHJpbmcoJ2JpbmFyeScsIHAsIGlkeGFtcCkpIH1cbiAgICAgICAgdGhpcy5ib3kuZW1pdCgnZmllbGQnLCBkZWNvZGVUZXh0KHRoaXMuX2tleSwgJ2JpbmFyeScsIHRoaXMuY2hhcnNldCksXG4gICAgICAgICAgZGVjb2RlVGV4dCh0aGlzLl92YWwsICdiaW5hcnknLCB0aGlzLmNoYXJzZXQpLFxuICAgICAgICAgIHRoaXMuX2tleVRydW5jLFxuICAgICAgICAgIHRoaXMuX3ZhbFRydW5jKVxuICAgICAgICB0aGlzLl9zdGF0ZSA9ICdrZXknXG5cbiAgICAgICAgdGhpcy5faGl0TGltaXQgPSBmYWxzZVxuICAgICAgICB0aGlzLl9jaGVja2luZ0J5dGVzID0gdHJ1ZVxuICAgICAgICB0aGlzLl9rZXkgPSAnJ1xuICAgICAgICB0aGlzLl9ieXRlc0tleSA9IDBcbiAgICAgICAgdGhpcy5fa2V5VHJ1bmMgPSBmYWxzZVxuICAgICAgICB0aGlzLmRlY29kZXIucmVzZXQoKVxuXG4gICAgICAgIHAgPSBpZHhhbXAgKyAxXG4gICAgICAgIGlmICh0aGlzLl9maWVsZHMgPT09IHRoaXMuZmllbGRzTGltaXQpIHsgcmV0dXJuIGNiKCkgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9oaXRMaW1pdCkge1xuICAgICAgICAvLyB3ZSBtYXkgbm90IGhhdmUgaGl0IHRoZSBhY3R1YWwgbGltaXQgaWYgdGhlcmUgYXJlIGVuY29kZWQgYnl0ZXMuLi5cbiAgICAgICAgaWYgKGkgPiBwKSB7IHRoaXMuX3ZhbCArPSB0aGlzLmRlY29kZXIud3JpdGUoZGF0YS50b1N0cmluZygnYmluYXJ5JywgcCwgaSkpIH1cbiAgICAgICAgcCA9IGlcbiAgICAgICAgaWYgKCh0aGlzLl92YWwgPT09ICcnICYmIHRoaXMuZmllbGRTaXplTGltaXQgPT09IDApIHx8XG4gICAgICAgICAgICAodGhpcy5fYnl0ZXNWYWwgPSB0aGlzLl92YWwubGVuZ3RoKSA9PT0gdGhpcy5maWVsZFNpemVMaW1pdCkge1xuICAgICAgICAgIC8vIHllcCwgd2UgYWN0dWFsbHkgZGlkIGhpdCB0aGUgbGltaXRcbiAgICAgICAgICB0aGlzLl9jaGVja2luZ0J5dGVzID0gZmFsc2VcbiAgICAgICAgICB0aGlzLl92YWxUcnVuYyA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHAgPCBsZW4pIHsgdGhpcy5fdmFsICs9IHRoaXMuZGVjb2Rlci53cml0ZShkYXRhLnRvU3RyaW5nKCdiaW5hcnknLCBwKSkgfVxuICAgICAgICBwID0gbGVuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNiKClcbn1cblxuVXJsRW5jb2RlZC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5ib3kuX2RvbmUpIHsgcmV0dXJuIH1cblxuICBpZiAodGhpcy5fc3RhdGUgPT09ICdrZXknICYmIHRoaXMuX2tleS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5ib3kuZW1pdCgnZmllbGQnLCBkZWNvZGVUZXh0KHRoaXMuX2tleSwgJ2JpbmFyeScsIHRoaXMuY2hhcnNldCksXG4gICAgICAnJyxcbiAgICAgIHRoaXMuX2tleVRydW5jLFxuICAgICAgZmFsc2UpXG4gIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09ICd2YWwnKSB7XG4gICAgdGhpcy5ib3kuZW1pdCgnZmllbGQnLCBkZWNvZGVUZXh0KHRoaXMuX2tleSwgJ2JpbmFyeScsIHRoaXMuY2hhcnNldCksXG4gICAgICBkZWNvZGVUZXh0KHRoaXMuX3ZhbCwgJ2JpbmFyeScsIHRoaXMuY2hhcnNldCksXG4gICAgICB0aGlzLl9rZXlUcnVuYyxcbiAgICAgIHRoaXMuX3ZhbFRydW5jKVxuICB9XG4gIHRoaXMuYm95Ll9kb25lID0gdHJ1ZVxuICB0aGlzLmJveS5lbWl0KCdmaW5pc2gnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVybEVuY29kZWRcbiJdLCJuYW1lcyI6WyJEZWNvZGVyIiwicmVxdWlyZSIsImRlY29kZVRleHQiLCJnZXRMaW1pdCIsIlJFX0NIQVJTRVQiLCJVcmxFbmNvZGVkIiwiZGV0ZWN0IiwiYm95IiwiY2ZnIiwibGltaXRzIiwicGFyc2VkQ29uVHlwZSIsImZpZWxkU2l6ZUxpbWl0IiwiZmllbGROYW1lU2l6ZUxpbWl0IiwiZmllbGRzTGltaXQiLCJJbmZpbml0eSIsImNoYXJzZXQiLCJpIiwibGVuIiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwidGVzdCIsInRvTG93ZXJDYXNlIiwidW5kZWZpbmVkIiwiZGVmQ2hhcnNldCIsImRlY29kZXIiLCJfZmllbGRzIiwiX3N0YXRlIiwiX2NoZWNraW5nQnl0ZXMiLCJfYnl0ZXNLZXkiLCJfYnl0ZXNWYWwiLCJfa2V5IiwiX3ZhbCIsIl9rZXlUcnVuYyIsIl92YWxUcnVuYyIsIl9oaXRMaW1pdCIsInByb3RvdHlwZSIsIndyaXRlIiwiZGF0YSIsImNiIiwiaGl0RmllbGRzTGltaXQiLCJlbWl0IiwiaWR4ZXEiLCJpZHhhbXAiLCJwIiwidG9TdHJpbmciLCJyZXNldCIsImtleSIsImtleVRydW5jIiwiZW5kIiwiX2RvbmUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/types/urlencoded.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/Decoder.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/Decoder.js ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst RE_PLUS = /\\+/g;\nconst HEX = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n];\nfunction Decoder() {\n    this.buffer = undefined;\n}\nDecoder.prototype.write = function(str) {\n    // Replace '+' with ' ' before decoding\n    str = str.replace(RE_PLUS, \" \");\n    let res = \"\";\n    let i = 0;\n    let p = 0;\n    const len = str.length;\n    for(; i < len; ++i){\n        if (this.buffer !== undefined) {\n            if (!HEX[str.charCodeAt(i)]) {\n                res += \"%\" + this.buffer;\n                this.buffer = undefined;\n                --i // retry character\n                ;\n            } else {\n                this.buffer += str[i];\n                ++p;\n                if (this.buffer.length === 2) {\n                    res += String.fromCharCode(parseInt(this.buffer, 16));\n                    this.buffer = undefined;\n                }\n            }\n        } else if (str[i] === \"%\") {\n            if (i > p) {\n                res += str.substring(p, i);\n                p = i;\n            }\n            this.buffer = \"\";\n            ++p;\n        }\n    }\n    if (p < len && this.buffer === undefined) {\n        res += str.substring(p);\n    }\n    return res;\n};\nDecoder.prototype.reset = function() {\n    this.buffer = undefined;\n};\nmodule.exports = Decoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2xpYi91dGlscy9EZWNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsVUFBVTtBQUVoQixNQUFNQyxNQUFNO0lBQ1Y7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7Q0FDOUM7QUFFRCxTQUFTQztJQUNQLElBQUksQ0FBQ0MsTUFBTSxHQUFHQztBQUNoQjtBQUNBRixRQUFRRyxTQUFTLENBQUNDLEtBQUssR0FBRyxTQUFVQyxHQUFHO0lBQ3JDLHVDQUF1QztJQUN2Q0EsTUFBTUEsSUFBSUMsT0FBTyxDQUFDUixTQUFTO0lBQzNCLElBQUlTLE1BQU07SUFDVixJQUFJQyxJQUFJO0lBQUcsSUFBSUMsSUFBSTtJQUFHLE1BQU1DLE1BQU1MLElBQUlNLE1BQU07SUFDNUMsTUFBT0gsSUFBSUUsS0FBSyxFQUFFRixFQUFHO1FBQ25CLElBQUksSUFBSSxDQUFDUCxNQUFNLEtBQUtDLFdBQVc7WUFDN0IsSUFBSSxDQUFDSCxHQUFHLENBQUNNLElBQUlPLFVBQVUsQ0FBQ0osR0FBRyxFQUFFO2dCQUMzQkQsT0FBTyxNQUFNLElBQUksQ0FBQ04sTUFBTTtnQkFDeEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdDO2dCQUNkLEVBQUVNLEVBQUUsa0JBQWtCOztZQUN4QixPQUFPO2dCQUNMLElBQUksQ0FBQ1AsTUFBTSxJQUFJSSxHQUFHLENBQUNHLEVBQUU7Z0JBQ3JCLEVBQUVDO2dCQUNGLElBQUksSUFBSSxDQUFDUixNQUFNLENBQUNVLE1BQU0sS0FBSyxHQUFHO29CQUM1QkosT0FBT00sT0FBT0MsWUFBWSxDQUFDQyxTQUFTLElBQUksQ0FBQ2QsTUFBTSxFQUFFO29CQUNqRCxJQUFJLENBQUNBLE1BQU0sR0FBR0M7Z0JBQ2hCO1lBQ0Y7UUFDRixPQUFPLElBQUlHLEdBQUcsQ0FBQ0csRUFBRSxLQUFLLEtBQUs7WUFDekIsSUFBSUEsSUFBSUMsR0FBRztnQkFDVEYsT0FBT0YsSUFBSVcsU0FBUyxDQUFDUCxHQUFHRDtnQkFDeEJDLElBQUlEO1lBQ047WUFDQSxJQUFJLENBQUNQLE1BQU0sR0FBRztZQUNkLEVBQUVRO1FBQ0o7SUFDRjtJQUNBLElBQUlBLElBQUlDLE9BQU8sSUFBSSxDQUFDVCxNQUFNLEtBQUtDLFdBQVc7UUFBRUssT0FBT0YsSUFBSVcsU0FBUyxDQUFDUDtJQUFHO0lBQ3BFLE9BQU9GO0FBQ1Q7QUFDQVAsUUFBUUcsU0FBUyxDQUFDYyxLQUFLLEdBQUc7SUFDeEIsSUFBSSxDQUFDaEIsTUFBTSxHQUFHQztBQUNoQjtBQUVBZ0IsT0FBT0MsT0FBTyxHQUFHbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbm9kZV9tb2R1bGVzL0BmYXN0aWZ5L2J1c2JveS9saWIvdXRpbHMvRGVjb2Rlci5qcz9iNDY5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSRV9QTFVTID0gL1xcKy9nXG5cbmNvbnN0IEhFWCA9IFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMFxuXVxuXG5mdW5jdGlvbiBEZWNvZGVyICgpIHtcbiAgdGhpcy5idWZmZXIgPSB1bmRlZmluZWRcbn1cbkRlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cikge1xuICAvLyBSZXBsYWNlICcrJyB3aXRoICcgJyBiZWZvcmUgZGVjb2RpbmdcbiAgc3RyID0gc3RyLnJlcGxhY2UoUkVfUExVUywgJyAnKVxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwOyBsZXQgcCA9IDA7IGNvbnN0IGxlbiA9IHN0ci5sZW5ndGhcbiAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzLmJ1ZmZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIUhFWFtzdHIuY2hhckNvZGVBdChpKV0pIHtcbiAgICAgICAgcmVzICs9ICclJyArIHRoaXMuYnVmZmVyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdW5kZWZpbmVkXG4gICAgICAgIC0taSAvLyByZXRyeSBjaGFyYWN0ZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnVmZmVyICs9IHN0cltpXVxuICAgICAgICArK3BcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHRoaXMuYnVmZmVyLCAxNikpXG4gICAgICAgICAgdGhpcy5idWZmZXIgPSB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSAnJScpIHtcbiAgICAgIGlmIChpID4gcCkge1xuICAgICAgICByZXMgKz0gc3RyLnN1YnN0cmluZyhwLCBpKVxuICAgICAgICBwID0gaVxuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXIgPSAnJ1xuICAgICAgKytwXG4gICAgfVxuICB9XG4gIGlmIChwIDwgbGVuICYmIHRoaXMuYnVmZmVyID09PSB1bmRlZmluZWQpIHsgcmVzICs9IHN0ci5zdWJzdHJpbmcocCkgfVxuICByZXR1cm4gcmVzXG59XG5EZWNvZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5idWZmZXIgPSB1bmRlZmluZWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEZWNvZGVyXG4iXSwibmFtZXMiOlsiUkVfUExVUyIsIkhFWCIsIkRlY29kZXIiLCJidWZmZXIiLCJ1bmRlZmluZWQiLCJwcm90b3R5cGUiLCJ3cml0ZSIsInN0ciIsInJlcGxhY2UiLCJyZXMiLCJpIiwicCIsImxlbiIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJwYXJzZUludCIsInN1YnN0cmluZyIsInJlc2V0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/Decoder.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/basename.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/basename.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function basename(path) {\n    if (typeof path !== \"string\") {\n        return \"\";\n    }\n    for(var i = path.length - 1; i >= 0; --i){\n        switch(path.charCodeAt(i)){\n            case 0x2F:\n            case 0x5C:\n                path = path.slice(i + 1);\n                return path === \"..\" || path === \".\" ? \"\" : path;\n        }\n    }\n    return path === \"..\" || path === \".\" ? \"\" : path;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2xpYi91dGlscy9iYXNlbmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsU0FBVUMsSUFBSTtJQUN0QyxJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUFFLE9BQU87SUFBRztJQUMxQyxJQUFLLElBQUlDLElBQUlELEtBQUtFLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUcsRUFBRUEsRUFBRztRQUN6QyxPQUFRRCxLQUFLRyxVQUFVLENBQUNGO1lBQ3RCLEtBQUs7WUFDTCxLQUFLO2dCQUNIRCxPQUFPQSxLQUFLSSxLQUFLLENBQUNILElBQUk7Z0JBQ3RCLE9BQVFELFNBQVMsUUFBUUEsU0FBUyxNQUFNLEtBQUtBO1FBQ2pEO0lBQ0Y7SUFDQSxPQUFRQSxTQUFTLFFBQVFBLFNBQVMsTUFBTSxLQUFLQTtBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2xpYi91dGlscy9iYXNlbmFtZS5qcz9lNzkzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJhc2VuYW1lIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHsgcmV0dXJuICcnIH1cbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby12YXJcbiAgICBzd2l0Y2ggKHBhdGguY2hhckNvZGVBdChpKSkge1xuICAgICAgY2FzZSAweDJGOiAvLyAnLydcbiAgICAgIGNhc2UgMHg1QzogLy8gJ1xcJ1xuICAgICAgICBwYXRoID0gcGF0aC5zbGljZShpICsgMSlcbiAgICAgICAgcmV0dXJuIChwYXRoID09PSAnLi4nIHx8IHBhdGggPT09ICcuJyA/ICcnIDogcGF0aClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChwYXRoID09PSAnLi4nIHx8IHBhdGggPT09ICcuJyA/ICcnIDogcGF0aClcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiYmFzZW5hbWUiLCJwYXRoIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/basename.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/decodeText.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/decodeText.js ***!
  \**************************************************************************************/
/***/ (function(module) {

"use strict";
eval("\n// Node has always utf-8\nconst utf8Decoder = new TextDecoder(\"utf-8\");\nconst textDecoders = new Map([\n    [\n        \"utf-8\",\n        utf8Decoder\n    ],\n    [\n        \"utf8\",\n        utf8Decoder\n    ]\n]);\nfunction getDecoder(charset) {\n    let lc;\n    while(true){\n        switch(charset){\n            case \"utf-8\":\n            case \"utf8\":\n                return decoders.utf8;\n            case \"latin1\":\n            case \"ascii\":\n            case \"us-ascii\":\n            case \"iso-8859-1\":\n            case \"iso8859-1\":\n            case \"iso88591\":\n            case \"iso_8859-1\":\n            case \"windows-1252\":\n            case \"iso_8859-1:1987\":\n            case \"cp1252\":\n            case \"x-cp1252\":\n                return decoders.latin1;\n            case \"utf16le\":\n            case \"utf-16le\":\n            case \"ucs2\":\n            case \"ucs-2\":\n                return decoders.utf16le;\n            case \"base64\":\n                return decoders.base64;\n            default:\n                if (lc === undefined) {\n                    lc = true;\n                    charset = charset.toLowerCase();\n                    continue;\n                }\n                return decoders.other.bind(charset);\n        }\n    }\n}\nconst decoders = {\n    utf8: (data, sourceEncoding)=>{\n        if (data.length === 0) {\n            return \"\";\n        }\n        if (typeof data === \"string\") {\n            data = Buffer.from(data, sourceEncoding);\n        }\n        return data.utf8Slice(0, data.length);\n    },\n    latin1: (data, sourceEncoding)=>{\n        if (data.length === 0) {\n            return \"\";\n        }\n        if (typeof data === \"string\") {\n            return data;\n        }\n        return data.latin1Slice(0, data.length);\n    },\n    utf16le: (data, sourceEncoding)=>{\n        if (data.length === 0) {\n            return \"\";\n        }\n        if (typeof data === \"string\") {\n            data = Buffer.from(data, sourceEncoding);\n        }\n        return data.ucs2Slice(0, data.length);\n    },\n    base64: (data, sourceEncoding)=>{\n        if (data.length === 0) {\n            return \"\";\n        }\n        if (typeof data === \"string\") {\n            data = Buffer.from(data, sourceEncoding);\n        }\n        return data.base64Slice(0, data.length);\n    },\n    other: (data, sourceEncoding)=>{\n        if (data.length === 0) {\n            return \"\";\n        }\n        if (typeof data === \"string\") {\n            data = Buffer.from(data, sourceEncoding);\n        }\n        if (textDecoders.has(this.toString())) {\n            try {\n                return textDecoders.get(this).decode(data);\n            } catch (e) {}\n        }\n        return typeof data === \"string\" ? data : data.toString();\n    }\n};\nfunction decodeText(text, sourceEncoding, destEncoding) {\n    if (text) {\n        return getDecoder(destEncoding)(text, sourceEncoding);\n    }\n    return text;\n}\nmodule.exports = decodeText;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2xpYi91dGlscy9kZWNvZGVUZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsd0JBQXdCO0FBQ3hCLE1BQU1BLGNBQWMsSUFBSUMsWUFBWTtBQUNwQyxNQUFNQyxlQUFlLElBQUlDLElBQUk7SUFDM0I7UUFBQztRQUFTSDtLQUFZO0lBQ3RCO1FBQUM7UUFBUUE7S0FBWTtDQUN0QjtBQUVELFNBQVNJLFdBQVlDLE9BQU87SUFDMUIsSUFBSUM7SUFDSixNQUFPLEtBQU07UUFDWCxPQUFRRDtZQUNOLEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQU9FLFNBQVNDLElBQUk7WUFDdEIsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBT0QsU0FBU0UsTUFBTTtZQUN4QixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQU9GLFNBQVNHLE9BQU87WUFDekIsS0FBSztnQkFDSCxPQUFPSCxTQUFTSSxNQUFNO1lBQ3hCO2dCQUNFLElBQUlMLE9BQU9NLFdBQVc7b0JBQ3BCTixLQUFLO29CQUNMRCxVQUFVQSxRQUFRUSxXQUFXO29CQUM3QjtnQkFDRjtnQkFDQSxPQUFPTixTQUFTTyxLQUFLLENBQUNDLElBQUksQ0FBQ1Y7UUFDL0I7SUFDRjtBQUNGO0FBRUEsTUFBTUUsV0FBVztJQUNmQyxNQUFNLENBQUNRLE1BQU1DO1FBQ1gsSUFBSUQsS0FBS0UsTUFBTSxLQUFLLEdBQUc7WUFDckIsT0FBTztRQUNUO1FBQ0EsSUFBSSxPQUFPRixTQUFTLFVBQVU7WUFDNUJBLE9BQU9HLE9BQU9DLElBQUksQ0FBQ0osTUFBTUM7UUFDM0I7UUFDQSxPQUFPRCxLQUFLSyxTQUFTLENBQUMsR0FBR0wsS0FBS0UsTUFBTTtJQUN0QztJQUVBVCxRQUFRLENBQUNPLE1BQU1DO1FBQ2IsSUFBSUQsS0FBS0UsTUFBTSxLQUFLLEdBQUc7WUFDckIsT0FBTztRQUNUO1FBQ0EsSUFBSSxPQUFPRixTQUFTLFVBQVU7WUFDNUIsT0FBT0E7UUFDVDtRQUNBLE9BQU9BLEtBQUtNLFdBQVcsQ0FBQyxHQUFHTixLQUFLRSxNQUFNO0lBQ3hDO0lBRUFSLFNBQVMsQ0FBQ00sTUFBTUM7UUFDZCxJQUFJRCxLQUFLRSxNQUFNLEtBQUssR0FBRztZQUNyQixPQUFPO1FBQ1Q7UUFDQSxJQUFJLE9BQU9GLFNBQVMsVUFBVTtZQUM1QkEsT0FBT0csT0FBT0MsSUFBSSxDQUFDSixNQUFNQztRQUMzQjtRQUNBLE9BQU9ELEtBQUtPLFNBQVMsQ0FBQyxHQUFHUCxLQUFLRSxNQUFNO0lBQ3RDO0lBRUFQLFFBQVEsQ0FBQ0ssTUFBTUM7UUFDYixJQUFJRCxLQUFLRSxNQUFNLEtBQUssR0FBRztZQUNyQixPQUFPO1FBQ1Q7UUFDQSxJQUFJLE9BQU9GLFNBQVMsVUFBVTtZQUM1QkEsT0FBT0csT0FBT0MsSUFBSSxDQUFDSixNQUFNQztRQUMzQjtRQUNBLE9BQU9ELEtBQUtRLFdBQVcsQ0FBQyxHQUFHUixLQUFLRSxNQUFNO0lBQ3hDO0lBRUFKLE9BQU8sQ0FBQ0UsTUFBTUM7UUFDWixJQUFJRCxLQUFLRSxNQUFNLEtBQUssR0FBRztZQUNyQixPQUFPO1FBQ1Q7UUFDQSxJQUFJLE9BQU9GLFNBQVMsVUFBVTtZQUM1QkEsT0FBT0csT0FBT0MsSUFBSSxDQUFDSixNQUFNQztRQUMzQjtRQUVBLElBQUlmLGFBQWF1QixHQUFHLENBQUMsSUFBSSxDQUFDQyxRQUFRLEtBQUs7WUFDckMsSUFBSTtnQkFDRixPQUFPeEIsYUFBYXlCLEdBQUcsQ0FBQyxJQUFJLEVBQUVDLE1BQU0sQ0FBQ1o7WUFDdkMsRUFBRSxPQUFPYSxHQUFHLENBQUU7UUFDaEI7UUFDQSxPQUFPLE9BQU9iLFNBQVMsV0FDbkJBLE9BQ0FBLEtBQUtVLFFBQVE7SUFDbkI7QUFDRjtBQUVBLFNBQVNJLFdBQVlDLElBQUksRUFBRWQsY0FBYyxFQUFFZSxZQUFZO0lBQ3JELElBQUlELE1BQU07UUFDUixPQUFPM0IsV0FBVzRCLGNBQWNELE1BQU1kO0lBQ3hDO0lBQ0EsT0FBT2M7QUFDVDtBQUVBRSxPQUFPQyxPQUFPLEdBQUdKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHN0cmlwZS1kaXNjb3JkL3NlbGxlci8uLi8uLi9ub2RlX21vZHVsZXMvdW5kaWNpL25vZGVfbW9kdWxlcy9AZmFzdGlmeS9idXNib3kvbGliL3V0aWxzL2RlY29kZVRleHQuanM/NTEzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gTm9kZSBoYXMgYWx3YXlzIHV0Zi04XG5jb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKVxuY29uc3QgdGV4dERlY29kZXJzID0gbmV3IE1hcChbXG4gIFsndXRmLTgnLCB1dGY4RGVjb2Rlcl0sXG4gIFsndXRmOCcsIHV0ZjhEZWNvZGVyXVxuXSlcblxuZnVuY3Rpb24gZ2V0RGVjb2RlciAoY2hhcnNldCkge1xuICBsZXQgbGNcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGNoYXJzZXQpIHtcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgICByZXR1cm4gZGVjb2RlcnMudXRmOFxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2FzY2lpJzogLy8gVE9ETzogTWFrZSB0aGVzZSBhIHNlcGFyYXRlLCBzdHJpY3QgZGVjb2Rlcj9cbiAgICAgIGNhc2UgJ3VzLWFzY2lpJzpcbiAgICAgIGNhc2UgJ2lzby04ODU5LTEnOlxuICAgICAgY2FzZSAnaXNvODg1OS0xJzpcbiAgICAgIGNhc2UgJ2lzbzg4NTkxJzpcbiAgICAgIGNhc2UgJ2lzb184ODU5LTEnOlxuICAgICAgY2FzZSAnd2luZG93cy0xMjUyJzpcbiAgICAgIGNhc2UgJ2lzb184ODU5LTE6MTk4Nyc6XG4gICAgICBjYXNlICdjcDEyNTInOlxuICAgICAgY2FzZSAneC1jcDEyNTInOlxuICAgICAgICByZXR1cm4gZGVjb2RlcnMubGF0aW4xXG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgICByZXR1cm4gZGVjb2RlcnMudXRmMTZsZVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGRlY29kZXJzLmJhc2U2NFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsYyA9IHRydWVcbiAgICAgICAgICBjaGFyc2V0ID0gY2hhcnNldC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb2RlcnMub3RoZXIuYmluZChjaGFyc2V0KVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBkZWNvZGVycyA9IHtcbiAgdXRmODogKGRhdGEsIHNvdXJjZUVuY29kaW5nKSA9PiB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIHNvdXJjZUVuY29kaW5nKVxuICAgIH1cbiAgICByZXR1cm4gZGF0YS51dGY4U2xpY2UoMCwgZGF0YS5sZW5ndGgpXG4gIH0sXG5cbiAgbGF0aW4xOiAoZGF0YSwgc291cmNlRW5jb2RpbmcpID0+IHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZGF0YVxuICAgIH1cbiAgICByZXR1cm4gZGF0YS5sYXRpbjFTbGljZSgwLCBkYXRhLmxlbmd0aClcbiAgfSxcblxuICB1dGYxNmxlOiAoZGF0YSwgc291cmNlRW5jb2RpbmcpID0+IHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgc291cmNlRW5jb2RpbmcpXG4gICAgfVxuICAgIHJldHVybiBkYXRhLnVjczJTbGljZSgwLCBkYXRhLmxlbmd0aClcbiAgfSxcblxuICBiYXNlNjQ6IChkYXRhLCBzb3VyY2VFbmNvZGluZykgPT4ge1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBzb3VyY2VFbmNvZGluZylcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuYmFzZTY0U2xpY2UoMCwgZGF0YS5sZW5ndGgpXG4gIH0sXG5cbiAgb3RoZXI6IChkYXRhLCBzb3VyY2VFbmNvZGluZykgPT4ge1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBzb3VyY2VFbmNvZGluZylcbiAgICB9XG5cbiAgICBpZiAodGV4dERlY29kZXJzLmhhcyh0aGlzLnRvU3RyaW5nKCkpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGV4dERlY29kZXJzLmdldCh0aGlzKS5kZWNvZGUoZGF0YSlcbiAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnXG4gICAgICA/IGRhdGFcbiAgICAgIDogZGF0YS50b1N0cmluZygpXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjb2RlVGV4dCAodGV4dCwgc291cmNlRW5jb2RpbmcsIGRlc3RFbmNvZGluZykge1xuICBpZiAodGV4dCkge1xuICAgIHJldHVybiBnZXREZWNvZGVyKGRlc3RFbmNvZGluZykodGV4dCwgc291cmNlRW5jb2RpbmcpXG4gIH1cbiAgcmV0dXJuIHRleHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGVUZXh0XG4iXSwibmFtZXMiOlsidXRmOERlY29kZXIiLCJUZXh0RGVjb2RlciIsInRleHREZWNvZGVycyIsIk1hcCIsImdldERlY29kZXIiLCJjaGFyc2V0IiwibGMiLCJkZWNvZGVycyIsInV0ZjgiLCJsYXRpbjEiLCJ1dGYxNmxlIiwiYmFzZTY0IiwidW5kZWZpbmVkIiwidG9Mb3dlckNhc2UiLCJvdGhlciIsImJpbmQiLCJkYXRhIiwic291cmNlRW5jb2RpbmciLCJsZW5ndGgiLCJCdWZmZXIiLCJmcm9tIiwidXRmOFNsaWNlIiwibGF0aW4xU2xpY2UiLCJ1Y3MyU2xpY2UiLCJiYXNlNjRTbGljZSIsImhhcyIsInRvU3RyaW5nIiwiZ2V0IiwiZGVjb2RlIiwiZSIsImRlY29kZVRleHQiLCJ0ZXh0IiwiZGVzdEVuY29kaW5nIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/decodeText.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/getLimit.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/getLimit.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function getLimit(limits, name, defaultLimit) {\n    if (!limits || limits[name] === undefined || limits[name] === null) {\n        return defaultLimit;\n    }\n    if (typeof limits[name] !== \"number\" || isNaN(limits[name])) {\n        throw new TypeError(\"Limit \" + name + \" is not a valid number\");\n    }\n    return limits[name];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2xpYi91dGlscy9nZXRMaW1pdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsU0FBVUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFlBQVk7SUFDNUQsSUFDRSxDQUFDRixVQUNEQSxNQUFNLENBQUNDLEtBQUssS0FBS0UsYUFDakJILE1BQU0sQ0FBQ0MsS0FBSyxLQUFLLE1BQ2pCO1FBQUUsT0FBT0M7SUFBYTtJQUV4QixJQUNFLE9BQU9GLE1BQU0sQ0FBQ0MsS0FBSyxLQUFLLFlBQ3hCRyxNQUFNSixNQUFNLENBQUNDLEtBQUssR0FDbEI7UUFBRSxNQUFNLElBQUlJLFVBQVUsV0FBV0osT0FBTztJQUEwQjtJQUVwRSxPQUFPRCxNQUFNLENBQUNDLEtBQUs7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbm9kZV9tb2R1bGVzL0BmYXN0aWZ5L2J1c2JveS9saWIvdXRpbHMvZ2V0TGltaXQuanM/MTJkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRMaW1pdCAobGltaXRzLCBuYW1lLCBkZWZhdWx0TGltaXQpIHtcbiAgaWYgKFxuICAgICFsaW1pdHMgfHxcbiAgICBsaW1pdHNbbmFtZV0gPT09IHVuZGVmaW5lZCB8fFxuICAgIGxpbWl0c1tuYW1lXSA9PT0gbnVsbFxuICApIHsgcmV0dXJuIGRlZmF1bHRMaW1pdCB9XG5cbiAgaWYgKFxuICAgIHR5cGVvZiBsaW1pdHNbbmFtZV0gIT09ICdudW1iZXInIHx8XG4gICAgaXNOYU4obGltaXRzW25hbWVdKVxuICApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignTGltaXQgJyArIG5hbWUgKyAnIGlzIG5vdCBhIHZhbGlkIG51bWJlcicpIH1cblxuICByZXR1cm4gbGltaXRzW25hbWVdXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImdldExpbWl0IiwibGltaXRzIiwibmFtZSIsImRlZmF1bHRMaW1pdCIsInVuZGVmaW5lZCIsImlzTmFOIiwiVHlwZUVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/getLimit.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/parseParams.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/parseParams.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint-disable object-property-newline */ \nconst decodeText = __webpack_require__(/*! ./decodeText */ \"(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/decodeText.js\");\nconst RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;\nconst EncodedLookup = {\n    \"%00\": \"\\x00\",\n    \"%01\": \"\\x01\",\n    \"%02\": \"\\x02\",\n    \"%03\": \"\\x03\",\n    \"%04\": \"\\x04\",\n    \"%05\": \"\\x05\",\n    \"%06\": \"\\x06\",\n    \"%07\": \"\\x07\",\n    \"%08\": \"\\b\",\n    \"%09\": \"\t\",\n    \"%0a\": \"\\n\",\n    \"%0A\": \"\\n\",\n    \"%0b\": \"\\v\",\n    \"%0B\": \"\\v\",\n    \"%0c\": \"\\f\",\n    \"%0C\": \"\\f\",\n    \"%0d\": \"\\r\",\n    \"%0D\": \"\\r\",\n    \"%0e\": \"\\x0e\",\n    \"%0E\": \"\\x0e\",\n    \"%0f\": \"\\x0f\",\n    \"%0F\": \"\\x0f\",\n    \"%10\": \"\\x10\",\n    \"%11\": \"\\x11\",\n    \"%12\": \"\\x12\",\n    \"%13\": \"\\x13\",\n    \"%14\": \"\\x14\",\n    \"%15\": \"\\x15\",\n    \"%16\": \"\\x16\",\n    \"%17\": \"\\x17\",\n    \"%18\": \"\\x18\",\n    \"%19\": \"\\x19\",\n    \"%1a\": \"\\x1a\",\n    \"%1A\": \"\\x1a\",\n    \"%1b\": \"\\x1b\",\n    \"%1B\": \"\\x1b\",\n    \"%1c\": \"\\x1c\",\n    \"%1C\": \"\\x1c\",\n    \"%1d\": \"\\x1d\",\n    \"%1D\": \"\\x1d\",\n    \"%1e\": \"\\x1e\",\n    \"%1E\": \"\\x1e\",\n    \"%1f\": \"\\x1f\",\n    \"%1F\": \"\\x1f\",\n    \"%20\": \" \",\n    \"%21\": \"!\",\n    \"%22\": '\"',\n    \"%23\": \"#\",\n    \"%24\": \"$\",\n    \"%25\": \"%\",\n    \"%26\": \"&\",\n    \"%27\": \"'\",\n    \"%28\": \"(\",\n    \"%29\": \")\",\n    \"%2a\": \"*\",\n    \"%2A\": \"*\",\n    \"%2b\": \"+\",\n    \"%2B\": \"+\",\n    \"%2c\": \",\",\n    \"%2C\": \",\",\n    \"%2d\": \"-\",\n    \"%2D\": \"-\",\n    \"%2e\": \".\",\n    \"%2E\": \".\",\n    \"%2f\": \"/\",\n    \"%2F\": \"/\",\n    \"%30\": \"0\",\n    \"%31\": \"1\",\n    \"%32\": \"2\",\n    \"%33\": \"3\",\n    \"%34\": \"4\",\n    \"%35\": \"5\",\n    \"%36\": \"6\",\n    \"%37\": \"7\",\n    \"%38\": \"8\",\n    \"%39\": \"9\",\n    \"%3a\": \":\",\n    \"%3A\": \":\",\n    \"%3b\": \";\",\n    \"%3B\": \";\",\n    \"%3c\": \"<\",\n    \"%3C\": \"<\",\n    \"%3d\": \"=\",\n    \"%3D\": \"=\",\n    \"%3e\": \">\",\n    \"%3E\": \">\",\n    \"%3f\": \"?\",\n    \"%3F\": \"?\",\n    \"%40\": \"@\",\n    \"%41\": \"A\",\n    \"%42\": \"B\",\n    \"%43\": \"C\",\n    \"%44\": \"D\",\n    \"%45\": \"E\",\n    \"%46\": \"F\",\n    \"%47\": \"G\",\n    \"%48\": \"H\",\n    \"%49\": \"I\",\n    \"%4a\": \"J\",\n    \"%4A\": \"J\",\n    \"%4b\": \"K\",\n    \"%4B\": \"K\",\n    \"%4c\": \"L\",\n    \"%4C\": \"L\",\n    \"%4d\": \"M\",\n    \"%4D\": \"M\",\n    \"%4e\": \"N\",\n    \"%4E\": \"N\",\n    \"%4f\": \"O\",\n    \"%4F\": \"O\",\n    \"%50\": \"P\",\n    \"%51\": \"Q\",\n    \"%52\": \"R\",\n    \"%53\": \"S\",\n    \"%54\": \"T\",\n    \"%55\": \"U\",\n    \"%56\": \"V\",\n    \"%57\": \"W\",\n    \"%58\": \"X\",\n    \"%59\": \"Y\",\n    \"%5a\": \"Z\",\n    \"%5A\": \"Z\",\n    \"%5b\": \"[\",\n    \"%5B\": \"[\",\n    \"%5c\": \"\\\\\",\n    \"%5C\": \"\\\\\",\n    \"%5d\": \"]\",\n    \"%5D\": \"]\",\n    \"%5e\": \"^\",\n    \"%5E\": \"^\",\n    \"%5f\": \"_\",\n    \"%5F\": \"_\",\n    \"%60\": \"`\",\n    \"%61\": \"a\",\n    \"%62\": \"b\",\n    \"%63\": \"c\",\n    \"%64\": \"d\",\n    \"%65\": \"e\",\n    \"%66\": \"f\",\n    \"%67\": \"g\",\n    \"%68\": \"h\",\n    \"%69\": \"i\",\n    \"%6a\": \"j\",\n    \"%6A\": \"j\",\n    \"%6b\": \"k\",\n    \"%6B\": \"k\",\n    \"%6c\": \"l\",\n    \"%6C\": \"l\",\n    \"%6d\": \"m\",\n    \"%6D\": \"m\",\n    \"%6e\": \"n\",\n    \"%6E\": \"n\",\n    \"%6f\": \"o\",\n    \"%6F\": \"o\",\n    \"%70\": \"p\",\n    \"%71\": \"q\",\n    \"%72\": \"r\",\n    \"%73\": \"s\",\n    \"%74\": \"t\",\n    \"%75\": \"u\",\n    \"%76\": \"v\",\n    \"%77\": \"w\",\n    \"%78\": \"x\",\n    \"%79\": \"y\",\n    \"%7a\": \"z\",\n    \"%7A\": \"z\",\n    \"%7b\": \"{\",\n    \"%7B\": \"{\",\n    \"%7c\": \"|\",\n    \"%7C\": \"|\",\n    \"%7d\": \"}\",\n    \"%7D\": \"}\",\n    \"%7e\": \"~\",\n    \"%7E\": \"~\",\n    \"%7f\": \"\\x7f\",\n    \"%7F\": \"\\x7f\",\n    \"%80\": \"\\x80\",\n    \"%81\": \"\\x81\",\n    \"%82\": \"\\x82\",\n    \"%83\": \"\\x83\",\n    \"%84\": \"\\x84\",\n    \"%85\": \"\\x85\",\n    \"%86\": \"\\x86\",\n    \"%87\": \"\\x87\",\n    \"%88\": \"\\x88\",\n    \"%89\": \"\\x89\",\n    \"%8a\": \"\\x8a\",\n    \"%8A\": \"\\x8a\",\n    \"%8b\": \"\\x8b\",\n    \"%8B\": \"\\x8b\",\n    \"%8c\": \"\\x8c\",\n    \"%8C\": \"\\x8c\",\n    \"%8d\": \"\\x8d\",\n    \"%8D\": \"\\x8d\",\n    \"%8e\": \"\\x8e\",\n    \"%8E\": \"\\x8e\",\n    \"%8f\": \"\\x8f\",\n    \"%8F\": \"\\x8f\",\n    \"%90\": \"\\x90\",\n    \"%91\": \"\\x91\",\n    \"%92\": \"\\x92\",\n    \"%93\": \"\\x93\",\n    \"%94\": \"\\x94\",\n    \"%95\": \"\\x95\",\n    \"%96\": \"\\x96\",\n    \"%97\": \"\\x97\",\n    \"%98\": \"\\x98\",\n    \"%99\": \"\\x99\",\n    \"%9a\": \"\\x9a\",\n    \"%9A\": \"\\x9a\",\n    \"%9b\": \"\\x9b\",\n    \"%9B\": \"\\x9b\",\n    \"%9c\": \"\\x9c\",\n    \"%9C\": \"\\x9c\",\n    \"%9d\": \"\\x9d\",\n    \"%9D\": \"\\x9d\",\n    \"%9e\": \"\\x9e\",\n    \"%9E\": \"\\x9e\",\n    \"%9f\": \"\\x9f\",\n    \"%9F\": \"\\x9f\",\n    \"%a0\": \"\\xa0\",\n    \"%A0\": \"\\xa0\",\n    \"%a1\": \"\\xa1\",\n    \"%A1\": \"\\xa1\",\n    \"%a2\": \"\\xa2\",\n    \"%A2\": \"\\xa2\",\n    \"%a3\": \"\\xa3\",\n    \"%A3\": \"\\xa3\",\n    \"%a4\": \"\\xa4\",\n    \"%A4\": \"\\xa4\",\n    \"%a5\": \"\\xa5\",\n    \"%A5\": \"\\xa5\",\n    \"%a6\": \"\\xa6\",\n    \"%A6\": \"\\xa6\",\n    \"%a7\": \"\\xa7\",\n    \"%A7\": \"\\xa7\",\n    \"%a8\": \"\\xa8\",\n    \"%A8\": \"\\xa8\",\n    \"%a9\": \"\\xa9\",\n    \"%A9\": \"\\xa9\",\n    \"%aa\": \"\\xaa\",\n    \"%Aa\": \"\\xaa\",\n    \"%aA\": \"\\xaa\",\n    \"%AA\": \"\\xaa\",\n    \"%ab\": \"\\xab\",\n    \"%Ab\": \"\\xab\",\n    \"%aB\": \"\\xab\",\n    \"%AB\": \"\\xab\",\n    \"%ac\": \"\\xac\",\n    \"%Ac\": \"\\xac\",\n    \"%aC\": \"\\xac\",\n    \"%AC\": \"\\xac\",\n    \"%ad\": \"\\xad\",\n    \"%Ad\": \"\\xad\",\n    \"%aD\": \"\\xad\",\n    \"%AD\": \"\\xad\",\n    \"%ae\": \"\\xae\",\n    \"%Ae\": \"\\xae\",\n    \"%aE\": \"\\xae\",\n    \"%AE\": \"\\xae\",\n    \"%af\": \"\\xaf\",\n    \"%Af\": \"\\xaf\",\n    \"%aF\": \"\\xaf\",\n    \"%AF\": \"\\xaf\",\n    \"%b0\": \"\\xb0\",\n    \"%B0\": \"\\xb0\",\n    \"%b1\": \"\\xb1\",\n    \"%B1\": \"\\xb1\",\n    \"%b2\": \"\\xb2\",\n    \"%B2\": \"\\xb2\",\n    \"%b3\": \"\\xb3\",\n    \"%B3\": \"\\xb3\",\n    \"%b4\": \"\\xb4\",\n    \"%B4\": \"\\xb4\",\n    \"%b5\": \"\\xb5\",\n    \"%B5\": \"\\xb5\",\n    \"%b6\": \"\\xb6\",\n    \"%B6\": \"\\xb6\",\n    \"%b7\": \"\\xb7\",\n    \"%B7\": \"\\xb7\",\n    \"%b8\": \"\\xb8\",\n    \"%B8\": \"\\xb8\",\n    \"%b9\": \"\\xb9\",\n    \"%B9\": \"\\xb9\",\n    \"%ba\": \"\\xba\",\n    \"%Ba\": \"\\xba\",\n    \"%bA\": \"\\xba\",\n    \"%BA\": \"\\xba\",\n    \"%bb\": \"\\xbb\",\n    \"%Bb\": \"\\xbb\",\n    \"%bB\": \"\\xbb\",\n    \"%BB\": \"\\xbb\",\n    \"%bc\": \"\\xbc\",\n    \"%Bc\": \"\\xbc\",\n    \"%bC\": \"\\xbc\",\n    \"%BC\": \"\\xbc\",\n    \"%bd\": \"\\xbd\",\n    \"%Bd\": \"\\xbd\",\n    \"%bD\": \"\\xbd\",\n    \"%BD\": \"\\xbd\",\n    \"%be\": \"\\xbe\",\n    \"%Be\": \"\\xbe\",\n    \"%bE\": \"\\xbe\",\n    \"%BE\": \"\\xbe\",\n    \"%bf\": \"\\xbf\",\n    \"%Bf\": \"\\xbf\",\n    \"%bF\": \"\\xbf\",\n    \"%BF\": \"\\xbf\",\n    \"%c0\": \"\\xc0\",\n    \"%C0\": \"\\xc0\",\n    \"%c1\": \"\\xc1\",\n    \"%C1\": \"\\xc1\",\n    \"%c2\": \"\\xc2\",\n    \"%C2\": \"\\xc2\",\n    \"%c3\": \"\\xc3\",\n    \"%C3\": \"\\xc3\",\n    \"%c4\": \"\\xc4\",\n    \"%C4\": \"\\xc4\",\n    \"%c5\": \"\\xc5\",\n    \"%C5\": \"\\xc5\",\n    \"%c6\": \"\\xc6\",\n    \"%C6\": \"\\xc6\",\n    \"%c7\": \"\\xc7\",\n    \"%C7\": \"\\xc7\",\n    \"%c8\": \"\\xc8\",\n    \"%C8\": \"\\xc8\",\n    \"%c9\": \"\\xc9\",\n    \"%C9\": \"\\xc9\",\n    \"%ca\": \"\\xca\",\n    \"%Ca\": \"\\xca\",\n    \"%cA\": \"\\xca\",\n    \"%CA\": \"\\xca\",\n    \"%cb\": \"\\xcb\",\n    \"%Cb\": \"\\xcb\",\n    \"%cB\": \"\\xcb\",\n    \"%CB\": \"\\xcb\",\n    \"%cc\": \"\\xcc\",\n    \"%Cc\": \"\\xcc\",\n    \"%cC\": \"\\xcc\",\n    \"%CC\": \"\\xcc\",\n    \"%cd\": \"\\xcd\",\n    \"%Cd\": \"\\xcd\",\n    \"%cD\": \"\\xcd\",\n    \"%CD\": \"\\xcd\",\n    \"%ce\": \"\\xce\",\n    \"%Ce\": \"\\xce\",\n    \"%cE\": \"\\xce\",\n    \"%CE\": \"\\xce\",\n    \"%cf\": \"\\xcf\",\n    \"%Cf\": \"\\xcf\",\n    \"%cF\": \"\\xcf\",\n    \"%CF\": \"\\xcf\",\n    \"%d0\": \"\\xd0\",\n    \"%D0\": \"\\xd0\",\n    \"%d1\": \"\\xd1\",\n    \"%D1\": \"\\xd1\",\n    \"%d2\": \"\\xd2\",\n    \"%D2\": \"\\xd2\",\n    \"%d3\": \"\\xd3\",\n    \"%D3\": \"\\xd3\",\n    \"%d4\": \"\\xd4\",\n    \"%D4\": \"\\xd4\",\n    \"%d5\": \"\\xd5\",\n    \"%D5\": \"\\xd5\",\n    \"%d6\": \"\\xd6\",\n    \"%D6\": \"\\xd6\",\n    \"%d7\": \"\\xd7\",\n    \"%D7\": \"\\xd7\",\n    \"%d8\": \"\\xd8\",\n    \"%D8\": \"\\xd8\",\n    \"%d9\": \"\\xd9\",\n    \"%D9\": \"\\xd9\",\n    \"%da\": \"\\xda\",\n    \"%Da\": \"\\xda\",\n    \"%dA\": \"\\xda\",\n    \"%DA\": \"\\xda\",\n    \"%db\": \"\\xdb\",\n    \"%Db\": \"\\xdb\",\n    \"%dB\": \"\\xdb\",\n    \"%DB\": \"\\xdb\",\n    \"%dc\": \"\\xdc\",\n    \"%Dc\": \"\\xdc\",\n    \"%dC\": \"\\xdc\",\n    \"%DC\": \"\\xdc\",\n    \"%dd\": \"\\xdd\",\n    \"%Dd\": \"\\xdd\",\n    \"%dD\": \"\\xdd\",\n    \"%DD\": \"\\xdd\",\n    \"%de\": \"\\xde\",\n    \"%De\": \"\\xde\",\n    \"%dE\": \"\\xde\",\n    \"%DE\": \"\\xde\",\n    \"%df\": \"\\xdf\",\n    \"%Df\": \"\\xdf\",\n    \"%dF\": \"\\xdf\",\n    \"%DF\": \"\\xdf\",\n    \"%e0\": \"\\xe0\",\n    \"%E0\": \"\\xe0\",\n    \"%e1\": \"\\xe1\",\n    \"%E1\": \"\\xe1\",\n    \"%e2\": \"\\xe2\",\n    \"%E2\": \"\\xe2\",\n    \"%e3\": \"\\xe3\",\n    \"%E3\": \"\\xe3\",\n    \"%e4\": \"\\xe4\",\n    \"%E4\": \"\\xe4\",\n    \"%e5\": \"\\xe5\",\n    \"%E5\": \"\\xe5\",\n    \"%e6\": \"\\xe6\",\n    \"%E6\": \"\\xe6\",\n    \"%e7\": \"\\xe7\",\n    \"%E7\": \"\\xe7\",\n    \"%e8\": \"\\xe8\",\n    \"%E8\": \"\\xe8\",\n    \"%e9\": \"\\xe9\",\n    \"%E9\": \"\\xe9\",\n    \"%ea\": \"\\xea\",\n    \"%Ea\": \"\\xea\",\n    \"%eA\": \"\\xea\",\n    \"%EA\": \"\\xea\",\n    \"%eb\": \"\\xeb\",\n    \"%Eb\": \"\\xeb\",\n    \"%eB\": \"\\xeb\",\n    \"%EB\": \"\\xeb\",\n    \"%ec\": \"\\xec\",\n    \"%Ec\": \"\\xec\",\n    \"%eC\": \"\\xec\",\n    \"%EC\": \"\\xec\",\n    \"%ed\": \"\\xed\",\n    \"%Ed\": \"\\xed\",\n    \"%eD\": \"\\xed\",\n    \"%ED\": \"\\xed\",\n    \"%ee\": \"\\xee\",\n    \"%Ee\": \"\\xee\",\n    \"%eE\": \"\\xee\",\n    \"%EE\": \"\\xee\",\n    \"%ef\": \"\\xef\",\n    \"%Ef\": \"\\xef\",\n    \"%eF\": \"\\xef\",\n    \"%EF\": \"\\xef\",\n    \"%f0\": \"\\xf0\",\n    \"%F0\": \"\\xf0\",\n    \"%f1\": \"\\xf1\",\n    \"%F1\": \"\\xf1\",\n    \"%f2\": \"\\xf2\",\n    \"%F2\": \"\\xf2\",\n    \"%f3\": \"\\xf3\",\n    \"%F3\": \"\\xf3\",\n    \"%f4\": \"\\xf4\",\n    \"%F4\": \"\\xf4\",\n    \"%f5\": \"\\xf5\",\n    \"%F5\": \"\\xf5\",\n    \"%f6\": \"\\xf6\",\n    \"%F6\": \"\\xf6\",\n    \"%f7\": \"\\xf7\",\n    \"%F7\": \"\\xf7\",\n    \"%f8\": \"\\xf8\",\n    \"%F8\": \"\\xf8\",\n    \"%f9\": \"\\xf9\",\n    \"%F9\": \"\\xf9\",\n    \"%fa\": \"\\xfa\",\n    \"%Fa\": \"\\xfa\",\n    \"%fA\": \"\\xfa\",\n    \"%FA\": \"\\xfa\",\n    \"%fb\": \"\\xfb\",\n    \"%Fb\": \"\\xfb\",\n    \"%fB\": \"\\xfb\",\n    \"%FB\": \"\\xfb\",\n    \"%fc\": \"\\xfc\",\n    \"%Fc\": \"\\xfc\",\n    \"%fC\": \"\\xfc\",\n    \"%FC\": \"\\xfc\",\n    \"%fd\": \"\\xfd\",\n    \"%Fd\": \"\\xfd\",\n    \"%fD\": \"\\xfd\",\n    \"%FD\": \"\\xfd\",\n    \"%fe\": \"\\xfe\",\n    \"%Fe\": \"\\xfe\",\n    \"%fE\": \"\\xfe\",\n    \"%FE\": \"\\xfe\",\n    \"%ff\": \"\\xff\",\n    \"%Ff\": \"\\xff\",\n    \"%fF\": \"\\xff\",\n    \"%FF\": \"\\xff\"\n};\nfunction encodedReplacer(match) {\n    return EncodedLookup[match];\n}\nconst STATE_KEY = 0;\nconst STATE_VALUE = 1;\nconst STATE_CHARSET = 2;\nconst STATE_LANG = 3;\nfunction parseParams(str) {\n    const res = [];\n    let state = STATE_KEY;\n    let charset = \"\";\n    let inquote = false;\n    let escaping = false;\n    let p = 0;\n    let tmp = \"\";\n    const len = str.length;\n    for(var i = 0; i < len; ++i){\n        const char = str[i];\n        if (char === \"\\\\\" && inquote) {\n            if (escaping) {\n                escaping = false;\n            } else {\n                escaping = true;\n                continue;\n            }\n        } else if (char === '\"') {\n            if (!escaping) {\n                if (inquote) {\n                    inquote = false;\n                    state = STATE_KEY;\n                } else {\n                    inquote = true;\n                }\n                continue;\n            } else {\n                escaping = false;\n            }\n        } else {\n            if (escaping && inquote) {\n                tmp += \"\\\\\";\n            }\n            escaping = false;\n            if ((state === STATE_CHARSET || state === STATE_LANG) && char === \"'\") {\n                if (state === STATE_CHARSET) {\n                    state = STATE_LANG;\n                    charset = tmp.substring(1);\n                } else {\n                    state = STATE_VALUE;\n                }\n                tmp = \"\";\n                continue;\n            } else if (state === STATE_KEY && (char === \"*\" || char === \"=\") && res.length) {\n                state = char === \"*\" ? STATE_CHARSET : STATE_VALUE;\n                res[p] = [\n                    tmp,\n                    undefined\n                ];\n                tmp = \"\";\n                continue;\n            } else if (!inquote && char === \";\") {\n                state = STATE_KEY;\n                if (charset) {\n                    if (tmp.length) {\n                        tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), \"binary\", charset);\n                    }\n                    charset = \"\";\n                } else if (tmp.length) {\n                    tmp = decodeText(tmp, \"binary\", \"utf8\");\n                }\n                if (res[p] === undefined) {\n                    res[p] = tmp;\n                } else {\n                    res[p][1] = tmp;\n                }\n                tmp = \"\";\n                ++p;\n                continue;\n            } else if (!inquote && (char === \" \" || char === \"\t\")) {\n                continue;\n            }\n        }\n        tmp += char;\n    }\n    if (charset && tmp.length) {\n        tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), \"binary\", charset);\n    } else if (tmp) {\n        tmp = decodeText(tmp, \"binary\", \"utf8\");\n    }\n    if (res[p] === undefined) {\n        if (tmp) {\n            res[p] = tmp;\n        }\n    } else {\n        res[p][1] = tmp;\n    }\n    return res;\n}\nmodule.exports = parseParams;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VuZGljaS9ub2RlX21vZHVsZXMvQGZhc3RpZnkvYnVzYm95L2xpYi91dGlscy9wYXJzZVBhcmFtcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSwwQ0FBMEMsR0FDMUM7QUFFQSxNQUFNQSxhQUFhQyxtQkFBT0EsQ0FBQztBQUUzQixNQUFNQyxhQUFhO0FBRW5CLE1BQU1DLGdCQUFnQjtJQUNwQixPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lBQVEsT0FBTztJQUFRLE9BQU87SUFBUSxPQUFPO0lBQVEsT0FBTztJQUNuRSxPQUFPO0lB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QixJQUFJTyxPQUFPLENBQUN2QixZQUFZRSxrQkFDdkMsVUFDQVU7b0JBQ0o7b0JBQ0FBLFVBQVU7Z0JBQ1osT0FBTyxJQUFJSSxJQUFJRSxNQUFNLEVBQUU7b0JBQ3JCRixNQUFNbEIsV0FBV2tCLEtBQUssVUFBVTtnQkFDbEM7Z0JBQ0EsSUFBSU4sR0FBRyxDQUFDSyxFQUFFLEtBQUtPLFdBQVc7b0JBQUVaLEdBQUcsQ0FBQ0ssRUFBRSxHQUFHQztnQkFBSSxPQUFPO29CQUFFTixHQUFHLENBQUNLLEVBQUUsQ0FBQyxFQUFFLEdBQUdDO2dCQUFJO2dCQUNsRUEsTUFBTTtnQkFDTixFQUFFRDtnQkFDRjtZQUNGLE9BQU8sSUFBSSxDQUFDRixXQUFZTyxDQUFBQSxTQUFTLE9BQU9BLFNBQVMsR0FBRyxHQUFJO2dCQUFFO1lBQVM7UUFDckU7UUFDQUosT0FBT0k7SUFDVDtJQUNBLElBQUlSLFdBQVdJLElBQUlFLE1BQU0sRUFBRTtRQUN6QkYsTUFBTWxCLFdBQVdrQixJQUFJTyxPQUFPLENBQUN2QixZQUFZRSxrQkFDdkMsVUFDQVU7SUFDSixPQUFPLElBQUlJLEtBQUs7UUFDZEEsTUFBTWxCLFdBQVdrQixLQUFLLFVBQVU7SUFDbEM7SUFFQSxJQUFJTixHQUFHLENBQUNLLEVBQUUsS0FBS08sV0FBVztRQUN4QixJQUFJTixLQUFLO1lBQUVOLEdBQUcsQ0FBQ0ssRUFBRSxHQUFHQztRQUFJO0lBQzFCLE9BQU87UUFBRU4sR0FBRyxDQUFDSyxFQUFFLENBQUMsRUFBRSxHQUFHQztJQUFJO0lBRXpCLE9BQU9OO0FBQ1Q7QUFFQWMsT0FBT0MsT0FBTyxHQUFHakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy91bmRpY2kvbm9kZV9tb2R1bGVzL0BmYXN0aWZ5L2J1c2JveS9saWIvdXRpbHMvcGFyc2VQYXJhbXMuanM/YTc2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBvYmplY3QtcHJvcGVydHktbmV3bGluZSAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlY29kZVRleHQgPSByZXF1aXJlKCcuL2RlY29kZVRleHQnKVxuXG5jb25zdCBSRV9FTkNPREVEID0gLyVbYS1mQS1GMC05XVthLWZBLUYwLTldL2dcblxuY29uc3QgRW5jb2RlZExvb2t1cCA9IHtcbiAgJyUwMCc6ICdcXHgwMCcsICclMDEnOiAnXFx4MDEnLCAnJTAyJzogJ1xceDAyJywgJyUwMyc6ICdcXHgwMycsICclMDQnOiAnXFx4MDQnLFxuICAnJTA1JzogJ1xceDA1JywgJyUwNic6ICdcXHgwNicsICclMDcnOiAnXFx4MDcnLCAnJTA4JzogJ1xceDA4JywgJyUwOSc6ICdcXHgwOScsXG4gICclMGEnOiAnXFx4MGEnLCAnJTBBJzogJ1xceDBhJywgJyUwYic6ICdcXHgwYicsICclMEInOiAnXFx4MGInLCAnJTBjJzogJ1xceDBjJyxcbiAgJyUwQyc6ICdcXHgwYycsICclMGQnOiAnXFx4MGQnLCAnJTBEJzogJ1xceDBkJywgJyUwZSc6ICdcXHgwZScsICclMEUnOiAnXFx4MGUnLFxuICAnJTBmJzogJ1xceDBmJywgJyUwRic6ICdcXHgwZicsICclMTAnOiAnXFx4MTAnLCAnJTExJzogJ1xceDExJywgJyUxMic6ICdcXHgxMicsXG4gICclMTMnOiAnXFx4MTMnLCAnJTE0JzogJ1xceDE0JywgJyUxNSc6ICdcXHgxNScsICclMTYnOiAnXFx4MTYnLCAnJTE3JzogJ1xceDE3JyxcbiAgJyUxOCc6ICdcXHgxOCcsICclMTknOiAnXFx4MTknLCAnJTFhJzogJ1xceDFhJywgJyUxQSc6ICdcXHgxYScsICclMWInOiAnXFx4MWInLFxuICAnJTFCJzogJ1xceDFiJywgJyUxYyc6ICdcXHgxYycsICclMUMnOiAnXFx4MWMnLCAnJTFkJzogJ1xceDFkJywgJyUxRCc6ICdcXHgxZCcsXG4gICclMWUnOiAnXFx4MWUnLCAnJTFFJzogJ1xceDFlJywgJyUxZic6ICdcXHgxZicsICclMUYnOiAnXFx4MWYnLCAnJTIwJzogJ1xceDIwJyxcbiAgJyUyMSc6ICdcXHgyMScsICclMjInOiAnXFx4MjInLCAnJTIzJzogJ1xceDIzJywgJyUyNCc6ICdcXHgyNCcsICclMjUnOiAnXFx4MjUnLFxuICAnJTI2JzogJ1xceDI2JywgJyUyNyc6ICdcXHgyNycsICclMjgnOiAnXFx4MjgnLCAnJTI5JzogJ1xceDI5JywgJyUyYSc6ICdcXHgyYScsXG4gICclMkEnOiAnXFx4MmEnLCAnJTJiJzogJ1xceDJiJywgJyUyQic6ICdcXHgyYicsICclMmMnOiAnXFx4MmMnLCAnJTJDJzogJ1xceDJjJyxcbiAgJyUyZCc6ICdcXHgyZCcsICclMkQnOiAnXFx4MmQnLCAnJTJlJzogJ1xceDJlJywgJyUyRSc6ICdcXHgyZScsICclMmYnOiAnXFx4MmYnLFxuICAnJTJGJzogJ1xceDJmJywgJyUzMCc6ICdcXHgzMCcsICclMzEnOiAnXFx4MzEnLCAnJTMyJzogJ1xceDMyJywgJyUzMyc6ICdcXHgzMycsXG4gICclMzQnOiAnXFx4MzQnLCAnJTM1JzogJ1xceDM1JywgJyUzNic6ICdcXHgzNicsICclMzcnOiAnXFx4MzcnLCAnJTM4JzogJ1xceDM4JyxcbiAgJyUzOSc6ICdcXHgzOScsICclM2EnOiAnXFx4M2EnLCAnJTNBJzogJ1xceDNhJywgJyUzYic6ICdcXHgzYicsICclM0InOiAnXFx4M2InLFxuICAnJTNjJzogJ1xceDNjJywgJyUzQyc6ICdcXHgzYycsICclM2QnOiAnXFx4M2QnLCAnJTNEJzogJ1xceDNkJywgJyUzZSc6ICdcXHgzZScsXG4gICclM0UnOiAnXFx4M2UnLCAnJTNmJzogJ1xceDNmJywgJyUzRic6ICdcXHgzZicsICclNDAnOiAnXFx4NDAnLCAnJTQxJzogJ1xceDQxJyxcbiAgJyU0Mic6ICdcXHg0MicsICclNDMnOiAnXFx4NDMnLCAnJTQ0JzogJ1xceDQ0JywgJyU0NSc6ICdcXHg0NScsICclNDYnOiAnXFx4NDYnLFxuICAnJTQ3JzogJ1xceDQ3JywgJyU0OCc6ICdcXHg0OCcsICclNDknOiAnXFx4NDknLCAnJTRhJzogJ1xceDRhJywgJyU0QSc6ICdcXHg0YScsXG4gICclNGInOiAnXFx4NGInLCAnJTRCJzogJ1xceDRiJywgJyU0Yyc6ICdcXHg0YycsICclNEMnOiAnXFx4NGMnLCAnJTRkJzogJ1xceDRkJyxcbiAgJyU0RCc6ICdcXHg0ZCcsICclNGUnOiAnXFx4NGUnLCAnJTRFJzogJ1xceDRlJywgJyU0Zic6ICdcXHg0ZicsICclNEYnOiAnXFx4NGYnLFxuICAnJTUwJzogJ1xceDUwJywgJyU1MSc6ICdcXHg1MScsICclNTInOiAnXFx4NTInLCAnJTUzJzogJ1xceDUzJywgJyU1NCc6ICdcXHg1NCcsXG4gICclNTUnOiAnXFx4NTUnLCAnJTU2JzogJ1xceDU2JywgJyU1Nyc6ICdcXHg1NycsICclNTgnOiAnXFx4NTgnLCAnJTU5JzogJ1xceDU5JyxcbiAgJyU1YSc6ICdcXHg1YScsICclNUEnOiAnXFx4NWEnLCAnJTViJzogJ1xceDViJywgJyU1Qic6ICdcXHg1YicsICclNWMnOiAnXFx4NWMnLFxuICAnJTVDJzogJ1xceDVjJywgJyU1ZCc6ICdcXHg1ZCcsICclNUQnOiAnXFx4NWQnLCAnJTVlJzogJ1xceDVlJywgJyU1RSc6ICdcXHg1ZScsXG4gICclNWYnOiAnXFx4NWYnLCAnJTVGJzogJ1xceDVmJywgJyU2MCc6ICdcXHg2MCcsICclNjEnOiAnXFx4NjEnLCAnJTYyJzogJ1xceDYyJyxcbiAgJyU2Myc6ICdcXHg2MycsICclNjQnOiAnXFx4NjQnLCAnJTY1JzogJ1xceDY1JywgJyU2Nic6ICdcXHg2NicsICclNjcnOiAnXFx4NjcnLFxuICAnJTY4JzogJ1xceDY4JywgJyU2OSc6ICdcXHg2OScsICclNmEnOiAnXFx4NmEnLCAnJTZBJzogJ1xceDZhJywgJyU2Yic6ICdcXHg2YicsXG4gICclNkInOiAnXFx4NmInLCAnJTZjJzogJ1xceDZjJywgJyU2Qyc6ICdcXHg2YycsICclNmQnOiAnXFx4NmQnLCAnJTZEJzogJ1xceDZkJyxcbiAgJyU2ZSc6ICdcXHg2ZScsICclNkUnOiAnXFx4NmUnLCAnJTZmJzogJ1xceDZmJywgJyU2Ric6ICdcXHg2ZicsICclNzAnOiAnXFx4NzAnLFxuICAnJTcxJzogJ1xceDcxJywgJyU3Mic6ICdcXHg3MicsICclNzMnOiAnXFx4NzMnLCAnJTc0JzogJ1xceDc0JywgJyU3NSc6ICdcXHg3NScsXG4gICclNzYnOiAnXFx4NzYnLCAnJTc3JzogJ1xceDc3JywgJyU3OCc6ICdcXHg3OCcsICclNzknOiAnXFx4NzknLCAnJTdhJzogJ1xceDdhJyxcbiAgJyU3QSc6ICdcXHg3YScsICclN2InOiAnXFx4N2InLCAnJTdCJzogJ1xceDdiJywgJyU3Yyc6ICdcXHg3YycsICclN0MnOiAnXFx4N2MnLFxuICAnJTdkJzogJ1xceDdkJywgJyU3RCc6ICdcXHg3ZCcsICclN2UnOiAnXFx4N2UnLCAnJTdFJzogJ1xceDdlJywgJyU3Zic6ICdcXHg3ZicsXG4gICclN0YnOiAnXFx4N2YnLCAnJTgwJzogJ1xceDgwJywgJyU4MSc6ICdcXHg4MScsICclODInOiAnXFx4ODInLCAnJTgzJzogJ1xceDgzJyxcbiAgJyU4NCc6ICdcXHg4NCcsICclODUnOiAnXFx4ODUnLCAnJTg2JzogJ1xceDg2JywgJyU4Nyc6ICdcXHg4NycsICclODgnOiAnXFx4ODgnLFxuICAnJTg5JzogJ1xceDg5JywgJyU4YSc6ICdcXHg4YScsICclOEEnOiAnXFx4OGEnLCAnJThiJzogJ1xceDhiJywgJyU4Qic6ICdcXHg4YicsXG4gICclOGMnOiAnXFx4OGMnLCAnJThDJzogJ1xceDhjJywgJyU4ZCc6ICdcXHg4ZCcsICclOEQnOiAnXFx4OGQnLCAnJThlJzogJ1xceDhlJyxcbiAgJyU4RSc6ICdcXHg4ZScsICclOGYnOiAnXFx4OGYnLCAnJThGJzogJ1xceDhmJywgJyU5MCc6ICdcXHg5MCcsICclOTEnOiAnXFx4OTEnLFxuICAnJTkyJzogJ1xceDkyJywgJyU5Myc6ICdcXHg5MycsICclOTQnOiAnXFx4OTQnLCAnJTk1JzogJ1xceDk1JywgJyU5Nic6ICdcXHg5NicsXG4gICclOTcnOiAnXFx4OTcnLCAnJTk4JzogJ1xceDk4JywgJyU5OSc6ICdcXHg5OScsICclOWEnOiAnXFx4OWEnLCAnJTlBJzogJ1xceDlhJyxcbiAgJyU5Yic6ICdcXHg5YicsICclOUInOiAnXFx4OWInLCAnJTljJzogJ1xceDljJywgJyU5Qyc6ICdcXHg5YycsICclOWQnOiAnXFx4OWQnLFxuICAnJTlEJzogJ1xceDlkJywgJyU5ZSc6ICdcXHg5ZScsICclOUUnOiAnXFx4OWUnLCAnJTlmJzogJ1xceDlmJywgJyU5Ric6ICdcXHg5ZicsXG4gICclYTAnOiAnXFx4YTAnLCAnJUEwJzogJ1xceGEwJywgJyVhMSc6ICdcXHhhMScsICclQTEnOiAnXFx4YTEnLCAnJWEyJzogJ1xceGEyJyxcbiAgJyVBMic6ICdcXHhhMicsICclYTMnOiAnXFx4YTMnLCAnJUEzJzogJ1xceGEzJywgJyVhNCc6ICdcXHhhNCcsICclQTQnOiAnXFx4YTQnLFxuICAnJWE1JzogJ1xceGE1JywgJyVBNSc6ICdcXHhhNScsICclYTYnOiAnXFx4YTYnLCAnJUE2JzogJ1xceGE2JywgJyVhNyc6ICdcXHhhNycsXG4gICclQTcnOiAnXFx4YTcnLCAnJWE4JzogJ1xceGE4JywgJyVBOCc6ICdcXHhhOCcsICclYTknOiAnXFx4YTknLCAnJUE5JzogJ1xceGE5JyxcbiAgJyVhYSc6ICdcXHhhYScsICclQWEnOiAnXFx4YWEnLCAnJWFBJzogJ1xceGFhJywgJyVBQSc6ICdcXHhhYScsICclYWInOiAnXFx4YWInLFxuICAnJUFiJzogJ1xceGFiJywgJyVhQic6ICdcXHhhYicsICclQUInOiAnXFx4YWInLCAnJWFjJzogJ1xceGFjJywgJyVBYyc6ICdcXHhhYycsXG4gICclYUMnOiAnXFx4YWMnLCAnJUFDJzogJ1xceGFjJywgJyVhZCc6ICdcXHhhZCcsICclQWQnOiAnXFx4YWQnLCAnJWFEJzogJ1xceGFkJyxcbiAgJyVBRCc6ICdcXHhhZCcsICclYWUnOiAnXFx4YWUnLCAnJUFlJzogJ1xceGFlJywgJyVhRSc6ICdcXHhhZScsICclQUUnOiAnXFx4YWUnLFxuICAnJWFmJzogJ1xceGFmJywgJyVBZic6ICdcXHhhZicsICclYUYnOiAnXFx4YWYnLCAnJUFGJzogJ1xceGFmJywgJyViMCc6ICdcXHhiMCcsXG4gICclQjAnOiAnXFx4YjAnLCAnJWIxJzogJ1xceGIxJywgJyVCMSc6ICdcXHhiMScsICclYjInOiAnXFx4YjInLCAnJUIyJzogJ1xceGIyJyxcbiAgJyViMyc6ICdcXHhiMycsICclQjMnOiAnXFx4YjMnLCAnJWI0JzogJ1xceGI0JywgJyVCNCc6ICdcXHhiNCcsICclYjUnOiAnXFx4YjUnLFxuICAnJUI1JzogJ1xceGI1JywgJyViNic6ICdcXHhiNicsICclQjYnOiAnXFx4YjYnLCAnJWI3JzogJ1xceGI3JywgJyVCNyc6ICdcXHhiNycsXG4gICclYjgnOiAnXFx4YjgnLCAnJUI4JzogJ1xceGI4JywgJyViOSc6ICdcXHhiOScsICclQjknOiAnXFx4YjknLCAnJWJhJzogJ1xceGJhJyxcbiAgJyVCYSc6ICdcXHhiYScsICclYkEnOiAnXFx4YmEnLCAnJUJBJzogJ1xceGJhJywgJyViYic6ICdcXHhiYicsICclQmInOiAnXFx4YmInLFxuICAnJWJCJzogJ1xceGJiJywgJyVCQic6ICdcXHhiYicsICclYmMnOiAnXFx4YmMnLCAnJUJjJzogJ1xceGJjJywgJyViQyc6ICdcXHhiYycsXG4gICclQkMnOiAnXFx4YmMnLCAnJWJkJzogJ1xceGJkJywgJyVCZCc6ICdcXHhiZCcsICclYkQnOiAnXFx4YmQnLCAnJUJEJzogJ1xceGJkJyxcbiAgJyViZSc6ICdcXHhiZScsICclQmUnOiAnXFx4YmUnLCAnJWJFJzogJ1xceGJlJywgJyVCRSc6ICdcXHhiZScsICclYmYnOiAnXFx4YmYnLFxuICAnJUJmJzogJ1xceGJmJywgJyViRic6ICdcXHhiZicsICclQkYnOiAnXFx4YmYnLCAnJWMwJzogJ1xceGMwJywgJyVDMCc6ICdcXHhjMCcsXG4gICclYzEnOiAnXFx4YzEnLCAnJUMxJzogJ1xceGMxJywgJyVjMic6ICdcXHhjMicsICclQzInOiAnXFx4YzInLCAnJWMzJzogJ1xceGMzJyxcbiAgJyVDMyc6ICdcXHhjMycsICclYzQnOiAnXFx4YzQnLCAnJUM0JzogJ1xceGM0JywgJyVjNSc6ICdcXHhjNScsICclQzUnOiAnXFx4YzUnLFxuICAnJWM2JzogJ1xceGM2JywgJyVDNic6ICdcXHhjNicsICclYzcnOiAnXFx4YzcnLCAnJUM3JzogJ1xceGM3JywgJyVjOCc6ICdcXHhjOCcsXG4gICclQzgnOiAnXFx4YzgnLCAnJWM5JzogJ1xceGM5JywgJyVDOSc6ICdcXHhjOScsICclY2EnOiAnXFx4Y2EnLCAnJUNhJzogJ1xceGNhJyxcbiAgJyVjQSc6ICdcXHhjYScsICclQ0EnOiAnXFx4Y2EnLCAnJWNiJzogJ1xceGNiJywgJyVDYic6ICdcXHhjYicsICclY0InOiAnXFx4Y2InLFxuICAnJUNCJzogJ1xceGNiJywgJyVjYyc6ICdcXHhjYycsICclQ2MnOiAnXFx4Y2MnLCAnJWNDJzogJ1xceGNjJywgJyVDQyc6ICdcXHhjYycsXG4gICclY2QnOiAnXFx4Y2QnLCAnJUNkJzogJ1xceGNkJywgJyVjRCc6ICdcXHhjZCcsICclQ0QnOiAnXFx4Y2QnLCAnJWNlJzogJ1xceGNlJyxcbiAgJyVDZSc6ICdcXHhjZScsICclY0UnOiAnXFx4Y2UnLCAnJUNFJzogJ1xceGNlJywgJyVjZic6ICdcXHhjZicsICclQ2YnOiAnXFx4Y2YnLFxuICAnJWNGJzogJ1xceGNmJywgJyVDRic6ICdcXHhjZicsICclZDAnOiAnXFx4ZDAnLCAnJUQwJzogJ1xceGQwJywgJyVkMSc6ICdcXHhkMScsXG4gICclRDEnOiAnXFx4ZDEnLCAnJWQyJzogJ1xceGQyJywgJyVEMic6ICdcXHhkMicsICclZDMnOiAnXFx4ZDMnLCAnJUQzJzogJ1xceGQzJyxcbiAgJyVkNCc6ICdcXHhkNCcsICclRDQnOiAnXFx4ZDQnLCAnJWQ1JzogJ1xceGQ1JywgJyVENSc6ICdcXHhkNScsICclZDYnOiAnXFx4ZDYnLFxuICAnJUQ2JzogJ1xceGQ2JywgJyVkNyc6ICdcXHhkNycsICclRDcnOiAnXFx4ZDcnLCAnJWQ4JzogJ1xceGQ4JywgJyVEOCc6ICdcXHhkOCcsXG4gICclZDknOiAnXFx4ZDknLCAnJUQ5JzogJ1xceGQ5JywgJyVkYSc6ICdcXHhkYScsICclRGEnOiAnXFx4ZGEnLCAnJWRBJzogJ1xceGRhJyxcbiAgJyVEQSc6ICdcXHhkYScsICclZGInOiAnXFx4ZGInLCAnJURiJzogJ1xceGRiJywgJyVkQic6ICdcXHhkYicsICclREInOiAnXFx4ZGInLFxuICAnJWRjJzogJ1xceGRjJywgJyVEYyc6ICdcXHhkYycsICclZEMnOiAnXFx4ZGMnLCAnJURDJzogJ1xceGRjJywgJyVkZCc6ICdcXHhkZCcsXG4gICclRGQnOiAnXFx4ZGQnLCAnJWREJzogJ1xceGRkJywgJyVERCc6ICdcXHhkZCcsICclZGUnOiAnXFx4ZGUnLCAnJURlJzogJ1xceGRlJyxcbiAgJyVkRSc6ICdcXHhkZScsICclREUnOiAnXFx4ZGUnLCAnJWRmJzogJ1xceGRmJywgJyVEZic6ICdcXHhkZicsICclZEYnOiAnXFx4ZGYnLFxuICAnJURGJzogJ1xceGRmJywgJyVlMCc6ICdcXHhlMCcsICclRTAnOiAnXFx4ZTAnLCAnJWUxJzogJ1xceGUxJywgJyVFMSc6ICdcXHhlMScsXG4gICclZTInOiAnXFx4ZTInLCAnJUUyJzogJ1xceGUyJywgJyVlMyc6ICdcXHhlMycsICclRTMnOiAnXFx4ZTMnLCAnJWU0JzogJ1xceGU0JyxcbiAgJyVFNCc6ICdcXHhlNCcsICclZTUnOiAnXFx4ZTUnLCAnJUU1JzogJ1xceGU1JywgJyVlNic6ICdcXHhlNicsICclRTYnOiAnXFx4ZTYnLFxuICAnJWU3JzogJ1xceGU3JywgJyVFNyc6ICdcXHhlNycsICclZTgnOiAnXFx4ZTgnLCAnJUU4JzogJ1xceGU4JywgJyVlOSc6ICdcXHhlOScsXG4gICclRTknOiAnXFx4ZTknLCAnJWVhJzogJ1xceGVhJywgJyVFYSc6ICdcXHhlYScsICclZUEnOiAnXFx4ZWEnLCAnJUVBJzogJ1xceGVhJyxcbiAgJyVlYic6ICdcXHhlYicsICclRWInOiAnXFx4ZWInLCAnJWVCJzogJ1xceGViJywgJyVFQic6ICdcXHhlYicsICclZWMnOiAnXFx4ZWMnLFxuICAnJUVjJzogJ1xceGVjJywgJyVlQyc6ICdcXHhlYycsICclRUMnOiAnXFx4ZWMnLCAnJWVkJzogJ1xceGVkJywgJyVFZCc6ICdcXHhlZCcsXG4gICclZUQnOiAnXFx4ZWQnLCAnJUVEJzogJ1xceGVkJywgJyVlZSc6ICdcXHhlZScsICclRWUnOiAnXFx4ZWUnLCAnJWVFJzogJ1xceGVlJyxcbiAgJyVFRSc6ICdcXHhlZScsICclZWYnOiAnXFx4ZWYnLCAnJUVmJzogJ1xceGVmJywgJyVlRic6ICdcXHhlZicsICclRUYnOiAnXFx4ZWYnLFxuICAnJWYwJzogJ1xceGYwJywgJyVGMCc6ICdcXHhmMCcsICclZjEnOiAnXFx4ZjEnLCAnJUYxJzogJ1xceGYxJywgJyVmMic6ICdcXHhmMicsXG4gICclRjInOiAnXFx4ZjInLCAnJWYzJzogJ1xceGYzJywgJyVGMyc6ICdcXHhmMycsICclZjQnOiAnXFx4ZjQnLCAnJUY0JzogJ1xceGY0JyxcbiAgJyVmNSc6ICdcXHhmNScsICclRjUnOiAnXFx4ZjUnLCAnJWY2JzogJ1xceGY2JywgJyVGNic6ICdcXHhmNicsICclZjcnOiAnXFx4ZjcnLFxuICAnJUY3JzogJ1xceGY3JywgJyVmOCc6ICdcXHhmOCcsICclRjgnOiAnXFx4ZjgnLCAnJWY5JzogJ1xceGY5JywgJyVGOSc6ICdcXHhmOScsXG4gICclZmEnOiAnXFx4ZmEnLCAnJUZhJzogJ1xceGZhJywgJyVmQSc6ICdcXHhmYScsICclRkEnOiAnXFx4ZmEnLCAnJWZiJzogJ1xceGZiJyxcbiAgJyVGYic6ICdcXHhmYicsICclZkInOiAnXFx4ZmInLCAnJUZCJzogJ1xceGZiJywgJyVmYyc6ICdcXHhmYycsICclRmMnOiAnXFx4ZmMnLFxuICAnJWZDJzogJ1xceGZjJywgJyVGQyc6ICdcXHhmYycsICclZmQnOiAnXFx4ZmQnLCAnJUZkJzogJ1xceGZkJywgJyVmRCc6ICdcXHhmZCcsXG4gICclRkQnOiAnXFx4ZmQnLCAnJWZlJzogJ1xceGZlJywgJyVGZSc6ICdcXHhmZScsICclZkUnOiAnXFx4ZmUnLCAnJUZFJzogJ1xceGZlJyxcbiAgJyVmZic6ICdcXHhmZicsICclRmYnOiAnXFx4ZmYnLCAnJWZGJzogJ1xceGZmJywgJyVGRic6ICdcXHhmZidcbn1cblxuZnVuY3Rpb24gZW5jb2RlZFJlcGxhY2VyIChtYXRjaCkge1xuICByZXR1cm4gRW5jb2RlZExvb2t1cFttYXRjaF1cbn1cblxuY29uc3QgU1RBVEVfS0VZID0gMFxuY29uc3QgU1RBVEVfVkFMVUUgPSAxXG5jb25zdCBTVEFURV9DSEFSU0VUID0gMlxuY29uc3QgU1RBVEVfTEFORyA9IDNcblxuZnVuY3Rpb24gcGFyc2VQYXJhbXMgKHN0cikge1xuICBjb25zdCByZXMgPSBbXVxuICBsZXQgc3RhdGUgPSBTVEFURV9LRVlcbiAgbGV0IGNoYXJzZXQgPSAnJ1xuICBsZXQgaW5xdW90ZSA9IGZhbHNlXG4gIGxldCBlc2NhcGluZyA9IGZhbHNlXG4gIGxldCBwID0gMFxuICBsZXQgdG1wID0gJydcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby12YXJcbiAgICBjb25zdCBjaGFyID0gc3RyW2ldXG4gICAgaWYgKGNoYXIgPT09ICdcXFxcJyAmJiBpbnF1b3RlKSB7XG4gICAgICBpZiAoZXNjYXBpbmcpIHsgZXNjYXBpbmcgPSBmYWxzZSB9IGVsc2Uge1xuICAgICAgICBlc2NhcGluZyA9IHRydWVcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgIGlmICghZXNjYXBpbmcpIHtcbiAgICAgICAgaWYgKGlucXVvdGUpIHtcbiAgICAgICAgICBpbnF1b3RlID0gZmFsc2VcbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFX0tFWVxuICAgICAgICB9IGVsc2UgeyBpbnF1b3RlID0gdHJ1ZSB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgeyBlc2NhcGluZyA9IGZhbHNlIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVzY2FwaW5nICYmIGlucXVvdGUpIHsgdG1wICs9ICdcXFxcJyB9XG4gICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICBpZiAoKHN0YXRlID09PSBTVEFURV9DSEFSU0VUIHx8IHN0YXRlID09PSBTVEFURV9MQU5HKSAmJiBjaGFyID09PSBcIidcIikge1xuICAgICAgICBpZiAoc3RhdGUgPT09IFNUQVRFX0NIQVJTRVQpIHtcbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFX0xBTkdcbiAgICAgICAgICBjaGFyc2V0ID0gdG1wLnN1YnN0cmluZygxKVxuICAgICAgICB9IGVsc2UgeyBzdGF0ZSA9IFNUQVRFX1ZBTFVFIH1cbiAgICAgICAgdG1wID0gJydcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFNUQVRFX0tFWSAmJlxuICAgICAgICAoY2hhciA9PT0gJyonIHx8IGNoYXIgPT09ICc9JykgJiZcbiAgICAgICAgcmVzLmxlbmd0aCkge1xuICAgICAgICBzdGF0ZSA9IGNoYXIgPT09ICcqJ1xuICAgICAgICAgID8gU1RBVEVfQ0hBUlNFVFxuICAgICAgICAgIDogU1RBVEVfVkFMVUVcbiAgICAgICAgcmVzW3BdID0gW3RtcCwgdW5kZWZpbmVkXVxuICAgICAgICB0bXAgPSAnJ1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmICghaW5xdW90ZSAmJiBjaGFyID09PSAnOycpIHtcbiAgICAgICAgc3RhdGUgPSBTVEFURV9LRVlcbiAgICAgICAgaWYgKGNoYXJzZXQpIHtcbiAgICAgICAgICBpZiAodG1wLmxlbmd0aCkge1xuICAgICAgICAgICAgdG1wID0gZGVjb2RlVGV4dCh0bXAucmVwbGFjZShSRV9FTkNPREVELCBlbmNvZGVkUmVwbGFjZXIpLFxuICAgICAgICAgICAgICAnYmluYXJ5JyxcbiAgICAgICAgICAgICAgY2hhcnNldClcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhcnNldCA9ICcnXG4gICAgICAgIH0gZWxzZSBpZiAodG1wLmxlbmd0aCkge1xuICAgICAgICAgIHRtcCA9IGRlY29kZVRleHQodG1wLCAnYmluYXJ5JywgJ3V0ZjgnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNbcF0gPT09IHVuZGVmaW5lZCkgeyByZXNbcF0gPSB0bXAgfSBlbHNlIHsgcmVzW3BdWzFdID0gdG1wIH1cbiAgICAgICAgdG1wID0gJydcbiAgICAgICAgKytwXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYgKCFpbnF1b3RlICYmIChjaGFyID09PSAnICcgfHwgY2hhciA9PT0gJ1xcdCcpKSB7IGNvbnRpbnVlIH1cbiAgICB9XG4gICAgdG1wICs9IGNoYXJcbiAgfVxuICBpZiAoY2hhcnNldCAmJiB0bXAubGVuZ3RoKSB7XG4gICAgdG1wID0gZGVjb2RlVGV4dCh0bXAucmVwbGFjZShSRV9FTkNPREVELCBlbmNvZGVkUmVwbGFjZXIpLFxuICAgICAgJ2JpbmFyeScsXG4gICAgICBjaGFyc2V0KVxuICB9IGVsc2UgaWYgKHRtcCkge1xuICAgIHRtcCA9IGRlY29kZVRleHQodG1wLCAnYmluYXJ5JywgJ3V0ZjgnKVxuICB9XG5cbiAgaWYgKHJlc1twXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRtcCkgeyByZXNbcF0gPSB0bXAgfVxuICB9IGVsc2UgeyByZXNbcF1bMV0gPSB0bXAgfVxuXG4gIHJldHVybiByZXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVBhcmFtc1xuIl0sIm5hbWVzIjpbImRlY29kZVRleHQiLCJyZXF1aXJlIiwiUkVfRU5DT0RFRCIsIkVuY29kZWRMb29rdXAiLCJlbmNvZGVkUmVwbGFjZXIiLCJtYXRjaCIsIlNUQVRFX0tFWSIsIlNUQVRFX1ZBTFVFIiwiU1RBVEVfQ0hBUlNFVCIsIlNUQVRFX0xBTkciLCJwYXJzZVBhcmFtcyIsInN0ciIsInJlcyIsInN0YXRlIiwiY2hhcnNldCIsImlucXVvdGUiLCJlc2NhcGluZyIsInAiLCJ0bXAiLCJsZW4iLCJsZW5ndGgiLCJpIiwiY2hhciIsInN1YnN0cmluZyIsInVuZGVmaW5lZCIsInJlcGxhY2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/undici/node_modules/@fastify/busboy/lib/utils/parseParams.js\n");

/***/ })

};
;