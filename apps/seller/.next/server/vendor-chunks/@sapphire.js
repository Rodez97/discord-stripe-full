"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sapphire";
exports.ids = ["vendor-chunks/@sapphire"];
exports.modules = {

/***/ "(rsc)/../../node_modules/@sapphire/async-queue/dist/esm/index.mjs":
/*!*******************************************************************!*\
  !*** ../../node_modules/@sapphire/async-queue/dist/esm/index.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncQueue: () => (/* binding */ AsyncQueue)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __name = (target, value)=>__defProp(target, \"name\", {\n        value,\n        configurable: true\n    });\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\n// src/lib/AsyncQueueEntry.ts\nvar _AsyncQueueEntry = class _AsyncQueueEntry {\n    constructor(queue){\n        __publicField(this, \"promise\");\n        __publicField(this, \"resolve\");\n        __publicField(this, \"reject\");\n        __publicField(this, \"queue\");\n        __publicField(this, \"signal\", null);\n        __publicField(this, \"signalListener\", null);\n        this.queue = queue;\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    setSignal(signal) {\n        if (signal.aborted) return this;\n        this.signal = signal;\n        this.signalListener = ()=>{\n            const index = this.queue[\"promises\"].indexOf(this);\n            if (index !== -1) this.queue[\"promises\"].splice(index, 1);\n            this.reject(new Error(\"Request aborted manually\"));\n        };\n        this.signal.addEventListener(\"abort\", this.signalListener);\n        return this;\n    }\n    use() {\n        this.dispose();\n        this.resolve();\n        return this;\n    }\n    abort() {\n        this.dispose();\n        this.reject(new Error(\"Request aborted manually\"));\n        return this;\n    }\n    dispose() {\n        if (this.signal) {\n            this.signal.removeEventListener(\"abort\", this.signalListener);\n            this.signal = null;\n            this.signalListener = null;\n        }\n    }\n};\n__name(_AsyncQueueEntry, \"AsyncQueueEntry\");\nvar AsyncQueueEntry = _AsyncQueueEntry;\n// src/lib/AsyncQueue.ts\nvar _AsyncQueue = class _AsyncQueue {\n    constructor(){\n        /**\n     * The promises array\n     */ __publicField(this, \"promises\", []);\n    }\n    /**\n   * The amount of entries in the queue, including the head.\n   * @seealso {@link queued} for the queued count.\n   */ get remaining() {\n        return this.promises.length;\n    }\n    /**\n   * The amount of queued entries.\n   * @seealso {@link remaining} for the count with the head.\n   */ get queued() {\n        return this.remaining === 0 ? 0 : this.remaining - 1;\n    }\n    /**\n   * Waits for last promise and queues a new one\n   * @example\n   * ```typescript\n   * const queue = new AsyncQueue();\n   * async function request(url, options) {\n   *     await queue.wait({ signal: options.signal });\n   *     try {\n   *         const result = await fetch(url, options);\n   *         // Do some operations with 'result'\n   *     } finally {\n   *         // Remove first entry from the queue and resolve for the next entry\n   *         queue.shift();\n   *     }\n   * }\n   *\n   * request(someUrl1, someOptions1); // Will call fetch() immediately\n   * request(someUrl2, someOptions2); // Will call fetch() after the first finished\n   * request(someUrl3, someOptions3); // Will call fetch() after the second finished\n   * ```\n   */ wait(options) {\n        const entry = new AsyncQueueEntry(this);\n        if (this.promises.length === 0) {\n            this.promises.push(entry);\n            return Promise.resolve();\n        }\n        this.promises.push(entry);\n        if (options?.signal) entry.setSignal(options.signal);\n        return entry.promise;\n    }\n    /**\n   * Unlocks the head lock and transfers the next lock (if any) to the head.\n   */ shift() {\n        if (this.promises.length === 0) return;\n        if (this.promises.length === 1) {\n            this.promises.shift();\n            return;\n        }\n        this.promises.shift();\n        this.promises[0].use();\n    }\n    /**\n   * Aborts all the pending promises.\n   * @note To avoid race conditions, this does **not** unlock the head lock.\n   */ abortAll() {\n        if (this.queued === 0) return;\n        for(let i = 1; i < this.promises.length; ++i){\n            this.promises[i].abort();\n        }\n        this.promises.length = 1;\n    }\n};\n__name(_AsyncQueue, \"AsyncQueue\");\nvar AsyncQueue = _AsyncQueue;\n //# sourceMappingURL=out.js.map\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BzYXBwaGlyZS9hc3luYy1xdWV1ZS9kaXN0L2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsa0JBQWtCLENBQUNDLEtBQUtDLEtBQUtDLFFBQVVELE9BQU9ELE1BQU1KLFVBQVVJLEtBQUtDLEtBQUs7UUFBRUUsWUFBWTtRQUFNQyxjQUFjO1FBQU1DLFVBQVU7UUFBTUg7SUFBTSxLQUFLRixHQUFHLENBQUNDLElBQUksR0FBR0M7QUFDMUosSUFBSUksU0FBUyxDQUFDQyxRQUFRTCxRQUFVTixVQUFVVyxRQUFRLFFBQVE7UUFBRUw7UUFBT0UsY0FBYztJQUFLO0FBQ3RGLElBQUlJLGdCQUFnQixDQUFDUixLQUFLQyxLQUFLQztJQUM3QkgsZ0JBQWdCQyxLQUFLLE9BQU9DLFFBQVEsV0FBV0EsTUFBTSxLQUFLQSxLQUFLQztJQUMvRCxPQUFPQTtBQUNUO0FBRUEsNkJBQTZCO0FBQzdCLElBQUlPLG1CQUFtQixNQUFNQTtJQUMzQkMsWUFBWUMsS0FBSyxDQUFFO1FBQ2pCSCxjQUFjLElBQUksRUFBRTtRQUNwQkEsY0FBYyxJQUFJLEVBQUU7UUFDcEJBLGNBQWMsSUFBSSxFQUFFO1FBQ3BCQSxjQUFjLElBQUksRUFBRTtRQUNwQkEsY0FBYyxJQUFJLEVBQUUsVUFBVTtRQUM5QkEsY0FBYyxJQUFJLEVBQUUsa0JBQWtCO1FBQ3RDLElBQUksQ0FBQ0csS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDbkMsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO1lBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2hCO0lBQ0Y7SUFDQUMsVUFBVUMsTUFBTSxFQUFFO1FBQ2hCLElBQUlBLE9BQU9DLE9BQU8sRUFDaEIsT0FBTyxJQUFJO1FBQ2IsSUFBSSxDQUFDRCxNQUFNLEdBQUdBO1FBQ2QsSUFB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b3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3RyaXBlLWRpc2NvcmQvc2VsbGVyLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2FwcGhpcmUvYXN5bmMtcXVldWUvZGlzdC9lc20vaW5kZXgubWpzPzkzMzIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX25hbWUgPSAodGFyZ2V0LCB2YWx1ZSkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJuYW1lXCIsIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBzcmMvbGliL0FzeW5jUXVldWVFbnRyeS50c1xudmFyIF9Bc3luY1F1ZXVlRW50cnkgPSBjbGFzcyBfQXN5bmNRdWV1ZUVudHJ5IHtcbiAgY29uc3RydWN0b3IocXVldWUpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvbWlzZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVzb2x2ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVqZWN0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJxdWV1ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2lnbmFsXCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzaWduYWxMaXN0ZW5lclwiLCBudWxsKTtcbiAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICB9XG4gIHNldFNpZ25hbChzaWduYWwpIHtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB0aGlzLnNpZ25hbCA9IHNpZ25hbDtcbiAgICB0aGlzLnNpZ25hbExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlW1wicHJvbWlzZXNcIl0uaW5kZXhPZih0aGlzKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgIHRoaXMucXVldWVbXCJwcm9taXNlc1wiXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5yZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdCBhYm9ydGVkIG1hbnVhbGx5XCIpKTtcbiAgICB9O1xuICAgIHRoaXMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCB0aGlzLnNpZ25hbExpc3RlbmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1c2UoKSB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5yZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdCBhYm9ydGVkIG1hbnVhbGx5XCIpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLnNpZ25hbCkge1xuICAgICAgdGhpcy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRoaXMuc2lnbmFsTGlzdGVuZXIpO1xuICAgICAgdGhpcy5zaWduYWwgPSBudWxsO1xuICAgICAgdGhpcy5zaWduYWxMaXN0ZW5lciA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuX19uYW1lKF9Bc3luY1F1ZXVlRW50cnksIFwiQXN5bmNRdWV1ZUVudHJ5XCIpO1xudmFyIEFzeW5jUXVldWVFbnRyeSA9IF9Bc3luY1F1ZXVlRW50cnk7XG5cbi8vIHNyYy9saWIvQXN5bmNRdWV1ZS50c1xudmFyIF9Bc3luY1F1ZXVlID0gY2xhc3MgX0FzeW5jUXVldWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbWlzZXMgYXJyYXlcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvbWlzZXNcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIGVudHJpZXMgaW4gdGhlIHF1ZXVlLCBpbmNsdWRpbmcgdGhlIGhlYWQuXG4gICAqIEBzZWVhbHNvIHtAbGluayBxdWV1ZWR9IGZvciB0aGUgcXVldWVkIGNvdW50LlxuICAgKi9cbiAgZ2V0IHJlbWFpbmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlcy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgcXVldWVkIGVudHJpZXMuXG4gICAqIEBzZWVhbHNvIHtAbGluayByZW1haW5pbmd9IGZvciB0aGUgY291bnQgd2l0aCB0aGUgaGVhZC5cbiAgICovXG4gIGdldCBxdWV1ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtYWluaW5nID09PSAwID8gMCA6IHRoaXMucmVtYWluaW5nIC0gMTtcbiAgfVxuICAvKipcbiAgICogV2FpdHMgZm9yIGxhc3QgcHJvbWlzZSBhbmQgcXVldWVzIGEgbmV3IG9uZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHF1ZXVlID0gbmV3IEFzeW5jUXVldWUoKTtcbiAgICogYXN5bmMgZnVuY3Rpb24gcmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcbiAgICogICAgIGF3YWl0IHF1ZXVlLndhaXQoeyBzaWduYWw6IG9wdGlvbnMuc2lnbmFsIH0pO1xuICAgKiAgICAgdHJ5IHtcbiAgICogICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgKiAgICAgICAgIC8vIERvIHNvbWUgb3BlcmF0aW9ucyB3aXRoICdyZXN1bHQnXG4gICAqICAgICB9IGZpbmFsbHkge1xuICAgKiAgICAgICAgIC8vIFJlbW92ZSBmaXJzdCBlbnRyeSBmcm9tIHRoZSBxdWV1ZSBhbmQgcmVzb2x2ZSBmb3IgdGhlIG5leHQgZW50cnlcbiAgICogICAgICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgKiAgICAgfVxuICAgKiB9XG4gICAqXG4gICAqIHJlcXVlc3Qoc29tZVVybDEsIHNvbWVPcHRpb25zMSk7IC8vIFdpbGwgY2FsbCBmZXRjaCgpIGltbWVkaWF0ZWx5XG4gICAqIHJlcXVlc3Qoc29tZVVybDIsIHNvbWVPcHRpb25zMik7IC8vIFdpbGwgY2FsbCBmZXRjaCgpIGFmdGVyIHRoZSBmaXJzdCBmaW5pc2hlZFxuICAgKiByZXF1ZXN0KHNvbWVVcmwzLCBzb21lT3B0aW9uczMpOyAvLyBXaWxsIGNhbGwgZmV0Y2goKSBhZnRlciB0aGUgc2Vjb25kIGZpbmlzaGVkXG4gICAqIGBgYFxuICAgKi9cbiAgd2FpdChvcHRpb25zKSB7XG4gICAgY29uc3QgZW50cnkgPSBuZXcgQXN5bmNRdWV1ZUVudHJ5KHRoaXMpO1xuICAgIGlmICh0aGlzLnByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5wcm9taXNlcy5wdXNoKGVudHJ5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdGhpcy5wcm9taXNlcy5wdXNoKGVudHJ5KTtcbiAgICBpZiAob3B0aW9ucz8uc2lnbmFsKVxuICAgICAgZW50cnkuc2V0U2lnbmFsKG9wdGlvbnMuc2lnbmFsKTtcbiAgICByZXR1cm4gZW50cnkucHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogVW5sb2NrcyB0aGUgaGVhZCBsb2NrIGFuZCB0cmFuc2ZlcnMgdGhlIG5leHQgbG9jayAoaWYgYW55KSB0byB0aGUgaGVhZC5cbiAgICovXG4gIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLnByb21pc2VzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5wcm9taXNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMucHJvbWlzZXMuc2hpZnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wcm9taXNlcy5zaGlmdCgpO1xuICAgIHRoaXMucHJvbWlzZXNbMF0udXNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFib3J0cyBhbGwgdGhlIHBlbmRpbmcgcHJvbWlzZXMuXG4gICAqIEBub3RlIFRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucywgdGhpcyBkb2VzICoqbm90KiogdW5sb2NrIHRoZSBoZWFkIGxvY2suXG4gICAqL1xuICBhYm9ydEFsbCgpIHtcbiAgICBpZiAodGhpcy5xdWV1ZWQgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnByb21pc2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLnByb21pc2VzW2ldLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMucHJvbWlzZXMubGVuZ3RoID0gMTtcbiAgfVxufTtcbl9fbmFtZShfQXN5bmNRdWV1ZSwgXCJBc3luY1F1ZXVlXCIpO1xudmFyIEFzeW5jUXVldWUgPSBfQXN5bmNRdWV1ZTtcblxuZXhwb3J0IHsgQXN5bmNRdWV1ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3V0LmpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19uYW1lIiwidGFyZ2V0IiwiX19wdWJsaWNGaWVsZCIsIl9Bc3luY1F1ZXVlRW50cnkiLCJjb25zdHJ1Y3RvciIsInF1ZXVlIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic2V0U2lnbmFsIiwic2lnbmFsIiwiYWJvcnRlZCIsInNpZ25hbExpc3RlbmVyIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiRXJyb3IiLCJhZGRFdmVudExpc3RlbmVyIiwidXNlIiwiZGlzcG9zZSIsImFib3J0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkFzeW5jUXVldWVFbnRyeSIsIl9Bc3luY1F1ZXVlIiwicmVtYWluaW5nIiwicHJvbWlzZXMiLCJsZW5ndGgiLCJxdWV1ZWQiLCJ3YWl0Iiwib3B0aW9ucyIsImVudHJ5IiwicHVzaCIsInNoaWZ0IiwiYWJvcnRBbGwiLCJpIiwiQXN5bmNRdWV1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@sapphire/async-queue/dist/esm/index.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@sapphire/snowflake/dist/esm/index.mjs":
/*!*****************************************************************!*\
  !*** ../../node_modules/@sapphire/snowflake/dist/esm/index.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DiscordSnowflake: () => (/* binding */ DiscordSnowflake),\n/* harmony export */   MaximumIncrement: () => (/* binding */ MaximumIncrement),\n/* harmony export */   MaximumProcessId: () => (/* binding */ MaximumProcessId),\n/* harmony export */   MaximumWorkerId: () => (/* binding */ MaximumWorkerId),\n/* harmony export */   Snowflake: () => (/* binding */ Snowflake),\n/* harmony export */   TwitterSnowflake: () => (/* binding */ TwitterSnowflake)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __name = (target, value)=>__defProp(target, \"name\", {\n        value,\n        configurable: true\n    });\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\n// src/lib/Snowflake.ts\nvar IncrementSymbol = Symbol(\"@sapphire/snowflake.increment\");\nvar EpochSymbol = Symbol(\"@sapphire/snowflake.epoch\");\nvar ProcessIdSymbol = Symbol(\"@sapphire/snowflake.processId\");\nvar WorkerIdSymbol = Symbol(\"@sapphire/snowflake.workerId\");\nvar MaximumWorkerId = 0b11111n;\nvar MaximumProcessId = 0b11111n;\nvar MaximumIncrement = 0b111111111111n;\nvar _a, _b, _c, _d;\nvar _Snowflake = class _Snowflake {\n    /**\n   * @param epoch the epoch to use\n   */ constructor(epoch){\n        /**\n     * Alias for {@link deconstruct}\n     */ // eslint-disable-next-line @typescript-eslint/unbound-method\n        __publicField(this, \"decode\", this.deconstruct);\n        /**\n     * Internal reference of the epoch passed in the constructor\n     * @internal\n     */ __publicField(this, _a);\n        /**\n     * Internal incrementor for generating snowflakes\n     * @internal\n     */ __publicField(this, _b, 0n);\n        /**\n     * The process ID that will be used by default in the generate method\n     * @internal\n     */ __publicField(this, _c, 1n);\n        /**\n     * The worker ID that will be used by default in the generate method\n     * @internal\n     */ __publicField(this, _d, 0n);\n        this[EpochSymbol] = BigInt(epoch instanceof Date ? epoch.getTime() : epoch);\n    }\n    /**\n   * The epoch for this snowflake\n   */ get epoch() {\n        return this[EpochSymbol];\n    }\n    /**\n   * Gets the configured process ID\n   */ get processId() {\n        return this[ProcessIdSymbol];\n    }\n    /**\n   * Sets the process ID that will be used by default for the {@link generate} method\n   * @param value The new value, will be coerced to BigInt and masked with `0b11111n`\n   */ set processId(value) {\n        this[ProcessIdSymbol] = BigInt(value) & MaximumProcessId;\n    }\n    /**\n   * Gets the configured worker ID\n   */ get workerId() {\n        return this[WorkerIdSymbol];\n    }\n    /**\n   * Sets the worker ID that will be used by default for the {@link generate} method\n   * @param value The new value, will be coerced to BigInt and masked with `0b11111n`\n   */ set workerId(value) {\n        this[WorkerIdSymbol] = BigInt(value) & MaximumWorkerId;\n    }\n    /**\n   * Generates a snowflake given an epoch and optionally a timestamp\n   * @param options options to pass into the generator, see {@link SnowflakeGenerateOptions}\n   *\n   * **note** when `increment` is not provided it defaults to the private `increment` of the instance\n   * @example\n   * ```typescript\n   * const epoch = new Date('2000-01-01T00:00:00.000Z');\n   * const snowflake = new Snowflake(epoch).generate();\n   * ```\n   * @returns A unique snowflake\n   */ generate({ increment, timestamp = Date.now(), workerId = this[WorkerIdSymbol], processId = this[ProcessIdSymbol] } = {}) {\n        if (timestamp instanceof Date) timestamp = BigInt(timestamp.getTime());\n        else if (typeof timestamp === \"number\") timestamp = BigInt(timestamp);\n        else if (typeof timestamp !== \"bigint\") {\n            throw new TypeError(`\"timestamp\" argument must be a number, bigint, or Date (received ${typeof timestamp})`);\n        }\n        if (typeof increment !== \"bigint\") {\n            increment = this[IncrementSymbol];\n            this[IncrementSymbol] = increment + 1n & MaximumIncrement;\n        }\n        return timestamp - this[EpochSymbol] << 22n | (workerId & MaximumWorkerId) << 17n | (processId & MaximumProcessId) << 12n | increment & MaximumIncrement;\n    }\n    /**\n   * Deconstructs a snowflake given a snowflake ID\n   * @param id the snowflake to deconstruct\n   * @returns a deconstructed snowflake\n   * @example\n   * ```typescript\n   * const epoch = new Date('2000-01-01T00:00:00.000Z');\n   * const snowflake = new Snowflake(epoch).deconstruct('3971046231244935168');\n   * ```\n   */ deconstruct(id) {\n        const bigIntId = BigInt(id);\n        const epoch = this[EpochSymbol];\n        return {\n            id: bigIntId,\n            timestamp: (bigIntId >> 22n) + epoch,\n            workerId: bigIntId >> 17n & MaximumWorkerId,\n            processId: bigIntId >> 12n & MaximumProcessId,\n            increment: bigIntId & MaximumIncrement,\n            epoch\n        };\n    }\n    /**\n   * Retrieves the timestamp field's value from a snowflake.\n   * @param id The snowflake to get the timestamp value from.\n   * @returns The UNIX timestamp that is stored in `id`.\n   */ timestampFrom(id) {\n        return Number((BigInt(id) >> 22n) + this[EpochSymbol]);\n    }\n    /**\n   * Returns a number indicating whether a reference snowflake comes before, or after, or is same as the given\n   * snowflake in sort order.\n   * @param a The first snowflake to compare.\n   * @param b The second snowflake to compare.\n   * @returns `-1` if `a` is older than `b`, `0` if `a` and `b` are equals, `1` if `a` is newer than `b`.\n   * @example Sort snowflakes in ascending order\n   * ```typescript\n   * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];\n   * console.log(ids.sort((a, b) => Snowflake.compare(a, b)));\n   * // → ['254360814063058944', '737141877803057244', '1056191128120082432'];\n   * ```\n   * @example Sort snowflakes in descending order\n   * ```typescript\n   * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];\n   * console.log(ids.sort((a, b) => -Snowflake.compare(a, b)));\n   * // → ['1056191128120082432', '737141877803057244', '254360814063058944'];\n   * ```\n   */ static compare(a, b) {\n        const typeA = typeof a;\n        return typeA === typeof b ? typeA === \"string\" ? cmpString(a, b) : cmpBigInt(a, b) : cmpBigInt(BigInt(a), BigInt(b));\n    }\n};\n_a = EpochSymbol, _b = IncrementSymbol, _c = ProcessIdSymbol, _d = WorkerIdSymbol;\n__name(_Snowflake, \"Snowflake\");\nvar Snowflake = _Snowflake;\nfunction cmpBigInt(a, b) {\n    return a === b ? 0 : a < b ? -1 : 1;\n}\n__name(cmpBigInt, \"cmpBigInt\");\nfunction cmpString(a, b) {\n    return a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;\n}\n__name(cmpString, \"cmpString\");\n// src/lib/DiscordSnowflake.ts\nvar DiscordSnowflake = new Snowflake(1420070400000n);\n// src/lib/TwitterSnowflake.ts\nvar TwitterSnowflake = new Snowflake(1288834974657n);\n //# sourceMappingURL=out.js.map\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BzYXBwaGlyZS9zbm93Zmxha2UvZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsa0JBQWtCLENBQUNDLEtBQUtDLEtBQUtDLFFBQVVELE9BQU9ELE1BQU1KLFVBQVVJLEtBQUtDLEtBQUs7UUFBRUUsWUFBWTtRQUFNQyxjQUFjO1FBQU1DLFVBQVU7UUFBTUg7SUFBTSxLQUFLRixHQUFHLENBQUNDLElBQUksR0FBR0M7QUFDMUosSUFBSUksU0FBUyxDQUFDQyxRQUFRTCxRQUFVTixVQUFVVyxRQUFRLFFBQVE7UUFBRUw7UUFBT0UsY0FBYztJQUFLO0FBQ3RGLElBQUlJLGdCQUFnQixDQUFDUixLQUFLQyxLQUFLQztJQUM3QkgsZ0JBQWdCQyxLQUFLLE9BQU9DLFFBQVEsV0FBV0EsTUFBTSxLQUFLQSxLQUFLQztJQUMvRCxPQUFPQTtBQUNUO0FBRUEsdUJBQXVCO0FBQ3ZCLElBQUlPLGtCQUFrQkMsT0FBTztBQUM3QixJQUFJQyxjQUFjRCxPQUFPO0FBQ3pCLElBQUlFLGtCQUFrQkYsT0FBTztBQUM3QixJQUFJRyxpQkFBaUJILE9BQU87QUFDNUIsSUFBSUksa0JBQWtCLFFBQVE7QUFDOUIsSUFBSUMsbUJBQW1CLFFBQVE7QUFDL0IsSUFBSUMsbUJBQW1CLGVBQWU7QUFDdEMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7QUFDaEIsSUFBSUMsYUFBYSxNQUFNQTtJQUNyQjs7R0FFQyxHQUNEQyxZQUFZQyxLQUFLLENBQUU7UUFDakI7O0tBRUMsR0FDRCw2REFBNkQ7UUFDN0RmLGNBQWMsSUFBSSxFQUFFLFVBQVUsSUFBSSxDQUFDZ0IsV0FBVztRQUM5Qzs7O0tBR0MsR0FDRGhCLGNBQWMsSUFBSSxFQUFFUztRQUNwQjs7O0tBR0MsR0FDRFQsY0FBYyxJQUFJLEVBQUVVLElBQUksRUFBRTtRQUMxQjs7O0tBR0MsR0FDRFYsY0FB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LENBQUMsSUFBSTtBQUNwQztBQUNBbkMsT0FBT3NDLFdBQVc7QUFDbEIsU0FBU0QsVUFBVUgsQ0FBQyxFQUFFQyxDQUFDO0lBQ3JCLE9BQU9ELE1BQU1DLElBQUksSUFBSUQsRUFBRU0sTUFBTSxHQUFHTCxFQUFFSyxNQUFNLEdBQUcsQ0FBQyxJQUFJTixFQUFFTSxNQUFNLEdBQUdMLEVBQUVLLE1BQU0sR0FBRyxJQUFJTixJQUFJQyxJQUFJLENBQUMsSUFBSTtBQUN6RjtBQUNBbkMsT0FBT3FDLFdBQVc7QUFFbEIsOEJBQThCO0FBQzlCLElBQUlJLG1CQUFtQixJQUFJRixVQUFVLGNBQWM7QUFFbkQsOEJBQThCO0FBQzlCLElBQUlHLG1CQUFtQixJQUFJSCxVQUFVLGNBQWM7QUFFMkQsQ0FDOUcsK0JBQStCO0NBQy9CLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL0BzYXBwaGlyZS9zbm93Zmxha2UvZGlzdC9lc20vaW5kZXgubWpzPzhjM2YiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX25hbWUgPSAodGFyZ2V0LCB2YWx1ZSkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJuYW1lXCIsIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBzcmMvbGliL1Nub3dmbGFrZS50c1xudmFyIEluY3JlbWVudFN5bWJvbCA9IFN5bWJvbChcIkBzYXBwaGlyZS9zbm93Zmxha2UuaW5jcmVtZW50XCIpO1xudmFyIEVwb2NoU3ltYm9sID0gU3ltYm9sKFwiQHNhcHBoaXJlL3Nub3dmbGFrZS5lcG9jaFwiKTtcbnZhciBQcm9jZXNzSWRTeW1ib2wgPSBTeW1ib2woXCJAc2FwcGhpcmUvc25vd2ZsYWtlLnByb2Nlc3NJZFwiKTtcbnZhciBXb3JrZXJJZFN5bWJvbCA9IFN5bWJvbChcIkBzYXBwaGlyZS9zbm93Zmxha2Uud29ya2VySWRcIik7XG52YXIgTWF4aW11bVdvcmtlcklkID0gMGIxMTExMW47XG52YXIgTWF4aW11bVByb2Nlc3NJZCA9IDBiMTExMTFuO1xudmFyIE1heGltdW1JbmNyZW1lbnQgPSAwYjExMTExMTExMTExMW47XG52YXIgX2EsIF9iLCBfYywgX2Q7XG52YXIgX1Nub3dmbGFrZSA9IGNsYXNzIF9Tbm93Zmxha2Uge1xuICAvKipcbiAgICogQHBhcmFtIGVwb2NoIHRoZSBlcG9jaCB0byB1c2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVwb2NoKSB7XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBkZWNvbnN0cnVjdH1cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRlY29kZVwiLCB0aGlzLmRlY29uc3RydWN0KTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCByZWZlcmVuY2Ugb2YgdGhlIGVwb2NoIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIF9hKTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBpbmNyZW1lbnRvciBmb3IgZ2VuZXJhdGluZyBzbm93Zmxha2VzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBfYiwgMG4pO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9jZXNzIElEIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IGRlZmF1bHQgaW4gdGhlIGdlbmVyYXRlIG1ldGhvZFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgX2MsIDFuKTtcbiAgICAvKipcbiAgICAgKiBUaGUgd29ya2VyIElEIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IGRlZmF1bHQgaW4gdGhlIGdlbmVyYXRlIG1ldGhvZFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgX2QsIDBuKTtcbiAgICB0aGlzW0Vwb2NoU3ltYm9sXSA9IEJpZ0ludChlcG9jaCBpbnN0YW5jZW9mIERhdGUgPyBlcG9jaC5nZXRUaW1lKCkgOiBlcG9jaCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlcG9jaCBmb3IgdGhpcyBzbm93Zmxha2VcbiAgICovXG4gIGdldCBlcG9jaCgpIHtcbiAgICByZXR1cm4gdGhpc1tFcG9jaFN5bWJvbF07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbmZpZ3VyZWQgcHJvY2VzcyBJRFxuICAgKi9cbiAgZ2V0IHByb2Nlc3NJZCgpIHtcbiAgICByZXR1cm4gdGhpc1tQcm9jZXNzSWRTeW1ib2xdO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9jZXNzIElEIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IGRlZmF1bHQgZm9yIHRoZSB7QGxpbmsgZ2VuZXJhdGV9IG1ldGhvZFxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSwgd2lsbCBiZSBjb2VyY2VkIHRvIEJpZ0ludCBhbmQgbWFza2VkIHdpdGggYDBiMTExMTFuYFxuICAgKi9cbiAgc2V0IHByb2Nlc3NJZCh2YWx1ZSkge1xuICAgIHRoaXNbUHJvY2Vzc0lkU3ltYm9sXSA9IEJpZ0ludCh2YWx1ZSkgJiBNYXhpbXVtUHJvY2Vzc0lkO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb25maWd1cmVkIHdvcmtlciBJRFxuICAgKi9cbiAgZ2V0IHdvcmtlcklkKCkge1xuICAgIHJldHVybiB0aGlzW1dvcmtlcklkU3ltYm9sXTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgd29ya2VyIElEIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IGRlZmF1bHQgZm9yIHRoZSB7QGxpbmsgZ2VuZXJhdGV9IG1ldGhvZFxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSwgd2lsbCBiZSBjb2VyY2VkIHRvIEJpZ0ludCBhbmQgbWFza2VkIHdpdGggYDBiMTExMTFuYFxuICAgKi9cbiAgc2V0IHdvcmtlcklkKHZhbHVlKSB7XG4gICAgdGhpc1tXb3JrZXJJZFN5bWJvbF0gPSBCaWdJbnQodmFsdWUpICYgTWF4aW11bVdvcmtlcklkO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBzbm93Zmxha2UgZ2l2ZW4gYW4gZXBvY2ggYW5kIG9wdGlvbmFsbHkgYSB0aW1lc3RhbXBcbiAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyB0byBwYXNzIGludG8gdGhlIGdlbmVyYXRvciwgc2VlIHtAbGluayBTbm93Zmxha2VHZW5lcmF0ZU9wdGlvbnN9XG4gICAqXG4gICAqICoqbm90ZSoqIHdoZW4gYGluY3JlbWVudGAgaXMgbm90IHByb3ZpZGVkIGl0IGRlZmF1bHRzIHRvIHRoZSBwcml2YXRlIGBpbmNyZW1lbnRgIG9mIHRoZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGVwb2NoID0gbmV3IERhdGUoJzIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWicpO1xuICAgKiBjb25zdCBzbm93Zmxha2UgPSBuZXcgU25vd2ZsYWtlKGVwb2NoKS5nZW5lcmF0ZSgpO1xuICAgKiBgYGBcbiAgICogQHJldHVybnMgQSB1bmlxdWUgc25vd2ZsYWtlXG4gICAqL1xuICBnZW5lcmF0ZSh7XG4gICAgaW5jcmVtZW50LFxuICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCksXG4gICAgd29ya2VySWQgPSB0aGlzW1dvcmtlcklkU3ltYm9sXSxcbiAgICBwcm9jZXNzSWQgPSB0aGlzW1Byb2Nlc3NJZFN5bWJvbF1cbiAgfSA9IHt9KSB7XG4gICAgaWYgKHRpbWVzdGFtcCBpbnN0YW5jZW9mIERhdGUpXG4gICAgICB0aW1lc3RhbXAgPSBCaWdJbnQodGltZXN0YW1wLmdldFRpbWUoKSk7XG4gICAgZWxzZSBpZiAodHlwZW9mIHRpbWVzdGFtcCA9PT0gXCJudW1iZXJcIilcbiAgICAgIHRpbWVzdGFtcCA9IEJpZ0ludCh0aW1lc3RhbXApO1xuICAgIGVsc2UgaWYgKHR5cGVvZiB0aW1lc3RhbXAgIT09IFwiYmlnaW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwidGltZXN0YW1wXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlciwgYmlnaW50LCBvciBEYXRlIChyZWNlaXZlZCAke3R5cGVvZiB0aW1lc3RhbXB9KWApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluY3JlbWVudCAhPT0gXCJiaWdpbnRcIikge1xuICAgICAgaW5jcmVtZW50ID0gdGhpc1tJbmNyZW1lbnRTeW1ib2xdO1xuICAgICAgdGhpc1tJbmNyZW1lbnRTeW1ib2xdID0gaW5jcmVtZW50ICsgMW4gJiBNYXhpbXVtSW5jcmVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gdGltZXN0YW1wIC0gdGhpc1tFcG9jaFN5bWJvbF0gPDwgMjJuIHwgKHdvcmtlcklkICYgTWF4aW11bVdvcmtlcklkKSA8PCAxN24gfCAocHJvY2Vzc0lkICYgTWF4aW11bVByb2Nlc3NJZCkgPDwgMTJuIHwgaW5jcmVtZW50ICYgTWF4aW11bUluY3JlbWVudDtcbiAgfVxuICAvKipcbiAgICogRGVjb25zdHJ1Y3RzIGEgc25vd2ZsYWtlIGdpdmVuIGEgc25vd2ZsYWtlIElEXG4gICAqIEBwYXJhbSBpZCB0aGUgc25vd2ZsYWtlIHRvIGRlY29uc3RydWN0XG4gICAqIEByZXR1cm5zIGEgZGVjb25zdHJ1Y3RlZCBzbm93Zmxha2VcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBlcG9jaCA9IG5ldyBEYXRlKCcyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFonKTtcbiAgICogY29uc3Qgc25vd2ZsYWtlID0gbmV3IFNub3dmbGFrZShlcG9jaCkuZGVjb25zdHJ1Y3QoJzM5NzEwNDYyMzEyNDQ5MzUxNjgnKTtcbiAgICogYGBgXG4gICAqL1xuICBkZWNvbnN0cnVjdChpZCkge1xuICAgIGNvbnN0IGJpZ0ludElkID0gQmlnSW50KGlkKTtcbiAgICBjb25zdCBlcG9jaCA9IHRoaXNbRXBvY2hTeW1ib2xdO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogYmlnSW50SWQsXG4gICAgICB0aW1lc3RhbXA6IChiaWdJbnRJZCA+PiAyMm4pICsgZXBvY2gsXG4gICAgICB3b3JrZXJJZDogYmlnSW50SWQgPj4gMTduICYgTWF4aW11bVdvcmtlcklkLFxuICAgICAgcHJvY2Vzc0lkOiBiaWdJbnRJZCA+PiAxMm4gJiBNYXhpbXVtUHJvY2Vzc0lkLFxuICAgICAgaW5jcmVtZW50OiBiaWdJbnRJZCAmIE1heGltdW1JbmNyZW1lbnQsXG4gICAgICBlcG9jaFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdGltZXN0YW1wIGZpZWxkJ3MgdmFsdWUgZnJvbSBhIHNub3dmbGFrZS5cbiAgICogQHBhcmFtIGlkIFRoZSBzbm93Zmxha2UgdG8gZ2V0IHRoZSB0aW1lc3RhbXAgdmFsdWUgZnJvbS5cbiAgICogQHJldHVybnMgVGhlIFVOSVggdGltZXN0YW1wIHRoYXQgaXMgc3RvcmVkIGluIGBpZGAuXG4gICAqL1xuICB0aW1lc3RhbXBGcm9tKGlkKSB7XG4gICAgcmV0dXJuIE51bWJlcigoQmlnSW50KGlkKSA+PiAyMm4pICsgdGhpc1tFcG9jaFN5bWJvbF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbnVtYmVyIGluZGljYXRpbmcgd2hldGhlciBhIHJlZmVyZW5jZSBzbm93Zmxha2UgY29tZXMgYmVmb3JlLCBvciBhZnRlciwgb3IgaXMgc2FtZSBhcyB0aGUgZ2l2ZW5cbiAgICogc25vd2ZsYWtlIGluIHNvcnQgb3JkZXIuXG4gICAqIEBwYXJhbSBhIFRoZSBmaXJzdCBzbm93Zmxha2UgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIGIgVGhlIHNlY29uZCBzbm93Zmxha2UgdG8gY29tcGFyZS5cbiAgICogQHJldHVybnMgYC0xYCBpZiBgYWAgaXMgb2xkZXIgdGhhbiBgYmAsIGAwYCBpZiBgYWAgYW5kIGBiYCBhcmUgZXF1YWxzLCBgMWAgaWYgYGFgIGlzIG5ld2VyIHRoYW4gYGJgLlxuICAgKiBAZXhhbXBsZSBTb3J0IHNub3dmbGFrZXMgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgaWRzID0gWyc3MzcxNDE4Nzc4MDMwNTcyNDQnLCAnMTA1NjE5MTEyODEyMDA4MjQzMicsICcyNTQzNjA4MTQwNjMwNTg5NDQnXTtcbiAgICogY29uc29sZS5sb2coaWRzLnNvcnQoKGEsIGIpID0+IFNub3dmbGFrZS5jb21wYXJlKGEsIGIpKSk7XG4gICAqIC8vIOKGkiBbJzI1NDM2MDgxNDA2MzA1ODk0NCcsICc3MzcxNDE4Nzc4MDMwNTcyNDQnLCAnMTA1NjE5MTEyODEyMDA4MjQzMiddO1xuICAgKiBgYGBcbiAgICogQGV4YW1wbGUgU29ydCBzbm93Zmxha2VzIGluIGRlc2NlbmRpbmcgb3JkZXJcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBpZHMgPSBbJzczNzE0MTg3NzgwMzA1NzI0NCcsICcxMDU2MTkxMTI4MTIwMDgyNDMyJywgJzI1NDM2MDgxNDA2MzA1ODk0NCddO1xuICAgKiBjb25zb2xlLmxvZyhpZHMuc29ydCgoYSwgYikgPT4gLVNub3dmbGFrZS5jb21wYXJlKGEsIGIpKSk7XG4gICAqIC8vIOKGkiBbJzEwNTYxOTExMjgxMjAwODI0MzInLCAnNzM3MTQxODc3ODAzMDU3MjQ0JywgJzI1NDM2MDgxNDA2MzA1ODk0NCddO1xuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBjb21wYXJlKGEsIGIpIHtcbiAgICBjb25zdCB0eXBlQSA9IHR5cGVvZiBhO1xuICAgIHJldHVybiB0eXBlQSA9PT0gdHlwZW9mIGIgPyB0eXBlQSA9PT0gXCJzdHJpbmdcIiA/IGNtcFN0cmluZyhhLCBiKSA6IGNtcEJpZ0ludChhLCBiKSA6IGNtcEJpZ0ludChCaWdJbnQoYSksIEJpZ0ludChiKSk7XG4gIH1cbn07XG5fYSA9IEVwb2NoU3ltYm9sLCBfYiA9IEluY3JlbWVudFN5bWJvbCwgX2MgPSBQcm9jZXNzSWRTeW1ib2wsIF9kID0gV29ya2VySWRTeW1ib2w7XG5fX25hbWUoX1Nub3dmbGFrZSwgXCJTbm93Zmxha2VcIik7XG52YXIgU25vd2ZsYWtlID0gX1Nub3dmbGFrZTtcbmZ1bmN0aW9uIGNtcEJpZ0ludChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiID8gMCA6IGEgPCBiID8gLTEgOiAxO1xufVxuX19uYW1lKGNtcEJpZ0ludCwgXCJjbXBCaWdJbnRcIik7XG5mdW5jdGlvbiBjbXBTdHJpbmcoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhLmxlbmd0aCA8IGIubGVuZ3RoID8gLTEgOiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gMSA6IGEgPCBiID8gLTEgOiAxO1xufVxuX19uYW1lKGNtcFN0cmluZywgXCJjbXBTdHJpbmdcIik7XG5cbi8vIHNyYy9saWIvRGlzY29yZFNub3dmbGFrZS50c1xudmFyIERpc2NvcmRTbm93Zmxha2UgPSBuZXcgU25vd2ZsYWtlKDE0MjAwNzA0MDAwMDBuKTtcblxuLy8gc3JjL2xpYi9Ud2l0dGVyU25vd2ZsYWtlLnRzXG52YXIgVHdpdHRlclNub3dmbGFrZSA9IG5ldyBTbm93Zmxha2UoMTI4ODgzNDk3NDY1N24pO1xuXG5leHBvcnQgeyBEaXNjb3JkU25vd2ZsYWtlLCBNYXhpbXVtSW5jcmVtZW50LCBNYXhpbXVtUHJvY2Vzc0lkLCBNYXhpbXVtV29ya2VySWQsIFNub3dmbGFrZSwgVHdpdHRlclNub3dmbGFrZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3V0LmpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19uYW1lIiwidGFyZ2V0IiwiX19wdWJsaWNGaWVsZCIsIkluY3JlbWVudFN5bWJvbCIsIlN5bWJvbCIsIkVwb2NoU3ltYm9sIiwiUHJvY2Vzc0lkU3ltYm9sIiwiV29ya2VySWRTeW1ib2wiLCJNYXhpbXVtV29ya2VySWQiLCJNYXhpbXVtUHJvY2Vzc0lkIiwiTWF4aW11bUluY3JlbWVudCIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiX1Nub3dmbGFrZSIsImNvbnN0cnVjdG9yIiwiZXBvY2giLCJkZWNvbnN0cnVjdCIsIkJpZ0ludCIsIkRhdGUiLCJnZXRUaW1lIiwicHJvY2Vzc0lkIiwid29ya2VySWQiLCJnZW5lcmF0ZSIsImluY3JlbWVudCIsInRpbWVzdGFtcCIsIm5vdyIsIlR5cGVFcnJvciIsImlkIiwiYmlnSW50SWQiLCJ0aW1lc3RhbXBGcm9tIiwiTnVtYmVyIiwiY29tcGFyZSIsImEiLCJiIiwidHlwZUEiLCJjbXBTdHJpbmciLCJjbXBCaWdJbnQiLCJTbm93Zmxha2UiLCJsZW5ndGgiLCJEaXNjb3JkU25vd2ZsYWtlIiwiVHdpdHRlclNub3dmbGFrZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@sapphire/snowflake/dist/esm/index.mjs\n");

/***/ })

};
;