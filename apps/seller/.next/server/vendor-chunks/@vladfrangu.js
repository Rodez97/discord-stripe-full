"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vladfrangu";
exports.ids = ["vendor-chunks/@vladfrangu"];
exports.modules = {

/***/ "(rsc)/../../node_modules/@vladfrangu/async_event_emitter/dist/index.mjs":
/*!*************************************************************************!*\
  !*** ../../node_modules/@vladfrangu/async_event_emitter/dist/index.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   AsyncEventEmitter: () => (/* binding */ AsyncEventEmitter)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __name = (target, value)=>__defProp(target, \"name\", {\n        value,\n        configurable: true\n    });\n// src/index.ts\nfunction validateListener(input) {\n    if (typeof input !== \"function\") {\n        throw new TypeError(`The listener argument must be a function. Received ${typeof input}`);\n    }\n}\n__name(validateListener, \"validateListener\");\nfunction validateAbortSignal(input) {\n    if (input && !(input instanceof AbortSignal)) {\n        throw new TypeError(`The signal option must be an AbortSignal. Received ${input}`);\n    }\n}\n__name(validateAbortSignal, \"validateAbortSignal\");\nfunction spliceOne(list, index) {\n    for(; index + 1 < list.length; index++){\n        list[index] = list[index + 1];\n    }\n    list.pop();\n}\n__name(spliceOne, \"spliceOne\");\nfunction arrayClone(arr) {\n    switch(arr.length){\n        case 2:\n            return [\n                arr[0],\n                arr[1]\n            ];\n        case 3:\n            return [\n                arr[0],\n                arr[1],\n                arr[2]\n            ];\n        case 4:\n            return [\n                arr[0],\n                arr[1],\n                arr[2],\n                arr[3]\n            ];\n        case 5:\n            return [\n                arr[0],\n                arr[1],\n                arr[2],\n                arr[3],\n                arr[4]\n            ];\n        case 6:\n            return [\n                arr[0],\n                arr[1],\n                arr[2],\n                arr[3],\n                arr[4],\n                arr[5]\n            ];\n    }\n    return arr.slice();\n}\n__name(arrayClone, \"arrayClone\");\nfunction identicalSequenceRange(a, b) {\n    for(let i = 0; i < a.length - 3; i++){\n        const pos = b.indexOf(a[i]);\n        if (pos !== -1) {\n            const rest = b.length - pos;\n            if (rest > 3) {\n                let len = 1;\n                const maxLen = Math.min(a.length - i, rest);\n                while(maxLen > len && a[i + len] === b[pos + len]){\n                    len++;\n                }\n                if (len > 3) {\n                    return [\n                        len,\n                        i\n                    ];\n                }\n            }\n        }\n    }\n    return [\n        0,\n        0\n    ];\n}\n__name(identicalSequenceRange, \"identicalSequenceRange\");\nfunction enhanceStackTrace(err, own) {\n    let ctorInfo = \"\";\n    try {\n        const { name } = this.constructor;\n        if (name !== \"AsyncEventEmitter\") ctorInfo = ` on ${name} instance`;\n    } catch  {}\n    const sep = `\nEmitted 'error' event${ctorInfo} at:\n`;\n    const errStack = err.stack.split(\"\\n\").slice(1);\n    const ownStack = own.stack.split(\"\\n\").slice(1);\n    const { 0: len, 1: off } = identicalSequenceRange(ownStack, errStack);\n    if (len > 0) {\n        ownStack.splice(off + 1, len - 2, \"    [... lines matching original stack trace ...]\");\n    }\n    return err.stack + sep + ownStack.join(\"\\n\");\n}\n__name(enhanceStackTrace, \"enhanceStackTrace\");\nvar _AsyncEventEmitter = class _AsyncEventEmitter {\n    constructor(){\n        this._events = {\n            __proto__: null\n        };\n        this._eventCount = 0;\n        this._maxListeners = 10;\n        this._internalPromiseMap = /* @__PURE__ */ new Map();\n        this._wrapperId = 0n;\n    }\n    addListener(eventName, listener) {\n        validateListener(listener);\n        const wrapped = this._wrapListener(eventName, listener, false);\n        this._addListener(eventName, wrapped, false);\n        return this;\n    }\n    on(eventName, listener) {\n        return this.addListener(eventName, listener);\n    }\n    once(eventName, listener) {\n        validateListener(listener);\n        const wrapped = this._wrapListener(eventName, listener, true);\n        this._addListener(eventName, wrapped, false);\n        return this;\n    }\n    removeListener(eventName, listener) {\n        validateListener(listener);\n        const events = this._events;\n        const eventList = events[eventName];\n        if (eventList === void 0) {\n            return this;\n        }\n        if (eventList === listener || eventList.listener === listener) {\n            if (--this._eventCount === 0) {\n                this._events = {\n                    __proto__: null\n                };\n            } else {\n                delete events[eventName];\n                if (events.removeListener) {\n                    this.emit(\"removeListener\", eventName, eventList.listener ?? eventList);\n                }\n            }\n        } else if (typeof eventList !== \"function\") {\n            let position = -1;\n            for(let i = eventList.length - 1; i >= 0; i--){\n                if (eventList[i] === listener || eventList[i].listener === listener) {\n                    position = i;\n                    break;\n                }\n            }\n            if (position < 0) {\n                return this;\n            }\n            if (position === 0) {\n                eventList.shift();\n            } else {\n                spliceOne(eventList, position);\n            }\n            if (eventList.length === 0) {\n                delete events[eventName];\n                --this._eventCount;\n            }\n            if (events.removeListener !== void 0) {\n                this.emit(\"removeListener\", eventName, listener);\n            }\n        }\n        return this;\n    }\n    off(eventName, listener) {\n        return this.removeListener(eventName, listener);\n    }\n    removeAllListeners(event) {\n        const events = this._events;\n        if (events.removeListener === void 0) {\n            if (!event) {\n                this._events = {\n                    __proto__: null\n                };\n                this._eventCount = 0;\n            } else if (events[event] !== void 0) {\n                if (--this._eventCount === 0) {\n                    this._events = {\n                        __proto__: null\n                    };\n                } else {\n                    delete events[event];\n                }\n            }\n            return this;\n        }\n        if (!event) {\n            for (const key of Reflect.ownKeys(events)){\n                if (key === \"removeListener\") {\n                    continue;\n                }\n                this.removeAllListeners(key);\n            }\n            this.removeAllListeners(\"removeListener\");\n            this._events = {\n                __proto__: null\n            };\n            this._eventCount = 0;\n            return this;\n        }\n        const listeners = events[event];\n        if (typeof listeners === \"function\") {\n            this.removeListener(event, listeners);\n        } else if (listeners !== void 0) {\n            for(let i = listeners.length - 1; i >= 0; i--){\n                this.removeListener(event, listeners[i]);\n            }\n        }\n        return this;\n    }\n    setMaxListeners(n) {\n        if (typeof n !== \"number\" || n < 0 || Number.isNaN(n)) {\n            throw new RangeError(`Expected to get a non-negative number for \"setMaxListeners\", got ${n} instead`);\n        }\n        this._maxListeners = n;\n        return this;\n    }\n    getMaxListeners() {\n        return this._maxListeners;\n    }\n    listeners(eventName) {\n        const eventList = this._events[eventName];\n        if (eventList === void 0) {\n            return [];\n        }\n        if (typeof eventList === \"function\") {\n            return [\n                eventList.listener ?? eventList\n            ];\n        }\n        const ret = arrayClone(eventList);\n        for(let i = 0; i < ret.length; ++i){\n            const orig = ret[i].listener;\n            if (typeof orig === \"function\") {\n                ret[i] = orig;\n            }\n        }\n        return ret;\n    }\n    rawListeners(eventName) {\n        const eventList = this._events[eventName];\n        if (eventList === void 0) {\n            return [];\n        }\n        if (typeof eventList === \"function\") {\n            return [\n                eventList\n            ];\n        }\n        return arrayClone(eventList);\n    }\n    emit(eventName, ...args) {\n        let doError = eventName === \"error\";\n        const events = this._events;\n        if (events !== void 0) {\n            doError = doError && events.error === void 0;\n        } else if (!doError) {\n            return false;\n        }\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                er = args[0];\n            }\n            if (er instanceof Error) {\n                try {\n                    const capture = {};\n                    Error.captureStackTrace(capture, _AsyncEventEmitter.prototype.emit);\n                    Object.defineProperty(er, \"stack\", {\n                        value: enhanceStackTrace.call(this, er, capture),\n                        configurable: true\n                    });\n                } catch  {}\n                throw er; // Unhandled 'error' event\n            }\n            const stringifiedError = String(er);\n            const err = new Error(`Unhandled 'error' event emitted, received ${stringifiedError}`);\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        const handlers = events[eventName];\n        if (handlers === void 0) {\n            return false;\n        }\n        if (typeof handlers === \"function\") {\n            const result = handlers.apply(this, args);\n            if (result !== void 0 && result !== null) {\n                handleMaybeAsync(this, result);\n            }\n        } else {\n            const len = handlers.length;\n            const listeners = arrayClone(handlers);\n            for(let i = 0; i < len; ++i){\n                const result = listeners[i].apply(this, args);\n                if (result !== void 0 && result !== null) {\n                    handleMaybeAsync(this, result);\n                }\n            }\n        }\n        return true;\n    }\n    listenerCount(eventName) {\n        const events = this._events;\n        if (events === void 0) {\n            return 0;\n        }\n        const eventListeners = events[eventName];\n        if (typeof eventListeners === \"function\") {\n            return 1;\n        }\n        return eventListeners?.length ?? 0;\n    }\n    prependListener(eventName, listener) {\n        validateListener(listener);\n        const wrapped = this._wrapListener(eventName, listener, false);\n        this._addListener(eventName, wrapped, true);\n        return this;\n    }\n    prependOnceListener(eventName, listener) {\n        validateListener(listener);\n        const wrapped = this._wrapListener(eventName, listener, true);\n        this._addListener(eventName, wrapped, true);\n        return this;\n    }\n    eventNames() {\n        return this._eventCount > 0 ? Reflect.ownKeys(this._events) : [];\n    }\n    async waitForAllListenersToComplete() {\n        const promises = [\n            ...this._internalPromiseMap.values()\n        ];\n        if (promises.length === 0) {\n            return false;\n        }\n        await Promise.all(promises);\n        return true;\n    }\n    _addListener(eventName, wrappedListener, prepend) {\n        if (this._events.newListener !== void 0) {\n            this.emit(\"newListener\", eventName, wrappedListener.listener ?? wrappedListener);\n        }\n        let existing = this._events[eventName];\n        if (existing === void 0) {\n            existing = this._events[eventName] = wrappedListener;\n            ++this._eventCount;\n        } else if (typeof existing === \"function\") {\n            existing = this._events[eventName] = prepend ? [\n                wrappedListener,\n                existing\n            ] : [\n                existing,\n                wrappedListener\n            ];\n        } else if (prepend) {\n            existing.unshift(wrappedListener);\n        } else {\n            existing.push(wrappedListener);\n        }\n        if (this._maxListeners > 0 && existing.length > this._maxListeners && !existing._hasWarnedAboutMaxListeners) {\n            existing._hasWarnedAboutMaxListeners = true;\n            const warningMessage = [\n                `Possible AsyncEventEmitter memory leak detected. ${existing.length} ${String(eventName)} listeners added to ${this.constructor.name}.`,\n                `Use emitter.setMaxListeners() to increase the limit.`\n            ].join(\" \");\n            console.warn(warningMessage);\n        }\n    }\n    _wrapListener(eventName, listener, once) {\n        if (!once) {\n            return listener;\n        }\n        const state = {\n            fired: false,\n            wrapFn: void 0,\n            eventEmitter: this,\n            eventName,\n            listener\n        };\n        const aliased = onceWrapper;\n        const wrapped = aliased.bind(state);\n        wrapped.listener = listener;\n        state.wrapFn = wrapped;\n        return wrapped;\n    }\n    static listenerCount(emitter, eventName) {\n        return emitter.listenerCount(eventName);\n    }\n    static async once(emitter, eventName, options = {}) {\n        const signal = options?.signal;\n        validateAbortSignal(signal);\n        if (signal?.aborted) {\n            throw new AbortError(void 0, {\n                cause: getReason(signal)\n            });\n        }\n        return new Promise((resolve, reject)=>{\n            const errorListener = /* @__PURE__ */ __name((err)=>{\n                emitter.removeListener(eventName, resolver);\n                if (signal) {\n                    eventTargetAgnosticRemoveListener(emitter, eventName, abortListener);\n                }\n                reject(err);\n            }, \"errorListener\");\n            const resolver = /* @__PURE__ */ __name((...args)=>{\n                emitter.removeListener(\"error\", errorListener);\n                if (signal) {\n                    eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener);\n                }\n                resolve(args);\n            }, \"resolver\");\n            emitter.once(eventName, resolver);\n            if (eventName !== \"error\") {\n                emitter.once(\"error\", errorListener);\n            }\n            const abortListener = /* @__PURE__ */ __name(()=>{\n                eventTargetAgnosticRemoveListener(emitter, eventName, resolver);\n                eventTargetAgnosticRemoveListener(emitter, \"error\", errorListener);\n                reject(new AbortError(void 0, {\n                    cause: getReason(signal)\n                }));\n            }, \"abortListener\");\n            if (signal) {\n                eventTargetAgnosticAddListener(signal, \"abort\", abortListener, {\n                    once: true\n                });\n            }\n        });\n    }\n    static on(emitter, eventName, options = {}) {\n        const signal = options?.signal;\n        validateAbortSignal(signal);\n        if (signal?.aborted) {\n            throw new AbortError(void 0, {\n                cause: getReason(signal)\n            });\n        }\n        const unconsumedEvents = [];\n        const unconsumedPromises = [];\n        let error = null;\n        let finished = false;\n        const abortListener = /* @__PURE__ */ __name(()=>{\n            errorHandler(new AbortError(void 0, {\n                cause: getReason(signal)\n            }));\n        }, \"abortListener\");\n        const eventHandler = /* @__PURE__ */ __name((...args)=>{\n            const promise = unconsumedPromises.shift();\n            if (promise) {\n                promise.resolve(createIterResult(args, false));\n            } else {\n                unconsumedEvents.push(args);\n            }\n        }, \"eventHandler\");\n        const errorHandler = /* @__PURE__ */ __name((err)=>{\n            finished = true;\n            const toError = unconsumedPromises.shift();\n            if (toError) {\n                toError.reject(err);\n            } else {\n                error = err;\n            }\n            void iterator.return();\n        }, \"errorHandler\");\n        const iterator = Object.setPrototypeOf({\n            next () {\n                const value = unconsumedEvents.shift();\n                if (value) {\n                    return Promise.resolve(createIterResult(value, false));\n                }\n                if (error) {\n                    const p = Promise.reject(error);\n                    error = null;\n                    return p;\n                }\n                if (finished) {\n                    return Promise.resolve(createIterResult(void 0, true));\n                }\n                return new Promise((resolve, reject)=>{\n                    unconsumedPromises.push({\n                        resolve,\n                        reject\n                    });\n                });\n            },\n            return () {\n                emitter.off(eventName, eventHandler);\n                emitter.off(\"error\", errorHandler);\n                if (signal) {\n                    eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener);\n                }\n                finished = true;\n                const doneResult = createIterResult(void 0, true);\n                for (const promise of unconsumedPromises){\n                    promise.resolve(doneResult);\n                }\n                return Promise.resolve(doneResult);\n            },\n            throw (err) {\n                if (!err || !(err instanceof Error)) {\n                    throw new TypeError(`Expected Error instance to be thrown in AsyncEventEmitter.AsyncIterator. Got ${err}`);\n                }\n                error = err;\n                emitter.off(eventName, eventHandler);\n                emitter.off(\"error\", errorHandler);\n            },\n            [Symbol.asyncIterator] () {\n                return this;\n            }\n        }, AsyncIteratorPrototype);\n        emitter.on(eventName, eventHandler);\n        if (eventName !== \"error\") {\n            emitter.on(\"error\", errorHandler);\n        }\n        if (signal) {\n            eventTargetAgnosticAddListener(signal, \"abort\", abortListener);\n        }\n        return iterator;\n    }\n};\n__name(_AsyncEventEmitter, \"AsyncEventEmitter\");\nvar AsyncEventEmitter = _AsyncEventEmitter;\nfunction onceWrapper() {\n    if (!this.fired) {\n        this.eventEmitter.removeListener(this.eventName, this.wrapFn);\n        this.fired = true;\n        if (arguments.length === 0) {\n            return this.listener.call(this.eventEmitter);\n        }\n        return this.listener.apply(this.eventEmitter, arguments);\n    }\n}\n__name(onceWrapper, \"onceWrapper\");\nfunction getReason(signal) {\n    return signal?.reason;\n}\n__name(getReason, \"getReason\");\nfunction eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {\n    if (typeof emitter.off === \"function\") {\n        emitter.off(name, listener);\n    } else if (typeof emitter.removeEventListener === \"function\") {\n        emitter.removeEventListener(name, listener, flags);\n    }\n}\n__name(eventTargetAgnosticRemoveListener, \"eventTargetAgnosticRemoveListener\");\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === \"function\") {\n        if (flags?.once) {\n            emitter.once(name, listener);\n        } else {\n            emitter.on(name, listener);\n        }\n    } else if (typeof emitter.addEventListener === \"function\") {\n        emitter.addEventListener(name, listener, flags);\n    }\n}\n__name(eventTargetAgnosticAddListener, \"eventTargetAgnosticAddListener\");\nvar AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);\nfunction createIterResult(value, done) {\n    return {\n        value,\n        done\n    };\n}\n__name(createIterResult, \"createIterResult\");\nvar _AbortError = class _AbortError extends Error {\n    constructor(message = \"The operation was aborted\", options = void 0){\n        if (options !== void 0 && typeof options !== \"object\") {\n            throw new TypeError(`Failed to create AbortError: options is not an object or undefined`);\n        }\n        super(message, options);\n        this.code = \"ABORT_ERR\";\n        this.name = \"AbortError\";\n    }\n};\n__name(_AbortError, \"AbortError\");\nvar AbortError = _AbortError;\nfunction handleMaybeAsync(emitter, result) {\n    try {\n        const fin = result.finally;\n        if (typeof fin === \"function\") {\n            const promiseId = String(++emitter[\"_wrapperId\"]);\n            emitter[\"_internalPromiseMap\"].set(promiseId, result);\n            fin.call(result, /* @__PURE__ */ __name(function final() {\n                emitter[\"_internalPromiseMap\"].delete(promiseId);\n            }, \"final\"));\n        }\n    } catch (err) {\n        emitter.emit(\"error\", err);\n    }\n}\n__name(handleMaybeAsync, \"handleMaybeAsync\");\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0B2bGFkZnJhbmd1L2FzeW5jX2V2ZW50X2VtaXR0ZXIvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLFNBQVMsQ0FBQ0MsUUFBUUMsUUFBVUwsVUFBVUksUUFBUSxRQUFRO1FBQUVDO1FBQU9DLGNBQWM7SUFBSztBQUV0RixlQUFlO0FBQ2YsU0FBU0MsaUJBQWlCQyxLQUFLO0lBQzdCLElBQUksT0FBT0EsVUFBVSxZQUFZO1FBQy9CLE1BQU0sSUFBSUMsVUFBVSxDQUFDLG1EQUFtRCxFQUFFLE9BQU9ELE1BQU0sQ0FBQztJQUMxRjtBQUNGO0FBQ0FMLE9BQU9JLGtCQUFrQjtBQUN6QixTQUFTRyxvQkFBb0JGLEtBQUs7SUFDaEMsSUFBSUEsU0FBUyxDQUFFQSxDQUFBQSxpQkFBaUJHLFdBQVUsR0FBSTtRQUM1QyxNQUFNLElBQUlGLFVBQVUsQ0FBQyxtREFBbUQsRUFBRUQsTUFBTSxDQUFDO0lBQ25GO0FBQ0Y7QUFDQUwsT0FBT08scUJBQXFCO0FBQzVCLFNBQVNFLFVBQVVDLElBQUksRUFBRUMsS0FBSztJQUM1QixNQUFPQSxRQUFRLElBQUlELEtBQUtFLE1BQU0sRUFBRUQsUUFBUztRQUN2Q0QsSUFBSSxDQUFDQyxNQUFNLEdBQUdELElBQUksQ0FBQ0MsUUFBUSxFQUFFO0lBQy9CO0lBQ0FELEtBQUtHLEdBQUc7QUFDVjtBQUNBYixPQUFPUyxXQUFXO0FBQ2xCLFNBQVNLLFdBQVdDLEdBQUc7SUFDckIsT0FBUUEsSUFBSUgsTUFBTTtRQUNoQixLQUFLO1lBQ0gsT0FBTztnQkFBQ0csR0FBRyxDQUFDLEVBQUU7Z0JBQUVBLEdBQUcsQ0FBQyxFQUFFO2FBQUM7UUFDekIsS0FBSztZQUNILE9BQU87Z0JBQUNBLEdBQUcsQ0FBQyxFQUFFO2dCQUFFQSxHQUFHLENBQUMsRUFBRTtnQkFBRUEsR0FBRyxDQUFDLEVBQUU7YUFBQztRQUNqQyxL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LFNBQVNwRSxpQkFBaUI0QixPQUFPLEVBQUU5QixNQUFNO0lBQ3ZDLElBQUk7UUFDRixNQUFNeUUsTUFBTXpFLE9BQU8wRSxPQUFPO1FBQzFCLElBQUksT0FBT0QsUUFBUSxZQUFZO1lBQzdCLE1BQU1FLFlBQVk5RSxPQUFPLEVBQUVpQyxPQUFPLENBQUMsYUFBYTtZQUNoREEsT0FBTyxDQUFDLHNCQUFzQixDQUFDOEMsR0FBRyxDQUFDRCxXQUFXM0U7WUFDOUN5RSxJQUFJOUUsSUFBSSxDQUFDSyxRQUFRLGFBQWEsR0FBRzVGLE9BQU8sU0FBU3lLO2dCQUMvQy9DLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQ2dELE1BQU0sQ0FBQ0g7WUFDeEMsR0FBRztRQUNMO0lBQ0YsRUFBRSxPQUFPMUksS0FBSztRQUNaNkYsUUFBUTdELElBQUksQ0FBQyxTQUFTaEM7SUFDeEI7QUFDRjtBQUNBN0IsT0FBTzhGLGtCQUFrQjtBQUl2QixDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdHJpcGUtZGlzY29yZC9zZWxsZXIvLi4vLi4vbm9kZV9tb2R1bGVzL0B2bGFkZnJhbmd1L2FzeW5jX2V2ZW50X2VtaXR0ZXIvZGlzdC9pbmRleC5tanM/MGJlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fbmFtZSA9ICh0YXJnZXQsIHZhbHVlKSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIm5hbWVcIiwgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIHZhbGlkYXRlTGlzdGVuZXIoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIGxpc3RlbmVyIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbi4gUmVjZWl2ZWQgJHt0eXBlb2YgaW5wdXR9YCk7XG4gIH1cbn1cbl9fbmFtZSh2YWxpZGF0ZUxpc3RlbmVyLCBcInZhbGlkYXRlTGlzdGVuZXJcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZUFib3J0U2lnbmFsKGlucHV0KSB7XG4gIGlmIChpbnB1dCAmJiAhKGlucHV0IGluc3RhbmNlb2YgQWJvcnRTaWduYWwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHNpZ25hbCBvcHRpb24gbXVzdCBiZSBhbiBBYm9ydFNpZ25hbC4gUmVjZWl2ZWQgJHtpbnB1dH1gKTtcbiAgfVxufVxuX19uYW1lKHZhbGlkYXRlQWJvcnRTaWduYWwsIFwidmFsaWRhdGVBYm9ydFNpZ25hbFwiKTtcbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgfVxuICBsaXN0LnBvcCgpO1xufVxuX19uYW1lKHNwbGljZU9uZSwgXCJzcGxpY2VPbmVcIik7XG5mdW5jdGlvbiBhcnJheUNsb25lKGFycikge1xuICBzd2l0Y2ggKGFyci5sZW5ndGgpIHtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gW2FyclswXSwgYXJyWzFdXTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gW2FyclswXSwgYXJyWzFdLCBhcnJbMl1dO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBbYXJyWzBdLCBhcnJbMV0sIGFyclsyXSwgYXJyWzNdXTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gW2FyclswXSwgYXJyWzFdLCBhcnJbMl0sIGFyclszXSwgYXJyWzRdXTtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gW2FyclswXSwgYXJyWzFdLCBhcnJbMl0sIGFyclszXSwgYXJyWzRdLCBhcnJbNV1dO1xuICB9XG4gIHJldHVybiBhcnIuc2xpY2UoKTtcbn1cbl9fbmFtZShhcnJheUNsb25lLCBcImFycmF5Q2xvbmVcIik7XG5mdW5jdGlvbiBpZGVudGljYWxTZXF1ZW5jZVJhbmdlKGEsIGIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aCAtIDM7IGkrKykge1xuICAgIGNvbnN0IHBvcyA9IGIuaW5kZXhPZihhW2ldKTtcbiAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgY29uc3QgcmVzdCA9IGIubGVuZ3RoIC0gcG9zO1xuICAgICAgaWYgKHJlc3QgPiAzKSB7XG4gICAgICAgIGxldCBsZW4gPSAxO1xuICAgICAgICBjb25zdCBtYXhMZW4gPSBNYXRoLm1pbihhLmxlbmd0aCAtIGksIHJlc3QpO1xuICAgICAgICB3aGlsZSAobWF4TGVuID4gbGVuICYmIGFbaSArIGxlbl0gPT09IGJbcG9zICsgbGVuXSkge1xuICAgICAgICAgIGxlbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAzKSB7XG4gICAgICAgICAgcmV0dXJuIFtsZW4sIGldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbMCwgMF07XG59XG5fX25hbWUoaWRlbnRpY2FsU2VxdWVuY2VSYW5nZSwgXCJpZGVudGljYWxTZXF1ZW5jZVJhbmdlXCIpO1xuZnVuY3Rpb24gZW5oYW5jZVN0YWNrVHJhY2UoZXJyLCBvd24pIHtcbiAgbGV0IGN0b3JJbmZvID0gXCJcIjtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IG5hbWUgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgaWYgKG5hbWUgIT09IFwiQXN5bmNFdmVudEVtaXR0ZXJcIilcbiAgICAgIGN0b3JJbmZvID0gYCBvbiAke25hbWV9IGluc3RhbmNlYDtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgY29uc3Qgc2VwID0gYFxuRW1pdHRlZCAnZXJyb3InIGV2ZW50JHtjdG9ySW5mb30gYXQ6XG5gO1xuICBjb25zdCBlcnJTdGFjayA9IGVyci5zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgxKTtcbiAgY29uc3Qgb3duU3RhY2sgPSBvd24uc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSk7XG4gIGNvbnN0IHsgMDogbGVuLCAxOiBvZmYgfSA9IGlkZW50aWNhbFNlcXVlbmNlUmFuZ2Uob3duU3RhY2ssIGVyclN0YWNrKTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBvd25TdGFjay5zcGxpY2Uob2ZmICsgMSwgbGVuIC0gMiwgXCIgICAgWy4uLiBsaW5lcyBtYXRjaGluZyBvcmlnaW5hbCBzdGFjayB0cmFjZSAuLi5dXCIpO1xuICB9XG4gIHJldHVybiBlcnIuc3RhY2sgKyBzZXAgKyBvd25TdGFjay5qb2luKFwiXFxuXCIpO1xufVxuX19uYW1lKGVuaGFuY2VTdGFja1RyYWNlLCBcImVuaGFuY2VTdGFja1RyYWNlXCIpO1xudmFyIF9Bc3luY0V2ZW50RW1pdHRlciA9IGNsYXNzIF9Bc3luY0V2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIF9fcHJvdG9fXzogbnVsbFxuICAgIH07XG4gICAgdGhpcy5fZXZlbnRDb3VudCA9IDA7XG4gICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gMTA7XG4gICAgdGhpcy5faW50ZXJuYWxQcm9taXNlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl93cmFwcGVySWQgPSAwbjtcbiAgfVxuICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY29uc3Qgd3JhcHBlZCA9IHRoaXMuX3dyYXBMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgdGhpcy5fYWRkTGlzdGVuZXIoZXZlbnROYW1lLCB3cmFwcGVkLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG4gIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNvbnN0IHdyYXBwZWQgPSB0aGlzLl93cmFwTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgdGhpcy5fYWRkTGlzdGVuZXIoZXZlbnROYW1lLCB3cmFwcGVkLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBjb25zdCBldmVudExpc3QgPSBldmVudHNbZXZlbnROYW1lXTtcbiAgICBpZiAoZXZlbnRMaXN0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoZXZlbnRMaXN0ID09PSBsaXN0ZW5lciB8fCBldmVudExpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICBpZiAoLS10aGlzLl9ldmVudENvdW50ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHsgX19wcm90b19fOiBudWxsIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLCBldmVudE5hbWUsIGV2ZW50TGlzdC5saXN0ZW5lciA/PyBldmVudExpc3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnRMaXN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGxldCBwb3NpdGlvbiA9IC0xO1xuICAgICAgZm9yIChsZXQgaSA9IGV2ZW50TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoZXZlbnRMaXN0W2ldID09PSBsaXN0ZW5lciB8fCBldmVudExpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uID09PSAwKSB7XG4gICAgICAgIGV2ZW50TGlzdC5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlT25lKGV2ZW50TGlzdCwgcG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50TGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50c1tldmVudE5hbWVdO1xuICAgICAgICAtLXRoaXMuX2V2ZW50Q291bnQ7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIiwgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuICAgICAgICB0aGlzLl9ldmVudENvdW50ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW2V2ZW50XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50Q291bnQgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbZXZlbnRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdC5vd25LZXlzKGV2ZW50cykpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJyZW1vdmVMaXN0ZW5lclwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVtb3ZlTGlzdGVuZXJcIik7XG4gICAgICB0aGlzLl9ldmVudHMgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuICAgICAgdGhpcy5fZXZlbnRDb3VudCA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB2b2lkIDApIHtcbiAgICAgIGZvciAobGV0IGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgICBpZiAodHlwZW9mIG4gIT09IFwibnVtYmVyXCIgfHwgbiA8IDAgfHwgTnVtYmVyLmlzTmFOKG4pKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRXhwZWN0ZWQgdG8gZ2V0IGEgbm9uLW5lZ2F0aXZlIG51bWJlciBmb3IgXCJzZXRNYXhMaXN0ZW5lcnNcIiwgZ290ICR7bn0gaW5zdGVhZGApO1xuICAgIH1cbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldE1heExpc3RlbmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICB9XG4gIGxpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICBjb25zdCBldmVudExpc3QgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcbiAgICBpZiAoZXZlbnRMaXN0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBldmVudExpc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIFtldmVudExpc3QubGlzdGVuZXIgPz8gZXZlbnRMaXN0XTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gYXJyYXlDbG9uZShldmVudExpc3QpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBvcmlnID0gcmV0W2ldLmxpc3RlbmVyO1xuICAgICAgaWYgKHR5cGVvZiBvcmlnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0W2ldID0gb3JpZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICByYXdMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgY29uc3QgZXZlbnRMaXN0ID0gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgaWYgKGV2ZW50TGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXZlbnRMaXN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBbZXZlbnRMaXN0XTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5Q2xvbmUoZXZlbnRMaXN0KTtcbiAgfVxuICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgIGxldCBkb0Vycm9yID0gZXZlbnROYW1lID09PSBcImVycm9yXCI7XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIGlmIChldmVudHMgIT09IHZvaWQgMCkge1xuICAgICAgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmICghZG9FcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZG9FcnJvcikge1xuICAgICAgbGV0IGVyO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBlciA9IGFyZ3NbMF07XG4gICAgICB9XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNhcHR1cmUgPSB7fTtcbiAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShjYXB0dXJlLCBfQXN5bmNFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlciwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgICB2YWx1ZTogZW5oYW5jZVN0YWNrVHJhY2UuY2FsbCh0aGlzLCBlciwgY2FwdHVyZSksXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJpbmdpZmllZEVycm9yID0gU3RyaW5nKGVyKTtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgVW5oYW5kbGVkICdlcnJvcicgZXZlbnQgZW1pdHRlZCwgcmVjZWl2ZWQgJHtzdHJpbmdpZmllZEVycm9yfWApO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlcnMgPSBldmVudHNbZXZlbnROYW1lXTtcbiAgICBpZiAoaGFuZGxlcnMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGhhbmRsZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGhhbmRsZXJzLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICBoYW5kbGVNYXliZUFzeW5jKHRoaXMsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbiA9IGhhbmRsZXJzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlcnMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICBoYW5kbGVNYXliZUFzeW5jKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKGV2ZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSBldmVudHNbZXZlbnROYW1lXTtcbiAgICBpZiAodHlwZW9mIGV2ZW50TGlzdGVuZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcnM/Lmxlbmd0aCA/PyAwO1xuICB9XG4gIHByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY29uc3Qgd3JhcHBlZCA9IHRoaXMuX3dyYXBMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgdGhpcy5fYWRkTGlzdGVuZXIoZXZlbnROYW1lLCB3cmFwcGVkLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwcmVwZW5kT25jZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjb25zdCB3cmFwcGVkID0gdGhpcy5fd3JhcExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIHRoaXMuX2FkZExpc3RlbmVyKGV2ZW50TmFtZSwgd3JhcHBlZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZXZlbnROYW1lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JBbGxMaXN0ZW5lcnNUb0NvbXBsZXRlKCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gWy4uLnRoaXMuX2ludGVybmFsUHJvbWlzZU1hcC52YWx1ZXMoKV07XG4gICAgaWYgKHByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX2FkZExpc3RlbmVyKGV2ZW50TmFtZSwgd3JhcHBlZExpc3RlbmVyLCBwcmVwZW5kKSB7XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmVtaXQoXCJuZXdMaXN0ZW5lclwiLCBldmVudE5hbWUsIHdyYXBwZWRMaXN0ZW5lci5saXN0ZW5lciA/PyB3cmFwcGVkTGlzdGVuZXIpO1xuICAgIH1cbiAgICBsZXQgZXhpc3RpbmcgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcbiAgICBpZiAoZXhpc3RpbmcgPT09IHZvaWQgMCkge1xuICAgICAgZXhpc3RpbmcgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXSA9IHdyYXBwZWRMaXN0ZW5lcjtcbiAgICAgICsrdGhpcy5fZXZlbnRDb3VudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBleGlzdGluZyA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdID0gcHJlcGVuZCA/IFt3cmFwcGVkTGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgd3JhcHBlZExpc3RlbmVyXTtcbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQod3JhcHBlZExpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaCh3cmFwcGVkTGlzdGVuZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbWF4TGlzdGVuZXJzID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiB0aGlzLl9tYXhMaXN0ZW5lcnMgJiYgIWV4aXN0aW5nLl9oYXNXYXJuZWRBYm91dE1heExpc3RlbmVycykge1xuICAgICAgZXhpc3RpbmcuX2hhc1dhcm5lZEFib3V0TWF4TGlzdGVuZXJzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHdhcm5pbmdNZXNzYWdlID0gW1xuICAgICAgICBgUG9zc2libGUgQXN5bmNFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICR7ZXhpc3RpbmcubGVuZ3RofSAke1N0cmluZyhldmVudE5hbWUpfSBsaXN0ZW5lcnMgYWRkZWQgdG8gJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9LmAsXG4gICAgICAgIGBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSB0aGUgbGltaXQuYFxuICAgICAgXS5qb2luKFwiIFwiKTtcbiAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nTWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIF93cmFwTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb25jZSkge1xuICAgIGlmICghb25jZSkge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgIGZpcmVkOiBmYWxzZSxcbiAgICAgIHdyYXBGbjogdm9pZCAwLFxuICAgICAgZXZlbnRFbWl0dGVyOiB0aGlzLFxuICAgICAgZXZlbnROYW1lLFxuICAgICAgbGlzdGVuZXJcbiAgICB9O1xuICAgIGNvbnN0IGFsaWFzZWQgPSBvbmNlV3JhcHBlcjtcbiAgICBjb25zdCB3cmFwcGVkID0gYWxpYXNlZC5iaW5kKHN0YXRlKTtcbiAgICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgICByZXR1cm4gd3JhcHBlZDtcbiAgfVxuICBzdGF0aWMgbGlzdGVuZXJDb3VudChlbWl0dGVyLCBldmVudE5hbWUpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIG9uY2UoZW1pdHRlciwgZXZlbnROYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChzaWduYWwpO1xuICAgIGlmIChzaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKHZvaWQgMCwgeyBjYXVzZTogZ2V0UmVhc29uKHNpZ25hbCkgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBlcnJvckxpc3RlbmVyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoZXJyKSA9PiB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCByZXNvbHZlcik7XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICBldmVudFRhcmdldEFnbm9zdGljUmVtb3ZlTGlzdGVuZXIoZW1pdHRlciwgZXZlbnROYW1lLCBhYm9ydExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0sIFwiZXJyb3JMaXN0ZW5lclwiKTtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoLi4uYXJncykgPT4ge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JMaXN0ZW5lcik7XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICBldmVudFRhcmdldEFnbm9zdGljUmVtb3ZlTGlzdGVuZXIoc2lnbmFsLCBcImFib3J0XCIsIGFib3J0TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICB9LCBcInJlc29sdmVyXCIpO1xuICAgICAgZW1pdHRlci5vbmNlKGV2ZW50TmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gXCJlcnJvclwiKSB7XG4gICAgICAgIGVtaXR0ZXIub25jZShcImVycm9yXCIsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYWJvcnRMaXN0ZW5lciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICAgICAgICBldmVudFRhcmdldEFnbm9zdGljUmVtb3ZlTGlzdGVuZXIoZW1pdHRlciwgZXZlbnROYW1lLCByZXNvbHZlcik7XG4gICAgICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNSZW1vdmVMaXN0ZW5lcihlbWl0dGVyLCBcImVycm9yXCIsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgICByZWplY3QobmV3IEFib3J0RXJyb3Iodm9pZCAwLCB7IGNhdXNlOiBnZXRSZWFzb24oc2lnbmFsKSB9KSk7XG4gICAgICB9LCBcImFib3J0TGlzdGVuZXJcIik7XG4gICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihzaWduYWwsIFwiYWJvcnRcIiwgYWJvcnRMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBvbihlbWl0dGVyLCBldmVudE5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKHNpZ25hbCk7XG4gICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3Iodm9pZCAwLCB7IGNhdXNlOiBnZXRSZWFzb24oc2lnbmFsKSB9KTtcbiAgICB9XG4gICAgY29uc3QgdW5jb25zdW1lZEV2ZW50cyA9IFtdO1xuICAgIGNvbnN0IHVuY29uc3VtZWRQcm9taXNlcyA9IFtdO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG4gICAgY29uc3QgYWJvcnRMaXN0ZW5lciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICAgICAgZXJyb3JIYW5kbGVyKG5ldyBBYm9ydEVycm9yKHZvaWQgMCwgeyBjYXVzZTogZ2V0UmVhc29uKHNpZ25hbCkgfSkpO1xuICAgIH0sIFwiYWJvcnRMaXN0ZW5lclwiKTtcbiAgICBjb25zdCBldmVudEhhbmRsZXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBwcm9taXNlID0gdW5jb25zdW1lZFByb21pc2VzLnNoaWZ0KCk7XG4gICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChhcmdzLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5jb25zdW1lZEV2ZW50cy5wdXNoKGFyZ3MpO1xuICAgICAgfVxuICAgIH0sIFwiZXZlbnRIYW5kbGVyXCIpO1xuICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGVycikgPT4ge1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgY29uc3QgdG9FcnJvciA9IHVuY29uc3VtZWRQcm9taXNlcy5zaGlmdCgpO1xuICAgICAgaWYgKHRvRXJyb3IpIHtcbiAgICAgICAgdG9FcnJvci5yZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgICAgdm9pZCBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICB9LCBcImVycm9ySGFuZGxlclwiKTtcbiAgICBjb25zdCBpdGVyYXRvciA9IE9iamVjdC5zZXRQcm90b3R5cGVPZihcbiAgICAgIHtcbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHVuY29uc3VtZWRFdmVudHMuc2hpZnQoKTtcbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZmFsc2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHZvaWQgMCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdW5jb25zdW1lZFByb21pc2VzLnB1c2goeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJldHVybigpIHtcbiAgICAgICAgICBlbWl0dGVyLm9mZihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgZW1pdHRlci5vZmYoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNSZW1vdmVMaXN0ZW5lcihzaWduYWwsIFwiYWJvcnRcIiwgYWJvcnRMaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBkb25lUmVzdWx0ID0gY3JlYXRlSXRlclJlc3VsdCh2b2lkIDAsIHRydWUpO1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvbWlzZSBvZiB1bmNvbnN1bWVkUHJvbWlzZXMpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShkb25lUmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkb25lUmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhyb3coZXJyKSB7XG4gICAgICAgICAgaWYgKCFlcnIgfHwgIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIEVycm9yIGluc3RhbmNlIHRvIGJlIHRocm93biBpbiBBc3luY0V2ZW50RW1pdHRlci5Bc3luY0l0ZXJhdG9yLiBHb3QgJHtlcnJ9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgIGVtaXR0ZXIub2ZmKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgICBlbWl0dGVyLm9mZihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBBc3luY0l0ZXJhdG9yUHJvdG90eXBlXG4gICAgKTtcbiAgICBlbWl0dGVyLm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICBpZiAoZXZlbnROYW1lICE9PSBcImVycm9yXCIpIHtcbiAgICAgIGVtaXR0ZXIub24oXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgIH1cbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoc2lnbmFsLCBcImFib3J0XCIsIGFib3J0TGlzdGVuZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0b3I7XG4gIH1cbn07XG5fX25hbWUoX0FzeW5jRXZlbnRFbWl0dGVyLCBcIkFzeW5jRXZlbnRFbWl0dGVyXCIpO1xudmFyIEFzeW5jRXZlbnRFbWl0dGVyID0gX0FzeW5jRXZlbnRFbWl0dGVyO1xuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy5ldmVudEVtaXR0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLmV2ZW50RW1pdHRlciwgYXJndW1lbnRzKTtcbiAgfVxufVxuX19uYW1lKG9uY2VXcmFwcGVyLCBcIm9uY2VXcmFwcGVyXCIpO1xuZnVuY3Rpb24gZ2V0UmVhc29uKHNpZ25hbCkge1xuICByZXR1cm4gc2lnbmFsPy5yZWFzb247XG59XG5fX25hbWUoZ2V0UmVhc29uLCBcImdldFJlYXNvblwiKTtcbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNSZW1vdmVMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9mZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZW1pdHRlci5vZmYobmFtZSwgbGlzdGVuZXIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpO1xuICB9XG59XG5fX25hbWUoZXZlbnRUYXJnZXRBZ25vc3RpY1JlbW92ZUxpc3RlbmVyLCBcImV2ZW50VGFyZ2V0QWdub3N0aWNSZW1vdmVMaXN0ZW5lclwiKTtcbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoZmxhZ3M/Lm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIsIGZsYWdzKTtcbiAgfVxufVxuX19uYW1lKGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lciwgXCJldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXJcIik7XG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXN5bmMgZnVuY3Rpb24qICgpIHtcbn0pLnByb3RvdHlwZSk7XG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7IHZhbHVlLCBkb25lIH07XG59XG5fX25hbWUoY3JlYXRlSXRlclJlc3VsdCwgXCJjcmVhdGVJdGVyUmVzdWx0XCIpO1xudmFyIF9BYm9ydEVycm9yID0gY2xhc3MgX0Fib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWRcIiwgb3B0aW9ucyA9IHZvaWQgMCkge1xuICAgIGlmIChvcHRpb25zICE9PSB2b2lkIDAgJiYgdHlwZW9mIG9wdGlvbnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgQWJvcnRFcnJvcjogb3B0aW9ucyBpcyBub3QgYW4gb2JqZWN0IG9yIHVuZGVmaW5lZGApO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICB0aGlzLmNvZGUgPSBcIkFCT1JUX0VSUlwiO1xuICAgIHRoaXMubmFtZSA9IFwiQWJvcnRFcnJvclwiO1xuICB9XG59O1xuX19uYW1lKF9BYm9ydEVycm9yLCBcIkFib3J0RXJyb3JcIik7XG52YXIgQWJvcnRFcnJvciA9IF9BYm9ydEVycm9yO1xuZnVuY3Rpb24gaGFuZGxlTWF5YmVBc3luYyhlbWl0dGVyLCByZXN1bHQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmaW4gPSByZXN1bHQuZmluYWxseTtcbiAgICBpZiAodHlwZW9mIGZpbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBwcm9taXNlSWQgPSBTdHJpbmcoKytlbWl0dGVyW1wiX3dyYXBwZXJJZFwiXSk7XG4gICAgICBlbWl0dGVyW1wiX2ludGVybmFsUHJvbWlzZU1hcFwiXS5zZXQocHJvbWlzZUlkLCByZXN1bHQpO1xuICAgICAgZmluLmNhbGwocmVzdWx0LCAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uIGZpbmFsKCkge1xuICAgICAgICBlbWl0dGVyW1wiX2ludGVybmFsUHJvbWlzZU1hcFwiXS5kZWxldGUocHJvbWlzZUlkKTtcbiAgICAgIH0sIFwiZmluYWxcIikpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZW1pdHRlci5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgfVxufVxuX19uYW1lKGhhbmRsZU1heWJlQXN5bmMsIFwiaGFuZGxlTWF5YmVBc3luY1wiKTtcbmV4cG9ydCB7XG4gIEFib3J0RXJyb3IsXG4gIEFzeW5jRXZlbnRFbWl0dGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fbmFtZSIsInRhcmdldCIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwidmFsaWRhdGVMaXN0ZW5lciIsImlucHV0IiwiVHlwZUVycm9yIiwidmFsaWRhdGVBYm9ydFNpZ25hbCIsIkFib3J0U2lnbmFsIiwic3BsaWNlT25lIiwibGlzdCIsImluZGV4IiwibGVuZ3RoIiwicG9wIiwiYXJyYXlDbG9uZSIsImFyciIsInNsaWNlIiwiaWRlbnRpY2FsU2VxdWVuY2VSYW5nZSIsImEiLCJiIiwiaSIsInBvcyIsImluZGV4T2YiLCJyZXN0IiwibGVuIiwibWF4TGVuIiwiTWF0aCIsIm1pbiIsImVuaGFuY2VTdGFja1RyYWNlIiwiZXJyIiwib3duIiwiY3RvckluZm8iLCJuYW1lIiwiY29uc3RydWN0b3IiLCJzZXAiLCJlcnJTdGFjayIsInN0YWNrIiwic3BsaXQiLCJvd25TdGFjayIsIm9mZiIsInNwbGljZSIsImpvaW4iLCJfQXN5bmNFdmVudEVtaXR0ZXIiLCJfZXZlbnRzIiwiX19wcm90b19fIiwiX2V2ZW50Q291bnQiLCJfbWF4TGlzdGVuZXJzIiwiX2ludGVybmFsUHJvbWlzZU1hcCIsIk1hcCIsIl93cmFwcGVySWQiLCJhZGRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImxpc3RlbmVyIiwid3JhcHBlZCIsIl93cmFwTGlzdGVuZXIiLCJfYWRkTGlzdGVuZXIiLCJvbiIsIm9uY2UiLCJyZW1vdmVMaXN0ZW5lciIsImV2ZW50cyIsImV2ZW50TGlzdCIsImVtaXQiLCJwb3NpdGlvbiIsInNoaWZ0IiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZXZlbnQiLCJrZXkiLCJSZWZsZWN0Iiwib3duS2V5cyIsImxpc3RlbmVycyIsInNldE1heExpc3RlbmVycyIsIm4iLCJOdW1iZXIiLCJpc05hTiIsIlJhbmdlRXJyb3IiLCJnZXRNYXhMaXN0ZW5lcnMiLCJyZXQiLCJvcmlnIiwicmF3TGlzdGVuZXJzIiwiYXJncyIsImRvRXJyb3IiLCJlcnJvciIsImVyIiwiRXJyb3IiLCJjYXB0dXJlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJwcm90b3R5cGUiLCJjYWxsIiwic3RyaW5naWZpZWRFcnJvciIsIlN0cmluZyIsImNvbnRleHQiLCJoYW5kbGVycyIsInJlc3VsdCIsImFwcGx5IiwiaGFuZGxlTWF5YmVBc3luYyIsImxpc3RlbmVyQ291bnQiLCJldmVudExpc3RlbmVycyIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJldmVudE5hbWVzIiwid2FpdEZvckFsbExpc3RlbmVyc1RvQ29tcGxldGUiLCJwcm9taXNlcyIsInZhbHVlcyIsIlByb21pc2UiLCJhbGwiLCJ3cmFwcGVkTGlzdGVuZXIiLCJwcmVwZW5kIiwibmV3TGlzdGVuZXIiLCJleGlzdGluZyIsInVuc2hpZnQiLCJwdXNoIiwiX2hhc1dhcm5lZEFib3V0TWF4TGlzdGVuZXJzIiwid2FybmluZ01lc3NhZ2UiLCJjb25zb2xlIiwid2FybiIsInN0YXRlIiwiZmlyZWQiLCJ3cmFwRm4iLCJldmVudEVtaXR0ZXIiLCJhbGlhc2VkIiwib25jZVdyYXBwZXIiLCJiaW5kIiwiZW1pdHRlciIsIm9wdGlvbnMiLCJzaWduYWwiLCJhYm9ydGVkIiwiQWJvcnRFcnJvciIsImNhdXNlIiwiZ2V0UmVhc29uIiwicmVzb2x2ZSIsInJlamVjdCIsImVycm9yTGlzdGVuZXIiLCJyZXNvbHZlciIsImV2ZW50VGFyZ2V0QWdub3N0aWNSZW1vdmVMaXN0ZW5lciIsImFib3J0TGlzdGVuZXIiLCJldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIiLCJ1bmNvbnN1bWVkRXZlbnRzIiwidW5jb25zdW1lZFByb21pc2VzIiwiZmluaXNoZWQiLCJlcnJvckhhbmRsZXIiLCJldmVudEhhbmRsZXIiLCJwcm9taXNlIiwiY3JlYXRlSXRlclJlc3VsdCIsInRvRXJyb3IiLCJpdGVyYXRvciIsInJldHVybiIsInNldFByb3RvdHlwZU9mIiwibmV4dCIsInAiLCJkb25lUmVzdWx0IiwidGhyb3ciLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwiQXN5bmNJdGVyYXRvclByb3RvdHlwZSIsIkFzeW5jRXZlbnRFbWl0dGVyIiwiYXJndW1lbnRzIiwicmVhc29uIiwiZmxhZ3MiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImdldFByb3RvdHlwZU9mIiwiZG9uZSIsIl9BYm9ydEVycm9yIiwibWVzc2FnZSIsImNvZGUiLCJmaW4iLCJmaW5hbGx5IiwicHJvbWlzZUlkIiwic2V0IiwiZmluYWwiLCJkZWxldGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@vladfrangu/async_event_emitter/dist/index.mjs\n");

/***/ })

};
;